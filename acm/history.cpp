//
//  history.cpp
//  acm
//
//  Created by 李弘辰 on 2019/9/4.
//  Copyright © 2019 李弘辰. All rights reserved.
//


/*#include <iostream>
 #include <stdio.h>
 #include <math.h>
 //#include <sstream>
 
 //void triangle();
 //void ants();
 void chouqian();
 
 using namespace std;
 
 string toString(int n)
 {
 //int length = 0;
 //length = log10(n);
 //length += 1;
 //string str;
 //for (int i = 0;i < length;i ++)
 //{
 //    str += ((int) n / pow(10,length - i - 1)) + '0';
 //    n = n % ((int) pow(10,length - i - 1));
 //}
 //return str;
 
 
 
 stringstream ss;
 ss << n;
 return ss.str();
 }
 
 int main(int argc, const char * argv[]) {
 // insert code here...
 
 return 0;
 }
 
 void triangle()
 {
 int n,N_MAX = 100;
 int a[N_MAX];
 scanf("%d",&n);
 
 for (int i = 0;i < n;i ++)
 {
 scanf("%d",&a[i]);
 }
 
 bool ok = false;
 
 for (int i = n - 1;i >= 0; i --)
 {
 int max = a[i];
 if (i - 2 >= 0)
 {
 if (a[i - 1] + a[i - 2] > max)
 {
 ok = true;
 cout << a[i - 2] + a[i - 1] + a[i];
 break;
 }
 } else
 {
 break;
 }
 }
 
 if (!ok)
 {
 cout << 0;
 }
 }*/

/*void ants()
 {
 int times = 0;
 scanf("%d",&times);
 for (int t = 0;t < times;t ++)
 {
 // Ants: --o-------o--------o-------- 求所有蚂蚁的最长时间/最短时间
 // 蚂蚁有往右的，也有往左的，但是可以不管这些，忽略蚂蚁的区别，那么问题
 int N_MAX = pow(10,6);
 int n,L;
 scanf("%d",&L);
 scanf("%d",&n);
 int L_mid = L / 2;
 int x[N_MAX];
 for (int i = 0;i < n;i ++)
 {
 scanf("%d",&x[i]);
 }
 
 int mid = 0;
 int max = 0;
 for (int i = 0;i < n;i ++)
 {
 // min
 if (x[i] <= L_mid)
 {
 if (x[i] > mid)
 {
 mid = x[i];
 }
 } else
 {
 if ((L - x[i]) > mid)
 {
 mid = L - x[i];
 }
 }
 // max
 if (x[i] > max)
 {
 max = x[i];
 }
 if (L - x[i] > max)
 {
 max = L - x[i];
 }
 }
 
 printf("%d %d\n",mid,max);
 }
 
 }*/

/*void chouqian()
 {
 
 }*/


/////////////////////////////////

/*#include<stdio.h>
#include<math.h>


void things()
{
    
}

int main()
{
    
    int r = 0;
    scanf("%d",&r);
    getchar();
    for (int k = 0;k < r;k ++)
    {
        things();
    }
}*/
/////////////////////

/*#include<stdio.h>

int main()
{
    int v,t;
    while(scanf("%d %d",&v,&t) != EOF)
    {
        printf("%d\n",v * t * 2);
    }
    printf("%d",EOF);
    return 0;
}*/

/*#include<stdio.h>
#include<stack>

int main()
{
    int n;
    scanf("%d",&n);
    int egg[101] = {0};
    for (int i = 0; i < n * 2 + 1; i ++) {
        int in;
        scanf("%d",&in);
        if (in == 0) break;
        else egg[in] += 1;
    }
    for (int i = 0;i < n;i ++)
    {
        
    }
    for (int i = 0;i < 101;i ++)
    {
        printf(" %d",egg[i]);
    }
    return 0;
}*/

/*#include<stdio.h>

void things()
{
    int n;
    scanf("%d",&n);
    int nums[n];
    int min = -1;
    for (int i = 0;i < n;i ++)
    {
        int in;
        scanf("%d",&in);
        if (min == -1) min = in;
        if (in < min) min = in;
        nums[i] = in;
    }
    int gong = 1;
    for (int i = 1;i <= min;i ++)
    {
        int ok = 1;
        for (int j = 0;j < n;j ++)
        {
            if (nums[j] % i != 0) ok = 0;
        }
        if (ok == 1) gong = i;
    }
    printf("%d\n",gong);
}

int main()
{
    int r = 0;
    scanf("%d",&r);
    getchar();
    for (int k = 0;k < r;k ++)
    {
        things();
    }
    return 0;
}*/


/*#include<stdio.h>
#include<string>
#include<iostream>

using namespace std;

void things()
{
    int num;
    scanf("%d",&num);
    string str = "";
    while (num != 0)
    {
        int last = num % 16;
        num = num / 16;
        char n;
        if (last >= 0 && last <= 9) n = '0' + last;
        else n = 'A' + last - 10;
        str = n + str;
    }
    cout << str << endl;
}

int main()
{
    int r = 0;
    scanf("%d",&r);
    getchar();
    for (int k = 0;k < r;k ++)
    {
        things();
    }
    return 0;
}*/

///求余
/*#include<stdio.h>
#include<iostream>

using namespace std;

int main()
{
    string n;
    int k;
    while (cin >> n >> k)
    {
        int last = 0;
        for (int i = 0;i < ((int) n.length());i ++)
        {
            int num = ((int) (n[i] - '0')) + last * 10;
            last = num % k;
        }
        printf("%d\n",last);
            
    }
    return 0;
}*/

/*#include<stdio.h>
#include<string>



int isHui(string n)
{
    
}

int main()
{
    int min,max;
    scanf("%d %d",&min,&max);
    for (int i = min;i <= max; i ++)
    {
        
    }
    return 0;
}
*/

/*#include<stdio.h>

int main()
{
    float m,n;
    scanf("%f %f",&m,&n);
    const float Fe = 56, H2 = 2;
    float mol_Fe = n / H2;
    float mFe = mol_Fe * Fe;
    float mCu = m - mFe;
    if (mCu < 0) printf("impossible");
    else printf("%.2f%%",mCu / m * 100);
    return 0;
}*/

/*#include<stdio.h>
#include<iostream>

using namespace std;

int a[21];
int n, k;

bool dfs(int i, int sum)
{
    if (i == n) return sum == k; //
    if (dfs(i + 1, sum)) return true; //
    if (dfs(i + 1, sum + a[i])) return true;
    return false;
}

int main()
{
    
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++)
    {
        scanf("%d",&a[i]);
    }
    scanf("%d",&k);
    cout << dfs(1, 0);
    return 0;
}*/

/*#include<stdio.h>

int main()
{
    int input = 1;
    while (input != 0) {
        scanf("%d",&input);
        int sum = 0;
        for (int i = 0;i < input;i ++)
        {
            int in;
            scanf("%d",&in);
            sum += in;
        }
        if (input != 0) printf("%d\n",sum);
    }
    return 0;
}
*/

/*#include<stdio.h>

int main()
{
    int a,b;
    while (scanf("%d %d",&a,&b) != EOF)
    {
        printf("%d\n",a + b);
    }
    return 0;
}*/

/*#include<stdio.h>

void things()
{
    int input;
    scanf("%d",&input);
    int sum = 0;
    for (int i = 0;i < input;i ++)
    {
        int in;
        scanf("%d",&in);
        sum += in;
    }
    printf("%d\n",sum);
}

int main()
{
    int r = 0;
    scanf("%d",&r);
    getchar();
    for (int k = 0;k < r;k ++)
    {
        things();
    }
    return 0;
}*/

/*#include<stdio.h>
#include<math.h>

void printNum(int n,int hasSpace)
{
    char pinyin[10][5] = {{'l','i','n','g','\0'},
        {'y','i','\0'},
        {'e','r','\0'},
        {'s','a','n','\0'},
        {'s','i','\0'},
        {'w','u','\0'},
        {'l','i','u','\0'},
        {'q','i','\0'},
        {'b','a','\0'},
        {'j','i','u','\0'}};
    if (hasSpace) printf(" ");
    printf("%s",pinyin[n]);
}

int main()
{
    
    char in[101];
    
    scanf("%s",in);
    int sum = 0;
    for (int i = 0;in[i] != '\0';i ++)
    {
        sum += in[i] - '0';
    }
    int length = log10(sum);
    length ++;
    
    for (int i = length;i > 0;i --)
    {
        int n = sum / pow(10, i - 1);
        sum = sum % ((int) pow(10, i - 1));
        int s = 0;
        if (i != length) s = 1;
        printNum(n, s);
    }
    printf("\n");
    return 0;
}
*/

/*#include<stdio.h>
#include<iostream>
#include<string>
#include<math.h>
#include<vector>

using namespace std;

int main()
{
    string in;
    cin >> in;
    vector<int> nums;
    for (int i = 0;in[i] != '\0';i ++)
    {
        nums.push_back(in[i] - '0');
    }
    int length = (int) nums.size();
    string op = "";
    // 234
    // 012
    // 23
    // 01
    for (int i = 0;i < length;i ++)
    {
        string single = "";
        switch (length - i - 1) {
            case 0:
                for (int j = 1;j <= nums[i];j ++)
                {
                    single += ((char) j) + '0';
                }
                op += single;
                break;
            case 1:
                for (int j = 1;j <= nums[i];j ++)
                {
                    single += "S";
                }
                op += single;
                break;
            case 2:
                for (int j = 1;j <= nums[i];j ++)
                {
                    single += "B";
                }
                op += single;
                break;
            default:
                break;
        }
    }
    cout << op << endl;
    
    return 0;
}*/

/*#include<stdio.h>

int main()
{
    int N,M;
    scanf("%d %d",&N,&M);
    int arr[N];
    for (int i = 0;i < N;i ++)
    {
        int n = i + M;
        while (n >= N) n -= N;
        scanf("%d",&arr[n]);
    }
    int isF = 1;
    for (int i = 0;i < N;i ++)
    {
        if (isF == 1)
        {
            isF = 0;
        } else
        {
            printf(" ");
        }
        printf("%d",arr[i]);
    }
    return 0;
}*/

/*#include<string>
#include<iostream>
#include<stdio.h>
#include<vector>

using namespace std;

int main()
{
    vector<string> words;
    string _text;
    getline(cin,_text);
    int last = 0;
    for (int i = 0;i <= _text.size();i ++){
        if (_text[i] == '\0' || _text[i] == ' ')
        {
            words.push_back(_text.substr(last,i - last));
            last = i + 1;
        }
    }
    bool isF = true;
    for (int i = (int) (words.size() - 1);i >= 0;i --)
    {
        if (!isF) printf(" ");
        else isF = false;
        cout << words[i];
    }
    cout << endl;
    return 0;
}*/

////////////////////////////////////////////////////////////////////////////////

/*#include <stdio.h>

int main()
{
    int a,b;
    int isFisrt = 1;
    while(scanf("%d%d",&a,&b) != EOF)
    {
        if (a == 0 || b == 0) continue;
        a = a * b;
        b -= 1;
        if (!isFisrt) printf(" ");
        else isFisrt = 0;
        printf("%d %d",a,b);
    }
    if (isFisrt) printf("0 0");
}
*/


//#include<stdio.h>
//
//
//int main()
//{
//    int r = 0;
//    scanf("%d",&r);
//    getchar();
//    for (int k = 0;k < r;k ++)
//    {
//        long long a,b,c;
//        scanf("%lld %lld %lld",&a,&b,&c);
//        int ok = 0;
//        if (a + b > c) ok = 1;
//        if (!ok) printf("Case #%d: false\n",k + 1);
//        else printf("Case #%d: true\n",k + 1);
//    }
//    return 0;
//}

/*#include<stdio.h>

int main()
{
    int r = 0;
    scanf("%d",&r);
    int A1 = 0,A2 = 0,A3 = 0,A4_n = 0,A5 = 0;
    int hasA[5] = {0};
    float A4 = 0;
    int isP = 1;
    for (int k = 0;k < r;k ++)
    {
        int num;
        scanf("%d",&num);
        if (num % 10 == 0)
        {
            A1 += num;
            hasA[0] = 1;
        }
        if (num % 5 == 1)
        {
            A2 += isP * num;
            isP *= -1;
            hasA[1] = 1;
        }
        if (num % 5 == 2)
        {
            A3 ++;
            hasA[2] = 1;
        }
        if (num % 5 == 3)
        {
            A4_n ++;
            A4 += (float) num;
            hasA[3] = 1;
        }
        if (num % 5 == 4)
        {
            if (num > A5) A5 = num;
            hasA[4] = 1;
        }
        
    }
    A4 /= (float) A4_n;
    if (hasA[0]) printf("%d",A1);
    else printf("N");
    printf(" ");
    if (hasA[1]) printf("%d",A2);
    else printf("N");
    printf(" ");
    if (hasA[2]) printf("%d",A3);
    else printf("N");
    printf(" ");
    if (hasA[3]) printf("%.1f",A4);
    else printf("N");
    printf(" ");
    if (hasA[4]) printf("%d\n",A5);
    else printf("N\n");
} */

//#include<stdio.h>
//
//int main()
//{
//    char nums[1001];
//    int d = 0;
//    scanf("%s %d",nums,&d);
//    int last = 0;
//    char left[1001];
//    int leftIndex = 0;
//    for (int i = 0;nums[i] != '\0';i ++)
//    {
//        int n = (nums[i] - '0') + last * 10;
//        if (n >= d)
//        {
//            int a = n / d;
//            last = n % d;
//            left[leftIndex] = '0' + a;
//            leftIndex ++;
//        } else
//        {
//            if (leftIndex != 0)
//            {
//                left[leftIndex] = '0';
//                leftIndex ++;
//            }
//            last = n;
//        }
//    }
//    if (leftIndex == 0) printf("%d",0);
//    left[leftIndex] = '\0';
//    for (int i = 0;left[i] != '\0';i ++)
//    {
//        printf("%c",left[i]);
//    }
//    printf(" %d\n",last);
//    return 0;
//}


/////////////////////////time

/*#include <stdio.h>
#include <math.h>

int main()
{
    long min,max;
    scanf("%ld %ld",&min,&max);
    long zhiIndex = 0;
    long zhi[max];
    int isF = 1;
    int hang = 1;
    for (long i = 2;;i ++)
    {
        if (zhiIndex >= max) {
            break;
        }

        int shouldContinue = 0;
        for (long j = 0;j < zhiIndex && zhi[j] <= sqrt(i);j ++)
        {
            if (i % zhi[j] == 0)
            {
                shouldContinue = 1;
                break;
            }
        }
        if (shouldContinue) continue;
        zhi[zhiIndex] = i;
        zhiIndex ++;
        if (zhiIndex >= min)
        {
            if (!isF) printf(" ");
            else isF = 0;
            printf("%ld",i);
            if (hang % 10 == 0)
            {
                printf("\n");
                isF = 1;
            }
            hang ++;
        }
    }
    return 0;
}*/

//#include <iostream>
//#include <map>
//
//using namespace std;
//
//int main()
//{
//    map<char,string> day;
//    day['A'] = "MON";
//    day['B'] = "TUE";
//    day['C'] = "WED";
//    day['D'] = "THU";
//    day['E'] = "FRI";
//    day['F'] = "SAT";
//    day['G'] = "SUN";
//    string str[4];
//    cin >> str[0] >> str[1] >> str[2] >> str[3];
//    string dd = "MON";
//    int h = 0,m = 0;
//    bool is1F = true;
//    for (int i = 0;i < min(str[0].size(), str[1].size());i ++)
//    {
//        char c = str[0][i];
//        if (is1F && (c >= 'A' && c <= 'Z') && c == str[1][i])
//        {
//            dd = day[c];
//            is1F = false;
//        }
//        if (!is1F)
//        {
//            if (((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z')) && c == str[1][i])
//            {
//                if (c >= '0' && c <= '9') h = c - '0';
//                if (c >= 'A' && c <= 'Z') h = c - 'A' + 10;
//            }
//        }
//
//    }
//    for (int i = 0;i < min(str[2].size(), str[3].size());i ++)
//    {
//        char c = str[2][i];
//        if (((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) && c == str[3][i])
//        {
//            m = i;
//            break;
//        }
//    }
//
//
//    cout << dd << " ";
//    if (h < 10) cout << 0;
//    cout << h << ":";
//    if (m < 10) cout << 0;
//    cout << m << endl;
//    return 0;
//}

/*#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

int main()
{
    string A,B;
    char Da,Db;
    cin >> A >> Da >> B >> Db;
    long Pa = 0, Pb = 0;
    for (int i = 0;i < A.size();i ++)
    {
        if (A[i] == Da) Pa = Pa * 10 + Da - '0';
    }
    for (int i = 0;i < B.size();i ++)
    {
        if (B[i] == Db) Pb = Pb * 10 + Db - '0';
    }
    cout << Pa + Pb << endl;
    return 0;
}
*/


//////////////////////////////////////读%s速度很慢，要读%d快一些
/*#include <stdio.h>

void sort(int a[])
{
    int NUM = 4;
    for (int i = 0;i < NUM - 1;i ++)
    {
        for (int j = 1;j < NUM - i;j ++)
        {
            if (a[j] < a[j - 1])
            {
                int t = a[j];
                a[j] = a[j - 1];
                a[j - 1] = t;
            }
        }
    }
}

int main()
{
    int num = 1;
    int input[4];
    scanf("%d",&num);
    do
    {
        input[0] = num / 1000;
        num %= 1000;
        input[1] = num / 100;
        num %= 100;
        input[2] = num / 10;
        num %= 10;
        input[3] = num;
        sort(input);
        int a = input[3] * 1000 + input[2] * 100 + input[1] * 10 + input[0];
        int b = input[0] * 1000 + input[1] * 100 + input[2] * 10 + input[3];
        num = a - b;
        printf("%04d - %04d = ",a,b);
        printf("%04d\n",num);
        if (num == 0 || num == 6174) break;
    } while (1);

    return 0;
}*/

/*#include <stdio.h>

int main()
{
    int N;
    double D;
    scanf("%d %lf",&N,&D);
    double n[N],dan[N];
    for (int i = 0;i < N;i ++)
    {
        scanf("%lf",&n[i]);
    }
    for (int i = 0;i < N;i ++)
    {
        double a;
        scanf("%lf",&a);
        dan[i] = a / n[i];
    }
    double sum = 0;
    for (int i = 0;i < N;i ++)
    {
        int k = i;
        for (int j = i;j < N;j ++)
        {
            if (dan[j] >= dan[k]) k = j;
        }
        if (D >= n[k])
        {
            D -= n[k];
            sum += dan[k] * n[k];
        } else {
            sum += dan[k] * (D);
            break;
        }
        if (k != i)
        {
            double t = dan[k];
            dan[k] = dan[i];
            dan[i] = t;
        }
        
    }
    printf("%.2lf\n",sum);
    return 0;
}
*/

/*#include <stdio.h>

int main()
{
    int num[10] = {0};
    char n[1001];
    scanf("%s",n);
    for (int i = 0;n[i] != '\0';i ++)
    {
        num[n[i] - '0'] ++;
    }
    for (int i = 0;i < 10;i ++)
    {
        if (num[i] != 0) printf("%d:%d\n",i,num[i]);
    }
    return 0;
}
*/


/*#include <stdio.h>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    unsigned long a,b,sum;
    unsigned long d;
    scanf("%lu %lu %lu",&a,&b,&d);
    sum = a + b;
    string op;
    if (sum == 0) printf("%d",0);
    while (sum != 0)
    {
        char n = '0' + (char) (sum % d);
        op = n + op;
        sum /= d;
    }
    cout << op << endl;
    return 0;
}*/

/*
#include <stdio.h>

int num[10];

void printIt()
{
    for (int i = 0;i < 10;i ++)
    {
        for (int j = 0;j < num[i];j ++)
        {
            printf("%d",i);
        }
    }
    printf("\n");
}

int main()
{
    
    for (int i = 0;i < 10;i ++)
    {
        int n;
        scanf("%d",&n);
        num[i] = n;
    }
    if (num[0] != 0)
    {
        int min = 10;
        for (int i = 1;i < 10;i ++)
        {
            if (num[i] != 0)
            {
                min = i;
                num[i] --;
                break;
            }
        }
        if (min == 10) printf("0");
        else
        {
            printf("%d",min);
            printIt();
        }
    } else
    {
        printIt();
    }
    
    return 0;
}
*/

/*#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string num_k;
    cin >> num_k;
    if (num_k[0] == '-') printf("-");
    int ZHENG = num_k[1] - '0';
    int index_e = 3;
    string XIAO;
    for (;num_k[index_e] != 'E';index_e ++)
    {
        XIAO = XIAO + num_k[index_e];
    }
    int isZhiFu = num_k[index_e + 1] == '-';
    int zhi = 0;
    for (int i = index_e + 2;num_k[i] != '\0';i ++)
    {
        zhi = zhi * 10 + (num_k[i] - '0');
    }
    if (isZhiFu)
    {
        printf("0.");
        for (int i = 0;i < zhi - 1;i ++)
        {
            printf("0");
        }
        printf("%d",ZHENG);
        cout << XIAO;
    } else {
        printf("%d",ZHENG);
        if (XIAO.size() > zhi)
        {
            for (int i = 0;i < zhi;i ++)
            {
                printf("%c",XIAO[i]);
            }
            printf(".");
            for (int i = zhi;i < XIAO.size(); i ++) {
                printf("%c",XIAO[i]);
            }
        } else
        {
            cout << XIAO;
        }
        for (int i = (int) XIAO.size();i < zhi;i ++)
        {
            printf("0");
        }
    }
    printf("\n");
}*/


//SB 题目a*b=c
/*
#include <stdio.h>

void things()
{
    char str[101];
    scanf("%s",str);
    int isPStart = 0;
    int isTEnd = 0;
    int hasA = 0;
    int numA = 0;
    int numA2 = 0;
    int i = 0;
    for (;str[i] != '\0';i ++)
    {
        if (!isPStart)
        {
            if (str[i] != 'A')
            {
                if (str[i] == 'P') isPStart = 1;
                else break;
            } else numA ++;
        } else {
            if (!isTEnd)
            {
                if (str[i] == 'A') hasA ++;
                else
                if (str[i] == 'T')
                {
                    if (hasA == 1 || hasA == 2) isTEnd = 1;
                    else break;
                } else break;
            } else {
                if (str[i] != 'A') break;
                else numA2 ++;
                
            }
        }
    }
    if (isPStart && str[i] == '\0' && isTEnd && numA2 >= numA) printf("YES\n");
    else printf("NO\n");
}

int main()
{
    int r = 0;
    scanf("%d",&r);
    getchar();
    for (int k = 0;k < r;k ++)
    {
        things();
    }
    return 0;
}
*/


/*#include <stdio.h>
#include <math.h>

int main()
{
    long max;
    scanf("%ld",&max);
    long zhiIndex = 0;
    long zhi[max];
    int all = 0;
    for (long i = 2;;i ++)
    {
        if (i > max) {
            break;
        }
        
        int shouldContinue = 0;
        for (long j = 0;j < zhiIndex && zhi[j] <= sqrt(i);j ++)
        {
            if (i % zhi[j] == 0)
            {
                shouldContinue = 1;
                break;
            }
        }
        if (shouldContinue) continue;
        
        zhi[zhiIndex] = i;
        if (zhiIndex > 0 && (zhi[zhiIndex] - zhi[zhiIndex - 1] == 2))
        {
            all ++;
        }
        zhiIndex ++;
        
    }
    printf("%d\n",all);
    return 0;
}
*/

/*
#include <stdio.h>

int main()
{
    double c1,c2,d_value;
    scanf("%lf %lf", &c1, &c2);
    d_value = c2 - c1;
    double sec, min, hour;
    sec = d_value / 100;
    min = sec / 60;
    hour = min / 60;
    long long hour_int = (long long) hour;
    int min_int;
    min_int = (int) (min - hour_int * 60);
    sec = sec - ((double) (min_int * 60 + hour_int * 3600));
    if (sec - ((int) sec) >= 0.5)
    {
        sec += 0.1;
    }
    printf("%02lld:%02d:%02.0lf\n",hour_int,min_int,sec);
    return 0;
}
*/


/*#include <stdio.h>

int main()
{
    int n;
    char c;
    scanf("%d %c",&n,&c);
    int sum = 1;
    int max = 3;
    while (sum + max * 2 < n)
    {
        sum += max * 2;
        max += 2;
    }
    max -= 2;
    int blank = 0;
    for (int i = max;i > 1;i -= 2)
    {
        for (int j = 0;j < blank;j ++) printf(" ");
        for (int j = 0;j < i;j ++) printf("%c",c);
        blank ++;
        printf("\n");
    }
    for (int i = 1;i <= max;i += 2)
    {
        for (int j = 0;j < blank;j ++) printf(" ");
        for (int j = 0;j < i;j ++) printf("%c",c);
        blank --;
        printf("\n");
    }
    printf("%d",n - sum);
    return 0;
}*/

/*
#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

int main()
{
    int n;
    long valid = 0;
    scanf("%d",&n);
    string name_in;
    int year,month,day;
    long min = 999999999,max = 0;
    string name_max,name_min;
    long TODAY = 2014 * 10000 + 9 * 100 + 6;
    long Y200 = TODAY - (1814 * 10000 + 9 * 100 + 6);
    for (int i = 0;i < n;i ++)
    {
        cin >> name_in;
        scanf("%d/%d/%d",&year,&month,&day);
        long time = year * 10000 + month * 100 + day;
        if (time <= TODAY && TODAY - time <= Y200)
        {
            if (time >= max)
            {
                max = time;
                name_max = name_in;
            }
            if (time <= min)
            {
                min = time;
                name_min = name_in;
            }
            valid ++;
        }
        
    }
    printf("%ld",valid);
    if (valid != 0) cout << " " << name_min << " " << name_max << endl;
    return 0;
}
*/

/*
#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

void upper(char *c)
{
    if (*c >= 'a' && *c <= 'z') *c += 'A' - 'a';
}

int main()
{
    int a[96] = {0};
    string origin,current;
    cin >> origin >> current;
    int i = 0, j = 0;
    while(origin[i] != '\0')
    {
        upper(&origin[i]);
        upper(&current[j]);
        //printf("%c==%c\n",origin[i],current[j]);
        if (origin[i] != current[j])
        {
            if (a[origin[i]] == 0)
            {
                printf("%c",origin[i]);
                a[origin[i]] = 1;
            }
            i ++;
            continue;
        }
        
        
        i ++;
        if (current[j] != '\0') j ++;
    }
    
    
    
}
*/


/*#include <stdio.h>
#include <math.h>
#include <algorithm>

int main()
{
    long long n,p;
    scanf("%lld %lld",&n,&p);
    long long nums[n];
    for (long long i = 0;i < n;i ++)
    {
        scanf("%lld",&nums[i]);
    }
    std::sort(nums,nums + n);

    long long max = 0;
    long long j = 0;
    for (long long i = 0;i < n;i ++)
    {
        for (;j < n;j ++)
        {
            if (!(nums[i] * p >= nums[j])) break;
        }
        max = (max < j - i) ? (j - i) : max;
    }

    printf("%lld",max);
    return 0;
}*/


/*
#include <stdio.h>
#include <map>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    //Z：0 1 2 3 4 5 6 7 8 9 10
    //M：1 0 X 9 8 7 6 5 4 3 2
    map<int,char> ZM;
    ZM[0] = '1';
    ZM[1] = '0';
    ZM[2] = 'X';
    ZM[3] = '9';
    ZM[4] = '8';
    ZM[5] = '7';
    ZM[6] = '6';
    ZM[7] = '5';
    ZM[8] = '4';
    ZM[9] = '3';
    ZM[10] = '2';
    vector<string> wrong;
    int quan[] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};
    int n;
    scanf("%d",&n);
    for (int i = 0;i < n;i ++)
    {
        int sum = 0;
        bool shouldC = false;
        string num;
        cin >> num;
        for (int j = 0;j < 17;j ++)
        {
            if (num[j] >= '0' && num[j] <= '9')
            {
                sum += quan[j] * (num[j] - '0');
            } else
            {
                wrong.push_back(num);
                shouldC = true;
                break;
            }
        }
        if (shouldC) continue;
        if (ZM[sum % 11] != num[17])
        {
            wrong.push_back(num);
        }
    }
    //cout << endl;
    if (wrong.size() == 0) printf("All passed\n");
    for (int i = 0;i < wrong.size();i ++)
    {
        cout << wrong[i] << endl;
    }
    return 0;
}
*/

/*
#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    long schools[100001] = {0};
    int last = 1;
    for (int t = 0;t < n;t ++)
    {
        int num,scr;
        scanf("%d %d",&num,&scr);
        schools[num] += scr;
        last = (num > last) ? num : last;
    }
    
    long max = -1,max_index = 0;
    for (int i = 1;i <= last;i ++)
    {
        //printf("%d ",i);
        if (schools[i] > max) {
            max = schools[i];
            max_index = i;
        }
    }
    
    printf("%ld %ld\n",max_index,max);
    return 0;
}*/

/*
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int character[129] = {0};
    char c;
    bool hasU = true;
    while ((c = getchar()) != '\n')
    {
        if (c != '+') {
            if (c >= 'A' && c <= 'Z') {
                character[c] = 1;
                c -= ('A' - 'a');
            }
            character[c] = 1;
        }
        else hasU = false;
    }
    string str;
    cin >> str;
    for (int i = 0;str[i] != '\0';i ++)
    {
        if ((!hasU) && (str[i] >= 'A' && str[i] <= 'Z')) continue;
        if (character[str[i]] == 1) continue;
        cout << str[i];
    }
    cout << endl;
    return 0;
}
*/

//#include <stdio.h>
//#include <vector>
//
//int main()
//{
//    const int N = 10;
//    int a[N];
//    for (int i = 0;i < N;i ++)
//    {
//        scanf("%d",&a[i]);
//    }
//    for (int j = 0;j < (N + 1) / 2;j ++)
//    {
//
//    }
//
//}

/*#include <stdio.h>

int main()
{
    int n;
    char c;
    scanf("%d %c",&n,&c);
    float hh = n / 2.0;
    hh += 0.5;
    int h = (int) hh;
    for (int i = 0;i < n;i ++) printf("%c",c);
    printf("\n");
    for (int i = 0;i < h - 2;i ++)
    {
        printf("%c",c);
        for (int j = 0;j < n - 2;j ++) printf(" ");
        printf("%c\n",c);
    }
    for (int i = 0;i < n;i ++) printf("%c",c);
    printf("\n");
    return 0;
}*/

/*
#include <stdio.h>

struct Money {
    long galleon;
    long sickle;
    long knut;
};

long toKnut(struct Money m)
{
    long st = m.sickle + m.galleon * 17;
    return st * 29 + m.knut;
}

struct Money toMoney(long knut)
{
    long st = knut / 29;
    knut %= 29;
    long gl = st / 17;
    st %= 17;
    struct Money r;
    r.galleon = gl;
    r.sickle = st;
    r.knut = knut;
    return r;
}

int main()
{
    struct Money P,A;
    scanf("%ld.%ld.%ld %ld.%ld.%ld",&P.galleon,&P.sickle,&P.knut,&A.galleon,&A.sickle,&A.knut);
    long leftK = toKnut(A) - toKnut(P);
    long isF = (leftK < 0) ? -1 : 1;
    leftK *= isF;
    struct Money left = toMoney(leftK);
    if (isF < 0) printf("-");
    printf("%ld.%ld.%ld\n",left.galleon,left.sickle,left.knut);
    return 0;
}*/


/*#include <stdio.h>

int main()
{
    int N;
    scanf("%d",&N);
    int scr[101] = {0};
    for (int i = 0;i < N;i ++)
    {
        int n;
        scanf("%d",&n);
        scr[n] += 1;
    }
    int K;
    scanf("%d",&K);
    for (int i = 0;i < K;i ++)
    {
        int n;
        scanf("%d",&n);
        if (i != 0) printf(" ");
        printf("%d",scr[n]);
    }
    return 0;
}*/

/*
#include <stdio.h>

int main()
{
    int cs[128] = {0};
    char c;
    while ((c = getchar()) != '\n')
    {
        cs[c] ++;
    }
    char need[1001];
    scanf("%s",need);
    for (int i = 0;need[i] != '\0';i ++)
    {
        cs[need[i]] --;
    }
    int duo = 0;
    int shao = 0;
    for (int i = 0;i < 128;i ++)
    {
        if (cs[i] < 0) shao += cs[i] * -1;
        else duo += cs[i];
    }
    if (shao == 0) printf("Yes %d\n",duo);
    else printf("No %d\n",shao);
    return 0;
}*/


//#include <stdio.h>
//#include <iostream>
//#include <string>
//
//using namespace std;
//
//int main()
//{
//    string in;
//    cin >> in;
//    long words = 0;
//    for (int i = 0;in[i] != '\0';i ++)
//    {
//        if (in[i] == 'P')
//        {
//            int hasA = 0;
//            for (int j = i + 1;in[j] != '\0';j ++)
//            {
//
//                if (in[j] == 'T') {
//                    words ++;
//                    break;
//                }
//            }
//        }
//    }
//    return 0;
//}

/*
#include <stdio.h>

struct Student
{
    char zhen[17];
    int zuo;
};

int main()
{
    int N;
    scanf("%d",&N);
    struct Student s[N + 1];
    
    for (int t = 0;t < N;t ++)
    {
        struct Student st;
        int j;
        scanf("%s %d %d", st.zhen, &j, &st.zuo);
        s[j] = st;
    }
    int k;
    scanf("%d",&k);
    for (int i = 0;i < k;i ++)
    {
        int j;
        scanf("%d",&j);
        printf("%s %d\n",s[j].zhen,s[j].zuo);
    }
    return 0;
}
*/

/*
#include <stdio.h>

int main()
{
    int t;
    scanf("%d",&t);
    int an = 0,bn = 0;
    for (int r = 0;r < t;r ++)
    {
        int ah,ax,bh,bx;
        scanf("%d %d %d %d",&ah,&ax,&bh,&bx);
        int sum = ah + bh;
        if (ax == sum && bx == sum) continue;
        if (ax == sum) bn ++;
        if (bx == sum) an ++;
    }
    printf("%d %d",an,bn);
    return 0;
}*/

/*
#include <stdio.h>

int main()
{
    int N;
    scanf("%d",&N);
    int num[N];
    for (int i = 0;i < N;i ++)
    {
        scanf("%d",&num[i]);
    }
    long sum = 0;
    for (int i = 0;i < N;i ++)
        for (int j = i + 1;j < N;j ++)
        {
            int n1 = num[i] * 10 + num[j],n2 = num[j] * 10 + num[i];
            sum += n1;
            if (n1 != n2) sum += n2;
        }
    
    printf("%ld\n",sum);
    return 0;
}
*/

/*
#include <stdio.h>

int main()
{
    int N,M;
    scanf("%d %d",&N,&M);
    int mn[M];
    for (int i = 0;i < M;i ++) scanf("%d",&mn[i]);
    int dc[M];
    for (int i = 0;i < M;i ++) scanf("%d",&dc[i]);
    for (int i = 0;i < N;i ++)
    {
        int sum = 0;
        for (int j = 0;j < M;j ++)
        {
            int n;
            scanf("%d",&n);
            if (n == dc[j]) sum += mn[j];
        }
        printf("%d\n",sum);
    }
    return 0;
}*/

/*
#include <stdio.h>

int main()
{
    int M,N;
    scanf("%d %d",&M,&N);
    int A,B;
    int To;
    scanf("%d %d %d",&A,&B,&To);
    for (int i = 0;i < M;i ++)
    {
        for (int j = 0;j < N;j ++)
        {
            int a;
            scanf("%d",&a);
            if (a >= A && a <= B) a = To;
            if (j != 0) printf(" ");
            printf("%03d",a);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int T,k;
    scanf("%d %d",&T,&k);
    for (int i = 0;i < k;i ++)
    {
        int n1,b,t,n2;
        scanf("%d %d %d %d",&n1,&b,&t,&n2);
        if (t > T) printf("Not enough tokens.  Total = %d.\n",T);
        else {
            int ok = (n1 > n2) ? 0 : 1;
            if (b == ok)
            {
                T += t;
                printf("Win %d!  Total = %d.\n",t,T);
            } else {
                T -= t;
                printf("Lose %d.  Total = %d.\n",t,T);
                if (T <= 0) {
                    printf("Game Over.\n");
                    break;
                }
            }
        }
    }
    return 0;
}
*/

/*
int main()
{
    int r;
    scanf("%d",&r);
    for (int t = 0;t < r;t ++)
    {
        for (int i = 0;i < 4;i ++)
        {
            char str[4];
            scanf("%s",str);
            char a = str[0],b = str[2];
            if (b == 'T') printf("%c",a - 'A' + '1');
        }
    }
    return 0;
}*/

/*using namespace std;

int main()
{
    int t = 0;
    string num;
    getline(cin,num);
    for (int i = 0;num[i] != '\0';i ++)
    {
        t = t * 10 + num[i] - '0';
    }
    for (int r = 0;r < t;r ++)
    {
        string pw;
        getline(cin,pw);
        int hasNum = 0;
        int hasLetter = 0;
        int invalid = 0;
        int i = 0;
        for (;pw[i] != '\0';i ++)
        {
            
            if ((pw[i] >= 'a' && pw[i] <= 'z') || (pw[i] >= 'A' && pw[i] <= 'Z'))
                hasLetter = 1;
            else if (pw[i] >= '0' && pw[i] <= '9')
                hasNum = 1;
            else if (pw[i] != '.') invalid = 1;
        }
        if (i < 6) printf("Your password is tai duan le.\n");
        else if (invalid) printf("Your password is tai luan le.\n");
        else
        {
            if (hasLetter && !hasNum) printf("Your password needs shu zi.\n");
            if (hasNum && !hasLetter) printf("Your password needs zi mu.\n");
            if (hasNum && hasLetter) printf("Your password is wan mei.\n");
        }
        
    }
    return 0;
}*/

/*
int main()
{
    int M;
    scanf("%d",&M);
    for (int u = 0;u < M;u ++)
    {
        long long K;
        scanf("%lld",&K);
        int length = log10(K) + 1;
        long long num = 0;
        double len = pow(10, length);
        long long K2 = K * K;
        int has = 0;
        for (long long N = 1;N < 10;N ++)
        {
            num = N * K2;
            //printf("num = %lld ",num);
            double d = ((double) num) / len;
            //printf("d = %lf  ",d);
            long long zheng = d;
            double mm = ((d - (double) zheng)) * len;
            mm += 0.1;
            long long mo = mm;
            //printf("mo = %lld\n",mo);
            if (mo == K) {
                printf("%lld %lld\n",N,K2 * N);
                has = 1;
                break;
            }
        }
        if (!has) printf("No\n");
    }
    return 0;
}
*/

/*#include <stdio.h>

int main()
{
    char c;
    char cs[128] = {0};
    while ((c = getchar()) != '\n')
    {
        if (c >= 'A' && c <= 'Z') c += 'a' - 'A';
        if (c >= 'a' && c <= 'z') cs[c] ++;
    }
    int max = 0;
    char cc = '\0';
    for (char i = 0;i < 127;i ++)
    {
        if (cs[i] > max && (i >= 'a' && i <= 'z'))
        {
            max = cs[i];
            cc = i;
        }
    }
    printf("%c %d",cc,max);
    return 0;
}
*/

/*#include <stdio.h>

int main()
{
    char cs[128] = {0};
    char c;
    while ((c = getchar()) != EOF && c != '\n')
    {
        cs[c] ++;
    }
    const int length = 6;
    int n = length;
    char str[] = "PATest";
    while (n > 0) {
        n = length;
        for (int i = 0;str[i] != '\0';i ++)
        {
            if (cs[str[i]] == 0) n --;
            else {
                printf("%c",str[i]);
                cs[str[i]] --;
            }
        }
    }
    return 0;
}*/

/*
#include <iostream>
#include <stdio.h>
#include <string>
#include <vector>
#include <map>

using namespace std;

int main()
{
    map<int,string> EtM;
    map<string,int> MtE;
    EtM[0] = "tret";
    MtE["tret"] = 0;
    string nm[] = {"jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec"};
    string _nm[] = {"tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou"};
    for (int i = 1;i <= 12;i ++)
    {
        EtM[i] = nm[i - 1];
        MtE[nm[i - 1]] = i;
        EtM[i * 13] = _nm[i - 1];
        MtE[_nm[i - 1]] = i * 13;
    }
    int N;
    scanf("%d ",&N);
    for (int t = 0;t < N;t ++)
    {
        string input;
        getline(cin, input);
        if (input[0] >= '0' && input[0] <= '9')
        {
            int num = 0;
            for (int i = 0;input[i] != '\0';i ++)
            {
                num = num * 10 + input[i] - '0';
            }
            if (num == 0) cout << EtM[0] << endl;
            else
            {
                int a1 = num % 13;
                num /= 13;
                if (num != 0) cout << EtM[num * 13];
                if (num != 0 && a1 != 0) cout << " ";
                if (a1 != 0) cout << EtM[a1];
                cout << endl;
            }
        } else
        {
            int num = 0;
            if (input[3] == ' ')
            {
                num = MtE[input.substr(0,3)] + MtE[input.substr(4,3)];
            } else {
                num = MtE[input];
            }
            printf("%d\n",num);
        }
    }
    
    
    return 0;
}
*/

/*
#include <stdio.h>

int main()
{
    char cs[128] = {0};
    char c;
    for (int i = 0;i < 2;i ++)
    while ((c = getchar()) != EOF && c != '\n')
    {
        if (cs[c] == 0)
        {
            printf("%c", c);
            cs[c] ++;
        }
    }
    return 0;
}
*/

/*
#include <stdio.h>
#include <math.h>

int isZhi(int n)
{
    for (int i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int toNum(char *start,int length)
{
    int num = 0;
    for (char *i = start;i < start + length;i ++)
    {
        num = num * 10 + *i - '0';
    }
    return num;
}

int numChanged(int origin,int length, int newNum)
{
    return (origin % (int) pow(10, length - 1)) * 10 + newNum;
}

int main()
{
    int L,K;
    scanf("%d %d",&L,&K);
    char num[L + 1];
    scanf("%s",num);
    int end = K;
    int n = toNum(num, K);
    int found = -1;
    while (end <= L)
    {
        if (isZhi(n))
        {
            found = n;
            break;
        }
        n = numChanged(n, K, num[end] - '0');
        end ++;
    }
    if (found == -1) printf("404\n");
    else {
        int length = log10(found) + 1;
        if (length < K) for (int i = 0;i < K - length;i ++) printf("0");
        printf("%d\n",found);
    }
}
*/

/*
#include <stdio.h>
#include <vector>

int main()
{
    int M,N;
    scanf("%d %d",&N,&M);
    // N 种月饼
    long all[1000] = {0};
    
    for (int r = 0;r < M;r ++)
    {
        for (int i = 0;i < N;i ++)
        {
            int a;
            scanf("%d",&a);
            all[i] += a;
        }
    }
    
    long max = -1;
    std::vector<int> maxs;
    for (int i = 0;i < N;i ++)
    {
        if (all[i] > max)
        {
            max = all[i];
            maxs.clear();
            maxs.push_back(i);
        } else
            if (all[i] == max) maxs.push_back(i);
    }
    int isF = 1;
    printf("%ld\n",max);
    for (int i = 0;i != maxs.size();i ++)
    {
        if (isF) isF = 0;
        else printf(" ");
        printf("%d",maxs[i] + 1);
    }
    return 0;
}
*/

//#include <stdio.h>
//
//int main()
//{
//    int N;
//    scanf("%d",&N);
//    for (int j = 0;j < N;j ++)
//    {
//        int a;
//        scanf("%d",&a);
//        printf("%d\n",a);
//    }
//    return 0;
//}

/*int main()
{
    int N;
    scanf("%d",&N);
    int dui[1001] = {0};
    for (int j = 0;j < N;j ++)
    {
        int d,yuan,scr;
        scanf("%d-%d %d",&d, &yuan, &scr);
        dui[d] += scr;
    }
    
    int max = 0;
    int maxIndex = 0;
    for (int i = 1;i < 1001;i ++)
    {
        if (dui[i] > max) {
            maxIndex = i;
            max = dui[i];
        }
    }
    printf("%d %d\n", maxIndex, max);
    return 0;
}*/

/*
#include <string>
#include <iostream>

using namespace std;

int main()
{
    string A,B;
    cin >> A >> B;
    int A_S = (int) A.size();
    int B_S = (int) B.size();
    for (int i = 0;i < B_S - A_S ;i ++) A = '0' + A;
    for (int i = 0;i < A_S - B_S ;i ++) B = '0' + B;
    int index = 1;
    string ans = "";
    for (int i = max(A_S, B_S) - 1;i >= 0;i --)
    {
        int a = A[i] - '0';
        int b = B[i] - '0';
        if (index % 2 == 1)
        {
            int l = (a + b) % 13;
            if (l >= 0 && l <= 9) ans = ((char) (l + '0')) + ans;
            else {
                char ll = '\0';
                switch (l) {
                    case 10:
                        ll = 'J';
                        break;
                    case 11:
                        ll = 'Q';
                        break;
                    case 12:
                        ll = 'K';
                        break;
                    default:
                        break;
                }
                ans = ll + ans;
            }
        } else {
            int l = b - a;
            if (l < 0) l += 10;
            ans = ((char) (l + '0')) + ans;
        }
        index ++;
    }
    cout << ans << endl;
    return 0;
}
*/

/*
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    double sum = 0;
    double last = 0;
    double a = 0;
    for (int i = 0;i < n;i ++)
    {
        scanf("%lf", &a);
        sum += (n - i) * a * ((double) (i + 1.0));
        //sum += last;
    }
    printf("%.2f\n",sum);
    return 0;
}*/

/*
#include<stdio.h>
#include<algorithm>
#include<functional>

int main()
{
    int N;
    scanf("%d",&N);
    int m = 1,n = N;
    int i = 1;
    while (m < n)
    {
        if (N % i == 0) {
            m = i;
            n = N / i;
        }
        i ++;
    }
    int arr[10000];
    for (int i  = 0;i < N;i ++)
    {
        scanf("%d",&arr[i]);
    }
    sort(arr,arr + N,std::greater<int>());
    int ju[1000][1000];
    int d = 0;
    int top = 0, bottom = 0, left = 0, right = 0;
    int x = 0,y = 0;
    for (int i = 0;i < N;i ++)
    {
        
        switch (d)
        {
            // ->
            case 0:
                ju[x][y] = arr[i];
                x ++;
                if (x == n - right)
                {
                    d = 3;
                    x --;
                    y ++;
                    top ++;
                }
                break;
            // <-
            case -1:
                ju[x][y] = arr[i];
                x --;
                if (x == left - 1)
                {
                    d = 2;
                    y --;
                    x ++;
                    bottom ++;
                }
                break;
            // up
            case 2:
                ju[x][y] = arr[i];
                y --;
                if (y == top - 1)
                {
                    y ++;
                    x ++;
                    d = 0;
                    left ++;
                }
                break;
            // down
            case 3:
                ju[x][y] = arr[i];
                y ++;
                if (y == m - bottom)
                {
                    d = -1;
                    x --;
                    y --;
                    right ++;
                }
                break;
            default:
                break;
                
        }
    }
    
    // Print
    int f = 1;
    for (int i = 0;i < m;i ++)
    {
        f = 1;
        for (int j = 0;j < n;j ++)
        {
            if (f == 1) f = 0;
            else printf(" ");
            printf("%d", ju[j][i]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*int main()
{
    int T;
    scanf("%d",&T);
    for (int t = 0;t < T;t ++)
    {
        int n;
        int k; // 抓鱼
        scanf("%d %d",&n,&k);
        vector<int> time_cook;
        int tt; // 炖鱼时间
        for (int r = 0;r < n;r ++)
        {
            scanf("%d",&tt);
            time_cook.push_back(tt);
        }
        sort(time_cook.begin(), time_cook.end(), greater<int>());
        int time_all = 0;
        time_all += k;
        int ok = 1;
        n --;
        while (ok > 0)
        {
            int current = time_cook[0];
            time_cook.erase(time_cook.begin());
            int times = 0;
            while (n > 0 && times <= current)
            {
                times += k;
                n --;
                ok ++;
            }
            if (n > 0)
            {
                int time_not = current - times;
                int time_yes = times + k - current;
                if (time_not > time_yes)
                {
                    
                    
                }
            }
        }
    }
    
    return 0;
}*/

/*int arr[101][101];

int arr_s[101][101];

int dp(int n, int x,int y)
{
    if (arr_s[y][x] >= 0) return arr_s[y][x];
    else return arr_s[y][x] = arr[y][x] + ((y == n - 1) ? 0 : max(dp(n, x, y + 1), dp(n, x + 1,y + 1)));
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n;
        memset(arr_s,-1,sizeof(arr_s));
        scanf("%d",&n);
        for (int y = 0;y < n;y ++) {
            for (int x = 0;x <= y;x ++) scanf("%d",&arr[y][x]);
        }
        
        printf("%d\n",dp(n,0,0));
    }
    return 0;
}*/

/*int main()
{
    int K;
    map<int,double,greater<int> > all;
    scanf("%d",&K);
    for (int t = 0;t < K;t ++)
    {
        int key;
        double value;
        scanf("%d %lf",&key,&value);
        auto it = all.find(key);
        if (it != all.end()) {
            all[key] += value;
            if (all[key] == 0) all.erase(it);
        }
        else all[key] = value;
    }
    scanf("%d",&K);
    for (int t = 0;t < K;t ++)
    {
        int key;
        double value;
        scanf("%d %lf",&key,&value);
        auto it = all.find(key);
        if (it != all.end()) {
            all[key] += value;
            if (all[key] == 0) all.erase(it);
        }
        else all[key] = value;
    }
    printf("%d", (int) all.size());
    string a = "";
    for (auto i = all.begin();i != all.end();i ++)
    {
        printf(" %d %.1f",i -> first,i -> second);
    }
    return 0;
}
*/

/*int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int t;
        scanf("%d",&t);
        int last = -1;
        int a;
        while (t --)
        {
            scanf("%d",&a);
            if (last == -1) last = a;
            else {
                if (last > a)
                {
                    int t = last;
                    last = a;
                    a = t;
                }
                last = gcd(a, last);
            }
        }
        printf("%d\n",last);
    }
    return 0;
}*/

/*
int main()
{
    string str;
    char c['Z' + 1] = {0};
    while (getline(cin,str))
    {
        for (int i = 0;str[i] != '\0';i ++)
        {
            if (str[i] >= 'a' && str[i] <= 'z')
            {
                c[str[i] - 32] ++;
            } else if (str[i] >= 'A' && str[i] <= 'Z')
            {
                c[str[i]] ++;
            }
        }
    }
    int max = -1;
    for (char i = 'A';i <= 'Z';i ++)
    {
        if (c[i] > max) max = c[i];
    }
    
    while (max != 0)
    {
        int f = 1;
        for (char i = 'A';i <= 'Z';i ++)
        {
            if (f) f = 0;
            else printf(" ");
            if (c[i] == max)
            {
                printf("*");
                c[i] --;
            } else printf(" ");
        }
        printf("\n");
        max --;
    }
    for (char i = 'A';i <= 'Z';i ++)
    {
        if (i != 'A') printf(" ");
        printf("%c",i);
    }
    return 0;
}
*/

// zcmuOJ 1029-normal
/*int main()
{
    int i,j;
    while (scanf("%d %d",&i,&j) != EOF) {
        int max_num = -1;
        int q,w;
        q = min(i,j);
        w = max(i,j);
        for (int num = q;num <= w;num ++)
        {
            int n = num;
            int a = 1;
            while (n != 1)
            {
                if (n % 2 == 1) n = 3 * n + 1;
                else n = n / 2;
                a ++;
            }
            max_num = (max_num > a) ? max_num : a;
        }
        printf("%d %d %d\n", i, j, max_num);
    }
    return 0;
}*/

// zcmuOJ 1029-dp
/*map<int,int> dp;

int dd(int n)
{
    if (n == 1) return 1;
    if (n % 2 == 1) n = 3 * n + 1;
    else n = n / 2;
    if (dp.find(n) != dp.end()) return dp[n];
    return dp[n] = dd(n) + 1;
}

int main()
{
    int i,j;
    while (scanf("%d %d",&i,&j) != EOF) {
        int max_num = -1;
        int s,b;
        s = min(i,j);
        b = max(i,j);
        for (int n = s;n <= b;n ++)
        {
            int a = dd(n);
            max_num = (max_num > a) ? max_num : a;
        }
        printf("%d %d %d\n", i, j, max_num);
    }
    return 0;
}*/

/*int main()
{
    const int N = 6;
    int time_all = 0;
    int times;
    int time_ac;
    int a = 0;
    while (scanf("%d %d",&times,&time_ac) != EOF)
    {
        if (!(times == 0 || time_ac == 0)) time_all += (times - 1) * 20 + time_ac;
        a ++;
        if (a == N)
        {
            printf("%d\n",time_all);
            time_all = 0;
            a = 0;
        }
    }
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    return b != 0 ? gcd(b,a % b) : a;
}

int main()
{
    int a,b;
    while (scanf("%d %d",&a,&b) != EOF)
    {
        if (a == 0 && b == 0) break;
        printf("%d\n",gcd(a,b));
    }
    return 0;
}
*/

/*
long long gcd(long long a,long long b)
{
    return b != 0 ? gcd(b,a % b) : a;
}

int main()
{
    long long a,b;
    while (scanf("%lld %lld",&a,&b) != EOF)
    {
        if (a == 0 && b == 0) break;
        printf("%lld\n",a * b / gcd(a,b));
    }
    return 0;
}
*/

/*int main()
{
    int n;
    while (scanf("%d",&n) != EOF)
    {
        long long a = 1;
        for (int i = 1;i <= n;i ++)
            a *= i;
        printf("%lld\n",a);
    }
    return 0;
}*/

/*
int main()
{
    int a,b;
    while (scanf("%d %d",&a,&b) != EOF)
    {
        if (a == 0 && b == 0) break;
        long long n = 1;
        if (b > a / 2) b = a - b;
        for (int i = 1,c = a;i <= b;i ++,c --)
        {
            n *= c;
            n /= i;
        }
        printf("%lld\n",n);
    }
    return 0;
}
*/
/*
int main()
{
    int N;
    scanf("%d",&N);
    while (N --)
    {
        long long a;
        scanf("%lld",&a);
        // 由于3个除数，那么除了自身和1，那么只有完全平方数才符合
        int ok = 1;
        if (a == 1) ok = 0;
        
        long long a_s = sqrt(a);
        if (a_s * a_s == a)
        {
            for (int i = 2;i <= sqrt(a_s);i ++)
                if (a_s % i == 0) {
                    ok = 0;
                    break;
                }
        } else ok = 0;
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}*/

/*
int a(int num)
{
    if (num == 1) return 1;
    return a(num / 2) + 1;
}

int main()
{
    int n;
    while (scanf("%d",&n) != EOF)
    {
        printf("%d\n",a(n));
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int f = 1;
    while (scanf("%d %d",&n,&m) != EOF)
    {
        int a[100][100];
        for (int i = 0;i < n;i ++)
            for (int j = 0;j < m;j ++) scanf("%d",&a[j][i]);
        for (int i = 0;i < n;i ++)
            for (int j = 0;j < m;j ++)
            {
                if (a[j][i] == -1)
                {
                    int num = 0;
                    for (int q = -1;q <= 1;q ++)
                    {
                        for (int w = -1;w <= 1;w ++)
                        {
                            if (j + w >= 0 && j + w < m && i + q >= 0 && i + q < n)
                            {
                                if (a[j + w][i + q] == 9) num ++;
                            }
                        }
                    }
                    a[j][i] = num;
                }
                
            }
        if (f) f = 0;
        else printf("\n");
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < m;j ++) printf("%d",a[j][i]);
            printf("\n");
        }
    }
    return 0;
}
*/

/*
int main()
{
    string in,current;
    while(cin >> in)
    {
        current = "";
        int c = 0;
        for (int i = 0;in[i] != '\0';i ++)
        {
            if (current.size() == 0) {
                current += in[i];
            } else {
                if (in[i] == current[c])
                {
                    c ++;
                    //cout << i << " y>> "<< current << endl;
                } else {
                    c = 1;
                    if (in[i] != current[0]) for (int k = (int) current.size();k <= i;k ++)
                    {
                        current += in[k];
                    }
                    //cout << i << " n>> "<< current << endl;
                }
            
            }
        }
        int e = (int) current.size();
        if (in.size() % e == 0) printf("%d\n",e);
        else printf("%d\n",(int) in.size());
    }
    return 0;
}
*/

/*int main()
{
    int a,b,c;
    while (scanf("%d %d %d",&a,&b,&c) != EOF) {
        if (a == 0 && b == 0 && c == 0) break;
        if (b == 0)
        {
            printf("%d\n",1 % c);
            continue;
        }
        int cr = 0;
        int gui[1000];
        int has = 0;
        for (int i = 1;i <= b;i ++)
        {
            int x = ((int) pow(a,i)) % c;
            if (cr != 0)
            {
                if (x == gui[0]) {
                    has = 1;
                    break;
                }
                else {
                    gui[cr] = x;
                    cr ++;
                }
            } else {
                gui[cr] = x;
                cr ++;
            }
        }
        int last = 0;
        if (has) last = gui[(b - 1) % cr];
        else last = gui[cr - 1];
        printf("%d\n",last);
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    while (scanf("%d %d",&n,&m) != EOF)
    {
        int *a = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        int sum = 0;
        for (int i = 0;i < n;i ++) sum += a[i];
        for (int i = 0;i < m;i ++)
        {
            int x,y;
            int s = sum;
            scanf("%d %d",&x,&y);
            if (x <= y)
            {
                for (int j = x;j < y;j ++) s -= a[j];
            } else {
                for (int j = y;j < x;j ++) s += a[j];
            }
            
            printf("%d\n",s);
        }
    }
    return 0;
}
*/

/*
int main ()
{
    unsigned int n;
    while (scanf("%ud",&n) != EOF)
    {
        int ok = 1;
        for (unsigned int i = 2;i <= sqrt(n);i ++)
        {
            if (n % i == 0) {
                ok = 0;
                break;
            }
        }
        if (n == 1) ok = 0;
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    while (n --) {
        int a;
        int all = 1;
        scanf("%d",&a);
        for (int i = 0;i < a;i ++)
        {
            all += i + 1;
        }
        printf("%d\n",all);
    }
    return 0;
}
*/

/*
int main()
{
    string num;
    while (cin >> num)
    {
        int n;
        scanf("%d",&n);
        if (n + 2 > num.size()) printf("0\n");
        else printf("%c\n",num[n + 1]);
    }
    return 0;
}
*/

/*int main()
{
    int n,m;
    while (scanf("%d %d",&n,&m) != EOF) {
        printf("%d\n",m * n - 1);
    }
    return 0;
}
*/

/*
int main()
{
    int N;
    scanf("%d",&N);
    while (N --)
    {
        string str;
        cin >> str;
        ll sum = 0;
        for (int i = 0;str[i] != '\0';i ++)
        {
            sum += str[i];
        }
        string bin_num = "";
        while (sum != 0)
        {
            bin_num = (char) (sum % 2 + '0') + bin_num;
            sum /= 2;
        }
        cout << bin_num << endl;
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n,o,e;
        scanf("%d %d %d",&n, &o ,&e);
        while (n --)
        {
            string url;
            cin >> url;
            int sum = 0;
            int odd = 0;
            int even = 0;
            for (int i = 0;url[i] != '\0';i ++)
            {
                sum += url[i];
                if (i % 2 == 0) odd += url[i];
                else even += url[i];
            }
            printf("(%d,%d)\n",odd % o + even % e,sum);
        }
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n;
        scanf("%d",&n);
        int m = 0;
        int i = 0;
        for (;i < n;)
        {
            m ++;
            i += log10(m) + 1;
        }
        if (i == n) printf("%d\n", m);
        else printf("-1\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n,c;
    while (scanf("%d %d",&n,&c) != EOF)
    {
        int *w = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",w + i);
        sort(w,w + n);
        int sum = 0,count = 0;
        for (int i = 0;i < n;i ++)
        {
            sum += w[i];
            if (sum <= c) count ++;
        }
        printf("%d\n",count);
    }
    return 0;
}
*/

//int main()
//{
//    int T;
//    while (scanf("%d", &T) != EOF)
//    {
//        vector<int> t(T);
//        vector<int> q(T);
//        for (int i = 0;i < T;i ++) scanf("%d", &t[i]);
//        for (int i = 0;i < T;i ++) scanf("%d", &q[i]);
//        sort(t.begin(), t.end());
//        sort(q.begin(), q.end());
//        int count = 0;
//        int pin = 0;
//        for (vector<int>::iterator i = t.begin(), j = q.begin();i != t.end();)
//        {
//            if (*i > *j)
//            {
//                count ++;
//                t.erase(i);
//                q.erase(j);
//
//            } else
//            {
//                i ++;
//            }
//        }
//        for (vector<int>::iterator i = t.begin(),j = q.begin();i != t.end();i ++,j ++)
//        {
//            if (*i == *j) pin ++;
//        }
//        printf("%d\n",count * 200 - (T - pin - count) * 200);
//    }
//    return 0;
//}

/*
int isHui(string num)
{
    size_t l = num.size();
    size_t l_d = num.size() / 2;
    for (size_t i = 0;i < l_d;i ++)
    {
        if (num[i] != num[l - i - 1]) return 0;
    }
    return 1;
}

int main()
{
    string num;
    while(cin >> num)
    {
        string re,ans;
        int p;
        for (int k = 0;k < 20;k ++)
        {
            ans = num;
            if (isHui(ans)) {
                cout << k << " " << ans << endl;
                goto end;
            }
            re = num;
            reverse(re.begin(),re.end());
            p = 0;
            ans = "";
            for (int i = 0;num[i] != '\0';i ++)
            {
                int pd = num[i] - '0' + re[i] - '0' + p;
                ans = (char) (pd % 10 + '0') + ans;
                p = pd / 10;
            }
            if (p != 0) ans = (char) (p + '0') + ans;
            num = ans;
        }
        printf("impossible\n");
        end:
        continue;
    }

    return 0;
}
*/

/*
int main()
{
    string str;
    while (cin >> str) {
        stringstream ss;
        ss << str;
        double current;
        double a[50];
        double sum = 0;
        char op;
        ss >> current;
        a[0] = current;
        int i = 0;
        while (ss >> op >> current)
        {
            switch (op) {
                case '+':
                    a[++ i] = current;
                    break;
                case '-':
                    a[++ i] = -current;
                    break;
                case '*':
                    a[i] *= current;
                    break;
                case '/':
                    if (current == 0) goto error;
                    a[i] /= current;
                    break;
                default:
                    break;
            }
        }
        for (int j = 0;j <= i;j ++) sum += a[j];
        printf("%e\n",sum);
        goto end;
        error:
        printf("DivByZero\n");
        end:
        continue;
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    while (scanf("%d",&n) != EOF)
    {
        int *a = (int*) malloc(sizeof(int) * (n + 1));
        a[n] = 0;
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        int c;
        scanf("%d",&c);
        int min = 0;
        for (int i = 0;i <= n;i ++)
        {
            int dis = 0;
            for (int j = 0;j <= n;j ++)
            {
                dis += abs(a[j] - a[i]);
            }
            if (i == 0) min = dis;
            else {
                if (dis < min) min = dis;
            }
        }
        printf("%d\n",min * c);
        free(a);
    }
    return 0;
}
*/

/*
int main()
{
    int n,m,a,b;
    while (scanf("%d %d %d %d",&n,&m,&a,&b) != EOF) {
        if (n < m) {
            printf("0\n");
            continue;
        }
        if (b >= a){
            if (n - a < m) printf("1\n");
            else printf("impossible\n");
            continue;
        }
        int t = 0;
        while (n >= m)
        {
            t ++;
            n -= a;
            if (n < m) break;
            n += b;
        }
        printf("%d\n",t);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int f = 1;
    while (getline(cin,str)) {
        if (str.size() >= 2)
        {
            if (str[0] == '/' && str[1] == '/') continue;
        }
        if (f) f = 0;
        else printf("\n");
        string a = "";
        int syh = 0;
        for (int i = 0;str[i] != '\0';i ++)
        {
            if (str[i] == '"') syh = !syh;
            if (str[i] == '/' && !syh)
            {
                if (str[i + 1] != '/')
                {
                    a += '/';
                } else break;
            } else a += str[i];
        }
        size_t s = a.size();
        while (a[s - 1] == ' ')
        {
            a.erase(a.begin() + (s - 1));
            s = a.size();
        }
        cout << a;
    }
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    return b != 0 ? gcd(b,a % b) : a;
}

int main()
{
    int a,b;
    while(scanf("%d %d",&a,&b) != EOF)
    {
        int c = gcd(a, b);
        int a_c = a / c;
        int b_c = b / c;
        int count = 0;
        while (a_c % 2 == 0 || a_c % 3 == 0)
        {
            if (a_c % 2 == 0) {
                a_c /= 2;
                count ++;
            }
            if (a_c % 3 == 0) {
                a_c /= 3;
                count ++;
            }
        }
        if (a_c != 1) {
            printf("-1\n");
            continue;
        }
        while (b_c % 2 == 0 || b_c % 3 == 0)
        {
            if (b_c % 2 == 0) {
                b_c /= 2;
                count ++;
            }
            if (b_c % 3 == 0) {
                b_c /= 3;
                count ++;
            }
        }
        if (b_c != 1) {
            printf("-1\n");
            continue;
        } else printf("%d\n",count);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    while (cin >> str)
    {
        string xun = "";
        int j = 0;
        for (int i = 0;str[i] != '\0';i ++)
        {
            if (str[i] != xun[j])
            {
                j = 0;
                xun = str.substr(0,i + 1);
            } else {
                if (j < xun.size() - 1) j ++;
                else j = 0;
            }
        }
        if (j != 0) xun = str;
        cout << xun.size() << endl;
    }
    
    return 0;
}
*/

//int main()
//{
//    int N,K;
//    int a[100010];
//    while (scanf("%d %d",&N,&K) != EOF)
//    {
//        for (int i = 0;i < N;i ++) scanf("%d",i + a);
//        int s = a[0];
//        int e = a[N - 1];
//        int count = 0;
//        for (int i = 0;i < N;i ++)
//        {
//            if (a[i] % K == 0)
//            {
//                count ++;
//                count += min(a[i] - s,e - a[i]);
//            }
//        }
//
//        printf("%d\n",count);
//    }
//    return 0;
//}

//typedef struct Item
//{
//    int a;
//    int b;
//    int c;
//} Item;
//
//int main()
//{
//    int m,n;
//    while (~scanf("%d %d",&n,&m))
//    {
//        Item *it = (Item*) malloc(sizeof(Item) * n);
//        for (int i = 0;i < n;i ++) scanf("%d",&(it[i].a));
//        for (int i = 0;i < n;i ++) scanf("%d",&(it[i].b));
//        for (int i = 0;i < n;i ++) scanf("%d",&(it[i].c));
//        sort(it, it + n, [](Item a, Item b){return a.b < b.b;});
//        int my = 0;
//        int i = 0;
//        while (i < n)
//        {
//            Item *t = it + i;
//            if (t -> c > 0)
//            {
//                m -= t -> a;
//                my += t -> b;
//                (t -> c) --;
//            } else i ++;
//            if (m <= 0) break;
//        }
//        if (m <= 0) printf("%d\n",my);
//        else printf("Impossible\n");
//    }
//    return 0;
//}

/*int dp[26] = {0};

int f(int n)
{
    if (n == 1 || n == 2)
    {
        return n;
    }
    return (dp[n - 1] == 0 ? (dp[n - 1] = f(n - 1)) : dp[n - 1]) + (dp[n - 2] == 0 ? (dp[n - 2] = f(n - 2)) : dp[n - 2]);
}

int main()
{
    int N;
    while (scanf("%d",&N) != EOF)
    {
        printf("%d\n",f(N));
    }
    return 0;
}*/


/*
int f;

struct Node
{
    struct Node *left;
    struct Node *right;
    int data;
};

struct Node *crt(int data)
{
    struct Node *n = (struct Node*) malloc(sizeof(struct Node));
    n -> left = NULL;
    n -> right = NULL;
    n -> data = data;
    return n;
}

void postorderTraversal(struct Node *nd)
{
    if (nd == NULL) return;
    postorderTraversal(nd -> left);
    postorderTraversal(nd -> right);
    if (f) f = 0;
    else printf(" ");
    printf("%d",nd -> data);
}

void pre_in_add(int *pr, int l, int *in, struct Node **n)
{
    int data = pr[0];
    *n = crt(data);
    int i = 0;
    for (;i < l;i ++) if (in[i] == data) break;
    if (i > 0) pre_in_add(pr + 1, i, in, &((*n) -> left));
    if (i + 1 < l) pre_in_add(pr + 1 + i, l - 1 - i, in + i + 1, &((*n) -> right));
}



int main()
{
    int n;
    while (scanf("%d",&n) != EOF)
    {
        f = 1;
        int *pr = (int*) malloc(sizeof(int) * n);
        int *in = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d", i + pr);
        for (int i = 0;i < n;i ++) scanf("%d", i + in);
        struct Node *root = NULL;
        pre_in_add(pr, n, in, &root);
        postorderTraversal(root);
        printf("\n");
    }
    return 0;
}
*/


/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////
/*
#include<stdio.h>
 
int main()
{
    int n,m;
    while (scanf("%d %d",&n,&m) != EOF && n != 0 && m != 0)
    {
        if (n % 2 == 0 || m % 2 == 0) printf("H\n");
        else printf("X\n");
    }
    return 0;
}
*/

/*
int main()
{
    int t;
    scanf("%d",&t);
    int f = 1;
    while (t --)
    {
        int n;
        scanf("%d",&n);
        double ji = 0;
        double unji = 0;
        while (n --)
        {
            int a;
            scanf("%d",&a);
            if (a >= 60) ji ++;
            else unji ++;
        }
        double rate = ji / (ji + unji) * 100.0;
        if (f) f = 0;
        else printf("\n\n");
        printf("%.3f%%",rate);
    }
    return 0;
}
*/

/*
map<int,int> dp;

int go(int n)
{
    if (n == 1) return 1;
    else if (n % 2 == 1) n = 3 * n + 1;
    else n /= 2;
    return dp.find(n) != dp.end() ? dp[n] : dp[n] = go(n) + 1;
}

int main()
{
    int a,b,m,n;
    while (~scanf("%d %d",&m,&n))
    {
        int max = 0;
        a = m;
        b = n;
        if (m > n)
        {
            a = n;
            b = m;
        }
        for (int i = a;i <= b;i ++)
        {
            int k = go(i);
            if (k >= max) max = k;
        }
        printf("%d %d %d\n",m,n,max);
    }
    return 0;
}
*/

//int find(int *a, int i, int n, int s, int sum, int ct)
//{
//    if (i == n) {
//        if (sum == s && ct == 3) return 1;
//        return 0;
//    }
//    if (find(a, i + 1, n, s, sum, ct)) return 1;
//    if (find(a, i + 1, n, s, sum + a[i], ct + 1)) return 1;
//    return 0;
//}
//
//int main()
//{
//    int n;
//    while (scanf("%d",&n) != EOF)
//    {
//        int *a = (int*) malloc(sizeof(int) * n);
//        for (int i = 0;i < n;i ++) scanf("%d",a + i);
//        sort(a,a + n);
//        long sum = 0;
//        for (int i = 0;i < n;i ++)
//        {
//            sum += a[i];
//        }
//        for (int i = n - 1;i >= 0;i --)
//        {
//            sum -= a[i];
//            if (sum >= a[i])
//            {
//                if (find(a, 0, i, a[i], 0, 0)) {
//                    printf("%d\n", a[i]);
//                    goto ok;
//                }
//            }
//        }
//        printf("no solution\n");
//        ok:
//        continue;
//    }
//    return 0;
//}


/// (a * b) % c = (a % c * b % c) % c.
//int main()
//{
//    int n;
//    while (scanf("%d",&n) != EOF)
//    {
//        int c = 1;
//        int f = 2 % n;
//        int k = 2 % n;
//        while (1)
//        {
//            f = (f * k) % n;
//            c ++;
//            if (f == 1)
//            {
//                printf("2^%d mod %d = 1\n", c, n);
//                goto end;
//            }
//            if (f == k || f == 0) goto error;
//        }
//        error:
//        printf("2^? mod %d = 1\n", n);
//        end:
//        continue;
//    }
//    return 0;
//}

/*
int main()
{
    int m,n;
    while (~scanf("%d %d",&m,&n))
    {
        int *a = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",i + a);
        sort(a,a + n);
        int c = 0;
        for (int i = 0;i < n;i ++)
        {
            if (a[i] > m)
            {
                m += 2;
                c ++;
            }
        }
        m += n - c;
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
struct time
{
    int hour;
    int min;
    double angle;
};

int com(struct time a, struct time b)
{
    if (a.angle == b.angle) return a.hour * 100 + a.min < b.hour * 100 + b.min;
    return a.angle < b.angle;
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        struct time t[5];
        for (int i = 0;i < 5;i ++)
        {
            int h,m;
            scanf("%d:%d", &h, &m);
            struct time *crt = t + i;
            crt -> hour = h;
            crt -> min = m;
            double a = fabs(m * 6.0 - (h % 12) * 30.0 - m * 0.5);
            crt -> angle = (a > 180) ? 360.0 - a : a;
            
        }
        sort(t,t + 5,com);
        int f = 1;
        for (int i = 0;i < 5;i ++)
        {
            if (f) f = 0;
            else printf(" ");
            printf("%02d:%02d",(t + i) -> hour, (t + i) -> min);
        }
        printf("\n");
    }
    return 0;
}
*/

//int dp[1011][1011] = {0};
//
//int T(int k, int n)
//{
//    if (k == 0) return n;
//    int sum = 0;
//    //printf("(");
//    //int f = 1;
//    for (int i = 1;i <= n;i ++)
//    {
//        //if (f) f = 0;
//        //else printf(" ");
//        //printf("%d",i);
//        sum += (dp[k - 1][i] == 0) ? dp[k - 1][i] = T(k - 1, i) : dp[k - 1][i];
//        if (sum >= 100007) sum -= 100007;
//    }
//    //printf(")");
//    return sum;
//}
//
//int main()
//{
//    int k,n;
//    while (~scanf("%d %d",&k,&n))
//    {
//        int sum = 0;
//        for (int j = 0;j < k;j ++)
//        {
//
//        }
//        printf("%d\n",T(k,n));
//    }
//    return 0;
//}



/*int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        int *a = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        sort(a,a + n);
        printf("%d\n",a[n / 2]);
        free(a);
    }
    return 0;
}*/

/*int main()
{
    long long sum = 0;
    long long a,b;
    long long last = 0;
    while (~scanf("%lld %lld",&a,&b))
    {
        sum = 0;
        last = a;
        sum += last;
        for (int i = 1;i < b;i ++)
        {
            last = last * 10 + a;
            sum += last;
        }
        printf("%lld\n",sum);
    }
    return 0;
}*/

/*int main()
{
    int N;
    while (~scanf("%d",&N))
    {
        if (N <= 0) break;
        int k[101] = {0};
        for (int h = 0;h < N;h ++)
        {
            int a,b;
            scanf("%d %d",&a,&b);
            for (int i = a;i <= b;i ++)
            {
                k[i] ++;
            }
        }
        int f = 1;
        for (int i = 1;i <= N;i ++)
        {
            if (f) f = 0;
            else printf(" ");
            printf("%d",k[i]);
        }
        printf("\n");
    }
    return 0;
}*/

/*int main()
{
    int N,M;
    while (~scanf("%d",&N))
    {
        if (N == 0) break;
        scanf("%d",&M);
        int *a = (int*) malloc(sizeof(int) * N);
        memset(a, 0, sizeof(int) * N);
        for (int h = 0;h < M;h ++)
        {
            int p,q;
            scanf("%d %d",&p,&q);
            a[p - 1] ++;
            a[q - 1] --;
        }
        int f = 1;
        int num = 0;
        for (int i = 0;i < N;i ++) {
            num += a[i];
            if (f) f = 0;
            else printf(" ");
            printf("%d",num);
        }
        printf("\n");
    }
    return 0;
}
*/

/*int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n;
        scanf("%d",&n);
        int *a = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        int times = 0;
        for (int i = 0;i < n - 1;i ++)
        {
            for (int j = i + 1;j < n;j ++)
            {
                if (a[i] > a[j])
                {
                    times ++;
                    break;
                }
            }
        }
        printf("%d\n",times);
    }
    return 0;
}
*/

/*int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        if (n % 2 == 0)
        {
            for (int i = 0;i < n / 2;i ++) printf("1");
            printf("\n");
        }
        else {
            printf("7");
            for (int i = 0;i < n / 2 - 1;i ++) printf("1");
            printf("\n");
        }
    }
    return 0;
}
*/

//int main()
//{
//    int N,M,a,b,t;
//    while (~scanf("%d %d",&N,&M))
//    {
//        int *arr = (int*) calloc(N, sizeof(int));
//        for (int j = 0;j < M;j ++)
//        {
//            scanf("%d %d %d",&t,&a,&b);
//            if (a > b)
//            {
//                a = a ^ b;
//                b = a ^ b;
//                a = a ^ b;
//            }
//            if (t == 1) for (int i = a - 1;i < b;i ++) arr[i] = !arr[i];
//            else {
//                for (int i = a - 1;i < b;i ++) printf("%d",arr[i]);
//                printf("\n");
//            }
//        }
//    }
//    return 0;
//}

//int main()
//{
//    int n,m;
//    while (~scanf("%d %d",&n,&m))
//    {
//        if (n == 0 && m == 0) break;
//        vector<set<int>> meng;
//        while (m --)
//        {
//            char c;
//            int a;
//            scanf(" %c",&c);
//            if (c == 'M')
//            {
//                int b;
//                scanf("%d %d",&a,&b);
//                vector<set<int>>::iterator fd_1 = meng.end(), fd_2 = meng.end();
//                for (vector<set<int>>::iterator i = meng.begin();i != meng.end();i ++)
//                {
//                    set<int>::iterator n1 = i -> find(a);
//                    set<int>::iterator n2 = i -> find(b);
//                    if (n1 != i -> end())
//                    {
//                        fd_1 = i;
//                    }
//                    if (n2 != i -> end())
//                    {
//                        fd_2 = i;
//                    }
//                }
//                if (fd_1 == meng.end() && fd_2 == meng.end())
//                {
//                    set<int> s;
//                    s.insert(a);
//                    s.insert(b);
//                    meng.push_back(s);
//                } else if (fd_1 != meng.end() && fd_2 == meng.end())
//                {
//                    fd_1 -> insert(b);
//                } else if (fd_2 != meng.end() && fd_1 == meng.end())
//                {
//                    fd_2 -> insert(a);
//                } else if (fd_1 != fd_2)
//                {
//                    for (set<int>::iterator i;i != fd_2 -> end();i ++)
//                    {
//                        fd_1 -> insert(*i);
//                    }
//                    meng.erase(fd_2);
//                }
//            } else {
//                scanf("%d",&a);
//                for (vector<set<int>>::iterator i = meng.begin();i != meng.end();)
//                {
//                    if (i -> find(a) != i -> end()) meng.erase(i);
//                    else i ++;
//                }
//            }
//        }
//        printf("%lu",meng.size());
//    }
//    return 0;
//}

/*int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        if (a < 12 && b >= 12)
        {
            if (b == 24) printf("%d\n",b - a - 2);
            else printf("%d\n",b - a - 1);
        }
        else if (b % 12 != 0) printf("%d\n",b - a);
        else printf("%d\n",b - a - 1);
    }
    return 0;
}
*/

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    while (T --)
//    {
//        double a,b;
//        scanf("%lf %lf",&a,&b);
//        printf("%.0f\n",pow(a,b) - pow(b,a));
//    }
//    return 0;
//}

//int main()
//{
//    int m,n;
//    while (~scanf("%d %d",&n,&m))
//    {
//        char a[12][12];
//        int s_x,s_y,e_x,e_y;
//        for (int i = 0;i < n;i ++)
//        {
//            scanf(" ");
//            for (int j = 0;j < m;j ++)
//            {
//                char c;
//                scanf("%c",&c);
//                a[i][j] = c;
//                if (c == 'S') {
//                    s_x = j;
//                    s_y = i;
//                } else if (c == 'T')
//                {
//                    e_x = j;
//                    e_y = i;
//                }
//            }
//        }
//        stack<int> stk;
//
//    }
//    return 0;
//}

//struct msn
//{
//    int start;
//    int end;
//};
//
//int com(msn a, msn b)
//{
//    if (a.start == b.start) return a.end > b.end;
//    else return a.start < b.start;
//}
//
//int main()
//{
//    int N;
//    while (~scanf("%d",&N))
//    {
//        if (!N) break;
//        msn *m = (msn*) malloc(sizeof(msn) * N);
//        for (int i = 0;i < N;i ++)
//        {
//            int a,b;
//            scanf("%d %d",&a,&b);
//            (m + i) -> start = a;
//            (m + i) -> end = a + b;
//        }
//        sort(m, m + N, com);
//        //for (int i = 0;i < N;i ++) printf("%d %d\n",m[i].start,m[i].end);
//        for (int i = 0;i < N;i ++)
//        {
//
//        }
//    }
//    return 0;
//}

//int com(pair<int,int> a,pair<int,int> b)
//{
//    if (a.first == b.first) return a.second < b.second;
//    return a.first > b.first;
//}
//
//int main()
//{
//    int T;
//    while (~scanf("%d",&T))
//    {
//        vector<pair<int,int> > a(T);
//        set<int> b;
//        for (int i = 0;i < T;i ++)
//        {
//            int n;
//            scanf("%d",&n);
//            a[i]=pair<int,int>(n,i);
//            b.insert(i);
//        }
//        sort(a.begin(),a.end(),com);
//        int c = 0;
//        for (vector<pair<int,int> >::iterator i = a.begin();i != a.end();i ++)
//        {
//            set<int>::iterator k = b.find(i -> second);
//            c += distance(k,b.end()) - 1;
//            b.erase(k);
//        }
//        printf("%d\n",c);
//    }
//    return 0;

/*int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        queue<int> a;
        stack<int> b;
        priority_queue<int,vector<int>,greater<int> > c;
        priority_queue<int> d;
        for (int i = 0;i < n;i ++)
        {
            int k;
            scanf("%d",&k);
            a.push(k);
            b.push(k);
            c.push(k);
            d.push(k);
        }
        int ok[4] = {1,1,1,1};
        for (int i = 0;i < n;i ++)
        {
            int k;
            scanf("%d",&k);

            if (k != a.front()) ok[0] = 0;
            if (k != b.top()) ok[1] = 0;
            if (k != c.top()) ok[2] = 0;
            if (k != d.top()) ok[3] = 0;

            a.pop();
            b.pop();
            c.pop();
            d.pop();
        }
        int f = 1;
        if (ok[1]) {
            if (f) f = 0;
            else printf(" ");
            printf("stack");
        }
        if (ok[0]) {
            if (f) f = 0;
            else printf(" ");
            printf("queue");
        }
        if (ok[2] || ok[3]) {
            if (f) f = 0;
            else printf(" ");
            printf("priority_queue");
        }
        if (f) printf("none");
        printf("\n");

    }
    return 0;
}
*/

/*
int a[1000002] = {0};
int j = 2;

int main()
{
    int T;
    scanf("%d",&T);
    a[1] = 2;
    a[2] = 4;
    while (T --)
    {
        int n;
        scanf("%d",&n);
        
        if (n == 1) printf("1\n");
        else {
            int k = n / 2 + 1;
            if (k > j) for (int i = j;i < k;i ++)
            {
                a[i] = (a[i / 2] % 1000000000 + a[i - 1] % 1000000000) % 1000000000;
                j ++;
            }
            printf("%d\n",a[k - 1]);
        }
    }
    return 0;
}
*/

/*
int main()
{
    int M, L;
    scanf("%d %d",&L,&M);
    vector<set<int> > aaa(L + 1);
    int *arr = (int*) calloc(L + 1,sizeof(int));
    int *brr = (int*) calloc(M + 1,sizeof(int));
    int n = 1;
    for (int i = 1;i <= M;i ++)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        aaa[a].insert(i);
        aaa[b].insert(i);
        arr[a] = 1;
        arr[b] = 1;
    }
    int k = 0;
    int c = 0;
    for (int i = 0;i <= L;i ++)
    {
        if (k == 0) c ++;
        if (arr[i] != 0)
        {
            for (set<int>::iterator j = aaa[i].begin();j != aaa[i].end();j ++)
            {
                if (brr[*j] == 0)
                {
                    brr[*j] = 1;
                    if (k == 0) c --;
                    k ++;
                } else {
                    k --;
                }
            }
            
        }
        //printf("%d\n",c);
    }
    printf("%d",c);
    return 0;
*/

/*int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        map<int,int> arr;
        for (int i = 0;i < n;i ++) {
            int m;
            scanf("%d", &m);
            arr[m] ++;
        }
        for (map<int,int>::iterator i = arr.begin();i != arr.end();)
        {
            
            int a = i -> first, b = i -> second;
            if (b >= 2) arr[a + 1] += b / 2;
            if (b % 2 == 0)
            {
                arr.erase(i++);
            } else {
                arr[a] = 1;
                i ++;
            }
        }
        
        printf("%lu\n",arr.size());
    }
    return 0;
}*/

/*int main()
{
    int n,k;
    while (~scanf("%d %d",&n,&k))
    {
        int *a = (int*) malloc(sizeof(int) * n);
        for (int i = 0;i < n;i ++) scanf("%d",i + a);
        sort(a,a + n);
        printf("%d\n",a[k - 1]);
        
    }
    
}*/

/*int main()
{
    int n,m;
    while (~scanf("%d %d",&n,&m))
    {
    if (m - n >= 2) printf("NO\n");
    else if (m == 0){
        while (n --) printf("0");
        printf("\n");
    } else {
        if (m > n)
        {
            printf("1");
            while (n --) printf("01");
            printf("\n");
        } else {
            int c = m;
            while (c --) printf("01");
            int k = n - m;
            while (k --) printf("0");
            printf("\n");
        }
    }
    }
    return 0;
}*/

/*int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        if (n <= 36) printf("duiciwohenbaoqian\n");
        else printf("wochengrenniyingle\n");
    }
    return 0;
}*/

/*int main()
{
    int n,w,s;
    while (~scanf("%d %d %d",&n,&w,&s))
    {
        vector<int> a(n);
        for (int i = 0;i < n;i ++) a[i] = i + 1;
        int k = n;
        for (int i = 0;i < n;i ++)
        {
            int m = (w - 1 + s - 1) % k;
            printf("%d\n",a[m]);
            a.erase(a.begin() + m);
            k --;
            if (k != 0) w = m % k + 1;
            
        }
    }
    return 0;
}*/

/*int main()
{
    char num[20] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j'};
    string a,b;
    string ans;
    while (cin >> a >> b)
    {
        ans = "";
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        size_t a_s = a.size();
        size_t b_s = b.size();
        if (a_s > b_s) for (size_t i = b_s;i < a_s;i ++) b += '0';
        else for (size_t i = a_s;i < b_s;i ++) a += '0';
        int jin = 0;
        int current = 0;
        for (int i = 0;i < max(a_s,b_s);i ++)
        {
            int a_n,b_n;
            if (a[i] >= 'a' && a[i] <= 'j') a_n = 10 + a[i] - 'a';
            else a_n = a[i] - '0';
            if (b[i] >= 'a' && b[i] <= 'j') b_n = 10 + b[i] - 'a';
            else b_n = b[i] - '0';
            current = a_n + b_n + jin;
            jin = current / 20;
            current %= 20;
            ans = num[current] + ans;
        }
        if (jin != 0)
        {
            current = jin;
            jin = current / 20;
            current %= 20;
            ans = num[current] + ans;
        }
        cout << ans << endl;
    }
    
    return 0;
}*/

/////////////精度
/*
int main()
{
    int a,b,c,d;
    while (~scanf("%d %d %d %d",&a,&b,&c,&d))
    {
        double k = b * log(a);
        double l = d * log(c);
        //printf("%.5f %.5f\n",k,l);
        if (fabs(k - l) < 1e-10) printf("=\n");
        else if (k > l) printf(">\n");
        else printf("<\n");
    }
    return 0;
}*/

//struct stu
//{
//    double jun;
//    int fen[5];
//} a[50];
//
//int main()
//{
//    int n,m;
//    while (~scanf("%d %d",&n,&m))
//    {
//        double *c = (double*) calloc(m,sizeof(double));
//        for (int i = 0;i < n;i ++)
//        {
//            (a + i) -> jun = 0;
//            for (int j = 0;j < m;j ++)
//            {
//                int k;
//                scanf("%d",&k);
//                *((a + i) -> fen + j) = k;
//                (a + i) -> jun += k;
//                *(c + j) = k;
//            }
//        }
//        for (int i = 0;i < n;i ++)
//        {
//            if (i) printf(" ");
//            printf("%.2f",(a + i) -> jun / m);
//        }
//        printf("\n");
//        for (int i = 0;i < m;i ++)
//        {
// 
//        }
//    }
//    return 0;
//}


/*int main()
{
    int T;
    while (~scanf("%d",&T))
    {
        if (!T) break;
        string a;
        map<string,int> l;
        while (T --)
        {
            cin >> a;
            l[a] ++;
        }
        int max = -1;
        string k;
        for (map<string,int>::iterator i = l.begin();i != l.end();i ++)
        {
            if (i -> second > max)
            {
                max = i -> second;
                k = i -> first;
            }
        }
        cout << k << endl;
    }
    return 0;
}*/

//map<pair<pair<int,int>,int>,int> dp;
//
//int f(int n,pair<int,int> &p)
//{
//    if (n == 1 || n == 2) return 1;
//    return (p.first * f(n  - 1,p) + p.second * f(n - 2,p)) % 7;
//}
//
//int main()
//{
//    int A,B,n;
//    while (~scanf("%d %d %d",&A,&B,&n))
//    {
//        if (!A && !B && !n) break;
//        pair<int,int> a(A,B);
//        printf("%d\n",f(n,a));
//    }
//    return 0;
//}

//////zcmu oj 1226
/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n;
        scanf("%d",&n);
        int has = 0;
        int ans = 1000;
        int last = 0;
        int l = 0;
        int current;
        for (int i = 0;i < n;i ++)
        {
            scanf("%d",&current);
            
            last = max(l, last) + current;
            l = current;
            if (i != 0)
            {
                if (!has) {
                    ans = last;
                    has = 1;
                }
                else ans = max(last, ans);
            }
        }
        if (ans > 0) printf("%d\n",ans);
        else printf("Game Over\n");
    }
    return 0;
}
*/

/*
int w;

void printDot()
{
    for (int i = 0;i < w;i ++) printf(".");
}

int main()
{
    scanf("%d",&w);
    printf("o...o");
    printDot();
    printf("o...o");
    printDot();
    printf("o...o");
    printDot();
    printf("ooooo");
    printDot();
    printf("o...o\n");
    
    printf("o...o");
    printDot();
    printf("oo..o");
    printDot();
    printf("o...o");
    printDot();
    printf("o....");
    printDot();
    printf("oo.oo\n");
    
    printf("ooooo");
    printDot();
           printf("o.o.o");
    printDot();
           printf("o...o");
    printDot();
           printf("o....");
    printDot();
           printf("o.o.o\n");
    
    printf("o...o");
    printDot();
           printf("o..oo");
    printDot();
           printf("o...o");
    printDot();
           printf("o....");
    printDot();
           printf("o...o\n");
    
    printf("o...o");
    printDot();
           printf("o...o");
    printDot();
           printf("ooooo");
    printDot();
           printf("ooooo");
    printDot();
           printf("o...o\n");
    return 0;
}
*/

/*
int main()
{
    int N,k;
    scanf("%d %d",&N,&k);
    
    int a[1000][1000] = {0};
    int y[5][5] = {0};
    char c;
    for (int i = 0;i < N;i ++)
    {
        scanf(" ");
        for (int j = 0;j < N;j ++)
        {
            scanf("%c",&c);
            if (c == '.') y[i][j] = 1;
        }
    }
    
    
    
    int b[1000][1000] = {0};
    int n = N;
    for (int i = 0;i < n;i ++) for (int j = 0;j < n;j ++) a[i][j] = y[i][j];
    for (int z = 1;z < k;z ++)
    {
        for (int q = 0;q < N;q ++)
        {
            for (int w = 0;w < N;w ++)
            {

                for (int i = 0;i < n;i ++)
                {

                    for (int j = 0;j < n;j ++)
                    {
                        if (y[q][w]) b[q * n + i][w * n + j] = a[i][j];
                        else b[q * n + i][w * n + j] = 0;
                    }
                }
            }
        }

        n *= N;
        for (int i = 0;i < n;i ++) for (int j = 0;j < n;j ++) a[i][j] = b[i][j];

    }
    
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            if (a[i][j]) c = '.';
            else c = '*';
            printf("%c",c);
        }
        if (i != n - 1) printf("\n");
    }
    return 0;
}
*/

/*int main()
{
    uint n;
    uint sum,a;
    while (~scanf("%d",&n))
    {
        sum = 0;
        while (n --)
        {
            scanf("%u",&a);
            sum += a;
        }
        printf("%u\n",sum);
    }
    return 0;
}
*/

/*
int main()
{
    int m,n;
    while (~scanf("%d %d",&n,&m))
    {
        vector<string> arr;
        string line;
        for(int i=0; i<n; i++)
        {
            cin >> line;
            arr.push_back(line);
        }

        long q;
        scanf("%ld", &q);
        while(q--){
            int o;
            scanf("%d",&o);
            int f = 1;
            if(o){
                if (f) f = 0;
                else printf("\n");
                int x1, y1, x2, y2;
                scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
                int s[26] = {0};
                for(int i=x1; i<=x2; i++){
                    for(int j=y1; j<=y2; j++) {
                        s[arr[i-1][j-1] - 'a'] ++;
                    }
                }
                for(int i=0; i<26; i++){
                    if(i!=0){
                        printf(" ");
                    }
                    printf("%d", s[i]);
                }
            }else{
                int x, y;
                char z;
                scanf("%d %d %c", &x, &y, &z);
                arr[x-1][y-1] = z;
            }
        }
    }
    return 0;
}
*/

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    map<string,int> arr_name;
//    map<int,string> arr_src;
//    for (int i = 0;i < n;i ++)
//    {
//        string name;
//        int src;
//        cin >> name >> src;
//        arr_name[name] = src;
//        arr_src[src] = name;
//    }
//    int m;
//    scanf("%d",&m);
//    int mx = -1;
//    for (int i = 0;i < m;i ++)
//    {
//        int a;
//        scanf("%d",&a);
//        if (a > mx) mx = a;
//    }
//
//    return 0;
//}

//int main()
//{
//    string str;
//    string chn = "CHN";
//    cin >> str;
//    int cnt = 0;
//    set<int> c,h,n;
//    for (int i = 0;str[i] != 0;i ++)
//    {
//        if (str[i] == 'C') c.insert(i);
//        else if (str[i] == 'H') h.insert(i);
//        else if (str[i] == 'N') n.insert(i);
//    }
//    for (set<int>::iterator i = c.begin();i != c.end();i ++) printf("%d ",*i);
//    printf("\n");
//    for (set<int>::iterator i = h.begin();i != h.end();i ++) printf("%d ",*i);
//    printf("\n");
//    for (set<int>::iterator i = n.begin();i != n.end();i ++) printf("%d ",*i);
//    printf("\n");
//
////    for (set<int>::iterator i = c.begin();i != c.end();i ++)
////    {
////        for ()
////    }
//    //printf("%d",cnt);
//
//    return 0;
//}

/*int dp[505] = {0};

int f(int n)
{
    if (n == 1) return 1;
    int i = n - 3;
    int m = (1 + i) / 2;
    int k = (2 - i % 2 + i) * m / 2;
    return dp[n] = (dp[n - 1] == 0 ? f(n - 1) : dp[n - 1]) + 2 * n - 1 + (n - 1) * n / 2 + k;
}

int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        printf("%d\n",f(n));
        //for (int i = 0;i < 500;i ++) printf("%d ",dp[i]);
    }
    return 0;
}*/

/*int main()
{
    char a[5];
    scanf("%s",a);
    for (int i = 0;i < 4;i ++)
    {
        a[i] = (a[i] - '0' + 9) % 10;
    }
    printf("The encrypted number is %hhd%hhd%hhd%hhd\n",a[2],a[3],a[0],a[1]);
    return 0;
}*/

/*
int main()
{
    int N;
    while (~scanf("%d",&N))
    {
        double sum = 0;
        int k = 0;
        while (N --)
        {
            int s;
            char c;
            double a = 0;
            scanf("%d %c",&s,&c);
            if (c != 'P' && c != 'N')
            {
                switch (c) {
                    case 'A':
                        a = 4;
                        break;
                    case 'B':
                        a = 3;
                        break;
                    case 'C':
                        a = 2;
                        break;
                    case 'D':
                        a = 1.3;
                        break;
                }
                k += s;
                sum += s * a;
            }
        }
        if (k != 0) sum /= k;
        printf("%.2lf\n",sum);
    }
    return 0;
}
*/

/*int main()
{
    int T;
    scanf("%d", &T);
    while (T --)
    {
        int K;
        scanf("%d",&K);
        string str = "a";
        int k = 0;
        int n = 'b';
        int i = 1;
        while (k != K)
        {
            str += n;
            if (str[i] > str[i - 1]) k ++;
            if (n != 'z') n ++;
            else {
                n = 'a';
            }
            i ++;
        }
        reverse(str.begin(), str.end());
        cout << str << endl;
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    multiset<int> s;
    while (n --)
    {
        int op, n;
        scanf("%d %d", &op, &n);
        int i;
        multiset<int>::iterator l;
        switch (op) {
            case 1:
                s.insert(n);
                break;
            case 2:
                s.erase(s.find(n));
                break;
            case 3:
                l = s.find(n);
                if (l != s.end()) printf("%ld\n",distance(s.begin(), l) + 1);
                break;
            case 4:
                i = 0;
                for (multiset<int>::iterator p = s.begin(); p != s.end(); p ++, i ++)
                {
                    if (i == n - 1) {
                        printf("%d\n", *p);
                        break;
                    }
                }
                break;
            case 5:
                l = s.find(n);
                if (l == s.end()) l = s.upper_bound(n);
                if (l != s.begin()) printf("%d\n",*(-- l));
                break;
            case 6:
                l = s.upper_bound(n);
                if (l != s.end()) printf("%d\n",*l);
                break;
            default:
                for (multiset<int>::iterator p = s.begin();p != s.end();p ++) printf("%d ",*p);
                printf("\n");
                break;
        }
        
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    vector<int> s;
    for (int i = 1;i <= n;i ++) s.push_back(i);
    while (m --)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        reverse(s.begin() + (a - 1), s.begin() + b);
    }
    
    for (vector<int>::iterator i = s.begin();i != s.end();i ++)
    {
        if (i != s.begin()) printf(" ");
        printf("%d",*i);
    }
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    return b != 0 ? gcd(b,a % b) : a;
}

int main()
{
    int T;
    scanf("%d",&T);
    int a[(int)1e5+10];
    while (T --)
    {
        int l;
        scanf("%d",&l);
        int last;
        int ok = -1;
        for (int i = 0;i < l;i ++) {
            scanf("%d",a + i);
            if (i > 0) {
                if (i == 1) last = gcd(a[i],a[i - 1]);
                else last = gcd(a[i],last);
                if (last == 1) ok = 1;
            }
        }
        if (ok != -1) ok = l;
        printf("%d\n",ok);
    }
    return 0;
}
*/

//int com(pair<int,int> a, pair<int,int> b)
//{
//    if (a.second == b.second) return a.first < b.first;
//    return a.second > b.second;
//}
//
//int main()
//{
//    int T;
//    scanf("%d",&T);
//    while (T --)
//    {
//        int v,n;
//        scanf("%d %d", &v, &n);
//        pair<int,int> ab[1010];
//        for (int i = 0;i < n;i ++) scanf("%d %d",&(ab + i) -> first, &(ab + i) -> second);
//
//        /*sort(ab, ab + n, com);
//        int ok = 1;
//        for (int i = 0;i < n;i ++)
//        {
//            pair<int,int> *it = ab + i;
//            printf("v=%d\n",v);
//            if (v >= it -> second) v -= it -> first;
//            else {
//                ok = 0;
//                break;
//            }
//            printf(">>%d %d\n",(ab + i) -> first, (ab + i) -> second);
//        }
//        if (ok) printf("Yes\n");
//        else printf("No\n");*/
//    }
//    return 0;
//}

/*
int main()
{
    string str;
    cin >> str;
    string p;
    cin >> p;
    int ps = -1;
    int cnt = 0;
    while ((ps = str.find(p, ps + 1)) != string::npos)
    {
        cnt ++;
    }
    printf("%d",cnt);
    return 0;
}
*/

//int main()
//{
//    int n;
//    int tmp;
//    while (~scanf("%d",&n))
//    {
//        vector<set<int> > v;
//        while (n --)
//        {
//            int k;
//            scanf("%d", &k);
//            set<int> s;
//            while (k --)
//            {
//                scanf("%d",&tmp);
//                s.insert(tmp);
//            }
//            v.push_back(s);
//        }
//        int q;
//        int a,b;
//        scanf("%d", &q);
//        while (q --)
//        {
//            scanf("%d %d", &a, &b);
//            int ok = 0;
//            for (vector<set<int> >::iterator i = v.begin();i != v.end();i ++)
//            {
//                if (i -> find(a) != i -> end() && i -> find(b) != i -> end()) {
//                    ok = 1;
//                    printf("Yes\n");
//                }
//            }
//            if (!ok) printf("No\n");
//        }
//    }
//    return 0;
//}

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int a,b,c,d;
        scanf("%d %d %d %d",&a,&b,&c,&d);
        int arr[12];
        for (int i = 0;i < 12;i ++) scanf("%d", arr + i);
        int k[4] = {0};
        for (int i = 0;i < 12;i ++)
        {
            k[0] = arr[i];
            for (int j = 0;j < 12;j ++)
            {
                if (j != i)
                {
                    k[1] = arr[j];
                    if (k[0] + k[1] == a || k[0] * k[1] == a)
                    {
                        for (int t = 0;t < 12;t ++)
                        {
                            if (t != i && t != j)
                            {
                                k[2] = arr[t];
                                if (k[0] + k[2] == c || k[0] * k[2] == c)
                                {
                                    for (int y = 0;y < 12;y ++)
                                    {
                                        if (y != i && y != j && y != t)
                                        {
                                            k[3] = arr[y];
                                            if ((k[1] + k[3] == d || k[1] * k[3] == d) && (k[3] + k[2] == b || k[3] * k[2] == b))
                                            {
                                                goto done;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        done:
        for (int i = 0;i < 4;i ++) {
            if (i != 0) printf(" ");
            printf("%d",k[i]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int x;
        scanf("%d",&x);
        printf("%d\n",x);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    string k[] = {"1","#1","2","#2","3","4","#4","5","#5","6","#6","7"};
    map<string,ll> l;
    l["1"] = 0;
    l["#1"] = 1;
    l["2"] = 2;
    l["#2"] = 3;
    l["3"] = 4;
    l["4"] = 5;
    l["#4"] = 6;
    l["5"] = 7;
    l["#5"] = 8;
    l["6"] = 9;
    l["#6"] = 10;
    l["7"] = 11;
    while (T --)
    {
        ll n,m;
        scanf("%lld %lld",&n,&m);
        int f = 1;
        for (int i = 0;i < n;i ++)
        {
            string s;
            cin >> s;
            if (f) f = 0;
            else printf(" ");
            cout << k[(l[s] + m + 12 * abs(m)) % 12];
        }
        printf("\n");
    }
    return 0;
}*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    pair<int,int> d[10] = {make_pair(0, 0),
        make_pair(-1, -1),make_pair(0, -1),make_pair(1, -1),
        make_pair(-1, 0),make_pair(0, 0),make_pair(1, 0),
        make_pair(-1, 1),make_pair(0, 1),make_pair(1, 1)};
    while (T --)
    {
        int k[3][3];
        for (int i = 0;i < 3;i ++)
        {
            for (int j = 0;j < 3;j ++)
            {
                scanf("%d",&k[i][j]);
            }
        }
        int a[3][3] = {0};
        int b[3][3] = {0};
        for (int i = 0;i < 3;i ++)
        {
            for (int j = 0;j < 3;j ++)
            {
                if (k[i][j] == 5) continue;
                a[i + d[k[i][j]].second][j + d[k[i][j]].first] ++;
            }
        }
        int max_a = -1;
        pair<int,int> index_a;
        for (int i = 0;i < 3;i ++)
        {
            for (int j = 0;j < 3;j ++)
            {
                if (a[i][j] > max_a){
                    max_a = a[i][j];
                    index_a = make_pair(i, j);
                }
                if (k[i][j] == 5) {
                    b[i][j] = 9;
                    continue;
                }
                b[i][j] = a[i + d[k[i][j]].second][j + d[k[i][j]].first];
            }
        }
        int min_b = 10;
        pair<int, int> index_b;
        for (int i = 0;i < 3;i ++)
        {
            for (int j = 0;j < 3;j ++)
            {
                if (!(i == index_a.first && j == index_a.second))
                if (b[i][j] < min_b)
                {
                    index_b = make_pair(i, j);
                    min_b = b[i][j];
                }
            }
        }
        printf("%d %d %d %d\n",index_a.first + 1,index_a.second + 1,index_b.first + 1,index_b.second + 1);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int a[10010];
    while (T --)
    {
        int n,k;
        scanf("%d %d",&n,&k);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        if (k == 1)
        {
            printf("0\n");
            continue;
        }
        sort(a, a + n);
        int sum = 0;
        if (n % 2) {
            int s = 0;
            for (int i = 0;i < n - 1;i += 2)
            {
                s = 0;
                for (int j = 0;j < n;j ++)
                {
                    if (i == j)
                    {
                        s += a[j + 2] - a[j];
                        j += 2;
                    } else {
                        s += a[j + 1] - a[j];
                        j ++;
                    }
                }
                if (i == 0) sum = s;
                else sum = min(s, sum);
            }
        } else {
            for (int i = 0;i < n - 1;i += 2)
            {
                sum += a[i + 1] - a[i];
            }
        }
        printf("%d\n",sum);
    }
    return 0;
}
*/

//void combinate(int iPos, int iProc, long iTol, int iKey, vector<int> data,int des[],long long *sum,vector<int> p)
//{
//    if(iProc > iTol)
//    {
//        return;
//    }
//    if(iPos == iKey)
//    {
//        ll ans = 1;
//        for(int i = 0;i < iKey; i++)
//        {
//            ans  = ans * p[des[i]] % 1000000007;
//        }
//        *sum = (*sum + ans) % 1000000007;
//        return;
//    }
//    else
//    {
//        combinate(iPos,iProc+1,iTol,iKey,data,des,sum,p);
//        des[iPos] = data[iProc];
//        combinate(iPos+1,iProc+1,iTol,iKey,data,des,sum,p);
//    }
//}
//
//int main()
//{
//    int T;
//    scanf("%d",&T);
//    map<int,int> b;
//    while (T --)
//    {
//        int n,m;
//        scanf("%d %d",&n,&m);
//        b.clear();
//        while (m --)
//        {
//            int op;
//            scanf("%d",&op);
//            if (op == 1)
//            {
//                int p,x;
//                scanf("%d %d",&p,&x);
//                b[p] += x;
//                // test
//
//            } else
//            {
//                int l,r,k;
//                scanf("%d %d %d",&l,&r,&k);
//                // test
////                for (map<int,int>::iterator i = b.begin();i != b.end();i ++) printf("%d ",i -> first);
////                cout << endl;
//                map<int,int>::iterator start_i = b.lower_bound(l);
//                map<int,int>::iterator end_i = b.upper_bound(r);
//                long d = distance(start_i, end_i);
//                if (d < k) printf("0\n");
//                else {
//                    if (d == k) printf("1\n");
//                    else {
//                        vector<int> p(d);
//                        vector<int> q(d);
//                        int u = 0;
//                        for (map<int,int>::iterator i = start_i;i != end_i;i ++,u ++)
//                        {
//                            p[u] = i -> second;
//                            q[u] = u;
//                        }
//                        int tmp[20];
//                        long long sum = 0;
//                        combinate(0, 0, d, k, q, tmp, &sum, p);
//                        printf("%lld\n",sum);
//                    }
//                }
//
////                long long num = distance(start_i, end_i);
//
////                cout << endl;
//            }
//        }
//    }
//    return 0;
//}

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n;
        scanf("%d",&n);
        int max = -1;
        int a;
        while (n --)
        {
            scanf("%d",&a);
            if (a > max) max = a;
        }
        printf("%d\n",max);
    }
    return 0;
}
*/

/*
int main()
{
    char a,b,c;
    scanf("%c%c",&a,&b);
    scanf(" %c",&c);
    int k = 0;
    switch (c) {
        case 'S':
            if ((a == 'S' && b == 'J') || (a == 'J' && b == 'S'))
            {
                k = 0;
            } else if ((a == 'S' && b == 'B') || (a == 'B' && b == 'S'))
            {
                k = 1;
            } else if ((a == 'J' && b == 'B') || (a == 'B' && b == 'J'))
            {
                k = 1;
            }
            break;
        case 'J':
            if ((a == 'S' && b == 'J') || (a == 'J' && b == 'S'))
            {
                k = 1;
            } else if ((a == 'S' && b == 'B') || (a == 'B' && b == 'S'))
            {
                k = 1;
            } else if ((a == 'J' && b == 'B') || (a == 'B' && b == 'J'))
            {
                k = 0;
            }
            break;
            
        case 'B':
            if ((a == 'S' && b == 'J') || (a == 'J' && b == 'S'))
            {
                k = 1;
            } else if ((a == 'S' && b == 'B') || (a == 'B' && b == 'S'))
            {
                k = 0;
            } else if ((a == 'J' && b == 'B') || (a == 'B' && b == 'J'))
            {
                k = 1;
            }
            break;
        default:
            break;
    }
    switch (k) {
        case 0:
            printf("lyrnb\n");;
            break;
        case 1:
            printf("pmznb\n");
            break;
        case 2:
            printf("ljrnb\n");
            break;
            
        default:
            break;
    }
    // S > J
    // J > B
    // B > S
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        string str;
        cin >> str;
        int num = (int) str.size();
        int y = 0, n = 0;
        for (int i = 0;str[i] != '\0';i ++)
        {
            if (str[i] == 'y' || str[i] == 'Y')
            {
                y ++;
            } else if (str[i] == 'n' || str[i] == 'N')
            {
                n ++;
            }
        }
        if (y >= num / 2) printf("pmznb\n");
        else if (n >= num / 2) printf("lyrnb\n");
        else printf("wsdd\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    ll j[110];
    for (int i = 0;i < n;i ++) scanf("%lld", j + i);
    while (m --)
    {
        int o,l,r;
        scanf("%d %d %d",&o,&l,&r);
        if (o == 1)
        {
            for (int i = l - 1;i < r;i ++)
            {
                j[i] = j[i] * 251 % 996 * 404 * 123;
            }
            
            //for (int i = 0;i < n;i ++) printf("%lld ",j[i]);
        } else {
            map<ll,int> mp;
            for (int i = l - 1;i < r;i ++)
            {
                mp[j[i]] ++;
            }
            int max = -1;
            for (map<ll,int>::iterator i = mp.begin();i != mp.end();i ++)
            {
                if (i -> second >= max) max = i -> second;
            }
            printf("%d\n",max);
        }
    }
    return 0;
}
*/

//int main()
//{
//    int n,m,k;
//    scanf("%d %d %d",&n,&m,&k);
//    int a[2010];
//    multiset<int> b;
//    for (int i = 0;i < n;i ++) {
//        scanf("%d", a + i);
//        if (i > 0) {
//            b.insert(a[i] - a[i - 1]);
//        }
//    }
//    int q = 0;
//    int sum = 0;
//    for (multiset<int>::reverse_iterator i = b.rbegin();i != b.rend();i ++) {
//
//        if (q >= k - 1) {
//            sum += *i + 1;
//        } else q ++;
//    }
//    printf("%d\n",sum);
//    return 0;
//}

/*
int main()
{
    ll n, k;
    scanf("%lld %lld",&n,&k);
    string str;
    cin >> str;
    string ss = str;
    reverse(ss.begin(),ss.end());
    str += ss;
    printf("%c\n",str[(k - 1) % str.size()]);
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        ll p;
        scanf("%lld",&p);
        ll a = sqrt((p - 1) / 3);
        if (3 * a * a + 3 * a + 1 == p) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
struct PP
{
    string name;
    int a;
    int b;
    int n;
} p[1010];

int cmp(PP a,PP b)
{
    if(a.a == b.a)
    {
        if (a.b == b.b)
        {
            return a.name < b.name;
        }
        return a.b > b.b;
    }
    return a.a > b.a;
}

int main()
{
    int T;
    scanf("%d",&T);
    map<int,int> k;
    while (T --)
    {
        int n;
        scanf("%d",&n);
        for (int i = 0;i < n;i ++)
        {
            cin >> p[i].name;
            scanf("%d %d", &(p + i) -> a, &(p + i) -> b);
            (p + i) -> n = i;
        }
        sort(p,p + n,cmp);
        
        for (int i = 0;i < n;i ++)
        {
            k[(p + i) -> n] = i + 1;
        }
        int f = 1;
        for (map<int,int>::iterator i = k.begin();i != k.end();i ++)
        {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i -> second);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    string a;
    cin >> a;
    for (int i = 0;a[i] != '\0';i ++) printf("%d", 1 - (a[i] - '0'));
    return 0;
}
*/

/*
int q(double a, double b)
{
    int k = a * b;
    if (k == a * b)return k;
    else return k + 1;
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        double n,k;
        scanf("%lf %lf",&n,&k);
        int j = q(n,0.1);
        int y = q(n,0.2);
        int t = q(n,0.3);
        
        
        
        if (k <= j) printf("jin\n");
        else if (k <= j + y) printf("yin\n");
        else if (k <= j + y + t) printf("tong\n");
        else printf("tie\n");
    }
    return 0;
}
*/

/*
int main()
{
    int x;
    scanf("%d",&x);
    ll f[50] = {0};
    f[1] = 1;
    for (int i = 2;i <= x;i ++)
    {
        for (int j = 1;j < i;j ++)
        {
            f[i] += f[j] * (i - j);
        }
    }
    printf("%lld",f[x]);
    return 0;
}
*/

/*
int main()
{
    double a,b;
    scanf("%lf %lf",&a,&b);
    if (a > b)
    {
        double t = a;
        a = b;
        b = t;
    }
    a /= 2;
    b /= 2;
    double k = sqrt(a * a + b * b);
    printf("%.4lf\n",(b - a * b / k) / (k / a + 1));
    return 0;
}
*/


/*
int main()
{
    int x,y,z;
    scanf("%d %d %d",&x,&y,&z);
    if (x * 2 > max(y,z)) printf("clever duxing201606\n");
    else printf("forever loney\n");
    return 0;
}*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[1010];
    int dp[1000010] = {0};
    for (int i = 0;i < n;i ++) scanf("%d", a + i);
    int sum = 0;
    for (int i = 0;i < n;i ++) sum += a[i];
    for (int i = 0;i < n;i ++)
    {
        for (int j = sum / 2;j >= 0;j --)
        {
            if (j - a[i] >= 0) dp[j] = max(dp[j],dp[j - a[i]] + a[i]);
        }
    }
    printf("%d\n",sum - dp[sum / 2] * 2);
    
    return 0;
}
*/


/*int main()
{
    int a;
    int n,m;
    scanf("%d",&a);
    scanf("%d %d",&n,&m);
    char dir[100010] = {0};
    char op[100010] = {0};
    char g[200][200] = {0};
    queue<pair<int,int> > dots;
    dots.push(make_pair(1, 1));
    dots.push(make_pair(2, 1));
    g[1][1] = 1;
    g[2][1] = 1;
    int tm;
    char dr;
    for (int i = 0;i < n;i ++)
    {
        int opt;
        scanf("%d",&opt);
        if (opt == 1)
        {
            // 1
            scanf("%d %c",&tm, &dr);
            dir[tm] = dr;
            op[tm] = 1;
        } else {
            // 2
            scanf("%d", &tm);
            op[tm] = 2;
        }
    }
    pair<int,int> next;
    
    const char R = 0;
    const char L = 1;
    const char U = 2;
    const char D = 3;
    
    char d = R, shouldDel = 1;
    
    
    pair<int,int> last;
    pair<int,int> current;
    int x,y;
    
    for (int i = 1;i <= m;i ++)
    {
        shouldDel = 1;
        if (op[i] == 1)
        {
            // change direction
            switch (dir[i])
            {
                case 'L':
                    if (d != R) d = L;
                    break;
                case 'U':
                    if (d != D) d = U;
                    break;
                case 'R':
                    if (d != L) d = R;
                    break;
                case 'D':
                    if (d != U) d = D;
                    break;
            }
        } else if (op[i] == 2) shouldDel = 0;
        
        if (shouldDel) {
            last = dots.front();
            g[last.first][last.second] = 0;
            dots.pop();
            //printf("%d %d\n",last.first,last.second);
        }
        
        current = dots.back();
        x = current.first;
        y = current.second;
        // TODO : Add next with "d"
        switch (d)
        {
            case L:
                if (x - 1 < 1 || g[x - 1][y]) goto die;
                next = make_pair(x - 1, y);
                break;
            case U:
                if (y - 1 < 1 || g[x][y - 1]) goto die;
                next = make_pair(x, y - 1);
                break;
            case R:
                if (x + 1 > a || g[x + 1][y]) goto die;
                next = make_pair(x + 1, y);
                break;
            case D:
                if (y + 1 > a || g[x][y + 1]) goto die;
                next = make_pair(x, y + 1);
                break;
        }
        dots.push(next);
        g[next.first][next.second] = 1;
    }
    goto win;
    die:
    if (shouldDel) g[last.first][last.second] = 1;
    win:
    for (int i = 1;i <= a;i ++)
    {
        for (int j = 1;j <= a;j ++)
        {
            if (g[j][i]) printf("o");
            else printf(".");
        }
        printf("\n");
    }
    return 0;
}
*/

//struct drug
//{
//    char tag;
//    int m1;
//    int m2;
//    int m3;
//};
//
//int cmp(drug a, drug b)
//{
//    if (a.m2 == b.m1) return a.m1 < b.m1;
//    return a.m2 > b.m1;
//}
//
//int main()
//{
//    drug d[] = {
//        {'A',13,15,20},
//        {'B',10,20,18},
//        {'C',20,16,15},
//        {'D',8,10,6},
//        {'E',9,14,13},
//        {'F',19,20,14},
//        {'G',11,16,12},
//        {'H',16,9,18},
//        {'I',15,12,7},
//        {'J',13,7,9}
//    };
////    drug d[] =
////    {
////        {'A',1,2,3},
////        {'B',2,3,4},
////        {'C',3,4,5}
////    };
//    sort(d,d + (sizeof d / sizeof(drug)),cmp);
//    for (int i = 0;i < sizeof d / sizeof(drug);i ++)
//    {
//        drug *dd = d + i;
//        printf("%c\t%d\t%d\t%d\n",dd -> tag,dd -> m1,dd -> m2,dd -> m3);
//    }
//
//    return 0;
//}


/*
vector<double> cash;

int l;

double f(int i, double j)
{
    if (i == l)
    {
        return 0;
    } else if (cash[i] > j) return f(i + 1, j);
    else {
        return max(f(i + 1, j), f(i + 1, j - cash[i]) + cash[i]);
    }
}

int main()
{
    double q;
    int n;
    char t;
    double p;
    int ok = 1;
    double a,b,c;
    while (~scanf("%lf %d",&q,&n))
    {
        if (n == 0) break;
        cash.clear();
        while (n --)
        {
            int m;
            scanf("%d",&m);
            a = b = c = 0;
            ok = 1;
            while (m --)
            {
                scanf(" %c:%lf", &t, &p);
                if (t == 'A') a += p;
                else if (t == 'B') b += p;
                else if (t == 'C') c += p;
                else ok = 0;
            }
            if (ok && a <= 600 && b <= 600 && c <= 600 && a + b + c <= 1000) cash.push_back(a + b + c);
        }
        l = (int) cash.size();
        //for (int i = 0;i < l;i ++) printf("%f ",cash[i]);
        //printf("\n");
        printf("%.2f\n",f(0,q));
    }
    return 0;
}

*/

//
//int main()
//{
//    int T;
//    scanf("%d",&T);
//    int k = 1;
//    while (T --)
//    {
//        string url;
//        cin >> url;
//        ulong l = url.size();
//        string protocal = "", host = "", port = "", path = "";
//        /*int mode = 0;
//        int f = 0;
//        for (int i = 0;url[i] != '\0';i ++)
//        {
//
//            if (url[i] == ':')
//            {
//                if (i + 2 < l && url[i + 1] == '/' && url[i + 2] == '/' && !f)
//                {
//                    mode = 1;
//                    i = i + 2;
//                    f = 1;
//                    continue;
//                } else if (mode == 1) {
//                    mode = 2;
//                    continue;
//                }
//            }
//            if (url[i] == '/')
//            {
//                if (mode == 1 || mode == 2)
//                {
//                    mode = 3;
//                    continue;
//                }
//            }
//            if (mode == 0) protocal += url[i];
//            else if (mode == 1) host += url[i];
//            else if (mode == 2) port += url[i];
//            else if (mode == 3) path += url[i];
//        }*/
//        ulong pl_i = url.find("://");
//        protocal = url.substr(0, pl_i);
//        ulong pt_i = url.find(":", pl_i + 3);
//        ulong pth_i = url.find("/", pl_i + 3);
//        //cout << pl_i << " " << pt_i << " " << pth_i << endl;
//        if (pt_i != string::npos && pth_i != string::npos && pth_i > pt_i) port = url.substr(pt_i + 1, pth_i - pt_i - 1);
//        if (pt_i != string::npos && pth_i == string::npos) port = url.substr(pt_i + 1,l - pt_i);
//
//
//        if (pt_i != string::npos) host = url.substr(pl_i + 3, pt_i - pl_i - 3);
//        if (pt_i == string::npos && pth_i != string::npos) host = url.substr(pl_i + 3, pth_i - pl_i - 3);
//        if (pt_i == string::npos && pth_i == string::npos) host = url.substr(pl_i + 3, l - pl_i - 3);
//
//        if (pth_i != string::npos) path = url.substr(pth_i + 1);
//
//
//        if (port == "") port = "default";
//        if (path == "") path = "default";
//        cout << "URL #" << k << endl;
//        cout << "Protocol = " << protocal << endl;
//        cout << "Host     = " << host << endl;
//        cout << "Port     = " << port << endl;
//        cout << "Path     = " << path << endl << endl;
//
//
//        k ++;
//    }
//    return 0;
//}
//

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        int k = 0;
        int a,b,c;
        while (n --)
        {
            scanf("%d %d %d",&a,&b,&c);
            if (a + b + c >= 2) k ++;
        }
        printf("%d\n",k);
    }
    return 0;
}
*/

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    char arr[1000][1000];
//    return 0;
//}


/*
char mp[15][15];
int n,m;

int dir[][2] = {
    {-1,0},
    {1,0},
    {0,-1},
    {0,1}
};

bool dfs(int x,int y)
{
    if (mp[y][x] == 'T') return true;
    mp[y][x] = '*';
    bool result = false;
    for (int i = 0;i < 4;i ++)
    {
        int cx = x + dir[i][1],cy = y + dir[i][0];
        if (cx >= m || cy >= n || cx < 0 || cy < 0) continue;
        if (mp[cy][cx] != '*')
        {
            result = dfs(cx,cy);
            if (result) break;
        }
    }
    return result;
}

int main()
{
    while (~scanf("%d %d",&n,&m))
    {
        pair<int,int> start;
        for (int i = 0;i < n;i ++)
        {
            scanf(" ");
            for (int j = 0;j < m;j ++)
            {
                scanf("%c",&mp[i][j]);
                if (mp[i][j] == 'S') {
                    start.first = i; // y
                    start.second = j; // x
                }
            }
        }
        if (dfs(start.second,start.first)) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
struct stu
{
    string id;
    int de;
    int ca;
};

int main()
{
    int n,l,h;
    scanf("%d %d %d",&n,&l,&h);
    vector<stu> c1,c2,c3;
    
    while (n --)
    {
        stu s;
        cin >> s.id;
        scanf("%d %d",&s.de, &s.ca);
        
    }
    return 0;
}
*/

/*int main()
{
    
    int T;
    scanf("%d",&T);
    int a[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946};
    multiset<int> k;
    int t = sizeof(a) / sizeof(int);
    for (int i = 0;i < t;i ++) k.insert(a[i]);
    while (T --)
    {
        int m,n;
        scanf("%d %d",&m,&n);
        int f = 1;
        multiset<int>::iterator p = k.upper_bound(n);
        for (multiset<int>::iterator i = k.lower_bound(m);i != p;i ++)
        {
            if (f) f = 0;
            else printf(" ");
            printf("%d",*i);
        }
        printf("\n");
    }
    
    return 0;
}*/


/*
int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n,m;
        scanf("%d %d",&n,&m);
        int sum = 0;
        int c = 0;
        for (int i = n;i <= m;i ++)
        {
            if (isZhi(i))
            {
                sum += i;
                c ++;
            }
        }
        printf("count=%d,sum=%d\n",c,sum);
    }
    return 0;
}
*/

/*int main()
{
    int L,n;
    while (~scanf("%d %d",&L,&n))
    {
        int dis[110];
        int cut[110];
        for (int i = 0;i < n;i ++)
        {
            scanf("%d %d",dis + i, cut + i);
        }
        int m = -1;
        int sum = 0;
        for (int i = 0;i <= L;i ++)
        {
            sum = 0;
            for (int j = 0;j < n;j ++)
            {
                sum += cut[j] * abs(dis[j] - i);
            }
            if (i == 0) m = sum;
            else m = min(m, sum);
        }
        printf("%d\n",m);
    }
    
    return 0;
}*/

/*
char a[15][15];
int n;

const int dir[][2] = {{-1,0}, {1,0}, {0,1}, {0,-1}};

void mk(int i, int j)
{
    int c = 'A';
    int q = c;
    if (a[i][j] == '.')
    {
        for (int p = 0;p < 4;p ++)
        {
            q = c;
            for (int k = 0;k < 4;k ++)
            {
                int y = dir[k][1];
                int x = dir[k][0];
                if (i + y >= 0 && i + y < n && j + x >= 0 && j + x < n)
                {
                    for (;a[i + y][j + x] != '.' && a[i + y][j + x] == c;c ++);
                }
            }
            if (q == c) break;
        }
        a[i][j] = c;
    }
    
}

int main()
{
    while (~scanf("%d",&n))
    {
        for (int i = 0;i < n;i ++)
        {
            scanf(" ");
            for (int j = 0;j < n;j ++)
            {
                scanf("%c",&a[i][j]);
            }
        }
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < n;j ++)
            {
                mk(i, j);
            }
        }
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < n;j ++)
            {
                printf("%c",a[i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int bin(int *arr, int n, int num)
{
    printf("[");
    for (int i = 0;i < n;i ++)
    {
        printf("%d ",arr[i]);
    }
    printf("]\n");
     
    int start = 0;
    int end = n - 1;
    int mid = 0;
    while (start <= end)
    {
        mid = (start + end) / 2;
        if (arr[mid] == num) {
            //printf("--%d\n",mid);
            return 1;
        } else if (arr[mid] < num)
        {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int nums[1010];
    while (~scanf("%d",&n))
    {
        set<int,greater<int> > arr;
        int a;
        for (int i = 0;i < n;i ++) {
            scanf("%d",&a);
            arr.insert(a);
        }
        n = (int) arr.size();
        int k = 0;
        for (set<int, greater<int> >::iterator i = arr.begin();i != arr.end();i ++,k ++) nums[k] = *i;
        for (int d = 0;d < n - 3;d ++)
        {
            for (int c = d + 1;c < n - 2;c ++)
            {
                for (int b = c + 1;b < n - 1;b ++)
                {
                    printf(">>%d %d %d => %d\n",nums[d],nums[c],nums[b],nums[d] - nums[c] - nums[b]);
                    if (bin(nums + b + 1, n - b - 1, nums[d] - nums[c] - nums[b]))
                    {
                        printf("%d\n",nums[d]);
                        //goto ok;
                    }
                }
            }
        }
        printf("no solution\n");
        ok:
        continue;
    }
    return 0;
}
*/

/*
void swap(double *a, double *b)
{
    int *ta = (int*) a, *tb = (int*) b;
    *ta ^= *tb;
    *tb ^= *ta;
    *ta ^= *tb;
    *(ta + 1) ^= *(tb + 1);
    *(tb + 1) ^= *(ta + 1);
    *(ta + 1) ^= *(tb + 1);
}

int main()
{
    double a = 1833.22;
    double b = 32334.55;
    printf("%lf %lf\n",a,b);
    swap(&a, &b);
    printf("%lf %lf\n",a,b);
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        // Test
//        for (int i = 0;i < n;i ++)
//        {
//            for (int j = 0;j < i;j ++)
//            {
//                printf(" ");
//            }
//            for (int j = 0;j < n - i;j ++)
//            {
//                printf("* ");
//            }
//            printf("\n");
//        }
        
        int sum = (n + 1) * n / 2;
        
        int k = n / 3;
        if ((n % 2 && !(k % 2)) || (!(n % 2) && k % 2)) k --;
        //printf(">>k = %d\n", k);
        int h = (n - k) / 2 + 1;
        //printf(">>h = %d\n", h);
        int min = sum - ((h + 2 * k - 1) * h - (k + h - 1));
        int x = min;
        while (x <= min)
        {
            min = x;
            k += 2;
            h = (n - k) / 2 + 1;
            //printf(">>k = %d\n>>h = %d\n", k, h);
            x = sum - ((h + 2 * k - 1) * h - (k + h - 1));
        }
        printf("%d\n",min);
        
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        int c = 0;
        double C = 0;
        int fd = 0;
        for (int a = 1;a <= sqrt(n);a ++)
        {
            for (int b = a;b <= sqrt(n);b ++)
            {
                C = sqrt(n - a * a - b * b);
                if (C >= b && (c = C) == C)
                {
                    fd = 1;
                    printf("%d %d %d\n",a, b, c);
                }
            }
        }
        if (!fd) printf("No Solution\n");
    }
    return 0;
}
*/

/*
int isRun(int y)
{
    return (y % 100 != 0 && y % 4 == 0) || y % 400 == 0;
}

int main()
{
    int y,m,d,dd;
    int ms[] = {31,28,31,30,31,30,31,31,30,31,30,31};
    while (~scanf("%d %d %d %d",&y,&m,&d,&dd))
    {
        if (isRun(y)) ms[1] = 29;
        else ms[1] = 28;
        
        for (int i = 0;i < dd;i ++)
        {
            d ++;
            if (d > ms[m - 1])
            {
                m ++;
                d = 1;
                if (m > 12)
                {
                    y ++;
                    m = 1;
                    if (isRun(y)) ms[1] = 29;
                    else ms[1] = 28;
                }
            }
        }
        printf("%d-%02d-%02d\n",y,m,d);
    }
    return 0;
}
*/

/*
int main()
{
    ll a = 1;
    ll b, c;
    char ok;
    while (1)
    {
        char n[10] = {0};
        ok = 1;;
        b = a * a;
        while (b != 0)
        {
            n[b % 10] ++;
            b /= 10;
        }
        c = a * a * a;
        while (c != 0)
        {
            n[c % 10] ++;
            c /= 10;
        }
        for (int i = 0;i < 10;i ++)
        {
            if (n[i] != 1) {
                ok = 0;
                break;
            }
        }
        if (ok) {
            printf("%lld",a);
            break;
        }
        a ++;
        //if (a == 100000) break;
    }
    return 0;
}
*/

/*
// A 2 3 4 5 6 7 8 9 10 J Q K
int dfs(int n, int sum)
{
    if (n == 13)
    {
        if (sum == 13)
        {
            return 1;
        }
        return 0;
    }
    int s = 0;
    s += dfs(n + 1,sum + 0);
    s += dfs(n + 1,sum + 1);
    s += dfs(n + 1,sum + 2);
    s += dfs(n + 1,sum + 3);
    s += dfs(n + 1,sum + 4);
    return s;
}

int main()
{
    cout << dfs(0,0) << endl;
    return 0;
}
*/

/*
int main()
{
    //   B      B     ED      B
    // A   C  C   A  A   C  C   A
    //   ED     DE     B      D
    //
    // 1234 //
    // 1243
    // 1324
    // 1342
    // 1423
    // 1432
    // 2134
    // 2143
    // 2314
    // 2341 //
    // 2413
    // 2431
    // 3124
    // 3142
    // 3241
    // 3214
    // 3412 //
    // 3421
    // 4123 //
    // 4132
    // 4213
    // 4231
    // 4312
    // 4321
    
    // 123 //
    // 132
    // 213
    // 231 //
    // 312 //
    // 321
    
    
    //        A12/12             A5/5             A5/5
    //  (-----------------  -  ---------) / 2 + ---------
    //   A3/3*A4/4*A5/5*12     A2/2*A2/2        A2/2*A2/2
    //

    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        int sum = n;
        int lt;
        while (n >= 3)
        {
            lt = n % 3;
            n /= 3;
            sum += n;
            n += lt;
        }
        printf("%d\n",sum);
    }
    return 0;
}
*/

/*
int main()
{
    int sum = 0;
    string str;
    for (int i = 10000;i <= 99999;i ++)
    {
        str = to_string(i);
        for (int j = 0;str[j] != '\0';j ++)
        {
            if (str[j] == '4')
            {
                goto ed;
            }
        }
        sum ++;
        ed:
        continue;
    }
    cout << sum << endl;
    return 0;
}
*/

/*
int main()
{
    double x[3];
    double y[3];
    
    for (int i = 0;i < 3;i ++)
    {
        scanf("%lf %lf",x + i,y + i);
    }
    double b1 = (y[0] + y[1]) / 2 + (x[0] * x[0] - x[1] * x[1]) / 2 / (y[0] - y[1]);
    double b2 = (y[0] + y[2]) / 2 + (x[0] * x[0] - x[2] * x[2]) / 2 / (y[0] - y[2]);
    double k1 = (x[1] - x[0]) / (y[0] - y[1]);
    double k2 = (x[2] - x[0]) / (y[0] - y[2]);
    double x0 = (b2 - b1) / (k1 - k2);
    double y0 = k1 * x0 + b1;
    printf("%.3lf %.3lf\n",x0,y0);
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int n = str[str.size() - 1] - '0';
    if (n % 2 == 0) printf("1\n");
    else printf("-1\n");
    return 0;
}
*/

/*
int main()
{
    ll t1,t2;
    while (~scanf("%lld %lld",&t1,&t2))
    {
        ll time = 0;
        ll n1 = (t1 + 59) / 60;
        ll e1 = n1 * 60 - 59 + 49;
        if (t1 <= e1)
        {
            time += e1 - t1 + 1;
        }
        //cout << n1 << " " << e1 << " " << time;
        ll n2 = (t2 + 59) / 60;
        ll s2 = n2 * 60 - 59;
        //cout << endl << n2 << " " << s2 << endl;
        ll time2 = t2 - s2 + 1;
        if (time2 > 50) time2 = 50;
        time += time2 + (n2 - 1 - n1) * 50;
        printf("%lld\n",time);
    }
    return 0;
}
*/

//int main()
//{
//    string str;
//    cin >> str;
//    for (itn i = 0;str[i] != 0;i ++) if (str[i] >= 'A' && str[i] <= 'Z') str[i] += 32;
//    //cout << str;
//    ulong k = 0;
//    int sum = 0;
//    while (k != string::npos)
//    {
//        k = str.find("iloveyou",k + 1);
//        cout << ">>" << k << endl;
//        sum = (sum + 1) % 20010905;
//    }
//    printf("%d\n",sum);
//    return 0;
//}

/*
int main()
{
    itn n;
    scanf("%d",&n);
    int c = 0;
    for (int i = 2;i <= sqrt(n);i ++)
    {
        while (n % i == 0) {
            c ++;
            n /= i;
        }
    }
    if (n > 1) c ++;
    if (c % 2 == 0) printf("Johnson\n");
    else printf("Nancy\n");
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    double s = 0,sum = 0;
    while (n --)
    {
        char t;
        double src,
            ps, ps_r,
            zh, zh_r,
            mo, mo_r;
        scanf("%hhd %lf %lf %lf %lf %lf %lf %lf",&t,&src,
              &ps,&ps_r,
              &zh,&zh_r,
              &mo,&mo_r);
        if (t == 2) continue;
        s += src;
        int ss = (ps * ps_r + zh * zh_r + mo * mo_r) + 0.5;
        sum += ss * src;
    }
    printf("%.2lf\n",sum / s);
    return 0;
}
*/

/*
vector<int> aa,bb,cc;

int n;
int n2;
int c = 0;

void pt(int k, char c) {for (int i = 0;i < k;i ++) printf("%c",c);}

void prt(int l)
{
    int k = n - (l - 1) / 2;
    pt(k,'.');
}

void dis()
{
    int p;
    c ++;
    pt(3 * (2 * n + 1) + 4,'.');
    for (itn i = n;i >= 0;i --)
    {
        printf("\n");
        printf(".");
        if (aa.size() <= i) {
            prt(1);
            printf("|");
            prt(1);
        } else {
            p = aa[i];
            prt(p);
            pt(p,'*');
            prt(p);
        }
        printf(".");
        if (bb.size() <= i) {
            prt(1);
            printf("|");
            prt(1);
        } else {
            p = bb[i];
            prt(p);
            pt(p,'*');
            prt(p);
        }
        printf(".");
        if (cc.size() <= i) {
            prt(1);
            printf("|");
            prt(1);
        } else {
            p = cc[i];
            prt(p);
            pt(p,'*');
            prt(p);
        }
        printf(".");
    }
    printf("\n");
    if (c < n2) {
        pt(3 * (2 * n + 1) + 4,'-');
        printf("\n");
    }
    
}

void move(char a, char b)
{
    if (a == 'a' && b == 'b')
    {
        bb.push_back(*(aa.end() - 1));
        aa.erase(aa.end() - 1);
    } else if (a == 'b' && b == 'a')
    {
        aa.push_back(*(bb.end() - 1));
        bb.erase(bb.end() - 1);
    } else if (a == 'a' && b == 'c')
    {
        cc.push_back(*(aa.end() - 1));
        aa.erase(aa.end() - 1);
    } else if (a == 'c' && b == 'a')
    {
        aa.push_back(*(cc.end() - 1));
        cc.erase(cc.end() - 1);
    } else if (a == 'b' && b == 'c')
    {
        cc.push_back(*(bb.end() - 1));
        bb.erase(bb.end() - 1);
    } else if (a == 'c' && b == 'b')
    {
        bb.push_back(*(cc.end() - 1));
        cc.erase(cc.end() - 1);
    }
    dis();
}

void han(int n, char a, char b, char c)
{
    if (n == 1)
    {
        move(a,c);
        return;
    }
    han(n - 1,a,c,b);
    move(a,c);
    han(n - 1,b,a,c);
}

int main()
{
    
    scanf("%d",&n);
    n2 = pow(2,n);
    for (int i = n;i >= 1;i --)
    {
        aa.push_back(i * 2 + 1);
    }
    dis();
    if (!(n % 2)) han(n,'a','b','c');
    else han(n,'a','c','b');
    
    return 0;
}
*/

/*
int main()
{
    for (int i = 0;i <= 49 - 4;i ++)
    {
        for (int j = i + 2;j <= 49 - 2;j ++)
        {
            int sum = 0;
            for (int k = 1;k < 50;k ++)
            {
                
                if (i == k - 2 || j == k - 2) sum += k * (k - 1);
                else if (!(i == k - 1 || j == k - 1)) sum += k;
            }
            if (sum == 2015) printf("i = %d, j = %d\n",i + 1, j + 1);
        }
    }
    return 0;
}
*/

/*
int main()
{
    int w,m,n;
    while (~scanf("%d %d %d",&w,&m,&n))
    {
        if (m < n) {
            int t = m;
            m = n;
            n = t;
        }
        // m > n
        int k_m = (m - 1) / w + 1;
        int k_n = (n - 1) / w + 1;
        // cout << k_m << " " << k_n << endl;
        int k = k_m - k_n;
        int step = k;
        
        int dis = m - (k_m - 1) * w;
        if ((k_n + k_m) % 2) dis = w - dis + 1;
        int p = (k_n - 1) * w + dis;
        
        step += abs(p - n);
        printf("%d\n",step);
    }
    return 0;
}
*/

/*
void prt(int n, char c) {for (itn i = 0;i < n;i ++) printf("%c",c);}

int main()
{
    int m,n;
    while (~scanf("%d %d",&m, &n))
    {
        for (int i = 0;i < n / 2;i ++)
        {
            prt(i,'.');
            int k = n / 2;
            k = m + k * 2;
            int p = k - i * 2 - m * 2;
            if (p >= 0)
            {
                prt(m, '*');
                prt(p, '.');
                prt(m, '*');
            } else prt(k - i * 2, '*');
            prt(i,'.');
            printf("\n");
        }
        for (int i = n / 2;i >= 0;i --)
        {
            prt(i,'.');
            int k = n / 2;
            k = m + k * 2;
            int p = k - i * 2 - m * 2;
            if (p >= 0)
            {
                prt(m, '*');
                prt(p, '.');
                prt(m, '*');
            } else prt(k - i * 2, '*');
            prt(i,'.');
            printf("\n");
        }
    }
    return 0;
}
*/

/*int main()
{
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    int sum = 0;
    int ok = 1;
    do {
        ok = 1;
        for (itn i = 1;i < 5;i ++)
        {
            if (!(arr[i] > arr[i - 1] && arr[i + 5] > arr[i + 4] && arr[i + 5] > arr[i]))
            {
                ok = 0;
                break;
            }
        }
        if (!(arr[5] > arr[0])) ok = 0;
        if (ok){
            sum ++;
            for (itn i = 0;i < 5;i ++) cout << arr[i] << " ";
            cout << endl;
            for (int i = 5;i < 10;i ++) cout << arr[i] << " ";
            cout << endl << endl;
        }
    } while (next_permutation(arr,arr + 10));
    cout << sum << endl;
    return 0;
}
*/

//int main()
//{
//    //int a[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
//    int a[16] = {1,2,15,16,12,14,3,5,13,7,10,4,8,11,6,9};
//    int c = 0;
//    do
//    {
//        int sum = 0;
//        for (itn i = 0;i < 4;i ++)
//        {
//            int s = 0;
//            for (int j = 0;j < 4;j ++)
//            {
//                s += a[4 * i + j];
//            }
//            if (i == 0) sum = s;
//            else if (sum != s) goto err;
//        }
//        c ++;
//        for (itn i = 0;i < 16;i ++)
//        {
//            cout << a[i] << " ";
//            if ((i + 1) % 4 == 0) cout << endl;
//        }
//        cout << endl;
//        err:
//        continue;
//    } while (next_permutation(a + 1, a + 16));
//    cout << c << endl;
//    return 0;
//}

//struct Dot{int x;int y;};
//
//void dfs(char a[110][110], int n)
//{
//    if (n == 2) return;
//    a[0][0] ++;
//    cout << (int) a[0][0] << endl;
//    dfs(a,n + 1);
//}
//
//int main()
//{
//    char a[110][110] = {0};
//    dfs(a,0);
//    cout << (int) a[0][0] << endl;
//    int n;
//    scanf("%d",&n);
//
//    Dot start;
//    Dot end;
//    for (int i = 0;i < n;i ++)
//    {
//        scanf(" ");
//        for (int j = 0;j < n;j ++)
//        {
//            scanf("%c",&a[i][j]);
//            if (a[i][j] == 'A') {
//                start.x = j;
//                start.y = i;
//            } else if (a[i][j] == 'B')
//            {
//                end.x = j;
//                end.y = i;
//            }
//        }
//    }
//
//    return 0;
//}

/*
int main()
{
    string n;
    int t;
    cin >> n;
    scanf("%d",&t);
    string m = "";
    for (int p = 0;p < t;p ++)
    {
        m = "";
        int k = 0;
        char last = '\0';
        for (int i = 0;n[i] != '\0';i ++)
        {
            if (last == n[i]) {
                k ++;
            }
            else if (last != '\0')
            {
                m += (char) (k + 1 + '0');
                m += last;
                k = 0;
            }
            last = n[i];
        }
        m += (char) (k + 1 + '0');
        m += last;
        n = m;
    }
    cout << n << endl;
    return 0;
}
*/

/*
int ok(int a, int b) {return abs(a - b) != 1;}

int main()
{
    int a[] = {0,1,2,3,4,5,6,7,8,9};
    int c = 0;
    do {
        if (ok(a[0],a[1]) && ok(a[2],a[1]) && ok(a[3],a[4]) && ok(a[4],a[5]) && ok(a[5],a[6]) && ok(a[7],a[8]) && ok(a[8],a[9]) && ok(a[0],a[4]) && ok(a[6],a[2]) && ok(a[5],a[1]) && ok(a[3],a[7]) && ok(a[4],a[8]) && ok(a[0],a[3]) && ok(a[5],a[9]) && ok(a[0],a[5]) && ok(a[4],a[1]) && ok(a[2],a[5]) && ok(a[6],a[1]) && ok(a[3],a[8]) && ok(a[4],a[7]) && ok(a[5],a[8]) && ok(a[4],a[9]) && ok(a[6],a[9])) c ++;
    } while (next_permutation(a, a + 10));
    cout << c << endl;
    return 0;
}
*/

/*
int main()
{
    int n = 100;
    
    int a = 1;
    ll sum = 1;
    for (int i = 0;i < n - 1; i++)
    {
        a = a + i + 2;
        sum += a;
    }
    cout << sum << endl;
    return 0;
}
*/

/*
int main()
{
    double a[] = {1,2,3,4,5,6,7,8,9};
    int c = 0;
    do {
        double k = a[0] + a[1] / a[2] + (a[3] * 100 + a[4] * 10 + a[5]) / (a[6] * 100 + a[7] * 10 + a[8]);
        if (k == 10) c ++;
    } while (next_permutation(a, a + 9));
    cout << c << endl;
    return 0;
}
*/

/*
int main()
{
    ll num = 2;
    ll m = 0;
    while (1)
    {
        ll k = 0;
        while (num != 0)
        {
            k += (num % 10) * (num % 10);
            num /= 10;
        }
        num = k;
        if (m == num) break;
        m = max(num, m);
        
    }
    cout << m << endl;
    return 0;
}*/


///////// 算绩点
/*int main()
{
    double scr, ji;
    double fen = 0, sum = 0;;
    while (~scanf("%lf %lf",&scr, &ji))
    {
        if (scr == 0 && ji == 0) break;
        fen += scr;
        sum += scr * ji;
    }
    cout << sum / fen << endl;
    return 0;
}*/

/*
int main()
{
    int a[10] = {0,1,2,3,4,5,6,7,8,9};
    int c = 0;
    do {
        if (a[0] < a[1] && a[0] < a[2] && a[1] < a[3] && a[1] < a[4] && a[2] < a[4] && a[2] < a[5] && a[3] < a[6] && a[3] < a[7] && a[4] < a[7] && a[4] < a[8] && a[5] < a[8] && a[5] < a[9]) c ++;
    } while (next_permutation(a, a + 10));
    cout << c << ednl;
    return 0;
}
*/

/*
int main()
{
    ll c = 777;
    string str;
    cin >> str;
    for (itn i = 0;str[i] != 0;i ++)
    {
        if (str[i] == 'v') c *= 2;
        else if (str[i] == 'x') c -= 555;
    }
    cout << c << ednl;
    return 0;
}
*/

/*
void dfs()
{
    
}

int main()
{
    
    return 0;
}
*/

/*int main()
{
    int b = 0;
    while (1)
    {
        double a = 127 * b + 1;
        a /= 97;
        int aa = a;
        if (a == aa) break;
        b ++;
    }
    cout << (127 * b + 1) / 97 + b << ednl;
    return 0;
}*/

//int ch(ll n)
//{
//    int a[10] = {0};
//    while (n != 0)
//    {
//        a[n % 10] ++;
//        n /= 10;
//    }
//    int ok = 1;
//    for (int i = 0;i < 10;i ++)
//    {
//        if (a[i] > 1) {
//            ok = 0;
//            break;
//        }
//    }
//    return ok;
//}
//
//set<int> gt(ll n)
//{
//    set<int> a;
//    while (n != 0)
//    {
//        a.insert(n % 10);
//        n /= 10;
//    }
//    return a;
//}
//
//int main()
//{
//    ll t = 0;
//    ll k = 0;
//    vector<pair<ll, set<int> > > nums;
//    while (1)
//    {
//        k = t * t;
//        if (ch(k)) {
//            nums.push_back(make_pair(k, gt(k)));
//        }
//        if (k > 10000000000) break;
//        t ++;
//    }
//    cout << nums.size() << endl;
//
//
//    for (int i = 0;i < nums.size();i ++)
//    {
//
//    }
//    return 0;
//}


/*int main()
{
    set<int> p;
    int k = 0;
    ll a;
    for (ll i = 4;i <= 10000;i ++)
    {
        k = 0;
        a = i * i;
        k += a % 10;
        a /= 10;
        k += (a % 10) * 10;
        p.insert(k);
    }
    for (auto i = p.begin();i != p.end();i ++) cout << *i << " ";
    cout << endl << p.size() << endl;
    return 0;
}*/

/*
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};
char e[] = {'R', 'U', 'L', 'D'};

int main()
{
    char a[15][15];
    int n;
    scanf("%d", &n);
    for (int i = 0;i < n;i ++)
    {
        scanf(" ");
        for (int j = 0;j < n;j ++)
        {
            scanf("%c", &a[i][j]);
        }
    }
    queue<pair<int,int> > dt;
    
    for (int i = 0;i < n;i ++)
    {
        if (a[0][i] == 'U') {
            a[0][i] = 'o';
            dt.push(make_pair(0, i));
        }
    }
    for (int i = 0;i < n;i ++)
    {
        if (a[i][0] == 'L') {
            a[i][0] = 'o';
            dt.push(make_pair(i, 0));
        }
    }
    for (int i = 0;i < n;i ++)
    {
        if (a[n - 1][i] == 'D') {
            a[n - 1][i] = 'o';
            dt.push(make_pair(n - 1, i));
        }
    }
    for (int i = 0;i < n;i ++)
    {
        if (a[i][n - 1] == 'R') {
            a[i][n - 1] = 'o';
            dt.push(make_pair(i, n - 1));
        }
    }
    
    while (!dt.empty())
    {
        pair<int, int> d = dt.front();
        for (int j = 0;j < 4;j ++)
        {
            int x = d.second + dx[j];
            int y = d.first + dy[j];
            if (x >= 0 && y >= 0 && x < n && y < n)
            {
                if (a[y][x] == e[j])
                {
                    a[y][x] = 'o';
                    dt.push(make_pair(y, x));
                }
            }
        }
        dt.pop();
    }
    cout << ednl;
    int c = 0;
    for (int i = 0;i < n; i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            printf("%c",a[i][j]);
            if (a[i][j] == 'o') c ++;
        }
        cout << ednl;
    }
    cout << c << endl;
    return 0;
}
*/

/*
int find_max(string str)
{
    stringstream ss;
    ss << str;
    int m = -1;
    string x;
    while (getline(ss, x, '|'))
    {
        m = max(m, (int) x.size());
    }
    return m;
}

int main()
{
    string str;
    cin >> str;
    stack<int> st;
    for (int i = 0;str[i] != 0;i ++)
    {
        if (str[i] == '(') st.push(i);
        else if (str[i] == ')')
        {
            string t = "";
            int x = find_max(str.substr(st.top() + 1,i - st.top() - 1));
            for (int j = 0;j < x;j ++) t += 'x';
            str = str.substr(0, st.top()) + t + str.substr(i + 1);
            i = st.top() + x - 1;
            st.pop();
            //cout << str << ednl;
        }
    }
    while (!st.empty())
    {
        string t = "";
        int x = find_max(str.substr(st.top() + 1));
        for (int i = 0;i < x;i ++) t += 'x';
        str = str.substr(0, st.top()) + t;
        //cout << str << endl;
        st.pop();
    }
    int x = find_max(str);
    printf("%d\n",x);
    return 0;
}
*/

/*
int main()
{
    string line;
    double sum = 0;
    while (getline(cin, line))
    {
        double zhe = 0;
        double prize = 0;
        stringstream ss;
        ss << line;
        string a,b;
        ss >> a >> prize >> b;
        //cout << prize << " " << b << endl;
        if (b == "半价") zhe = 0.5;
        else zhe = atoi(b.substr(0, (int) b.size() - 1).c_str()) / 100.0;
        if (zhe < 0.1) zhe *= 10;
        //cout << zhe << endl;
        sum += zhe * prize;
    }
    cout << sum << endl;
    return 0;
}
*/

/*
int isRun(int y)
{
    return (y % 100 != 0 && y % 4 == 0) || y % 400 == 0;
}

int ms[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

int main()
{
    int a,b,c;
    scanf("%d/%d/%d",&a,&b,&c);
    set<pair<pair<int,int>, int> > years;
    pair<pair<int,int>, int> y1 = make_pair(make_pair(2000 + a, b), c),
    y2 = make_pair(make_pair(2000 + c, a), b),
    y3 = make_pair(make_pair(2000 + c, b), a),
    y4 = make_pair(make_pair(1900 + a, b), c),
    y5 = make_pair(make_pair(1900 + c, a), b),
    y6 = make_pair(make_pair(1900 + c, b), a);
    years.insert(y1);
    years.insert(y2);
    years.insert(y3);
    years.insert(y4);
    years.insert(y5);
    years.insert(y6);
    for (set<pair<pair<int,int>, int> >::iterator i = years.begin();i != years.end();i ++)
    {
        int y = i -> first.first,
        m = i -> first.second,
        d = i -> second;
        if (m < 1 || m > 12 || d <= 0) continue;
        if (y < 1960 || y > 2059) continue;
        if (isRun(y)) ms[2] = 29;
        else ms[2] = 28;
        if (d > ms[m]) continue;
        printf("%d-%02d-%02d\n",y,m,d);
    }
    return 0;
}
*/



/*int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    int a;
    ll sum = 0;
    int dp[100010] = {1};
    ll c = 0;
    while (n --)
    {
        scanf("%d",&a);
        sum = (sum + a) % k;
        c += dp[sum];
        dp[sum] ++;
    }
    printf("%lld\n",c);
    return 0;
}*/

/*int main()
{
    string str;
    int k = 0;
    while (getline(cin, str))
    {
        for (int i = 0;str[i] != 0;i ++)
        {
            switch(str[i])
            {
                case 'H':
                    k ++;
                    break;
                case '#':
                    k ++;
                    break;
                case '@':
                    k += 2;
                    break;
                case 'T':
                    k ++;
                    break;
            }
        }
    }
    cout << k << endl;
    return 0;
}
*/

/*
int main()
{
    ifstream A("./A.txt");
    ifstream B("./B.txt");
    ifstream C("./C.txt");
    
    set<string> a,b,c;
    
    string t, p;
    while (getline(A,t))
    {
        stringstream ss;
        ss << t;
        while (ss >> p)
        {
            if (p[p.size() - 1] == ',') p = p.substr(0,p.size() - 1);
            a.insert(p);
        }
    }
    while (getline(B,t))
    {
        stringstream ss;
        ss << t;
        while (ss >> p)
        {
            if (p[p.size() - 1] == ',') p = p.substr(0,p.size() - 1);
            b.insert(p);
        }
    }
    while (getline(C,t))
    {
        stringstream ss;
        ss << t;
        while (ss >> p)
        {
            if (p[p.size() - 1] == ',') p = p.substr(0,p.size() - 1);
            c.insert(p);
        }
    }
    set<string> ct;
    for (auto i = a.begin();i != a.end();i ++) {
        if (b.find(*i) != b.end()) ct.insert(*i);
    }
    int con = 0;
    for (auto i = ct.begin();i != ct.end();i ++)
    {
        if (c.find(*i) == c.end()) con ++;
    }
    printf("%d\n",con);
    return 0;
}
*/

/*int main()
{
    int a[] = {0,1,2,3,4,5,6,7,8,9};
    do {
        if (a[0] != 0 && a[4] != 0 && a[8] != 0)
        {
            int k1 = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3];
            int k2 = a[4] * 1000 + a[5] * 100 + a[6] * 10 + a[7];
            int k3 = a[8] * 10 + a[9];
            if ((k1 - k2) * k3 == 900) printf("(%d%d%d%d-%d%d%d%d)*%d%d=900\n",a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]);
        }
    } while (next_permutation(a, a + 10));
    return 0;
}
*/

/*
int main()
{
    char c[26];
    for (int i = 0;i < 26;i ++) c[i] = i + 'A';
    ll n;
    while (~scanf("%lld",&n))
    {
        string str;
        while (n != 0)
        {
            n --;
            str = c[n % 26] + str;
            n /= 26;
        }
        cout << str << endl;
    }
    return 0;
}
*/

/*
int main()
{
    int a[9];
    
    int k[10] = {0};
    vector<int> pos;
    for (int i = 0;i < 9;i ++)
    {
        scanf("%d",&a[i]);
        k[a[i]] ++;
        if (!a[i]) pos.push_back(i);
    }
    vector<int> nums;
    for (int i = 1;i < 10;i ++)
    {
        if (k[i] == 0) nums.push_back(i);
    }
    int b[9] = {0};
    int j = 0;
    do
    {
        j = 0;
        for (vector<int>::iterator i = pos.begin();i != pos.end();i ++, j ++)
        {
            a[*i] = nums[j];
        }
        int t = 0;
        for (int i = 0;i < 3;i ++)
        {
            if (t == 0) t = a[i] + a[i + 3] + a[i + 6];
            else if (t != a[i] + a[i + 3] + a[i + 6]) goto err;
            if (t != a[i * 3] + a[i * 3 + 1] + a[i * 3 + 2]) goto err;
        }
        if (a[0] + a[4] + a[8] != t || a[2] + a[4] + a[6] != t) goto err;
        if (!b[0])
            for (int i = 0;i < 9;i ++)
            {
                b[i] = a[i];
            }
        else goto e;
        err:
        continue;
    } while (next_permutation(nums.begin(), nums.end()));
    if (b[0])
    {
        for (int i = 0;i < 3;i ++)
        {
            for (int j = 0;j < 3;j ++)
            {
                if (j != 0) printf(" ");
                printf("%d",b[i * 3 + j]);
            }
            printf("\n");
        }
    }
    return 0;
    e:
    printf("Too Many\n");
    
    return 0;
}
*/

/*
int main()
{
    string a = "123456789";
    int c = 0;
    do {
        for (int i = 1;i <= 4;i ++)
        {
            ll num1 = atoll(a.substr(0,i).c_str());
            ll num2 = atoll(a.substr(i).c_str());
            ll ji = num1 * num2;
            int k[10] = {0};
            while (ji != 0)
            {
                k[ji % 10] ++;
                ji /= 10;
            }
            int ok = 1;
            for (int i = 1;i <= 9;i ++)
            {
                if (k[i] != 1) {
                    ok = 0;
                    break;
                }
            }
            if (ok) {
                cout << num1 * num2 << endl;
                c ++;
            }
        }
    } while (next_permutation(a.begin(), a.end()));
    cout << c << endl;
    return 0;
}
*/

/*
int main()
{
    string a = "123456789";
    set<pair<set<int>, vector<set<int> > > > all;
    do {
        
        set<int> d;
        vector<set<int> > b;
        
        d.insert(a[0] - '0');
        d.insert(a[1] - '0');
        d.insert(a[2] - '0');
        
        set<int> tt;
        tt.insert(a[3] - '0');
        tt.insert(a[4] - '0');
        b.push_back(tt);
        
        tt.clear();
        tt.insert(a[5] - '0');
        tt.insert(a[6] - '0');
        b.push_back(tt);
        
        tt.clear();
        tt.insert(a[7] - '0');
        tt.insert(a[8] - '0');
        b.push_back(tt);
        
        int k = *d.begin() + *(++ d.begin()) + *b[0].begin() + *(++ b[0].begin());
        if (k == *d.begin() + *(++ (++ d.begin())) + *b[1].begin() + *(++ b[1].begin()) && k == *(++ d.begin()) + *(++ (++ d.begin())) + *b[2].begin() + *(++ b[2].begin()))
        {
            pair<set<int>, vector<set<int> > > cb = make_pair(d, b);
            all.insert(cb);
        }
        
        
    } while (next_permutation(a.begin(), a.end()));
//    for (auto i = all.begin();i != all.end();i ++)
//    {
//        set<int> d = i -> first;
//        vector<set<int> > b = i -> second;
//        cout << "(";
//        for (auto j = d.begin();j != d.end();j ++)
//        {
//            cout << *j << ", ";
//        }
//        cout << ")\n";
//        for (int j = 0;j < 3;j ++)
//        {
//            for (auto k = b[j].begin();k != b[j].end();k ++)
//            {
//                cout << *k << " ";
//            }
//            cout << endl;
//        }
//        cout << endl;
//    }
    cout << all.size() * 8 << endl;
    // C30 + C31 + C32 + C33 = 8
    return 0;
}
*/

/*
int main()
{
    int t;
    while (~scanf("%d",&t))
    {
        int k = t % 9;
        if (k == 0) k = 9;
        char p = 'A' + k - 1;
        cout << p << endl;
    }
    
    return 0;
}
*/

/*
int test(ll n)
{
    int a[10] = {0};
    while (n != 0)
    {
        a[n % 10] ++;
        n /= 10;
    }
    int ok = 1;
    for (int i = 0;i < 10;i ++) if (a[i] != 1) {ok = 0; break;}
    return ok;
}

int main()
{
    
    for (ll i = 31600;i <= 100000;i ++)
    {
        ll x = i * i;
        if (test(x)) cout << x << endl;
    }
    return 0;
}
*/

/*
int main()
{
    int p['Z' + 1];
    for (int i = 0;i < 10;i ++)
    {
        p[i] = i;
    }
    for (int i = 'A';i <= 'Z';i ++)
    {
        p[i] = i - 'A' + 10;
    }
    string str;
    //while (cin >> str)
    {
        str = "MANY";
        int n = (int) str.size();
        ll sum = 0;
        for (int i = n - 1, j = 0;i >= 0;i --, j ++)
        {
            sum += p[str[i]] * pow(36,j);
        }
        cout << sum << endl;
    }
    return 0;
}
*/

/*int s1(vector<int> a)
{
    int s = 0;
    for (auto i = a.begin();i != a.end();i ++) s += *i;
    return s;
}

int s2(vector<int> a)
{
    int s = 0;
    for (auto i = a.begin();i != a.end();i ++) s += (*i) * (*i);
    return s;
}

int s3(vector<int> a)
{
    int s = 0;
    for (auto i = a.begin();i != a.end();i ++) s += (*i) * (*i) * (*i);
    return s;
}

void dfs(vector<int> a, int n, vector<int> k)
{
    if (n == 0) {
        vector<int> left;
        //for (auto i = k.begin();i != k.end();i ++) cout << *i << " ";
        //cout << endl;
        auto i0 = k.begin();
        for (int i = 1;i <= 16;i ++)
        {
            if (*i0 != i) left.push_back(i);
            else i0 ++;
        }
        if (s1(k) == s1(left) && s2(k) == s2(left) && s3(k) == s3(left))
        {
            for (auto i = k.begin();i != k.end();i ++) cout << *i << " ";
            cout << endl;
            cout  << ">>";
            for (auto i = left.begin();i != left.end();i ++) cout << *i << " ";
            cout << endl << endl;
        }
        //cout  << ">>";
        //for (auto i = left.begin();i != left.end();i ++) cout << *i << " ";
        //cout << endl << endl;
        return;
    }
    ll sz = a.size();
    for (ll i = sz - 1;i >= n - 1;i --)
    {
        k.insert(k.begin(), a[i]);
        //k.push_back(a[i]);
        a.erase(a.begin() + i);
        dfs(a,n - 1,k);
        k.erase(k.begin());
    }
}


int main()
{
    vector<int> a;
    for (int i = 1;i <= 16;i ++)
    {
        a.push_back(i);
    }
    vector<int> k;
    for (int i = 1;i <= 8;i ++) dfs(a,i,k);
    return 0;
}
*/

/*
int sum(int n)
{
    int s = 0;
    while (n != 0)
    {
        s += n % 10;
        n /= 10;
    }
    return s;
}

int main()
{
    int s = 0;
    for (int i = 1;i <= 1000;i ++) s += sum(i);
    cout << s << endl;
    return 0;
}
*/


/*int ms[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

int isRun(int y)
{
    return (y % 100 != 0 && y % 4 == 0) || y % 400 == 0;
}

void jd(int y)
{
    if (isRun(y)) ms[2] = 29;
    else ms[2] = 28;
}

int main()
{
    int today_qi = 7;
    int y = 2000, m = 12, d = 31;
    int y_to, m_to, d_to;
    scanf("%d-%d-%d",&y_to,&m_to,&d_to);
    jd(y);
    int c = 0;
    while (y_to != y || m_to != m || d_to != d)
    {
        d --;
        if (d <= 0)
        {
            m --;
            if (m <= 0) {
                y --;
                jd(y);
                m = 12;
            }
            d = ms[m];
        }
        today_qi --;
        if (today_qi == 0) today_qi = 7;
        if (today_qi == 1) c ++;
    }
    cout << c << endl;//5217
    cout << today_qi << ednl;
    return 0;
}
*/

/*
int jd(int a, int b)
{
    return !(abs(a - b) == 1);
}

int main()
{
    int a[10] = {1,2,3,4,5,6,7,8,9,10};
    int c = 0;
    do {
        int ok = 1;
        for (int i = 1;i <= 9;i ++)
        {
            if (!jd(a[i - 1], a[i])) {
                ok = 0;
                break;
            }
        }
        if (ok) c ++;
    } while (next_permutation(a, a + 10));
    cout << c << endl;
    return 0;
}
*/

/*
class tim
{
public:
    int h = 0; int m = 0; int s = 0;
    
    tim() { }
    
    tim(int h, int m, int s)
    {
        this -> h = h;
        this -> m = m;
        this -> s = s;
    }
    
    tim sub(tim t)
    {
        t.s = s - t.s;
        t.m = m - t.m;
        t.h = h - t.h;
        if (t.s < 0) {
            t.s += 60;
            t.m --;
        }
        if (t.m < 0)
        {
            t.h --;
            t.m += 60;
        }
        return t;
    }
    
    tim add(tim t)
    {
        t.s = s + t.s;
        t.m = m + t.m;
        t.h = h + t.h;
        if (t.s >= 60) {
            t.s -= 60;
            t.m ++;
        }
        if (t.m >= 60)
        {
            t.h ++;
            t.m -= 60;
        }
        return t;
    }
    
    string toString()
    {
        string str = "";
        if (h < 10) str += '0';
        str += to_string(h);
        str += ':';
        if (m < 10) str += '0';
        str += to_string(m);
        str += ':';
        if (s < 10) str += '0';
        str += to_string(s);
        return str;
    }
};

int main()
{
    
    string line;
    int T;
    scanf("%d",&T);
    //scanf(" ");
    while (T --)
    {
        tim tt[4];
        scanf(" ");
        getline(cin, line);
        stringstream ss;
        ss << line;
        string s;
        for (int i = 0;ss >> s;i ++)
        {
            if (i != 2)
            {
                int t = 0,k = 0;
                for (int j = 0;s[j] != 0;j ++)
                {
                    if (s[j] == ':')
                    {
                        
                        if (k == 0) tt[i].h = t;
                        if (k == 1) tt[i].m = t;
                        t = 0;
                        k ++;
                    } else t = t * 10 + s[j] - '0';
                }
                tt[i].s = t;
            } else
            {
                int t = 0;
                for (int j = 0;s[j] != 0;j ++)
                {
                    if (s[j] >= '0' && s[j] <= '9') t = t * 10 + s[j] - '0';
                }
                tt[1].h += 24 * t;
            }
        }
        //cout << tt[1].sub(tt[0]).toString() << endl;
        //cout << tt[1].add(tt[0]).toString() << ednl;
        
        
        scanf(" ");
        getline(cin, line);
        ss = stringstream(line);
        for (int i = 2;ss >> s;i ++)
        {
            if (i != 4)
            {
                int t = 0,k = 0;
                for (int j = 0;s[j] != 0;j ++)
                {
                    if (s[j] == ':')
                    {
                        
                        if (k == 0) tt[i].h = t;
                        if (k == 1) tt[i].m = t;
                        t = 0;
                        k ++;
                    } else t = t * 10 + s[j] - '0';
                }
                tt[i].s = t;
            } else
            {
                int t = 0;
                for (int j = 0;s[j] != 0;j ++)
                {
                    if (s[j] >= '0' && s[j] <= '9') t = t * 10 + s[j] - '0';
                }
                tt[3].h += 24 * t;
            }
        }
        //cout << tt[0].toString() << endl << tt[1].toString() << endl << tt[2].toString() << endl << tt[3].toString() << endl;
        tim hh = tt[1].add(tt[2]).sub(tt[0].add(tt[3]));
        hh.h /= 2;
        cout << tt[1].sub(tt[0].add(hh)).toString() << endl;
    }
    
    return 0;
}
*/

/*
int dx[] = {1,0,-1,0};
int dy[] = {0,-1,0,1};
char a[1010][1010];
int t;

int bfs(int i, int j)
{
    int v = 1, l = 0;
    stack<pair<int,int> > s;
    s.push(make_pair(i, j));
    a[i][j] = '*';
    while (!s.empty())
    {
        pair<int,int> c = s.top();
        s.pop();
        int ok = 0;
        for (int p = 0;p < 4;p ++)
        {
            int x = c.second + dx[p],
            y = c.first + dy[p];
            if (x >= 0 && y >= 0 && x < t && y < t)
            {
                if (a[y][x] == '#')
                {
                    s.push(make_pair(y, x));
                    a[y][x] = '*';
                    v ++;
                }
                if (a[y][x] == '.') ok = 1;
            }
        }
        if (ok) l ++;
    }
    return l == v;
}

int tj()
{
    int c = 0;
    for (int i = 0;i < t;i ++)
    {
        for (int j = 0;j < t;j ++)
        {
            if (a[i][j] == '#')
            {
                if (bfs(i,j)) c ++;
            }
        }
    }
    return c;
}

int main()
{
    
    scanf("%d",&t);
    for (int i = 0;i < t;i ++)
    {
        scanf(" ");
        for (int j = 0;j < t;j ++)
        {
            scanf("%c", &a[i][j]);
        }
    }
    printf("%d\n", tj());
//    cout << endl;
//    for (int i = 0;i < t;i ++)
//    {
//        for (int j = 0;j < t;j ++)
//        {
//            printf("%c", a[i][j]);
//        }
//        printf("\n");
//    }
    return 0;
}
*/

/*
int ms[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

int isRun(int y)
{
    return (y % 100 != 0 && y % 4 == 0) || y % 400 == 0;
}

void jd(int y)
{
    if (isRun(y)) ms[2] = 29;
    else ms[2] = 28;
}

int main()
{
    int y = 2000, m = 1, d = 1;
    int y_to = 2000, m_to = 5, d_to = 4;
    //scanf("%d-%d-%d",&y_to,&m_to,&d_to);
    jd(y);
    int c = 1;
    while (y_to != y || m_to != m || d_to != d)
    {
        d ++;
        if (d > ms[m])
        {
            m ++;
            if (m > 12) {
                y ++;
                jd(y);
                m = 1;
            }
            d = 1;
        }
        c ++;
    }
    cout << c << endl;
    return 0;
}
*/

/*string to_bin(char n)
{
    if (n < 0) n = ~n;
    string str;
    while (n != 0)
    {
        str = ((char) ('0' + n % 2)) + str;
        n /= 2;
    }
    return str;
}

string add(char n, string b)
{
    while (b.size() < 8)
    {
        b.insert(b.begin(), '0');
    }
    if (n < 0)
    {
        for (int i = 0;b[i] != 0;i ++) b[i] = !(b[i] - '0') + '0';
    }
    return b;
}

void prt(char a, char b)
{
    string s1 = add(a, to_bin(a));
    string s2 = add(b, to_bin(b));
    for (int i = 0;s1[i] != 0;i ++)
    {
        if (s1[i] == '0') cout << " ";
        else cout << "1";
    }
    for (int i = 0;s2[i] != 0;i ++)
    {
        if (s2[i] == '0') cout << " ";
        else cout << "1";
    }
    cout << endl;
}

int main()
{
    char a,b;
    while (~scanf("%hhd %hhd",&a,&b))
    {
        prt(a,b);
        for (int i = 0;i < 15;i ++) {scanf("%hhd %hhd",&a,&b); prt(a,b);}
        cout << endl;
    }
    return 0;
}
*/

/*
int main()
{
    ll x,y;
    scanf("%lld %lld",&x, &y);
    
    ll dis = 0;
    if (x >= 0)
    {
        if (y >= -x && y <= x)
        {
            dis = (1 + 2 * x) * x * 2;
            dis -= 2 * x;
            dis += x - y;
        } else
        {
            if (y >= 0)
            {
                dis = (2 * y) * (2 * y - 1);
                dis += x + y;
            } else
            {
                dis += (1 + 2 * -y) * 2 * -y;
                dis += -y - x;
            }
        }
    } else
    {
        if (y >= x + 1 && y <= -x)
        {
            dis = 2 * -x * (-x * 2 - 1);
            dis -= 2 * -x - 1;
            dis += y - (x + 1);
        } else {
            if (y >= 0)
            {
                dis = (2 * y) * (2 * y - 1);
                dis += x + y;
            } else
            {
                dis += (1 + 2 * -y) * 2 * -y;
                dis += -y - x;
            }
        }
    }
    printf("%lld\n",dis);
    return 0;
}
*/

/*int main()
{
    string str;
    while (cin >> str)
    {
        int a['z' + 1] = {0};
        for (int i = 0;str[i] != 0;i ++)
        {
            a[str[i]] ++;
        }
        int ma = -1;
        int mi = 2000;
        for (int i = 'a';i <= 'z';i ++)
        {
            if (a[i] != 0)
            {
                if (a[i] >= ma) ma = a[i];
                if (a[i] <= mi) mi = a[i];
            }
        }
        printf("%d\n",ma - mi);
    }
    return 0;
}
*/

/*
void prt(int n, char c)
{
    for (int i = 0;i < n;i ++) printf("%c",c);
}

int main()
{
    int a;
    while (~scanf("%d",&a))
    {
        int n = a + a * 2 - 4 + a;
        string str;
        int i = 1;
        while (str.size() < n)
        {
            str += to_string(i);
            i ++;
        }
        while (str.size() > n)
        {
            str.erase(str.end() - 1);
        }
        //cout << str << ednl;
        for (i = 0;i < a;i ++)
        {
            prt(a - i - 1,'.');
            if (i == 0)
            {
                printf("%c\n",str[i]);
            } else if(i != a - 1) {
                printf("%c",str[i]);
                prt(2 * i - 1,'.');
                printf("%c\n",str[n - i]);
            } else {
                for (int j = i;j <= n - i;j ++) printf("%c",str[j]);
                printf("\n");
            }
        }
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    while (cin >> str)
    {
        int x = 0;
        for (int i = 0;str[i] != 0;i ++)
        {
            x += str[i] - '0';
        }
        int k;
        while (x / 10 >= 1)
        {
            k = x;
            x = 0;
            while (k != 0)
            {
                x += k % 10;
                k /= 10;
            }
        }
        printf("%d\n", x);
    }
    return 0;
}
*/

/*
double pp(double a) {return a * a;}

int main()
{
    double a,b,c;
    a = sqrt(pp(6.4 - 2.3) + pp(3.1 - 2.5));
    b = sqrt(pp(5.1 - 2.3) + pp(7.2 - 2.5));
    c = sqrt(pp(5.1 - 6.4) + pp(7.2 - 3.1));
    double t = (a + b + c) / 2;
    double s = sqrt(t * (t - a) * (t - b) * (t - c));
    printf("%.3lf",s);
    reutrn 0;
}
*/

/*
int main()
{
    int c = 0;
    for (int x = 1;1;x ++)
    {
        c = 0;
        for (int i = 1;i <= sqrt(x);i ++)
        {
            double K = sqrt(x - i * i);
            int k = K;
            if (k == K && k >= i) c ++;
        }
        if (c == 12)
        {
            printf("%d\n",x);
            break;
        }
    }
    return 0;
}
*/

// 约瑟夫环
//https://blog.csdn.net/qie_wei/article/details/87915174
/*
int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    int x = 0;
    for (int i = 1;i <= n;i ++) x = (x + k) % i;
    printf("%d\n", x + 1);
    
    return 0;
}
*/

/*
int main()
{
    int a[10] = {0,1,2,3,4,5,6,7,8,9};
    set<int> k;
    do {
        if (a[0] > a[1] && a[1] > a[2]) {
            k.insert(a[0] * 100 + a[1] * 10 + a[2]);
        }
    } while (next_permutation(a, a + 10));
    cout << k.size() << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        double D;
        int k;
        int a = -1,b = -1,c = -1,d = -1;
        for (int A = 0;A <= sqrt(n);A ++)
        {
            for (int B = A;B <= sqrt(n);B ++)
            {
                for (int C = B;C <= sqrt(n);C ++)
                {
                    D = sqrt(n - A * A - B * B - C * C);
                    if (D >= C && D == (k = D))
                    {
                        a = A;
                        b = B;
                        c = C;
                        d = k;
                        goto end;
                    }
                }
            }
        }
        end:
        printf("%d %d %d %d\n",a,b,c,d);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[10010];
    int k[10010];
    while (~scanf("%d",&n))
    {
        for (int i = 1;i <= n;i ++)
        {
            scanf("%d",a + i);
            k[a[i]] = i;
        }
        int c = 0;
        for (int i = 1;i <= n;i ++)
        {
            if (a[i] != i)
            {
                c ++;
                a[k[i]] = a[i];
                k[a[i]] = k[i];
                a[i] = i;
                
            }
        }
        printf("%d\n", c);
    }
    return 0;
}
*/

/*
int cpd(int *a, int n)
{
    int k = 0;
    for (int i = n - 1, j = 0;i >= 0;i --, j ++)
    {
        k += pow(10,j) * a[i];
    }
    return k;
}

int ok(int k)
{
    int a[10] = {0};
    int ok = 1;
    while (k != 0)
    {
        a[k % 10] ++;
        k /= 10;
    }
    if (a[0] != 0) return 0;
    for (int i = 1;i < 10;i ++)
    {
        if (a[i] != 1) return 0;
    }
    return ok;
}

int main()
{
    int a[9] = {1,2,3,4,5,6,7,8,9};
    int m = 0;
    do {
        int k = 1;
        for (int i = 1;i < 9;i ++)
        {
            //cout << cpd(a, 9) << " >> " << cpd(a, i) << " " << cpd(a + i, 9 - i) << endl;
            k = cpd(a, i) * cpd(a + i, 9 - i);
            if (ok(k) && k >= m) m = k;
        }
    } while (next_permutation(a, a + 9));
    cout << m;
    return 0;
}
*/

//vector<int> nds[100010];
//set<int> cds[100010];
//
//void dfs(int nd)
//{
//    if (nds[nd].size() == 0)
//    {
//        return;
//    }
//    for (vector<int>::iterator i = nds[nd].begin();i != nds[nd].end();i ++)
//    {
//        dfs(*i);
//    }
//}
//
//int main()
//{
//    int n,q;
//    scanf("%d %d",&n,&q);
//    int a,b;
//
//
//
//    for (int i = 0;i < n - 1;i ++)
//    {
//        scanf("%d %d",&a,&b);
//        nds[a].push_back(b);
//        cds[a].insert(b);
//    }
//
//
//
//    int x,y;
//    for (int i = 0;i < q;i ++)
//    {
//        scanf("%d %d",&x,&y);
//    }
//    return 0;
//}
//

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int m,n;
        scanf("%d %d",&n,&m);
        char r[15][15];
        int k[10] = {0};
        int ok = 1;
        for (int i = 0;i < n;i ++)
        {
            scanf(" ");
            for (int j = 0;j < m;j ++)
            {
                scanf("%c",&r[i][j]);
            }
        }
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < m;j ++)
            {
                if (r[i][j] != '.')
                {
                    if (k[r[i][j] - '0'] != 0) {ok = 0; goto end;}
                    char p = r[i][j];
                    int a = i,b = j;
                    for (;a < n && r[a][j] == r[i][j];a ++);
                    for (;b < m && r[i][b] == r[i][j];b ++);
                    //cout << a - i << " " << b - j << endl;
                    for (int x = i;x < a;x ++)
                    {
                        for (int y = j;y < b;y ++)
                        {
                            if (r[x][y] != p) {ok = 0; goto end;}
                            r[x][y] = '.';
                        }
                    }
                    k[p - '0'] = 1;
                }
            }
        }
        end:
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    string str = "";
    for (int i = 0;i < n;i ++)
    {
        char k = 'A' + i;
        str = str + k + str;
    }
    cout << str << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    multiset<int> a;
    int t;
    for (int i = 0;i < n;i ++) {
        scanf("%d", &t);
        a.insert(t);
    }
    int k = 0;
    while (a.size() != 1)
    {
        t = 0;
        t += *a.begin();
        a.erase(a.begin());
        t += *a.begin();
        a.erase(a.begin());
        a.insert(t);
        k += t;
    }
    printf("%d\n", k);
    
    return 0;
}
*/

/*
string getAn(int n)
{
    string str = "";
    for (int i = 1;i <= n;i ++)
    {
        if (i != 1)
        {
            if (i % 2) str += '+';
            else str += '-';
        }
        str += "sin(";
        str += to_string(i);
        
    }
    for (int i = 0;i < n;i ++) str += ")";
    return str;
}

string getSn(int n)
{
    string str = "";
    for (int i = 1;i < n;i ++) str += '(';
    for (int i = n;i >= 1;i --)
    {
        str += getAn(n - i + 1);
        str += '+';
        str += to_string(i);
        if (i != 1) str += ')';
    }
    return str;
}

int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        cout << getSn(n) << endl;
        
    }
    
    return 0;
}
*/

/*
int main()
{
    int h, m;
    scanf("%d %d",&h, &m);
    string nm[60] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
        "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"};
    for (int i = 21;i < 60;i ++)
    {
        if (i < 30) nm[i] = nm[20] + " " + nm[i - 20];
        else if (i == 30) nm[i] = "thirty";
        else if (i < 40) nm[i] = nm[30] + " " + nm[i - 30];
        else if (i == 40) nm[i] = "forty";
        else if (i < 50) nm[i] = nm[40] + " " + nm[i - 40];
        else if (i == 50) nm[i] = "fifty";
        else nm[i] = nm[50] + " " + nm[i - 50];
    }
    cout << nm[h] << " ";
    if (m == 0) cout << "o'clock" << endl;
    else cout << nm[m] << endl;
    return 0;
}
*/

/*
int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    int k = 0;
    int f = 1;
    for (int i = a;i <= b;i ++)
    {
        k = i;
        f = 1;
        printf("%d=",i);
        for (int j = 2;j <= i;j ++)
        {
            
            while (k % j == 0)
            {
                k /= j;
                if (f) f = 0;
                else printf("*");
                printf("%d",j);
            }
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int v1,v2,t,s,l;
    scanf("%d %d %d %d %d",&v1,&v2,&t,&s,&l);
    if (v2 > v1)
    {
        if (v2 > v1) cout << 'T' << endl;
        cout << l / v1 << endl;
    } else {
        int dis_r = 0, dis_t = 0;
        int x = -1;
        int i;
        for (i = 1;dis_r < l && dis_t < l;i ++)
        {
            dis_t += v2;
            if (x == -1) dis_r += v1;
            else if (i >= x + s) x = -1;
            //cout << "r" << dis_r << "t" << dis_t << endl;
            //cout << i << " " << x << ednl;
            if (s != 0 && dis_r - dis_t >= t && x == -1) x = i;
        }
        if (dis_t == dis_r) cout << 'D' << endl;
        else if (dis_t < dis_r) cout << 'R' << endl;
        else cout << 'T' << endl;
        cout << i - 1 << endl;
    }
    return 0;
}
*/

/*
int main()
{
    int m,n;
    scanf("%d %d",&m,&n);
    int a[210][210] = {0};
    char b[210][210] = {0};
    for (int i = 0;i < m;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    int d = 0;
    pair<int, int> pos(0, 0);
    // 0 - d, 1 - r, 2 - u, 3 - l;
    for (int i = 0;i < m * n;i ++)
    {
        if (i != 0) printf(" ");
        int x = pos.second,
        y = pos.first;
        printf("%d",a[y][x]);
        b[y][x] = '.';
        switch (d) {
            case 0:
                if (y + 1 >= m || b[y + 1][x] == '.') { d = 1; pos.second ++;}
                else pos.first ++;
                break;
            case 1:
                if (x + 1 >= n || b[y][x + 1] == '.') { d = 2; pos.first --;}
                else pos.second ++;
                break;
            case 2:
                if (y - 1 < 0 || b[y - 1][x] == '.') { d = 3; pos.second --;}
                else pos.first --;
                break;
            case 3:
                if (x - 1 < 0 || b[y][x - 1] == '.') { d = 0; pos.first ++;}
                else pos.second --;
                break;
            default:
                break;
        }
    }
    printf("\n");
    return 0;
}
*/


//int main()
//{
//    int dx1,dy1,dx2,dy2,dx3,dy3,dx4,dy4;
//    scanf("%d %d %d %d", &dx1, &dy1, &dx2, &dy2);
//    scanf("%d %d %d %d", &dx3, &dy3, &dx4, &dy4);
//    int x1 = min(dx1, dx2),
//    y1 = min(dy1, dy2),
//    x2 = max(dx1, dx2),
//    y2 = max(dy1, dy2),
//    x3 = min(dx3, dx4),
//    y3 = min(dy3, dy4),
//    x4 = max(dx3, dx4),
//    y4 = max(dy3, dy4);
//    printf("%d %d | %d %d | %d %d | %d %d",x1,y1,x2,y2,x3,y3,x4,y4);
//
//    return 0;
//}

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int A[50][50];
    vector<vector<int> > B(50), C(50);
    int t;
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf("%d",&t);
            A[i][j] = t;
            B[i].push_back(t);
            C[i].push_back(t);
        }
    }
    int s = 0;
    if (m == 0)
    {
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < n;j ++)
            {
                if (i == j)
                {
                    B[i][j] = 1;
                } else B[i][j] = 0;
            }
        }
    }
    for (int k = 0;k < m - 1;k ++)
    {
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < n;j ++)
            {
                s = 0;
                for (int v = 0;v < n;v ++)
                {
                    s += B[i][v] * A[v][j];
                }
                C[i][j] = s;
            }
        }
        B.swap(C);
    }
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            if (j != 0) printf(" ");
            printf("%d",B[i][j]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int t;
    scanf("%d",&t);
    int h = 0,m = 0,s = 0;
    for (int i = 0;i < t;i ++)
    {
        s ++;
        if (s == 60)
        {
            m ++;
            s = 0;
            if (m == 60)
            {
                h ++;
                m = 0;
            }
        }
    }
    printf("%d:%d:%d\n",h,m,s);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d", &n);
    int a[30][30];
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    int s = 0;
    int f = 1;
    for (int i = 0;i < n;i ++)
    {
        s = 0;
        for (int j = 0;j < n;j ++)
        {
            s += a[j][i];
        }
        if (s > n / 2)
        {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i + 1);
        }
    }
    printf("\n");
    return 0;
}
*/

/*
int main()
{
    string str1,str2;
    cin >> str1 >> str2;
    if (str1.size() != str2.size()) printf("1\n");
    else if (str1 == str2) printf("2\n");
    else {
        for (int i  = 0;str1[i] != 0;i ++) if (str1[i] >= 'a' &&  str1[i] <= 'z') str1[i] -= 32;
        for (int i  = 0;str2[i] != 0;i ++) if (str2[i] >= 'a' &&  str2[i] <= 'z') str2[i] -= 32;
        if (str1 == str2) printf("3\n");
        else printf("4\n");
    }
    return 0;
}
*/

/*
int main()
{
    int N;
    scanf("%d",&N);
    int a[100010];
    int i = 0;
    string str = "";
    
    while (N --)
    {
        scanf(" ");
        string s;
        getline(cin, s);
        str += " " + s;
    }
    stringstream ss(str);
    int id;
    while (ss >> id)
    {
        a[i] = id;
        i ++;
    }
    sort(a, a + i);
    int m = 0,n = 0;
    for (int k = 1;k < i;k ++)
    {
        if (a[k] - a[k - 1] != 1)
        {
            if (a[k] == a[k - 1]) n = a[k];
            else m = a[k] - 1;
        }
    }
    printf("%d %d\n", m, n);
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        int a[500][500] = {0};
        int k = n * 4 + 5;
        int ctr = k / 2;
        for (int i = 0;i <= n;i ++)
        {
            int y = ctr - (i + 1) * 2;
            //cout << ctr << " " << y << endl;
            int start = ctr - i * 2;
            int end = ctr + i * 2 + 1;
            //cout << end << endl;
            for (int j = start;j < end;j ++)
            {
                a[y][j] = 1;
            }
            a[y + 1][start] = 1;
            a[y + 1][end - 1] = 1;
            
            
            a[y + 2][start] = 1;
            a[y + 2][start - 1] = 1;
            
            a[y + 2][end - 1] = 1;
            a[y + 2][end] = 1;
            
            for (int j = y + 2;j < y + 2 + i * 4 + 1;j ++) {
                a[j][start - 2] = 1;
                a[j][end + 1] = 1;
            }
            
            
            y = ctr + (i + 1) * 2;
            for (int j = start;j < end;j ++)
            {
                a[y][j] = 1;
            }
            a[y - 1][start] = 1;
            a[y - 1][end - 1] = 1;
            
            a[y - 2][start] = 1;
            a[y - 2][start - 1] = 1;
            
            a[y - 2][end - 1] = 1;
            a[y - 2][end] = 1;
        }
        
        for (int i = 0;i < k;i ++)
        {
            for (int j = 0;j < k;j ++) if (a[i][j] == 1) printf("$");
            else printf(".");
            printf("\n");
        }
    }
    return 0;
}
*/

/*
int to_int(int a[], int n)
{
    int num = 0;
    for (int i = 0;i < n;i ++)
    {
        num = num * 10 + a[i];
    }
    return num;
}

int main()
{
    int a[9] = {1,2,3,4,5,6,7,8,9};
    int n;
    scanf("%d",&n);
    int k = 0;
    do {
        int A = 0;
        for (int i = 0;i <= 6;i ++)
        {
            A = A * 10 + a[i];
            int B = 0;
            for (int j = i + 1;j <= 7;j ++)
            {
                B = B * 10 + a[j];
                int C = to_int(a + j + 1, 9 - j - 1);
                int c = B / C;
                if (c * C != B) continue;
                if (n == A + c) k ++;
            }
        }
    } while (next_permutation(a, a + 9));
    printf("%d\n", k);
    return 0;
}
*/

//int n,m,k;
//int a[60][60];
//int dp[60][60][20][20] = {0};
//
//int dfs(int x, int y, int kk, int v)
//{
//    //cout << x << ", " << y << endl;
//    if (kk > k) return 0;
//    if (x == m && y == n)
//    {
//        return kk == k;
//    }
//    int sum = 0;
//    if (a[y][x] > v)
//    {
//        // Take
//        int w = a[y][x];
//        if (x == m - 1 && y == n - 1)
//        {
//            sum = (sum + (dp[x + 1][y + 1][kk + 1][w] == 0 ? dp[x + 1][y + 1][kk + 1][w] = dfs(x + 1,y + 1,kk + 1,w) : dp[x + 1][y + 1][kk + 1][w])) % 1000000007;
//        } else {
//            if (x != m - 1)
//            {
//                sum = (sum + (dp[x + 1][y][kk + 1][w] == 0 ? dp[x + 1][y][kk + 1][w] = dfs(x + 1,y,kk + 1,w) : dp[x + 1][y][kk + 1][w])) % 1000000007;
//            }
//            if (y != n - 1)
//            {
//                sum = (sum + (dp[x][y + 1][kk + 1][w] == 0 ? dp[x][y + 1][kk + 1][w] = dfs(x, y + 1,kk + 1,w) : dp[x][y + 1][kk + 1][w])) % 1000000007;
//            }
//        }
//    }
//    // Not Take
//    if (x == m - 1 && y == n - 1)
//    {
//        sum = (sum + (dp[x + 1][y + 1][kk][v] == 0 ? dp[x + 1][y + 1][kk][v] = dfs(x + 1,y + 1,kk,v) : dp[x + 1][y + 1][kk][v])) % 1000000007;
//    } else {
//        if (x != m - 1)
//        {
//            sum = (sum + (dp[x + 1][y][kk][v] == 0 ? dp[x + 1][y][kk][v] = dfs(x + 1,y,kk,v) : dp[x + 1][y][kk][v])) % 1000000007;
//        }
//        if (y != n - 1)
//        {
//            sum = (sum + (dp[x][y + 1][kk][v] == 0 ? dp[x][y + 1][kk][v] = dfs(x,y + 1,kk,v) : dp[x][y + 1][kk][v])) % 1000000007;
//        }
//    }
//    return sum;
//}
//
//int dfs_t(int x, int y, int kk, int v, vector<pair<int,int> > pos)
//{
//    //cout << x << ", " << y << endl;
//    if (x == m && y == n)
//    {
//
//        if (kk == k) {for (auto i = pos.begin();i != pos.end();i ++) cout << "(" << i -> first << ", " << i -> second << ") ";
//            cout << endl;}
//        return kk == k;
//    }
//    int sum = 0;
//    int ttt = 0;
//    if (a[y][x] > v)
//    {
//        // Take
//        ttt = 1;
//        int w = a[y][x];
//        if (x == m - 1 && y == n - 1)
//        {
//            pos.push_back(make_pair(x, y));
//            sum += dfs_t(x + 1,y + 1,kk + 1,w,pos);
//        } else {
//            if (x != m - 1)
//            {
//                pos.push_back(make_pair(x, y));
//                sum += dfs_t(x + 1,y,kk + 1,w,pos);
//            }
//            if (y != n - 1)
//            {
//                if (x != m - 1) pos.erase(pos.end() - 1);
//                pos.push_back(make_pair(x, y));
//                sum += dfs_t(x, y + 1,kk + 1,w,pos);
//            }
//        }
//    }
//    // Not Take
//    if (ttt) pos.erase(pos.end() - 1);
//    if (x == m - 1 && y == n - 1)
//    {
//        sum += dfs_t(x + 1,y + 1,kk,v,pos);
//    } else {
//        if (x != m - 1)
//        {
//            sum += dfs_t(x + 1,y,kk,v,pos);
//        }
//        if (y != n - 1)
//        {
//            sum += dfs_t(x,y + 1,kk,v,pos);
//        }
//    }
//    return sum;
//}
//
//
//int main()
//{
//    scanf("%d %d %d",&n,&m,&k);
//    for (int i = 0;i < n;i ++)
//    {
//        for (int j = 0;j < m;j ++)
//        {
//            scanf("%d", &a[i][j]);
//        }
//    }
//    //vector<pair<int,int> > p;
//    printf("%d\n",dfs(0,0,0,-1));
//    return 0;
//}

/*
int main()
{
    string a, b;
    cin >> a >> b;
    int c = 0;
    for (int i = 0;a[i] != 0;i ++)
    {
        if (a[i] != b[i])
        {
            c ++;
            if (b[i] == '*') b[i] = 'o';
            else b[i] = '*';
            if (b[i + 1] == '*') b[i + 1] = 'o';
            else b[i + 1] = '*';
        }
    }
    cout << c << endl;
    return 0;
}
*/

/*
int ok(int a[], int n)
{
    for (int i = 0;i < n - 1;i ++)
    {
        if (a[i] != a[i + 1] || a[i] % 2) return 0;
    }
    return 1;
}

int main()
{
    int n;
    int a[110];
    scanf("%d",&n);
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    int c = 0;
    int last,l;
    while (!ok(a,n))
    {
        last = a[n - 1] / 2;
        for (int i = 0;i < n;i ++)
        {
            l = a[i] /= 2;
            a[i] += last;
            last = l;
        }
        for (int i = 0;i < n;i ++) if (a[i] % 2) {
            a[i] ++;
            c ++;
        }
    }
    printf("%d\n",c);
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int a,b,c;
    scanf("%d %d %d",&a,&b,&c);
    int k = a * b / gcd(a, b);
    printf("%d\n", k * c / gcd(k, c));
    return 0;
}
*/

/*
struct node
{
    int n;
    node *l;
    node *r;
};

node *crt(int n)
{
    node *p = (node*) malloc(sizeof(node));
    p -> n = n;
    p -> l = NULL;
    p -> r = NULL;
    return p;
}

void add(int n, node **root)
{
    if (*root == NULL)
    {
        *root = crt(n);
        return;
    }
    if (n < (*root) -> n) add(n, &((*root) -> l));
    else add(n, &((*root) -> r));
}

struct ps {
    int dps;
    int length;
    int type;
};

void pbl(node *root, int d, int lr, vector<ps> dps)
{
    if (root == NULL) return;
    
    ps p = {d, (int) log10(root -> n) + 1, root -> r != NULL && lr == 0};
    if (dps.size() <= d) dps.push_back(p);
    else dps[d] = p;
    pbl(root -> r,d + 1, 1, dps);
    for (vector<ps>::iterator i = dps.begin();i != dps.end() - 1;i ++)
    {
        if (i -> type && i -> dps != 0) printf("|");
        else printf(".");
        for (int j = 0;j < i -> length + ((i -> dps) != 0) * 2;j ++)
        {
            printf(".");
        }
        
    }
    if (d != 0) printf("|-");
    printf("%d",root -> n);
    if (root -> l != NULL || root -> r != NULL) printf("-|");
    printf("\n");
    dps[d].type = root -> l != NULL && lr;
    pbl(root -> l,d + 1, 0, dps);
}

int main()
{
    int a;
    node *root = NULL;
    while (~scanf("%d",&a))
    {
        add(a, &root);
    }
    vector<ps> dps;
    pbl(root, 0, 1, dps);
    return 0;
}
*/


/*
int main()
{
    int n;
    scanf("%d",&n);
    if (n % 2)
    {
        set<int> k;
        int p;
        for (int i = 1;i <= 9;i += 2)
        {
            p = n;
            p -= i;
            p /= 2;
            if (p >= 1 && p <= 18)
            {
                for (int j = 1;j <= p;j ++)
                {
                    if (j >= 10 || p - j >= 10) continue;
                    k.insert(j * 10000 + (p - j) * 1000 + i * 100 + (p - j) * 10 + j);
                }
            }
        }
        if (k.size() == 0) printf("-1\n");
        else for (set<int>::iterator i = k.begin();i != k.end();i ++)
        {
            printf("%d\n",*i);
        }
    } else {
        set<int> k;
        int p;
        for (int i = 0;i <= 8;i += 2)
        {
            p = n;
            p -= i;
            p /= 2;
            if (p >= 1 && p <= 18)
            {
                for (int j = 1;j <= p;j ++)
                {
                    if (j >= 10 || p - j >= 10) continue;
                    k.insert(j * 10000 + (p - j) * 1000 + i * 100 + (p - j) * 10 + j);
                }
            }
        }
        p = n / 2;
        for (int i = 1;i < 10;i ++)
        {
            for (int j = 0;j < 10;j ++)
            {
                for (int l = 0;l < 10;l ++)
                {
                    if (p == i + j + l) k.insert(i * 100000 + j * 10000 + l * 1000 + l * 100 + j * 10 + i);
                }
            }
        }
        
        
        
        if (k.size() == 0) printf("-1\n");
        else for (set<int>::iterator i = k.begin();i != k.end();i ++)
        {
            printf("%d\n",*i);
        }
    }
    return 0;
}
*/

/*
int x,y;

void turn(int *d, int r)
{
    *d += r;
    if (*d < 0) *d = 3;
    if (*d > 3) *d = 0;
}

void move(int d)
{
    if (d == 0) x --;
    else if (d == 1) y ++;
    else if (d == 2) x ++;
    else if (d == 3) y --;
}

int main()
{
    int m,n;
    scanf("%d %d",&m,&n);
    char a[110][110];
    for (int i = 0;i < m;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf("%hhd",&a[i][j]);
        }
    }
    int k;
    char s;
    scanf("%d %d %c %d",&x,&y,&s,&k);
    int d = 0;
    switch (s) {
        case 'U':
            d = 0;
            break;
        case 'D':
            d = 2;
            break;
        case 'L':
            d = 3;
            break;
        case 'R':
            d = 1;
            break;
        default:
            break;
    }
    for (int v = 0;v < k;v ++)
    {
        if (a[x][y]) turn(&d, 1);
        else turn(&d, -1);
        a[x][y] = !a[x][y];
        move(d);
    }
    printf("%d %d\n",x,y);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[50010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    int miin = 100000,maax = -1;
    int sum = 0;
    int c = 0;
    for (int j = 0;j < n;j ++)
    {
        miin = 100000;
        maax = -1;
        sum = 0;
        for (int i = j;i < n;i ++)
        {
            sum += a[i];
            if (a[i] <= miin) miin = a[i];
            if (a[i] >= maax) maax = a[i];
            if ((miin + maax) * (maax - miin + 1) / 2 == sum) c ++;
        }
    }
    printf("%d\n",c);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    vector<pair<int,int> > a;
    int t;
    pair<int,int> f;
    for (int i = 0;i < n;i ++) {
        scanf("%d", &t);
        a.push_back(make_pair(abs(t), t / abs(t)));
    }
    f = a[0];
    sort(a.begin(),a.end());
    vector<pair<int, int> >::iterator p = lower_bound(a.begin(), a.end(), f);
    //cout << p -> first << " " << p -> second << endl;
    if (p -> second == 1) {
        int c = 1;
        for (vector<pair<int,int> >::iterator i = p + 1;i != a.end();i ++)
        {
            if (i -> second == -1) c ++;
        }
        if (c == 1) goto end;
        for (vector<pair<int,int> >::iterator i = a.begin();i != p;i ++)
        {
            if (i -> second == 1) c ++;
        }
        end:
        printf("%d\n",c);
    } else {
        int c = 1;
        for (vector<pair<int,int> >::iterator i = a.begin();i != p;i ++)
        {
            if (i -> second == 1) c ++;
        }
        if (c == 1) goto endd;
        for (vector<pair<int,int> >::iterator i = p + 1;i != a.end();i ++)
        {
            if (i -> second == -1) c ++;
        }
        endd:
        printf("%d\n",c);
    }
    return 0;
}
*/

/*
int main()
{
    int a,b;
    scanf("%d %d",&a,&b);
    printf("%d\n",a * b - a - b);
    return 0;
}
*/

/*
int main()
{
    int n,k,T;
    scanf("%d %d %d",&n,&k,&T);
    int m = 1;
    int a[1000010];
    for (int i = 1;i <= k;i ++)
    {
        a[i - 1] = m;
        m = (m + i) % k;
    }
    ll c = 0;
    int i = 0;
    int v = 0;
    c += a[i];
    for (int x = 1;x < T;x ++)
    {
        i = (i + n) % (k * 2);
        v = i;
        if (v >= k) v = 2 * k - v - 1;
        c += a[v];
    }
    printf("%lld\n",c);
    return 0;
}
*/


//int main()
//{
//    int n,m;
//    scanf("%d %d",&n,&m);
//    int a[510][510];
//    for (int i = 0;i < n;i ++)
//    {
//        for (int j = 0;j < m;j ++)
//        {
//            scanf("%d",&a[i][j]);
//        }
//    }
//    int dp[510][510] = {0};
//    for (int i = 0;i < n;i ++)
//    {
//
//        for (int j = 0;j < m;j ++)
//        {
//
//        }
//    }
//    return 0;
//}

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100];
    fir (int i = 0;i < n;i ++) scanf("%d",a + i);
    int last = a[0];
    int m = last;
    fro (int i = 1;i < n;i ++)
    {
        last = max(last, 0) + a[i];
        m = max(m, last);
    }
    cout << m << endl;
    return 0;
}
*/

/*
int ok(int n)
{
    int t;
    while (n != 0)
    {
        t = n % 10;
        if (t == 2 || t == 0 || t == 1 || t == 9) return 1;
        n /= 10;
    }
    return 0;
}

int main()
{
    ll k = 0;
    for (int i = 1;i <= 2019;i ++)
    {
        if (ok(i))
        {
            k += i * i;
        }
    }
    printf("%lld",k);
    return 0;
}
*/

/*
int main()
{
    int a = 1,
    b = 1,
    c = 1;
    int n;
    scanf("%d",&n);
    int t;
    for (int i = 3;i < n;i ++)
    {
        t = c;
        c = (a + b + c) % 10000;
        a = b;
        b = t;
    }
    cout << c << ednl;
    return 0;
}
*/

/*
int com(string a, string b)
{
    if (a.size() == b.size()) return a < b;
    return a.size() < b.size();
}

vector<string> bu;
vector<string> a;
int v[100][100];

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};
char dd[] = {'L','D','R','U'};

int n,m;
pair<int, int> ed;

void dfs(int x, int y, string k,int d)
{
    if (x == ed.second && y == ed.first) bu.push_back(k);
    int xx,yy;
    for (int i = 0;i < 4;i ++)
    {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < m && yy >= 0 && yy < n)
        {
            if (a[yy][xx] == '0' && (v[yy][xx] >= d || v[yy][xx] == -1))
            {
                v[yy][xx] = d;
                string kk = k;
                kk += dd[i];
                dfs(xx,yy,kk,d + 1);
            }
        }
    }
}

int main()
{
    freopen("in.txt", "r", stdin);
    mem(v,-1);
    char line[60];
    while (~scanf("%s", line)) a.push_back(line);
    n = (int) a.size();
    m = (int) a[0].size();
    ed.first = (int) a.size() - 1;
    ed.second = (int) a[a.size() - 1].size() - 1;
    cout << ed.first << " " << ed.second << endl;
    string k;
    dfs(0,0,k,0);
    sort(bu.begin(),bu.end(),com);
    cout << *bu.begin() << endl;
    return 0;
}
*/

/*
int com(pair<ll, int> a, pair<ll, int> b)
{
    if (a.first == b.first) return a.second < b.second;
    else return a.first > b.first;
}

int main()
{
    int a[100010];
    int n;
    scanf("%d",&n);
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    vector<pair<ll, int> > dps;
    int last = 0;
    int d = 1;
    ll sum = 0;
    for (int i = 0;i < n;i ++)
    {
        sum += a[i];
        if (i == 0 || i - last == pow(2,d - 1) || i == n - 1)
        {
            dps.push_back(make_pair(sum, d));
            last = i;
            d ++;
            sum = 0;
        }
    }
    
    sort(dps.begin(),dps.end(),com);
    printf("%d\n",dps.begin() -> second);
    return 0;
}
*/

/*int main()
{
    freopen("in.txt", "r", stdin);
    FILE *f = fopen("aaa.xls", "w");
    int k;
    while (~scanf("%d",&k))
    {
        fprintf(f, "%d",k);
        for (int i = 0;i < 5;i ++)
        {
            scanf("%d",&k);
            fprintf(f, "\t%d",k);
        }
        fprintf(f, "\n");
    }
    return 0;
}
*/

/*int main()
{
    itn n = 2019;
    //scanf("%d",&n);
    string str = "A";
    for (int i = 1;i < n;i ++)
    {
        str[0] ++;
        for (int j = 0;str[j] != 0 && !(str[j] >= 'A' && str[j] <= 'Z');j ++)
        {
            
                if (str[j + 1] != 0)
                {
                    str[j + 1] ++;
                } else str += 'A';
                str[j] = 'A';
            
        }
    }
    reverse(str.begin(), str.end());
    cout << str << endl;
    return 0;
}
*/

/*
int ok(int n)
{
    int t;
    while (n != 0)
    {
        t = n % 10;
        if (t == 2 || t == 4) return 0;
        n /= 10;
    }
    return 1;
}

int main()
{
    set<set<int> > k;
    for (int i = 1;i <= 2019;i ++)
    {
        for (int j = 1;j <= 2019;j ++)
        {
            int v = 2019 - i - j;
            if (v >= 1 && ok(i) && ok(j) && ok(v) && i + j + v == 2019)
            {
                set<int> m;
                m.insert(i);
                m.insert(j);
                m.insert(v);
                if (m.size() == 3) k.insert(m);
            }
            
        }
    }
    cout << k.size() << endl;
    return 0;
}
*/

/*
int ok(int n)
{
    int t;
    while (n != 0)
    {
        t = n % 10;
        if (t == 2 || t == 0 || t == 1 || t == 9) return 1;
        n /= 10;
    }
    return 0;
}

int main()
{
    ll k = 0;
    int n = 2019;
    //scanf("%d",&n);
    for (int i = 1;i <= n;i ++)
    {
        if (ok(i))
        {
            k += i;
        }
    }
    printf("%lld\n",k);
    return 0;
}
*/

/*
int main()
{
    int n = 2019,m = 324;
    //scanf("%d %d",&n,&m);
    int t, c = 0;
    while (m != n)
    {
        t = m;
        m = max(m,n);
        n = min(t,n);
        m -= n;
        c ++;
    }
    printf("%d\n",c + 1);
    return 0;
}
*/

/*
int jd(ll n)
{
    if (n == 1) return 0;
    for (ll i = 2;i <= sqrt(n);i ++)
    {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main()
{
    int n = 2019;
    //scanf("%d",&n);
    int last = 0;
    for (int i = 0, j = 1;i < n;j ++)
    {
        if (jd(j))
        {
            last = j;
            i ++;
        }
    }
    printf("%d\n",last);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[110][110];
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < m;j ++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    for (int j = 0;j < m;j ++)
    {
        for (int i = n - 1;i >= 0;i --)
        {
            if (i != n - 1) printf(" ");
            printf("%d",a[i][j]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int ok(ll n)
{
    int t;
    while (n != 0)
    {
        t = n % 10;
        if (t == 2 || t == 0 || t == 1 || t == 9) return 1;
        n /= 10;
    }
    return 0;
}

int main()
{
    ll k = 0;
    ll n = 2019;
    //scanf("%lld",&n);
    for (ll i = 1;i <= n;i ++)
    {
        if (ok(i))
        {
            k += i * i * i;
        }
    }
    printf("%lld\n",k);
    return 0;
}
*/

/*
int main()
{
    string str = "LANQIAO";
    //cin >> str;
    reverse(str.begin(),str.end());
    ll c = 0;
    for (int i = 0;str[i] != 0;i ++)
    {
        c += (str[i] - 'A' + 1) * pow(26, i);
    }
    cout << c << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    if (n >= 100) {printf("0.61803399\n"); return 0;}
    double a = 1,b = 1;
    double c;
    for (int i = 2;i <= n;i ++)
    {
        c = a + b;
        a = b;
        b = c;
    }
    //0.61803399
    printf("%.8lf\n", a / b);
    return 0;
}
*/


/*
int main()
{
    set<string> all;
    string str = "0100110001010001";
    for (int i = 0;i < str.size();i ++)
    {
        for (int j = i;j < str.size();j ++)
        {
            all.insert(str.substr(i,j - i + 1));
        }
    }
    printf("%lu\n",all.size());
    return 0;
}
*/

/*
int main()
{
    int c = 0;
    int a[] = {1,2,3,4,5,6,8,9,10,12};
    do {
        int t = a[0] + a[1] + a[2] + a[3];
        if (t == a[0] + a[5] + a[7] + a[9] &&
            t == a[4] + a[1] + a[5] + a[8] &&
            t == a[4] + a[2] + a[6] + a[9] &&
            t == a[3] + a[6] + a[7] + a[8]) c ++;
    } while (next_permutation(a, a + 10));
    printf("%d\n", c / (5 * 2));
    return 0;
}
*/

/*
int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    vector<int> a;
    int k = 1;
    for (int i = 0;i < 1000;k ++)
    {
        if (isZhi(k)) {a.push_back(k); i ++;}
    }
    // for (auto i = a.begin();i != a.end();i ++) cout << *i << endl;
    int v = 10;
    set<int> all;
    int d;
    for (int k = 0;k < 1000;k ++)
    {
        for (d = 1;d < 1000;d ++)
        {
            int last = a[k];
            all.clear();
            all.insert(last);
            for (int i = k + 1;i < 1000;i ++)
            {
                if (a[i] - last == d)
                {
                    last = a[i];
                    all.insert(last);
                    if (all.size() == v) goto end;
                } else if (a[i] - last > d)
                {
                    break;
                }
            }
        }
        end:
        if (all.size() == v){
            //for (auto i = all.begin();i != all.end();i ++) cout << *i << " ";
            printf("%d\n",d);
            break;
        }
    }
    return 0;
}
*/

/*
int main()
{
    fre("[蓝桥杯2017初赛]承压计算.txt");
    char a[5000];
    double b[5000] = {0};
    int k = 0;
    queue<pair<double,int> > q;
    for (int i = 0;i < 30;i ++)
    {
        for (int j = 0;j < i + 1;j ++)
        {
            scanf(" ");
            scanf("%c",&a[k]);
            if (a[k] >= '0' && a[k] <= '9')
            {
                b[k] += (a[k] - '0');
            }
            if (!q.empty())
            {
                b[k] += q.front().first / 2;
                q.front().second ++;
                
                if (q.front().second == 2)
                {
                    q.pop();
                    if (j != i) {
                        b[k] += q.front().first / 2;
                        q.front().second ++;
                    }
                }
            }
            if (a[k] >= '0' && a[k] <= '9') q.push(make_pair(b[k], 0));
            k ++;
        }
    }
    
    
    set<double> l;
//    int last = 0;
//    int v = 2;
//    for (int i = 0;i < k;i ++)
//    {
//        printf("%4.32lf ",b[i]);
//        if (i == 0) {
//            printf("\n");
//        }
//        if (i - last == v) {
//            printf("\n");
//            v ++;
//            last = i;
//        }
//    }
    
    for (int i = 0;i < 30;i ++)
    {
        l.insert(b[-- k]);
    }
    printf("%.0lf\n", 2086458231 / *l.begin() * *(-- l.end()));
    //72665192664
    
    return 0;
}
*/

/*
int main()
{
    int a[] = {1,2,3,4,5,6,7,8,9};
    int c = 0;
    set<int> k;
    do {
        k.clear();
        k.insert(a[0] + a[1] + a[2]);
        k.insert(a[3] + a[4] + a[5]);
        k.insert(a[6] + a[7] + a[8]);
        k.insert(a[0] + a[3] + a[6]);
        k.insert(a[1] + a[4] + a[7]);
        k.insert(a[2] + a[5] + a[8]);
        k.insert(a[0] + a[4] + a[8]);
        k.insert(a[2] + a[4] + a[6]);
        if (k.size() == 8) c ++;
    } while (next_permutation(a, a + 9));
    cout << c / 8 << endl;
    // 3120
    return 0;
}
*/

/*
int main()
{
    int a[] = {1,2,3,4,5,7,8,9,10,12,13};
    int t;
    do {
        t = a[0] + a[1] + a[2] + a[3];
        if (t == a[0] + a[10] + a[9] + a[8] &&
            t == 14 + a[10] + a[1] + 6 &&
            t == 14 + a[9] + a[7] + a[6] &&
            t == a[8] + a[7] + a[5] + 11 &&
            t == a[6] + a[5] + a[4] + a[3] &&
            t == a[2] + a[4] + 6 + 11)
        {
            printf("%d %d %d %d",a[0],a[1],a[2],a[3]);
        }
    } while (next_permutation(a, a + 11));
    return 0;
}
*/

/*
//set<ll> all;

//void dfs(ll m, ll n)
//{
//    if (m > n)
//    {
//        return;
//    }
//    if (all.find(m) != all.end()) return;
//    all.insert(m);
//    dfs(m * 3, n);
//    dfs(m * 5, n);
//    dfs(m * 7, n);
//}

int main()
{
    //dfs(1,59084709587505);
    //cout << all.size() - 1 << endl;
    printf("1905");
    return 0;
}
*/

/*
int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int n;
    scanf("%d",&n);
    int k[2000];
    int v = 0;
    for (int i = 1;i < 10000;i ++) if (isZhi(i)) k[v ++] = i;
    //for (int i = 0;i < v;i ++) cout << k[i] << " ";
    int mx = -1;
    int t;
    for (int m = 4;m <= n;m += 2)
    {
        for (int i = 0;i < v;i ++)
        {
            t = m - k[i];
            if (isZhi(t))
            {
                if (k[i] >= mx) mx = k[i];
                break;
            }
        }
    }
    cout << mx << endl;
    // 10000 -> 173
    return 0;
}
*/

/*
set<ll> ping;

int isPing(ll n)
{
    return ping.find(n) != ping.end();
}

ll to_num(int *a, int n)
{
    ll k = 0;
    for (int i = 0;i < n;i ++) k = k * 10 + a[i];
    return k;
}

set<set<ll> > all;

void dfs(int *a, int n, set<ll> k)
{
    ll num = 0;
    if (n == 0)
    {
        all.insert(k);
        return;
    }
    for (int i = 0;i < n;i ++)
    {
        num = num * 10 + a[i];
        if (isPing(num)) {
            k.insert(num);
            dfs(a + i + 1,n - i - 1,k);
            k.erase(k.find(num));
        }
        if (a[0] == 0) return;
    }
}

int main()
{
    for (ll i = 0;i < 100000;i ++)
    {
        ping.insert(i * i);
    }
    int a[] = {0,1,2,3,4,5,6,7,8,9};
    do {
        set<ll> k;
        dfs(a, 10, k);
    } while (next_permutation(a, a + 10));
    cout << all.size() << endl;
    // 300
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    while (n --)
    {
        int k;
        scanf("%d",&k);
        int a_s = 0,b_s = 0;
        int a,b;
        while (k --)
        {
            scanf("%d %d",&a,&b);
            a_s += a;
            b_s += b;
        }
        if (a_s > b_s) printf("Alice\n");
        else if (a_s < b_s) printf("Bob\n");
        else printf("All\n");
    }
    return 0;
}
*/

/*
int main()
{
    int k;
    scanf("%d",&k);
    while (k --)
    {
        int n;
        scanf("%d",&n);
        int a[110];
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        int last = a[0];
        int f = a[0];
        for (int i = 1;i < n;i ++)
        {
            last = max(a[i],last + a[i]);
            f = max(f,last);
        }
        if (f < 0) printf("0\n");
        else printf("%d\n",f);
    }
    return 0;
}
*/

//int main()
//{
//    int n,m;
//    scanf("%d %d",&n,&m);
//    int a[5010];
//    map<int,set<int> > b;
//
//    for (int i = 0;i < n;i ++) {
//        scanf("%d",a + i);
//        b[a[i]].insert(i);
//    }
//    int c = 0,k;
//    for (int i = 0;i < n - 2;i ++)
//    {
//        for (int j = i + 1;j < n - 1;j ++)
//        {
//            k = m - a[i] - a[j];
//            set<int> l = b[k];
//            int dis = (int) distance(l.upper_bound(j), l.end());
//            c += dis;
//        }
//    }
//    printf("%d\n",c);
//    return 0;
//}


///////////并查集 - 连通图
/*
int main()
{
    int v,e;
    scanf("%d %d",&v,&e);
    int g[100010] = {0};
    vector<set<int> > k(v + 1);
    for (int i = 1;i <= v;i ++) {
        g[i] = i;
        k[i].insert(i);
    }
    int a,b;
    for (int i = 0;i < e;i ++)
    {
        scanf("%d %d",&a,&b);
        //cout << g[a] << ", " << g[b] << endl;
        if (g[a] != g[b])
        {
            set<int> *m = &k[g[b]],
            *n = &k[g[a]];
            
            if (m -> size() <= n -> size())
            {
                for (set<int>::iterator j = m -> begin();j != m -> end();)
                {
                    g[*j] = g[a];
                    n -> insert(*j);
                    m -> erase(j ++);
                }
            } else {
                for (set<int>::iterator j = n -> begin();j != n -> end();)
                {
                    g[*j] = g[b];
                    m -> insert(*j);
                    n -> erase(j ++);
                }
            }
        }
        for (int i = 1;i <= v;i ++) printf("%d ",g[i]);
        cout << endl;
        for (int i = 1;i <= v;i ++)
        {
            printf("%d:",i);
            for (auto j = k[i].begin();j != k[i].end();j ++)
            {
                printf("%d ",*j);
            }
            printf("\n");
        }
    }
    vector<pair<int,int> > p;
    int last = -1;
    for (int i = 1;i <= v;i ++)
    {
        if (k[i].size()) {
            if (last != -1) p.push_back(make_pair(last, *k[i].begin()));
            last = *k[i].begin();
        }
    }
    printf("%lu\n", p.size());
    for (vector<pair<int, int> >::iterator i = p.begin();i != p.end();i ++)
    {
        printf("%d %d\n",i -> first, i -> second);
    }
    return 0;
}
*/

/*
int main()
{
    int p;
    scanf("%d",&p);
    while (p --)
    {
        int n,t;
        int a[1010];
        int maax = -1;
        scanf("%d %d",&n,&t);
        for (int i = 0;i < n;i ++) {
            scanf("%d",a + i);
            if (a[i] >= maax) maax = a[i];
        }
        int s = 0;
        int lt = 1, rt = maax;
        
        //for (double i = miin;i <= maax;i ++)
        int m = 0;
        while (lt <= rt)
        {
            //cout << lt << ", " << rt << endl;
            m = (lt + rt) / 2;
            s = 0;
            for (int j = 0;j < n;j ++) s += ceil(a[j] / (double) m);
            if (s > t)
            {
                lt = m + 1;
            } else {
                rt = m - 1;
            }
        }
        //cout << lt << ", " << rt << endl;
        printf("%d\n",lt);
    }

    return 0;
}
*/

/*
int com(pair<int,int> a, pair<int, int> b)
{
    if (a.first == b.first) return a.second > b.second;
    return a.first < b.first;
}
 
int com2(pair<int,int> a, pair<int, int> b)
{
    return a.first < b.first;
}
 
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[5010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    vector<pair<int, int> > k;
    for (int i = 0;i < n - 2;i ++)
    {
        for (int j = i + 1;j < n - 1;j ++)
        {
            k.push_back(make_pair(a[i] + a[j],j + 1));
        }
    }
    sort(k.begin(),k.end(),com);
     
    int c = 0;
    for (int i = 2;i < n;i ++)
    {
        pair<int, int> nm = make_pair(m - a[i],i);
        c += upper_bound(k.begin(), k.end(), nm, com2) - lower_bound(k.begin(), k.end(), nm, com);
    }
    printf("%d\n", c);
     
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[5010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    ll ans = 0;
    for (int j = 1;j < n - 1;j ++)
    {
        int k[10010] = {0};
        for (int l = j + 1;l < n;l ++) k[a[l] + 4010] ++;
        for (int i = 0;i < j;i ++)
        {
            
            ans += k[m - a[i] - a[j] + 4010];
        }
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
char a[105][105];
int q[105][105] = {0};

int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

int xa = 0, ya = 0;
int xb = 0, yb = 0;

int s = -1;
int n;

int getSign(int x, int y)
{
    if (a[y][x] == '+') return 1;
    else if (a[y][x] == '-') return -1;
    else return 0;
}

void dfs(int x, int y, int sign, int step)
{
//    for (int i = 0; i< n;i ++)
//    {
//        for (int j = 0;j < n;j ++)
//        {
//            printf("%2d",q[i][j]);
//        }
//        cout << endl;
//    }
//    cout << endl;
    
    if (x == xb && y == yb)
    {
        if (s == -1) s = step;
        else s = min(s, step);
        return;
    }
    int xx,yy,k;
    q[y][x] = step;
    for (int i = 0;i < 4;i ++)
    {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < n && yy >= 0 && yy < n && (q[yy][xx] >= step || q[yy][xx] == -1))
        {
            
            k = getSign(xx, yy) * sign;
            if (k == 0 || k == -1)
            {
                dfs(xx, yy, getSign(xx, yy), step + 1);
            }
        }
    }
    
}

int main()
{
    mem(q,-1);
    scanf("%d",&n);
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf(" %c",&a[i][j]);
            if (a[i][j] == 'A') {xa = j; ya = i;}
            else if (a[i][j] == 'B') {xb = j; yb = i;}
        }
    }
    dfs(xa,ya,0,0);
    printf("%d\n",s);
    return 0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

ll lcm(ll a, ll b)
{
    return a * b / gcd(a, b);
}

int main()
{
    int T;
    scanf("%d",&T);
    ll A = 0, B = 1,a,b;
    ll k;
    while (T --)
    {
        scanf("%lld/%lld",&a,&b);
        k = lcm(B, b);
        A *= k / B;
        A += a * k / b;
        B = k;
    }
    k = gcd(A,B);
    A /= k;
    B /= k;
    ll z = A / B;
    A -= B * z;
    if ((A < 0 && B < 0) || (A > 0 && B < 0))  {B = -B; A = -A;}
    if (A == 0) printf("%lld\n",z);
    else if (z != 0) printf("%lld %lld/%lld\n",z,A,B);
    else printf("%lld/%lld\n",A,B);
    return 0;
}
*/

/*
int main()
{
    string a,b;
    getline(cin,a);
    getline(cin,b);
    set<char> c;
    for (int i = 0;b[i] != 0;i ++)
    {
        c.insert(b[i]);
    }
    for (string::iterator i = a.begin();i != a.end();)
    {
        if (c.find(*i) != c.end())
        {
            a.erase(i);
        } else i ++;
    }
    cout << a << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll sum = 0,k = 0;
    for (int i = 1;i <= n;i ++)
    {
        k = 1;
        for (ll j = 1;j <= i;j ++)
        {
            k *= j;
        }
        sum += k;
    }
    printf("%lld\n",sum);
    
    return 0;
}
*/

/*
int main()
{
    int n;
    char c;
    scanf("%d %c",&n,&c);
    int h = n / 2.0 + 0.5;
    for (int i = 0;i < h;i ++)
    {
        for (int j = 0;j < n;j ++) printf("%c",c);
        printf("\n");
    }
    return 0;
}
*/

/*
int p[] = {0,1,2,3,7,11,4,9,14,5,6,8,10,12,13};
int c = 0;

void dfs(int n, vector<int> all, vector<int> list)
{
    if (n >= 3)
    {
        if (all[0] + all[1] + all[2] != 33) return;
        if (n >= 6) {
            if (all[3] + all[7] + all[11] != 33) return;
            if (n >= 9)
            {
                if (all[4] + all[9] + all[14] != 33) return;
                if (n >= 11)
                {
                    if (all[3] + all[4] + all[5] + all[6] != 34) return;
                    if (n >= 13)
                    {
                        if (all[7] + all[8] + all[9] + all[10] != 34) return;
                        if (n == 15)
                        {
                            if (all[11] + all[12] + all[13] + all[14] == 34 &&
                                all[0] + all[4] + all[8] + all[12] == 34 &&
                                all[1] + all[5] + all[9] + all[13] == 34 &&
                                all[2] + all[6] + all[10] + all[14] == 34 &&
                                all[2] + all[5] + all[8] + all[11] == 34)
                            {
//                                printf("1 ");
//                                for (int i = 0;i < 15;i ++)
//                                {
//                                    printf("%d ", all[i]);
//                                    if ((i + 2) % 4 == 0) printf("\n");
//                                }
//                                printf("\n");
                                c ++;
                            } else return;
                        }
                    }
                }
            }
        }
    }
    int s = (int) list.size();
    for (int i = 0;i < s;i ++)
    {
        vector<int> next(list);
        all[p[n]] = list[i];
        next.erase(next.begin() + i);
        dfs(n + 1, all, next);
    }

}

int main()
{
    vector<int> k(15);
    vector<int> lt;
    for (int i = 2;i <= 16;i ++)
    {
        lt.push_back(i);
    }
    dfs(0,k,lt);
    printf("%d\n",c);
    // 416
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    for (int t = 1;t <= T;t ++)
    {
        int n;
        scanf("%d",&n);
        int a['z' + 1] = {0};
        string str;
        cin >> str;
        for (int i = 0;str[i] != 0;i ++)
        {
            a[str[i]] ++;
        }
        int ok1 = 0, ok2 = 0;
        if (a['E'] && a['C'] && a['U'] && a['S'] && a['T']) ok1 = 1;
        if (a['e'] && a['c'] && a['u'] && a['s'] && a['t']) ok2 = 1;
        printf("Case %d: ",t);
        if (ok1 && ok2) printf("ECUST and ecust\n");
        else if (ok1) printf("ECUST\n");
        else if (ok2) printf("ecust\n");
        else {
            for (int k = 'A';k <= 'Z';k ++)
            {
                a[k + 32] += a[k];
            }
            if (a['e'] && a['c'] && a['u'] && a['s'] && a['t']) printf("Yes\n");
            else printf("No\n");
        }
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    for (int t = 1;t <= T;t ++)
    {
        string str;
        cin >> str;
        printf("Case %d: ",t);
        int s = 0;
        for (int i = 0;str[i] != 0;i ++)
        {
            s += str[i] - '0';
        }
        if (s % 3 == 0) printf("Yes\n");
        else printf("No\n");
    }
    reutrn 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    fro (int t = 1;t <= T;t ++)
    {
        ll n;
        scanf("%lld",&n);
        ll s = (1 + n) * n / 2;
        printf("Case %d: %lld\n",t,s);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    for (int t = 1;t <= T;t ++)
    {
        int a[6];
        for (int i = 0;i < 6;i ++) scanf("%d",a + i);
        string str;
        cin >> str;
        int tt = 0;
        for (int i = 0;str[i] != 0;i ++)
        {
            switch (str[i])
            {
                case 'B':
                    tt = a[0];
                    a[0] = a[4];
                    a[4] = a[1];
                    a[1] = a[5];
                    a[5] = tt;
                    break;
                case 'F':
                    tt = a[0];
                    a[0] = a[5];
                    a[5] = a[1];
                    a[1] = a[4];
                    a[4] = tt;
                    break;
                case 'L':
                    tt = a[2];
                    a[2] = a[0];
                    a[0] = a[3];
                    a[3] = a[1];
                    a[1] = tt;
                    break;
                case 'R':
                    tt = a[3];
                    a[3] = a[0];
                    a[0] = a[2];
                    a[2] = a[1];
                    a[1] = tt;
                    break;
            }
        }
        printf("Case %d: %d\n",t,a[0]);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    for (int t = 1;t <= T;t ++)
    {
        int n;
        scanf("%d",&n);
        string str;
        cin >> str;
        int a['z' + 1] = {0};
        for (int i = 0;str[i] != 0;i ++)
        {
            a[str[i]] ++;
        }
        ll m = -1,k;
        for (int i = 'a';i <= 'z';i ++)
        {
            k = 0;
            for (int j = 'a';j <= 'z';j ++)
            {
                k += abs(j - i) * a[j];
            }
            if (m == -1) m = k;
            else m = min(m,k);
        }
        printf("Case %d: %lld\n",t,m);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    fro (int t = 1;t <= T;t ++)
    {
        int n,a,b;
        scanf("%d %d %d",&n,&a,&b);
        double m = 0, k;
        int x = 0,y = 0,z = 0;
        int xx,yy,zz;
        while (n --)
        {
            scanf("%d %d %d",&xx,&yy,&zz);
            if (xx < 1 && yy < 1 && zz < 1) continue;
            if (yy % 2) continue;
            if (yy > 2 * xx + 2) continue;
            k = (xx * a + yy / 2.0 * b) / (xx * 12 + yy + zz * 16);
            if (k >= m) {
                m = k;
                x = xx;
                y = yy;
                z = zz;
            }
        }
        printf("Case %d: ",t);
        if (x != 0) {
            printf("C");
            if (x != 1) printf("%d",x);
        }
        if (y != 0) {
            printf("H");
            if (y != 1) printf("%d",y);
        }
        if (z != 0) {
            printf("O");
            if (z != 1) printf("%d",z);
        }
        printf("\n");
    }
    return 0;
}
*/

//////图暴力bfs
/*
struct nd {
    int tgt;
    ll w;
    nd *next;
};

struct pr {
    int to;
    ll w;
    int from;
};

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    nd *g[100010] = {NULL};
    int a,b,c;
    nd *p;
    for (int i = 0;i < n - 1;i ++)
    {
        scanf("%d %d %d",&a,&b,&c);
        p = (nd*) malloc(sizeof(nd));
        p -> next = g[a];
        p -> w = c;
        p -> tgt = b;
        g[a] = p;
        
        p = (nd*) malloc(sizeof(nd));
        p -> next = g[b];
        p -> w = c;
        p -> tgt = a;
        g[b] = p;
    }
    nd *root;
    pr r,d;
    for (int i = 0;i < m;i ++)
    {
        queue<pr> k;
        scanf("%d %d",&a,&b);
        if (a == b) {printf("0\n");continue;}
        r.to = a;
        r.from = 0;
        r.w = 0;
        k.push(r);
        while (!k.empty())
        {
            d = k.front();
            root = g[d.to];
            while (root != NULL)
            {
                if (root -> tgt != d.from)
                {
                    r.to = root -> tgt;
                    r.w = d.w + root -> w;
                    r.from = d.to;
                    k.push(r);
                    if (k.back().to == b) goto kkk;
                }
                root = root -> next;
            }
            k.pop();
        }
        kkk:
        printf("%lld\n",k.back().w);
    }
    return 0;
}
*/


/*
int isZhi(ll n)
{
    if (n == 1) return 0;
    for (ll i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int T;
    scanf("%d",&T);
    ll n,p;
    for (int t = 1;t <= T;t ++)
    {
        scanf("%lld",&n);
        p = sqrt(n);
        for (ll i = p;i < n;i ++)
        {
            if (isZhi(i))
            {
                printf("Case %d: %lld\n",t,n / i + i);
                break;
            }
        }
    }
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

struct Pr {
    int a;
    int b;
    int k;
};

int main()
{
    int T;
    scanf("%d",&T);
    int a[1010], n, v, p = 0;
    Pr g[500010];
    for (int t = 1;t <= T;t ++)
    {
        p = 0;
        int k[1010] = {0};
        scanf("%d",&n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        for (int i = 0;i < n - 1;i ++)
        {
            for (int j = i + 1;j < n;j ++)
            {
                v = gcd(a[i],a[j]);
                k[i] = max(k[i], v);
                k[j] = max(k[j], v);
                g[p].a = i;
                g[p].b = j;
                g[p ++].k = v;
            }
        }
        ll c = 0;
        for (int i = 0;i < p;i ++)
        {
            if (g[i].k >= k[g[i].a] && g[i].k >= k[g[i].b])
            {
                c ++;
            }
        }
        printf("Case %d: %lld\n",t,c);
    }
    return 0;
}
*/


/*
int main()
{
    int T;
    scanf("%d",&T);
    string str;
    int k[] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    int sum,v;
    char a[] = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};
    int ok = 1;
    while (T --)
    {
        cin >> str;
        sum = 0;
        for (int i = 0;i < 17;i ++)
        {
            sum += (str[i] - '0') * k[i];
        }
        v = sum % 11;
        if (a[v] != str[17]) {
            cout << str << endl;
            ok = 0;
        }
    }
    if (ok) printf("All passed\n");
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    set<int> a[55];
    int m,t;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&m);
        while (m --)
        {
            scanf("%d",&t);
            a[i].insert(t);
        }
    }
    scanf("%d",&m);
    int u,v;
    while (m --)
    {
        scanf("%d %d",&u,&v);
        set<int> aa = a[u - 1],bb = a[v - 1];
        double s = 0;
        if (aa.size() <= bb.size())
        {
            for (set<int>::iterator i = aa.begin();i != aa.end();i ++)
            {
                if (bb.find(*i) != bb.end()) s ++;
            }
        } else {
            for (set<int>::iterator i = bb.begin();i != bb.end();i ++)
            {
                if (aa.find(*i) != aa.end()) s ++;
            }
        }
        double k = s / (aa.size() - s + bb.size()) * 100;
        printf("%.2lf%%\n",k);
    }
    return 0;
}
*/

/*
#define debug

struct Node {
    int n;
    Node *left;
    Node *right;
};

#ifdef debug
struct ps {
    int dps;
    int length;
    int type;
};

void pbl(Node *root, int d, int lr, vector<ps> dps)
{
    if (root == NULL) return;
    
    ps p = {d, (int) log10(root -> n) + 1, root -> right != NULL && lr == 0};
    if (dps.size() <= d) dps.push_back(p);
    else dps[d] = p;
    pbl(root -> right,d + 1, 1, dps);
    for (vector<ps>::iterator i = dps.begin();i != dps.end() - 1;i ++)
    {
        if (i -> type && i -> dps != 0) printf("|");
        else printf(".");
        for (int j = 0;j < i -> length + ((i -> dps) != 0) * 2;j ++)
        {
            printf(".");
        }
        
    }
    if (d != 0) printf("|-");
    printf("%d",root -> n);
    if (root -> left != NULL || root -> right != NULL) printf("-|");
    printf("\n");
    dps[d].type = root -> left != NULL && lr;
    pbl(root -> left,d + 1, 0, dps);
}
#endif

void add(int *a, int *b, int n, Node *nd)
{
    int k = b[n - 1];
    nd -> n = k;
    int p = -1;
    if (a[n - 1] == k) p = n - 1;
    else if (a[0] == k) p = 0;
    else if (a[n / 2] == k) p = n / 2;
    if (p == -1)
    {
        for (int i = 0;i < n;i ++) if (a[i] == k) p = i;
    }
    if (p > 0) {
        Node *lt = (Node*) malloc(sizeof(Node));
        nd -> left = lt;
        lt -> left = NULL;
        lt -> right = NULL;
        add(a,b,p,lt);
    }
    if (n - p > 1) {
        Node *rt = (Node*) malloc(sizeof(Node));
        nd -> right = rt;
        rt -> left = NULL;
        rt -> right = NULL;
        add(a + p + 1,b + p,n - p - 1,rt);
    }
}

void levelTraversal(Node *root)
{
    if (root == NULL) return; // 如果root是空的直接return掉
    queue<Node*> childs; // 创建节点队列
    childs.push(root); // 先把root节点加入套餐
    int f = 1;
    while (childs.size() != 0) // 队列空了就结束
    {
        Node *current = childs.front(); // 取出队列前端的节点
        if (f) f = 0;
        else printf(" ");
        printf("%d",current -> n); // 提取数据
        if (current -> left != NULL) childs.push(current -> left); // 如果不是空的，就加入套餐
        if (current -> right != NULL) childs.push(current -> right); // 同上
        if (current != root) free(current);
        childs.pop(); // 去掉队列前端的节点
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    int a[35],b[35];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    for (int i = 0;i < n;i ++) scanf("%d",b + i);
    Node node = {-1,NULL,NULL};
    add(b,a,n,&node);
#ifdef debug
    vector<ps> dps;
    pbl(&node, 0, 1, dps);
#endif
    levelTraversal(&node);
    printf("\n");
    return 0;
}
*/

/*int cmp(pair<double, int> a, pair<double, int> b)
{
    if (a.first == b.first) return a.second < b.second;
    return a.first > b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    int vis[10010];
    set<int> g[10010];
    int nh_ple[10010] = {0};
    int sh_ple[10010] = {0};
    mem(vis,-1);
    int id,k,n_house,s_house,m;
    int k_id[10];
    for (int t = 0;t < n;t ++)
    {
        scanf("%d %d %d %d", &id, k_id, k_id + 1, &k);
        for (int i = 0;i < k;i ++) scanf("%d", k_id + i + 2);
        scanf("%d %d", &n_house, &s_house);
        m = id;
        for (int i = 0;i < k + 2;i ++)
        {
            if (k_id[i] != -1) {
                if (m < 0) m = k_id[i];
                else m = min(m, k_id[i]);
            }
        }
        if (m == -1) continue;
        k_id[k + 2] = id;
        for (int i = 0;i < k + 3;i ++)
        {
            if (k_id[i] != -1)
            {
                if (vis[k_id[i]] == -1) vis[k_id[i]] = m;
                else {
                    int k = vis[k_id[i]];
                    if (k < m)
                    {
                        for (set<int>::iterator j = g[m].begin();j != g[m].end();)
                        {
                            vis[*j] = k;
                            g[k].insert(*j);
                            g[m].erase(j ++);
                        }
                        nh_ple[k] += nh_ple[m];
                        sh_ple[k] += sh_ple[m];
                        nh_ple[m] = 0;
                        sh_ple[m] = 0;
                        m = k;
                    } else if (k > m) {
                        for (set<int>::iterator j = g[k].begin();j != g[k].end();)
                        {
                            vis[k_id[i]] = m;
                            g[m].insert(*j);
                            g[k].erase(j ++);
                        }
                        nh_ple[m] += nh_ple[k];
                        sh_ple[m] += sh_ple[k];
                        nh_ple[k] = 0;
                        sh_ple[k] = 0;
                    }
                }
                g[m].insert(k_id[i]);
            }
        }
        nh_ple[m] += n_house;
        sh_ple[m] += s_house;
    }
    vector<pair<double,int> > arr;
    for (int i = 0;i < 10010;i ++)
    {
        if (nh_ple[i] != 0)
        {
            arr.push_back(make_pair(sh_ple[i] / (double) g[i].size(), i));
        }
    }
    sort(arr.begin(),arr.end(),cmp);
    printf("%lu\n",arr.size());
    for (vector<pair<double,int> >::iterator i = arr.begin();i != arr.end();i ++)
    {
        printf("%04d %lu %.3lf %.3lf\n",i -> second,g[i -> second].size(),nh_ple[i -> second] / (double) g[i -> second].size(),i -> first);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    getline(cin,str);
    int m = 0, v;
    for (int i = 0;str[i] != '\0';i ++)
    {
        v = 0;
        for (int j = i, k = 2 * i - j;str[j] != 0 && (k = 2 * i - j) >= 0;j ++)
        {
            if (str[j] == str[k]) v += 2;
            else break;
        }
        if (v - 1 > m) m = v - 1;
        v = 0;
        for (int j = i + 1, k = 2 * i - (j - 1);str[j] != 0 && (k = 2 * i - (j - 1)) >= 0;j ++)
        {
            if (str[j] == str[k]) v += 2;
            else break;
        }
        if (v > m) m = v;
    }
    printf("%d\n", m);
    return 0;
}
*/

/*
int a[65][130][1300];
int m,n,l,T;

int dx[] = {1,0,-1,0,0,0};
int dy[] = {0,-1,0,1,0,0};
int dz[] = {0,0,0,0,1,-1};

int v = 0;

struct pt {
    int x,y,z;
};

void bfs(int x, int y, int z)
{
    if (!a[z][y][x]) return;
    int xx,yy,zz;
    queue<pt> sk;
    pt p = {x,y,z};
    a[z][y][x] = 0;
    sk.push(p);
    while (!sk.empty())
    {
        x = sk.front().x;
        y = sk.front().y;
        z = sk.front().z;
        
        for (int i = 0;i < 6;i ++)
        {
            xx = x + dx[i];
            yy = y + dy[i];
            zz = z + dz[i];
            if (xx >= 0 && yy >= 0 && zz >= 0 && xx < m && yy < n && zz < l)
            {
                if (a[zz][yy][xx]) {
                    p.x = xx;
                    p.y = yy;
                    p.z = zz;
                    sk.push(p);
                    a[zz][yy][xx] = 0;
                }
            }
        }
        sk.pop();
        v ++;
    }
}

int main()
{
    scanf("%d %d %d %d",&n,&m,&l,&T);
    for (int t = 0;t < l;t ++)
    {
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < m;j ++)
            {
                scanf("%d",&a[t][i][j]);
            }
        }
    }
    int V = 0;
    for (int t = 0;t < l;t ++)
    {
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < m;j ++)
            {
                v = 0;
                bfs(j,i,t);
                if (v >= T) V += v;
            }
        }
    }
    printf("%d\n",V);
    reutrn 0;
}
*/

///图 最短路
/*
struct Node {
    int n;
    int w;
    Node *next;
};

struct pp {
    int id;
    int miin;
    int s;
};

int toInt(char *a)
{
    int sum = 0;
    for (int i = 0;a[i] != 0;i ++)
    {
        sum = sum * 10 + a[i] - '0';
    }
    return sum;
}

int cmp(pp a, pp b)
{
    if (a.miin == b.miin)
    {
        if (a.s == b.s) return a.id < b.id;
        return a.s < b.s;
    }
    return a.miin > b.miin;
}

int main()
{
    int v,vg,e,d_s;
    scanf("%d %d %d %d",&v,&vg,&e,&d_s);
    Node *g[1020] = {NULL}; // 1 - 1000; 1001 - 1010
    char a[5], b[5];
    int w;
    int aa, bb;
    Node *nd;
    for (int i = 0;i < e;i ++)
    {
        scanf("%s %s %d", a, b, &w);
        if (*a == 'G') aa = toInt(a + 1) + 1000;
        else aa = toInt(a);
        if (*b == 'G') bb = toInt(b + 1) + 1000;
        else bb = toInt(b);
        
        nd = (Node*) malloc(sizeof(Node));
        nd -> w = w;
        nd -> n = bb;
        nd -> next = g[aa];
        g[aa] = nd;
        
        nd = (Node*) malloc(sizeof(Node));
        nd -> w = w;
        nd -> n = aa;
        nd -> next = g[bb];
        g[bb] = nd;
    }
    int dis[10010];
    int t_min,sum;
    vector<pp> vct;
    pp p;
    for (int i = 1001;i < 1015;i ++)
    {
        mem(dis, -1);
        if (g[i] == NULL) continue;
        queue<int> q;
        q.push(i);
        dis[i] = 0;
        int k,t,tw;
        while (!q.empty())
        {
            k = q.front();
            nd = g[k];
            while (nd != NULL)
            {
                t = dis[nd -> n]; // target
                tw = dis[k] + nd -> w; // there + weight to target
                if (t == -1 || t > tw)
                {
                    dis[nd -> n] = tw;
                    q.push(nd -> n);
                }
                nd = nd -> next;
            }
            q.pop();
        }
        t_min = -1;
        sum = 0;
        for (int i = 1;i <= v;i ++)
        {
            if (dis[i] > d_s) {
                t_min = -1;
                break;
            }
            sum += dis[i];
            if (t_min == -1) t_min = dis[i];
            else t_min = min(dis[i], t_min);
        }
        if (t_min != -1)
        {
            p.id = i;
            p.miin = t_min;
            p.s = sum;
            vct.push_back(p);
        }
    }
    if (vct.size() == 0) printf("No Solution\n");
    else {
        sort(vct.begin(), vct.end(), cmp);
        vector<pp>::iterator bg = vct.begin();
        double o = bg -> s / (double) v;
        printf("G%d\n%d.0 %.1lf\n",bg -> id - 1000,bg -> miin,o + 0.005);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int c = 0;
    int w = (int) str.size();
    for (int i = 0;str[i] != 0;i ++)
    {
        if (str[i] >= '0' && str[i] <= '9')
        {
            if (str[i] == '2') c ++;
        }
    }
    double k = c;
    if (str[0] == '-') {
        k *= 1.5;
        w --;
    }
    if ((str[str.size() - 1] - '0') % 2 == 0) k *= 2;
    k *= 100;
    k /= w;
    printf("%.2lf%%\n",k);
    
    return 0;
}
*/

/*
int main()
{
    int h,m;
    scanf("%d:%d", &h, &m);
    if ((h >= 0 && h < 12) || (h == 12 && m == 0)) printf("Only %02d:%02d.  Too early to Dang.",h,m);
    else {
        int k = h - 12;
        if (m != 0) k ++;
        for (int i = 0;i < k;i ++)
        {
            printf("Dang");
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int an, bn;
    scanf("%d %d", &an, &bn);
    int n;
    scanf("%d", &n);
    int a, b, ah, bh, ai = 0, bi = 0;
    int ok = 0;
    while (n --)
    {
        scanf("%d %d %d %d", &a, &ah, &b, &bh);
        if (ok) continue;
        if (ah == a + b && ah == bh) {continue;}
        if (ah == a + b) ai ++;
        if (bh == a + b) bi ++;
        if (ai > an) {printf("A\n%d\n", bi); ok = 1;}
        if (bi > bn) {printf("B\n%d\n", ai); ok = 1;}
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int k,id;
    int a[100000] = {0};
    while (n --)
    {
        scanf("%d",&k);
        set<int> v;
        while (k --)
        {
            scanf("%d",&id);
            v.insert(id);
        }
        if (v.size() <= 1) continue;
        for (set<int>::iterator i = v.begin();i != v.end();i ++)
        {
            a[*i] ++;
        }
    }
    scanf("%d",&n);
    int b[100000] = {0};
    int f = 1;
    while (n --)
    {
        scanf("%d",&id);
        if (b[id] == 0)
        {
            if (a[id] == 0) {
                if (f) f = 0;
                else printf(" ");
                printf("%05d",id);
            }
        }
        b[id] ++;
    }
    if (!f) printf("\n");
    else printf("No one is handsome\n");
    return 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    int j = 0, o = 0, k;
    while (n --)
    {
        scanf("%d",&k);
        if (k % 2) j ++;
        else o ++;
    }
    printf("%d %d\n", j, o);
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int a[200] = {0};
    for (int i = 0;str[i] != 0;i ++)
    {
        if (str[i] >= 'a' && str[i] <= 'z') str[i] -= 32;
        a[str[i]] ++;
    }
    while (a['G'] != 0 || a['P'] != 0 || a['L'] != 0 || a['T'] != 0)
    {
        if (a['G'] != 0) {printf("G"); a['G'] --;}
        if (a['P'] != 0) {printf("P"); a['P'] --;}
        if (a['L'] != 0) {printf("L"); a['L'] --;}
        if (a['T'] != 0) {printf("T"); a['T'] --;}
    }
    printf("\n");
    return 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    printf("%d\n",(n + 2) % 7 == 0 ? 7 : (n + 2) % 7);
    return 0;
}
*/

/*#define debug
 
struct Node
{
    struct Node *left;
    struct Node *right;
    int data;
};
 
struct Node *crt(int data)
{
    struct Node *n = (struct Node*) malloc(sizeof(struct Node));
    n -> left = NULL;
    n -> right = NULL;
    n -> data = data;
    return n;
}
 
void pre_in_add(int *pr, int l, int *in, struct Node **n)
{
    int data = pr[0];
    *n = crt(data);
    int i = 0;
    for (;i < l;i ++) if (in[i] == data) break;
    if (i > 0) pre_in_add(pr + 1, i, in, &((*n) -> left));
    if (i + 1 < l) pre_in_add(pr + 1 + i, l - 1 - i, in + i + 1, &((*n) -> right));
}

#ifdef debug
struct ps {
    int dps;
    int length;
    int type;
};
 
void pbl(Node *root, int d, int lr, vector<ps> dps)
{
    if (root == NULL) return;
    
    ps p = {d, (int) log10(root -> data) + 1, root -> right != NULL && lr == 0};
    if (dps.size() <= d) dps.push_back(p);
    else dps[d] = p;
    pbl(root -> right,d + 1, 1, dps);
    for (vector<ps>::iterator i = dps.begin();i != dps.end() - 1;i ++)
    {
        if (i -> type && i -> dps != 0) printf("|");
        else printf(".");
        for (int j = 0;j < i -> length + ((i -> dps) != 0) * 2;j ++)
        {
            printf(".");
        }
        
    }
    if (d != 0) printf("|-");
    printf("%d",root -> data);
    if (root -> left != NULL || root -> right != NULL) printf("-|");
    printf("\n");
    dps[d].type = root -> left != NULL && lr;
    pbl(root -> left,d + 1, 0, dps);
}
#endif

void levelTraversal(Node *root)
{
    if (root == NULL) return; // 如果root是空的直接return掉
    queue<Node*> childs; // 创建节点队列
    childs.push(root); // 先把root节点加入套餐
    int f = 1;
    while (childs.size() != 0) // 队列空了就结束
    {
        Node *current = childs.front(); // 取出队列前端的节点
        if (f) f = 0;
        else printf(" ");
        printf("%d",current -> data); // 提取数据
        if (current -> right != NULL) childs.push(current -> right); // 如果不是空的，就加入套餐
        if (current -> left != NULL) childs.push(current -> left); // 同上
        if (current != root) free(current);
        childs.pop(); // 去掉队列前端的节点
    }
}
 
int main()
{
    int n;
    scanf("%d",&n);
    int *pr = (int*) malloc(sizeof(int) * n);
    int *in = (int*) malloc(sizeof(int) * n);
    for (int i = 0;i < n;i ++) scanf("%d", i + in);
    for (int i = 0;i < n;i ++) scanf("%d", i + pr);
    struct Node *root = NULL;
    pre_in_add(pr, n, in, &root);
#ifdef debug
    vector<ps> dps;
    pbl(root, 0, 1, dps);
#endif
    levelTraversal(root);
    printf("\n");
    return 0;
}
*/


/*
int n,m;
char a[55][55];

int dp[55][55] = {0};

int dfs(int x,int y)
{
    if (x == m - 1 && y == n - 1) return 1;
    int v = 0;
    int xx,yy;
    if (a[y][x] == 'R')
    {
        xx = x + 1;
        yy = y;
        if (xx < m) v = (v + (dp[xx][yy] == 0 ? dp[xx][yy]  = dfs(xx,yy) : dp[xx][yy])) % 1000000007;
    } else if (a[y][x] == 'D')
    {
        xx = x;
        yy = y + 1;
        if (yy < n) v = (v + (dp[xx][yy] == 0 ? dp[xx][yy]  = dfs(xx,yy) : dp[xx][yy])) % 1000000007;
    } else if (a[y][x] == 'B')
    {
        xx = x + 1;
        yy = y;
        if (xx < m) v = (v + (dp[xx][yy] == 0 ? dp[xx][yy]  = dfs(xx,yy) : dp[xx][yy])) % 1000000007;
        xx = x;
        yy = y + 1;
        if (yy < n) v = (v + (dp[xx][yy] == 0 ? dp[xx][yy]  = dfs(xx,yy) : dp[xx][yy])) % 1000000007;
    }
    return v;
}

int main()
{
    scanf("%d %d",&n,&m);
    for (int i = 0;i < n;i ++)
    {
        scanf(" ");
        for (int j = 0;j < m;j ++)
        {
            scanf("%c",&a[i][j]);
        }
    }
    
    printf("%d\n",dfs(0,0));
    return 0;
}
*/

///埃氏筛
/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[100010];
    int k[100010] = {0};
    for (int i = 1;i <= n;i ++)
    {
        a[i] = i;
    }
    for (int i = 2;i < n;i ++)
    {
        if (k[i] == 0)
        {
            for (int j = i + i;j <= n;j += i)
            {
                if (a[j] == j) {
                    a[j] /= i;
                    k[j] ++;
                }
            }
        } else {
            for (int j = i + i;j <= n;j += i)
            {
                k[j] ++;
            }
        }
    }
    int v[100010] = {0};
    for (int i = 1;i <= n;i ++)
    {
        v[k[i]] ++;
    }
    while (m --)
    {
        scanf("%d",&n);
        printf("%d\n",v[n]);
    }
    return 0;
}
*/

/*
int a[1000010];

int main()
{
    int T;
    scanf("%d",&T);
    int n,m,p;
    int x,y,v;
    int ub, re;
    while (T --)
    {
        mem(a,0);
        scanf("%d %d %d",&n,&m,&p);
        ub = 0;
        re = 0;
        while (p --)
        {
            scanf("%d %d %d",&x,&y,&v);
            if (re) continue;
            if (x < 0 || y < 0) ub = 1;
            ll pt = x * m + y;
            if (pt >= 0 && pt < m * n)
            {
                a[pt] = v;
            } else re = 1;
        }
        if (re) printf("Runtime error\n");
        else {
            int k = 0;
            for (int i = 0;i < n;i ++)
            {
                for (int j = 0;j < m;j ++)
                {
                    if (j != 0) printf(" ");
                    printf("%d",a[k ++]);
                }
                printf("\n");
            }
            if (ub) printf("Undefined Behaviour\n");
            else printf("Accepted\n");
        }
    }
    return 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    int b[100010];
    a[0] = -1;
    int s = 0;
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
        if (a[i] != -1) {
            s ++;
            b[a[i]] = i;
        }
    }
    printf("The size of the tree is %d\n", s);
    if (s != 0)
    {
        printf("Node %d is the root node of the tree\n",a[1]);
        int l,r;
        for (int j = 1;j <= s;j ++)
        {
            int i = b[j];
            l = (i * 2) <= n ? a[i * 2] : -1;
            r = (i * 2 + 1) <= n ? a[i * 2 + 1] : -1;
            printf("The father of node %d is %d, the left child is %d, and the right child is %d\n",a[i],a[i / 2],l,r);
        }
    }
    return 0;
}*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    string str;
    cin >> str;
    ll a[100010] = {0};
    ll s = 0;
    int last = -1;
    for (int i = 0;i < n;i ++)
    {
        if (str[i] == '1')
        {
            if (last != -1) a[s ++] = i - last;
            last = i;
        }
    }
    ll sum = 0;
    ll p = 1000000007;
    for (ll i = 0;i < s;i ++)
    {
        sum = (sum + (a[i] * (((s - i) * (i + 1)) % p)) % p) % p;
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
map<pair<char,char>,int> d;

vector<ll> dp[65]['C' + 1]['C' + 1]['C' + 1];

vector<ll> Hanoi(int n, char a, char b, char c)
{
    vector<ll> arr(6);
    vector<ll> x;
    if (n == 1)
        arr[d[make_pair(a, c)]] ++;
    else {
        x = dp[n - 1][a][c][b].size() == 0 ? dp[n - 1][a][c][b] = Hanoi(n - 1, a, c, b) : dp[n - 1][a][c][b];
        for (int i = 0;i < 6;i ++) arr[i] += x[i];
        arr[d[make_pair(a, c)]] ++;
        x = dp[n - 1][b][a][c].size() == 0 ? dp[n - 1][b][a][c] = Hanoi(n - 1, b, a, c) : dp[n - 1][b][a][c];
        for (int i = 0;i < 6;i ++) arr[i] += x[i];
    }
    return arr;
}

int main()
{
    pair<char,char> a[] = {make_pair('A', 'B'),make_pair('A', 'C'),make_pair('B', 'A'),make_pair('B', 'C'),make_pair('C', 'A'),make_pair('C', 'B')};
    for (int i = 0;i < 6;i ++)
    {
        d[a[i]] = i;
    }
    printf("#include<stdio.h>\n");
    printf("int main() {\nint n;\nscanf(\"%%d\",&n);\n");
    for (int n = 1;n <= 60;n ++)
    {
        if (n != 1) printf("else ");
        printf("if (n == %d)\n{\n",n);
        
        vector<ll> k = Hanoi(n, 'A', 'B', 'C');
        ll s = 0;
        for (int i = 0;i < 6;i ++)
        {
            printf("\tprintf(\"%c->%c:%lld\\n\");\n",(a + i) -> first, (a + i) -> second,k[i]);
            s += k[i];
        }
        printf("\tprintf(\"SUM:%lld\\n\");\n",s);
        
        printf("} ");
    }
    printf("\nreturn 0;\n}\n");
    return 0;
}
*/

/*
int g[10010] = {0};
int cmp(pair<int,int> a,pair<int,int> b)
{
    if (a.first == b.first) {
        if (g[a.second] == g[b.second]) return a.second < b.second;
        return g[a.second] > g[b.second];
    }
    return a.first > b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    pair<int,int> mon[10010];
    int k;
    int ni,pi;
    int sum;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&k);
        sum = 0;
        while (k --)
        {
            scanf("%d %d",&ni,&pi);
            sum += pi;
            mon[ni].first += pi;
            g[ni] ++;
        }
        mon[i + 1].second = i + 1;
        mon[i + 1].first -= sum;
    }
    sort(mon + 1, mon + n + 1, cmp);
    for (int i = 1;i <= n;i ++) printf("%d %.2lf\n",mon[i].second, mon[i].first / 100.0);
    return 0;
}
*/

/*
int main()
{
    int n,m,c;
    scanf("%d %d %d",&n,&m,&c);
    int u,uu,v,vv,k,b[105];
    struct Node {
        int n;
        Node *nxt;
    } *g[105] = {NULL}, *g_b[105] = {NULL}, *node;
    for (int i = 1;i <= n;i ++) {
        b[i] = i;
        g_b[i] = (Node*) malloc(sizeof(Node));
        g_b[i] -> nxt = NULL;
        g_b[i] -> n = i;
    }
    
    for (int i = 0;i < m;i ++)
    {
        scanf("%d %d %d",&u,&v,&k);
        if (k == -1)
        {
            node = (Node*) malloc(sizeof(Node));
            node -> nxt = g[u];
            node -> n = v;
            g[u] = node;
            
            node = (Node*) malloc(sizeof(Node));
            node -> nxt = g[v];
            node -> n = u;
            g[v] = node;
        } else {
            uu = b[u];
            vv = b[v];
            if (uu == vv) continue;
            node = g_b[uu];
            while (node != NULL)
            {
                b[node -> n] = vv;
                if (node -> nxt != NULL) node = node -> nxt;
                else break;
            }
            node -> nxt = g_b[vv];
            g_b[vv] = g_b[uu];
            g_b[uu] = NULL;
            
            // ------
//            for (int i = 1;i <= n;i ++) {
//                printf("%d ",b[i]);
//            }
//            printf("\n");
//            for (int i = 1;i <= n;i ++)
//            {
//                printf("%d: ",i);
//                Node *node = g_b[i];
//                while (node != NULL)
//                {
//                    printf("%d ",node -> n);
//                    node = node -> nxt;
//                }
//                printf("\n");
//            }
//            printf("\n");
        }
    }
    for (int i = 0;i < c;i ++)
    {
        scanf("%d %d",&u,&v);
        node = g[u];
        int di = 0;
        while (node != NULL)
        {
            if (node -> n == v) {di = 1; break;}
            node = node -> nxt;
        }
        int you = b[v] == b[u];
        if (you && di) printf("OK but...\n");
        else if (!you && di) printf("No way\n");
        else if (you && !di) printf("No problem\n");
        else if (!you && !di) printf("OK\n");
    }
    return 0;
}
*/

/*
int main()
{
    int a = 0,b = 0;
    string A,B;
    cin >> A;
    getline(cin, B);
    int oka = 1,
    okb = 1;
    for (int i = 0;A[i] != 0;i ++)
    {
        if (A[i] >= '0' && A[i] <= '9') {
            a = a * 10 + A[i] - '0';
            if (a > 1000) {
                oka = 0;
                break;
            }
        }
        else {
            oka = 0;
            break;
        }
    }
    for (int i = 1;B[i] != 0;i ++)
    {
        if (B[i] >= '0' && B[i] <= '9') {
            b = b * 10 + B[i] - '0';
            if (b > 1000) {
                okb = 0;
                break;
            }
        }
        else {
            okb = 0;
            break;
        }
    }
    if (oka && okb && a && b) printf("%d + %d = %d\n",a,b,a + b);
    else {
        if (oka && a) printf("%d",a);
        else printf("?");
        printf(" + ");
        if (okb && b) printf("%d",b);
        else printf("?");
        printf(" = ?\n");
    }
    return 0;
}
*/

/*int main()
{
    string str = "I Love GPLT";
    for (int i = 0;str[i] != 0;i ++) printf("%c\n",str[i]);
    return 0;
}*/

/*int isZhi(uint n)
{
    if (n == 1) return 0;
    for (uint i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int n;
    scanf("%d",&n);
    while (n --)
    {
        uint a;
        scanf("%u",&a);
        if (isZhi(a)) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}*/

/*
int main()
{
    int h;
    scanf("%d",&h);
    printf("%.1lf\n",(h - 100) * 0.9 * 2);
    return 0;
}
*/

/*
int main()
{
    list<pair<int,string>> k;
    int n;
    scanf("%d",&n);
    int m;
    string name;
    while (n --)
    {
        cin >> m >> name;
        k.push_back(make_pair(m, name));
    }
    list<pair<int,string> >::iterator bg = k.begin();
    list<pair<int,string> >::reverse_iterator i = k.rbegin();
    while (!k.empty())
    {
        
        if (i -> first ^ bg -> first)
        {
            cout << bg -> second << " " << i -> second << endl;
            k.erase((++ i).base());
            k.erase(bg);
            i = k.rbegin();
            bg = k.begin();
        } else i ++;
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a,b;
    double o,c;
    int sign = 1;
    while (n --)
    {
        scanf("%d %d",&a,&b);
        o = (a - 100) * 0.9 * 2;
        c = fabs(b - o);
        sign = (b - o) / c;
        o *= 0.1;
        if (c < o) printf("You are wan mei!\n");
        else if (sign < 0) printf("You are tai shou le!\n");
        else printf("You are tai pang le!\n");
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int a[10] = {0};
    set<int> l;
    for (int i = 0;str[i] != 0;i ++)
    {
        l.insert(str[i] - '0');
    }
    int j = 0;
    printf("int[] arr = new int[]{");
    for (set<int>::reverse_iterator i = l.rbegin();i != l.rend();i ++, j ++) {
        a[*i] = j;
        if (j != 0) printf(",");
        printf("%d",*i);
    }
    printf("};\nint[] index = new int[]{");
    for (int i = 0;str[i] != 0;i ++)
    {
        if (i != 0) printf(",");
        printf("%d",a[str[i] - '0']);
    }
    printf("};\n");
    return 0;
}
*/


/*int main()
{
    int t;
    scanf("%d",&t);
    while (t --)
    {
        int n;
        scanf("%d",&n);
        ll a = 2, b = 1;
        for (int i = 1;i < n;i ++)
        {
            ll t = a;
            a = a + b;
            b = t;
        }
        if (n == 0) printf("1\n");
        else printf("%lld\n",a + b);
    }
    return 0;
}*/

/*
int main()
{
    string s,str = "";
    while (getline(cin,s))
    {
        str += s;
    }
    int ok = 1;
    s = "";
    for (int i = 0;str[i] != 0;i ++)
    {
        if (str[i] == '(' || str[i] == '{' || str[i] == '[') s += str[i];
        else {
            if (str[i] == ')')
            {
                if (*s.rbegin() == '(') s.erase(s.end() - 1);
                else {
                    ok = 0;
                    break;
                }
            }
            if (str[i] == ']')
            {
                if (*s.rbegin() == '[') s.erase(s.end() - 1);
                else {
                    ok = 0;
                    break;
                }
            }
            if (str[i] == '}')
            {
                if (*s.rbegin() == '{') s.erase(s.end() - 1);
                else {
                    ok = 0;
                    break;
                }
            }
        }
    }
    if (ok && s.empty()) printf("Yes\n");
    else printf("No\n");
    return 0;
}*/


/*
int main()
{
    string str;
    int a[11] = {0};
    cin >> str;
    int c = 1;
    for (int i = 0;str[i] != 0;i ++)
    {
        if (str[i] >= '0' && str[i] <= '9') a[str[i] - '0'] ++;
        else if (str[i] == '+') c ++;
    }
    string sum;
    ull jin = 0;
    
    for (int i = 9;i >= 0;i --)
    {
        if (a[i + 1] < 0)
        {
            if (a[i] + a[i + 1] >= 0)
            {
                jin += i * -a[i + 1];
                sum += (char) (jin % 10 + '0');
                jin /= 10;
            } else {
                jin += i * a[i];
            }
            a[i] += a[i + 1];
        }
        while (a[i] > 0)
        {
            if (a[i] >= c) {
                jin += i * c;
                sum += (char) (jin % 10 + '0');
                jin /= 10;
            }
            else jin += i * a[i];
            a[i] -= c;
        }
    }
    while (jin != 0)
    {
        sum += (char) (jin % 10 + '0');
        jin /= 10;
    }
    for (string::reverse_iterator i = sum.rbegin();i != sum.rend();i ++)
    {
        printf("%c",*i);
    }
    printf("\n");
    
    return 0;
}
*/

//逆元 快速幂https://ac.nowcoder.com/acm/contest/3005/C
/*
const ull mod = 998244353;

ull quickpow(ull a, ull b)
{
    ull ans = 1;
    while (b)
    {
        if (b & 1)
            ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    ull a[200010];
    ull max = 0;
    ull ji = 1;
    queue<int> z_p;
    for (int i = 0;i < n;i ++)
    {
        scanf("%llu",a + i);
        if (a[i] == 0 || a[i] == mod) {
            z_p.push(i);
            a[i] = 1;
        }
        if (i < k)
        {
            ji = (ji * a[i]) % mod;
            if (i + 1 == k)
            {
                if (z_p.empty())
                {
                    if (ji > max) max = ji;
                }
            }
        } else {
            ji = (ji * quickpow(a[i - k], mod - 2)) % mod;
            ji = (ji * a[i]) % mod;
            if (!z_p.empty() && i - k >= z_p.front()) z_p.pop();
            if (z_p.empty())
            {
                if (ji > max) max = ji;
            }
        }
    }
    printf("%llu\n",max);
    return 0;
}
*/

/*
int main()
{
    int n;
    char k;
    scanf("%d %c",&n,&k);
    scanf(" ");
    string str;
    getline(cin,str);
    long v = str.size();
    for (int i = 0;i < n - v;i ++)
    {
        printf("%c",k);
    }
    if (n - v < 0)
    {
        cout << str.substr(v - n,n) << endl;
    } else cout << str << endl;
    return 0;
}
*/


// xor前缀和https://ac.nowcoder.com/acm/contest/3005/D
/*int main()
{
    int n;
    scanf("%d",&n);
    int in;
    int f = 0;
    map<int,ll> dp;
    dp[f] ++;
    ll ans = 0;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&in);
        f ^= in;
        ans += dp[f]; // x ^ 0 = x相当于减法，减去前面和相等的那段区间，保留了中间那段0的区间
        dp[f] ++;
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int u,v;
    int g[510][510] = {0};
    for (int i = 0;i < m;i ++)
    {
        scanf("%d %d",&u,&v);
        g[u][v] = 1;
        g[v][u] = 1;
    }
    int k,d;
    scanf("%d",&k);
    int nn = n;
    while (k --)
    {
        scanf("%d",&d);
        int ok = 0;
        int vis[510] = {0};
        vector<int> nds;
        for (int i = 0;i < n;i ++)
        {
            if (g[d][i])
            {
                g[i][d] = 0;
                g[d][i] = 0;
                nds.push_back(i);
            }
        }
        int v = 0;
        for (vector<int>::iterator i = nds.begin();i != nds.end();i ++, v ++)
        {
            queue<int> q;
            q.push(*i);
            vis[*i] ++;
            while (!q.empty())
            {
                int tp = q.front();
                for (int a = 0;a < n;a ++)
                {
                    if (g[tp][a] && vis[a] == v)
                    {
                        vis[a] ++;
                        q.push(a);
                    }
                }
                q.pop();
            }
            for (vector<int>::iterator j = nds.begin();j != nds.end();j ++)
            {
                if (vis[*j] == v) {
                    ok = 1;
                    goto okk;
                }
            }
        }
        okk:
        if (ok) printf("Red Alert: ");
        printf("City %d is lost",d);
        if (ok) printf("!\n");
        else printf(".\n");
        nn --;
    }
    if (!nn) printf("Game Over.\n");
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    string s1,s2;
    cin >> s1 >> s2;
    int miin = min(n,m);
    int c = 0;
    for (int i = 0;i < miin;i ++)
    {
        if (s1[i] != s2[i]) c ++;
    }
    printf("%d\n",c + max(n,m) - miin);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[15];
    int b[15];
    for (int i = 0;i < n;i ++) {
        scanf("%d",a + i);
        b[i] = a[i];
    }
    sort(b,b + n,greater<int>());
    
    if (a[8] >= m * 0.8 || a[8] >= b[2])
    {
        printf("Yes\n");
    } else printf("No\n");
    return 0;
}
*/

/*
int main()
{
    ll n,r;
    scanf("%lld %lld",&n,&r);
    int i,j;
    scanf("%d %d",&i,&j);
    int miin = min(i,j);
    int maax = max(i,j);
    double rr = 2 * r * r;
    double l = sqrt((1 - cos(2 * pi / n)) * rr);
    int k = min(maax - miin, miin + (int) n - maax);
    printf("%f\n",k * l);
    return 0;
}
*/

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    if (n % 2) printf("Bob\n");
    else {
        double k = log2(n);
        ll v = k;
        if (pow(2,v) == n) printf("Alice\n");
        else printf("Bob\n");
    }
    return 0;
}
*/

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    double t,a,b,c,tt1,tt2;
//    double k = 1 / 3.0;
//    while (T --)
//    {
//        scanf("%lf %lf",&a,&b);
//        t = 0;
//        start:
//        if (a >= 0)
//        {
//            if (b >= a) {
//                printf("%.9f\n",t + b - a);
//                continue;
//            }
//            else {
//                c = pow(a, k);
//                if (a - 1 <= c)
//                {
//                    printf("%.9f\n",t + a - b);
//                    continue;
//                }
//                if (c < b)
//                {
//                    tt1 = b - c + 1;
//                    tt2 = a - b;
//                    if (tt1 <= tt2) {
//                        printf("%.9f\n",tt1 + t);
//                        continue;
//                    } else {
//                        printf("%.9f\n",tt2 + t);
//                        continue;
//                    }
//                }
//                a = c;
//                t ++;
//                goto start;
//            }
//        } else {
//            if (b <= a) {
//                printf("%.9f\n",t + a - b);
//                continue;
//            }
//            else {
//                a = -a;
//                c = pow(a, k);
//                a = -a;
//                c = -c;
//                if (a + 1 >= c)
//                {
//                    printf("%.9f\n",t + b - a);
//                    continue;
//                }
//                if (c > b)
//                {
//                    tt1 = c - b + 1;
//                    tt2 = b - 1;
//                    if (tt1 <= tt2) {
//                        printf("%.9f\n",tt1 + t);
//                        continue;
//                    } else {
//                        printf("%.9f\n",tt2 + t);
//                        continue;
//                    }
//                }
//                a = c;
//                t ++;
//                goto start;
//            }
//        }
//    }
//    return 0;
//}


/*set<string> hans;

void add(string str)
{
    if (str.find("=") == string::npos)
    {
        string all = "";
        vector<string> paras;
        for (int i = 0;str[i] != 0;i ++)
        {
            if (all != "")
            {
                for (;str[i] != 0 && str[i] == ' ';i ++);
                while (str[i] != 0 && str[i] != ')')
                {
                    string p = "";
                    for (;str[i] != 0 && str[i] != ')' && str[i] != ',' && str[i] != ' ';i ++)
                    {
                        p += str[i];
                    }
                    paras.push_back(p);
                    for (;str[i] != 0 && str[i] == ' ';i ++);
                    for (;str[i] != 0 && str[i] != ',' && str[i] != ')';i ++);
                    if (str[i] == ',') {
                        i ++;
                        for (;str[i] != 0 && str[i] == ' ';i ++);
                    }
                }
                break;
            }
            if (str[i] == '(')
            {
                //printf("1\n");
                int j = i - 1;
                if (j >= 0 && str[j] == ' ') for (;j >= 0 && str[j] == ' ';j --);
                //cout << j << endl;
                string name = "";
                for (;j >= 0 && str[j] != ' ';j --)
                {
                    name = str[j] + name;
                }
                //cout << j << endl;
                if (j >= 0 && str[j] == ' ') for (;j >= 0 && str[j] == ' ';j --);
                //cout << j << endl;
                if (j == 0 && str[j] == ' ') return;
                //printf("2\n");
                string lei = "";

                for (;j >= 0;j --)
                {
                    lei = str[j] + lei;
                }
                stringstream s(lei);
                string k;
                lei = "";
                int f = 1;
                while (s >> k)
                {
                    if (f) f = 0;
                    else lei += ' ';
                    lei += k;
                }
                if (lei == "") return;
                all = lei + " " + name;
            }
        }
        all += '(';
        for (int i = 0;i < paras.size();i ++)
        {
            if (i != 0) all += ",";
            all += paras[i];
        }
        all += ')';
        //cout << all << endl;
        hans.insert(all);
    }
}

int main()
{

    string line;
    int ch_start = 0, un_start = 0, str_start = 0;
    string dk;
    while (getline(cin,line))
    {
        for (int i = 0;line[i] != 0;i ++)
        {
            if (!un_start && !str_start && !ch_start && line[i] == '/' && line[i + 1] == '/')
            {
                goto end;
            }
            if (!un_start)
            {
                if (line[i] == '"') str_start = !str_start;
                if (line[i] == '\'') ch_start = !ch_start;
            }
            if (!str_start && !ch_start)
            {
                if (!un_start && line[i] == '/' && line[i + 1] == '*') {
                    un_start = 1;
                    line.erase(line.begin() + i);
                    line.erase(line.begin() + i);
                    i --;
                } else
                if (un_start && line[i] == '*' && line[i + 1] == '/') {
                    un_start = 0;
                    line.erase(line.begin() + i);
                    line.erase(line.begin() + i);
                    i --;
                } else
                if (un_start)
                {
                    line.erase(line.begin() + i);
                    i --;
                }
            }
            if (!ch_start && !str_start && !un_start)
            {
                if (line[i] == '{') dk += '{';
                if (line[i] == '}') dk.erase(dk.end() - 1);
                if (line[i] == '(')
                {
                    if (dk.empty())
                    {
                        add(line);
                    }
                }
            }
        }
        end:
        continue;
    }
    for (set<string>::iterator i = hans.begin();i != hans.end();i ++)
    {
        cout << *i << endl;
    }

    return 0;
}
*/

/*
int main()
{
    string str;
    getline(cin,str);
    int i = -1;
    while ((i = (int) str.find("6666666666",i + 1)) != string::npos)
    {
        int t = 0;
        for (int j = i;str[j] == '6';j ++,t ++);
        str.replace(i, t, "27");
    }
    i = -1;
    while ((i = (int) str.find("6666",i + 1)) != string::npos)
    {
        int t = 0;
        for (int j = i;str[j] == '6';j ++,t ++);
        str.replace(i, t, "9");
    }
    cout << str << endl;
    return 0;
}
*/

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    scanf(" ");
//    while (T --)
//    {
//        string str;
//        getline(cin,str);
//        int s = str.size() - 2;
//        if (s - 2>= 0)
//        {
//            if (str[s] == 'g' && str[s - 1] == 'n' && str[s - 2] == 'o')
//            {
//                stringstream ss(str);
//                vector<string> vs;
//                string p;
//                while (ss >> p)
//                {
//                    vs.push_back(p);
//                }
//                for (int i = 0;i < vs.size() - 3;i ++)
//                {
//                    cout << vs[i] << " ";
//                }
//                printf("qiao ben zhong.");
//                printf("\n");
//                continue;
//            }
//        }
//        printf("Skipped\n");
//    }
//    return 0;
//}

/*
int main()
{
    int all = 0;
    for (int c = 3;c <= 13;c ++)
    {
        for (int a = 1;a < c;a ++)
        {
            int b = c - a;
            if (a != b)
            {
                for (int f = 6;f <= 12;f ++)
                {
                    if (f == a || f == b || f == c) continue;
                    for (int d = 2;d < f;d ++)
                    {
                        if (d == a || d == b || d == c || f % d) continue;
                        int e = f / d;
                        if (e == a || e == b || e == c) continue;
                        if (e != d && e != f)
                        {
                            int k[7];
                            int j = 0;
                            for (int i = 1;i <= 13;i ++)
                            {
                                if (i != a && i != b && i != c && i != d && i != e && i != f)
                                {
                                    k[j ++] = i;
                                }
                            }
                            do {
                                if (k[0] - k[1] == k[2])
                                {
                                    if (k[3] % k[4] == 0 && k[3] / k[4] == k[5])
                                    {
                                        printf("%d + %d = %d\n%d - %d = %d\n%d * %d = %d\n%d / %d = %d\n\n",a,b,c,k[0],k[1],k[2],d,e,f,k[3],k[4],k[5]);
                                        all ++;
                                    }
                                }
                            } while (next_permutation(k, k + 7));
                            
                        }
                    }
                }
            }
        }
    }
    printf("%d\n",all);
    return 0;
}
*/

/*
int main()
{
    for (int n = 2;n <= 200;n ++)
    {
        int a = ((200 + 2 * n) / (n + 1) - n) / 2;
        if ((2 * a + n) * (n + 1) == 200 + 2 * n)
        {
            printf("%d %d\n",a,n);
        }
    }
    return 0;
}
*/

/*
int all = 0;

int g[15][15];

void dfs(vector<int> a, int n, vector<int> k)
{
    if (n == 0) {
        int vis[15] = {0};
        for (auto i = k.begin();i != k.end();i ++)
        {
            vis[*i] = 1;
        }
        queue<int> q;
        q.push(*k.begin());
        while (!q.empty())
        {
            for (int i = 1;i <= 13;i ++)
            {
                if (g[i][q.front()] && vis[i] == 1)
                {
                    q.push(i);
                    vis[i] = 2;
                }
            }
            q.pop();
        }
        int ok = 1;
        for (auto i = k.begin();i != k.end();i ++)
        {
            if (vis[*i] != 2) {
                ok = 0;
                break;
            }
        }
        if (ok) {
            all ++;
        }
        return;
    }
    ll sz = a.size();
    for (ll i = sz - 1;i >= n - 1;i --)
    {
        k.insert(k.begin(), a[i]);
        a.erase(a.begin() + i);
        dfs(a,n - 1,k);
        k.erase(k.begin());
    }
}

int main()
{
    vector<int> k;
    for (int i = 1;i <= 13;i ++) k.push_back(i);
    for (int i = 1;i < 4;i ++)
    {
        g[i][i + 1] = 1;
        g[i + 4][i + 5] = 1;
        g[i + 8][i + 9] = 1;
        
        g[i+ 1][i] = 1;
        g[i + 5][i + 4] = 1;
        g[i + 9][i + 8] = 1;
        
        g[i][i + 4] = 1;
        g[i + 4][i] = 1;
        g[i + 4][i + 8] = 1;
        g[i + 8][i + 4] = 1;
    }
    g[4][8] = 1;
    g[8][4] = 1;
    g[8][12] = 1;
    g[12][8] = 1;
    
    dfs(k,5,vector<int>());
    cout << all << endl;
    return 0;
}
*/

/*
int cb(int a,int b)
{
    return a * 10 + b;
}

int main()
{
    set<int> a,b;
    a.insert(2);
    a.insert(3);
    a.insert(5);
    a.insert(8);
    
    b.insert(1);
    b.insert(4);
    b.insert(6);
    b.insert(7);
    
    set<set<pair<int,int> > > all;
    
    int c[] = {1,2,3,4,5,6,7,8};
    do {
        if (a.find(c[0]) != a.end() && b.find(c[1]) != b.end() &&
            a.find(c[2]) != a.end() && b.find(c[3]) != b.end() &&
            a.find(c[4]) != a.end() && b.find(c[5]) != b.end() &&
            a.find(c[6]) != a.end() && b.find(c[7]) != b.end())
        {
            if (cb(c[0],c[1]) * cb(c[0],c[1]) + cb(c[2],c[3]) * cb(c[2],c[3]) + cb(c[4],c[5]) * cb(c[4],c[5]) + cb(c[6],c[7]) * cb(c[6],c[7]) == cb(c[1],c[0]) * cb(c[1],c[0]) + cb(c[3],c[2]) * cb(c[3],c[2]) + cb(c[5],c[4]) * cb(c[5],c[4]) + cb(c[7],c[6]) * cb(c[7],c[6]))
            {
                set<pair<int,int> > k;
                for (int i = 0;i < 7;i += 2)
                {
                    k.insert(make_pair(min(c[i], c[i + 1]),max(c[i], c[i + 1])));
                }
                all.insert(k);
            }
        }
    } while (next_permutation(c, c + 8));
    cout << all.size() << endl;
    return 0;
}
*/

/*
int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

int vx[25];
int vy[25];

int cx[25] = {0};
int cy[25] = {0};

int a[25][25] = {0};

int n;

vector<int> line;

void dfs(int x, int y, vector<int> l)
{
    if (line.size() != 0) return;
    if (x == n - 1 && y == n - 1)
    {
//        for (auto i = l.begin();i != l.end();i ++)
//        {
//            if (i != l.begin()) printf(" ");
//            printf("%d",*i);
//        }
//        printf("\n");
        int xok = 0,yok = 0;
        for (int i = 0;i < n;i ++)
        {
            if (cx[i] == vx[i]) xok ++;
            if (cy[i] == vy[i]) yok ++;
        }
        if (xok == n && yok == n) line = l;
        return;
    }
    a[y][x] = 1;
//    for (int i = 0;i < n;i ++)
//    {
//        for (int j = 0;j < n;j ++)
//        {
//            printf("%d ",a[i][j]);
//        }
//        printf("\n");
//    }
//    printf("\n");
    for (int i = 0;i < 4;i ++)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if (xx >= 0 && xx < n && yy >= 0 && yy < n && a[yy][xx] == 0)
        {
            if (cx[xx] + 1 > vx[xx]) continue;
            if (cy[yy] + 1 > vy[yy]) continue;
            cx[xx] ++;
            cy[yy] ++;
            l.push_back(yy * n + xx);
            dfs(xx,yy,l);
            cx[xx] --;
            cy[yy] --;
            l.erase(l.end() - 1);
        }
    }
    a[y][x] = 0;
}

int main()
{
    scanf("%d",&n);
    for (int i = 0;i < n;i ++) scanf("%d",vx + i);
    for (int i = 0;i < n;i ++) scanf("%d",vy + i);
    cx[0] ++;
    cy[0] ++;
    dfs(0,0,vector<int>());
    printf("0");
    for (auto i = line.begin();i != line.end();i ++)
    {
        printf(" ");
        printf("%d",*i);
    }
    printf("\n");
    return 0;
}
*/



/*
int main()
{
    int a[3];
    scanf("%d %d %d",a,a + 1,a + 2);
    sort(a,a+3);
    if (a[0] + a[1] > a[2])
    {
        double x = (a[0] + a[1] - a[2]) / 2.0;
        double b[] = {x,a[0] - x,a[1] - x};
        sort(b,b+3);
        if (b[0] > 0)
        {
            printf("Yes\n");
            printf("%.2f %.2f %.2f\n",b[0],b[1],b[2]);
        }
        else printf("No\n");
    } else printf("wtnl\n");
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    while (T --)
    {
        scanf("%d",&n);
        string str;
        cin >> str;
        int d = 0;
        stack<char> s;
        for (int i = 0;i < n;i ++)
        {
            if (str[i] == '(')
                s.push('(');
            if (str[i] == ')')
            {
                if (s.empty())
                {
                    d ++;
                } else s.pop();
            }
        }
        printf("%lu\n",d + s.size());
    }
    return 0;
}
*/

/*
int main()
{
    int n,m,h;
    scanf("%d %d %d",&n,&m,&h);
    int x,y;
    ll z;
    int mod = 1000000007;
    int sum = 0;
    for (int i = 0;i < h;i ++)
    {
        scanf("%d %d %lld",&x,&y,&z);
        sum = (sum + z * (y * n + (1 + n) * n / 2 + x * m + (1 + m) * m / 2 - x - y) % mod) % mod;
    }
    printf("%d\n",sum);
    return 0;
}
*/

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int a[100010],b[100010];
//    for (int i = 0;i < n;i ++) scanf("%d",a + i);
//    for (int i = 0;i < n;i ++) scanf("%d",b + i);
//    sort(a,a + n);
//    sort(b,b + n);
//    do {
//        for (int i = 0;i < n;i ++) printf("%d",a[i]);
//        printf("\n");
//    } while (next_permutation(a, a + n));
//    return 0;
//}

/*
int main()
{
    int a[100010];
    int b[100010];
    int c[100010];
    int n,k;
    scanf("%d %d",&n,&k);
    for(int i = 0;i < n;i ++) scanf("%d",a + i);
    for(int i = 0;i < n;i ++) scanf("%d",b + i);
    sort(a,a + n,greater<int>());
    sort(b,b + n,greater<int>());

    for(int i = 0,j = k - 1;i < k;i ++, j --) {
        c[i] = a[i] + b[j];
    }
    sort(c,c + k);
    printf("%d\n",c[0]);
    return 0;
}*/


/*int main()
{
    //fre("/Users/jackli/oj/1013/cases/6.in");
    int n;
    scanf("%d",&n);
    int a[1000010];
    int b[1000010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    for (int i = 0;i < n;i ++) scanf("%d",b + i);
    sort(a,a + n);
    sort(b,b + n);
    ll ans = 1;
    for (int i = 0,j = 0;i < n;i ++)
    {
        for (;j < n && b[i] >= a[j];j ++);
        ans = ans * (j - i) % 1000000007;
    }
    printf("%lld\n",ans);
    return 0;
}*/

//int g[1000010] = {0};
//char vis[1000010] = {0};
//char vis1[1000010] = {0};
//
//int dp[1000010] = {0};
//
//int start = -1,value;
//
//int dfs(int x,int k)
//{
//    vis[x] = 1;
//    //cout << x << " ";
//
//    vis1[x] = k;
//    if (vis1[g[x]]) {
//        if (x != g[x]) start = g[x];
//        value = vis1[x] - vis1[g[x]] + 1;
//        dp[x] = value;
//        vis1[x] = 0;
//        return 1;
//    }
//    int a = dp[g[x]];
//    if (a == 0) {
//        a = dfs(g[x], k + 1);
//        if (start != -1)
//        {
//            dp[x] = value;
//            if (x == start) start = -1;
//        } else dp[g[x]] = a;
//    }
//    vis1[x] = 0;
//    return a + 1;
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//
//    char t[1000010] = {0};
//    int in;
//    for (int i = 1;i <= n;i ++)
//    {
//        scanf("%d",&in);
//        g[i] = in;
//        t[in] = 1;
//    }
//    int maax = 0;
//    for (int i = 1;i <= n;i ++)
//    {
//        if (t[i] == 0)
//        {
//            maax = max(dfs(i,1),maax);
//            for (int j = 1;j <= n;j ++) printf("%d ",vis[j]);
//            printf("\n");
//            for (int j = 1;j <= n;j ++) printf("%d ",dp[j]);
//            printf("\n");
//        }
//    }
//    // 环
//    for (int i = 1;i <= n;i ++)
//    {
//        if (vis[i] == 0)
//        {
//            queue<int> q;
//            q.push(i);
//            int f,m = 0;
//            while (!q.empty())
//            {
//                f = q.front();
//                vis[f] = 1;
//                m ++;
//                if (!vis[g[f]]) q.push(g[f]);
//                q.pop();
//            }
//            maax = max(m,maax);
//            for (int j = 1;j <= n;j ++) printf("%d ",vis[j]);
//            printf("\n");
//        }
//    }
//    printf("%d\n",maax);
//    return 0;
//}
//

/*int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    struct Node {
        int n;
        int l;
        int t;
        Node *nxt;
    } *g[510] = {NULL};
    int v1,v2,s,l,t;
    Node *node;
    int dis[510];
    int tm[510];
    mem(dis,-1);
    mem(tm,-1);
    for (int i = 0;i < m;i ++)
    {
        scanf("%d %d %d %d %d",&v1,&v2,&s,&l,&t);
        node = (Node*) malloc(sizeof(Node));
        node -> nxt = g[v1];
        node -> n = v2;
        node -> l = l;
        node -> t = t;
        g[v1] = node;
        if (!s)
        {
            node = (Node*) malloc(sizeof(Node));
            node -> nxt = g[v2];
            node -> n = v1;
            node -> l = l;
            node -> t = t;
            g[v2] = node;
        }
    }
    int e;
    scanf("%d %d",&s,&e);
    queue<int> q;
    dis[s] = 0;
    tm[s] = 0;
    vector<int> lu_dis[510];
    vector<int> lu_tm[510];
    int cr;
    int ft;
    
    q.push(s);
    while (!q.empty())
    {
        ft = q.front();
        node = g[ft];
        if (lu_dis[ft].size() == 0 || *(lu_dis[ft].end() - 1) != ft) lu_dis[ft].push_back(ft);
        while (node != NULL)
        {
            t = dis[node -> n];
            cr = dis[ft] + node -> l;
            if (t == -1 || t > cr || (t == cr && lu_dis[node -> n].size() > lu_dis[ft].size()))
            {
                dis[node -> n] = cr;
                q.push(node -> n);
                lu_dis[node -> n] = lu_dis[ft];
            }
            node = node -> nxt;
        }
        q.pop();
    }
    int dd = dis[e];
    mem(dis,-1);
    q.push(s);
    dis[s] = 0;
    while (!q.empty())
    {
        ft = q.front();
        node = g[ft];
        if (lu_tm[ft].size() == 0 || *(lu_tm[ft].end() - 1) != ft) lu_tm[ft].push_back(ft);
        while (node != NULL)
        {
            t = tm[node -> n];
            cr = tm[ft] + node -> t;
            if (t == -1 || t > cr || (t == cr && dis[node -> n] > dis[ft] + node -> l))
            {
                tm[node -> n] = cr;
                dis[node -> n] = dis[ft] + node -> l;
                q.push(node -> n);
                lu_tm[node -> n] = lu_tm[ft];
            }
            node = node -> nxt;
        }
        q.pop();
    }
    if (lu_dis[e] == lu_tm[e])
    {
        printf("Time = %d; Distance = %d: ",tm[e],dd);
        int f = 1;
        for (auto i = lu_tm[e].begin();i != lu_tm[e].end();i ++)
        {
            if (f) f = 0;
            else printf(" => ");
            printf("%d",*i);
        }
        printf("\n");
    } else {
        printf("Time = %d: ",tm[e]);
        int f = 1;
        for (auto i = lu_tm[e].begin();i != lu_tm[e].end();i ++)
        {
            if (f) f = 0;
            else printf(" => ");
            printf("%d",*i);
        }
        printf("\n");
        printf("Distance = %d: ",dd);
        f = 1;
        for (auto i = lu_dis[e].begin();i != lu_dis[e].end();i ++)
        {
            if (f) f = 0;
            else printf(" => ");
            printf("%d",*i);
        }
        printf("\n");
    }
    
    return 0;
}
*/

/*
int main()
{
    int n,m,k;
    scanf("%d %d %d",&n,&m,&k);
    struct Node {
        int n;
        Node *nxt;
    } *g[10010] = {NULL};
    int u,v;
    Node *node;
    for (int i = 0;i < m;i ++)
    {
        scanf("%d %d",&u,&v);
        node = (Node*) malloc(sizeof(Node));
        node -> nxt = g[u];
        node -> n = v;
        g[u] = node;
        
        node = (Node*) malloc(sizeof(Node));
        node -> nxt = g[v];
        node -> n = u;
        g[v] = node;
    }
    int c;
    int vis[10010];
    for (int i = 0;i < k;i ++)
    {
        scanf("%d",&c);
        mem(vis,-1);
        vis[c] = 0;
        queue<int> q;
        int f,t,cr;
        q.push(c);
        while (!q.empty())
        {
            f = q.front();
            node = g[f];
            while (node != NULL)
            {
                t = vis[node -> n];
                cr = vis[f] + 1;
                if (t == -1 || cr < t)
                {
                    vis[node -> n] = cr;
                    q.push(node -> n);
                }
                node = node -> nxt;
            }
            q.pop();
        }
        int mx = 0,mx_i = 0;
        for (int i = 1;i <= n;i ++)
        {
            if (vis[i] > mx)
            {
                mx = vis[i];
                mx_i = i;
            }
        }
        printf("%d\n",mx_i);
    }
    return 0;
}
*/

/*
int main()
{
    int a,b,s;
    int T;
    scanf("%d",&T);
    while (T --)
    {
        scanf("%d %d",&a,&b);
        s = a + b;
        if (s == 1) printf("2\n");
        else printf("1\n");
        
    }
    
    return 0;
}
*/

/*
int main()
{
    int T,n;
    scanf("%d",&T);
    string str;
    while (T --)
    {
        scanf("%d",&n);
        cin >> str;
        double m = 0.5,t = 0.5;
        double m_h = 0,t_h = 0;
        for (int i = 0;i < n;i ++)
        {
            if (str[i] == 'H')
            {
                m_h += m /= 2;
                t_h += t /= 2;
                t += 0.5;
            } else if (str[i] == 'M')
            {
                m_h += m /= 2;
                t_h += t /= 2;
                m += 0.5;
            }
        }
        //printf("%lf\n%lf",t_h,m_h);
        if (fabs(m_h - t_h) <= 1e-15) printf("HM\n");
        else if (m_h > t_h) printf("M\n");
        else if (m_h < t_h) printf("H\n");
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n,m;
    ll a[100010];
    ll b[100010];
    int f = 1;
    while (T --)
    {
        scanf("%d %d",&n,&m);
        for (int i = 0;i < n;i ++) scanf("%lld",a + i);
        for (int i = 0;i < m;i ++) scanf("%lld",b + i);
        ll last = a[0];
        ll sum1 = a[0];
        for (int i = 1;i < n;i ++)
        {
            last = max(a[i] + last,a[i]);
            sum1 = max(last,sum1);
        }
        last = b[0];
        ll sum2 = b[0];
        for (int i = 1;i < m;i ++)
        {
            last = max(b[i] + last,b[i]);
            sum2 = max(last,sum2);
        }
        if (f) f = 0;
        else printf("\n");
        printf("%lld",sum1 + sum2);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    int k = 1;
    double a;
    int ok = 0;
    while (T --)
    {
        scanf("%d",&n);
        k = 1;
        for (int i = 2;i <= n;i ++)
        {
            a = i;
            ok = 1;
            while ((a = pow(i,a)) <= n)
            {
                k ++;
                ok = 0;
                printf("%lf\n",a);
            }
            if (ok) break;
        }
        printf("%d\n",k);
    }
    return 0;
}
*/

//ll gcd(ll a,ll b)
//{
//    if (a % b == 0) return b;
//    return gcd(b, a % b);
//}
//
//int main()
//{
//    int T;
//    scanf("%d",&T);
//    ll k,n;
//    while (T --)
//    {
//        scanf("%lld",&k);
//        ll v = -1;
//        for (ll i = 2;i * i <= k;i ++)
//        {
//            n = 0;
//            while (k % i == 0)
//            {
//                k /= i;
//                n ++;
//            }
//            if (n == 0) continue;
//            if (v == 1) break;
//            if (v == -1) v = n;
//            else v = gcd(v,n);
//        }
//        if (v == -1) v = 1;
//        printf("%lld\n",v);
//    }
//    return 0;
//}

/*int main()
{
    int n;
    char c1,c2;
    scanf("%d %c %c",&n,&c1,&c2);
    char a[100][100] = {0};
    a[n / 2][n / 2] = c1;
    for (int i = n / 2 - 1,v = 0;i >= 0;i --,v ++)
    {
        char c = (v % 2) ? c1 : c2;
        for (int j = n / 2 - v - 1;j <= n / 2 + v + 1;j ++) {
            a[i][j] = c;
            a[n / 2 + v + 1][j] = c;
        }
        for (int j = i + 1;j < n / 2 + v + 1;j ++) {
            a[j][n / 2 - v - 1] = c;
            a[j][n / 2 + v + 1] = c;
        }
    }
    if (n != 1) {
        a[0][0] = ' ';
        a[0][n - 1] = ' ';
        a[n - 1][0] = ' ';
        a[n - 1][n - 1] = ' ';
    }
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            printf("%c",a[i][j]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
char a[110][110];
char p[5][5];
int m,n;

int dx[] = {-1,-1,1,1,1,-1,0,0}; // 8个方向
int dy[] = {-1,0,0,-1,1,1,-1,1}; // 8个方向

int chk(int x,int y)
{
    if (a[y][x] == '#') return 0; // 如果玩家在墙上，直接0
    int xx,yy; // 玩家四周的坐标
    for (int i = 0;i < 8;i ++)
    {
        xx = x + dx[i]; // 玩家周围坐标的x
        yy = y + dy[i]; // 玩家周围坐标的y
        if (xx >= 0 && xx < m && yy >= 0 && yy < n) // 如果玩家周围一圈在地图内
        {
            if (a[yy][xx] != p[1 + dy[i]][1 + dx[i]]) return 0; // 直接判断和我们要的一不一样即可
        } else {
            if (p[1 + dy[i]][1 + dx[i]] != '*') return 0; // 在墙外也判一下
        }
    }
    return 1; // 没问题当然true
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        // 各种输入
        scanf("%d %d",&n,&m);
        for (int i = 0;i < n;i ++)
        {
            scanf(" ");
            for (int j = 0;j < m;j ++)
            {
                scanf("%c",&a[i][j]);
            }
        }
        for (int i = 0;i < 3;i ++)
        {
            scanf(" ");
            for (int j = 0;j < 3;j ++)
            {
                scanf("%c",&p[i][j]);
            }
        }
        // 定义开始判断的x轴的start和end，y轴的start和end
        int xs = 1,ys = 1,xe = m - 1,ye = n - 1; // 由于没有*的时候玩家不可能在边缘出现，所以他们一定是从1（数组从0开始）开始走，到边界处-1，注意这边的end是不包括的，还是左闭右开区间。
//        / 例如：
//         *     #..#..#
//         *     #....#.
//         *     ###...#
//         *     #......
//         * 玩家可能的活动范围只有中间的：
//         *      ...#.
//         *      ##...
//         * x轴也就是[1,5]
//         * y轴是[1,2]
//         /
        
        // 如果是*，那么就得从边界开始了
        if (p[0][1] == '*') ys --;
        if (p[1][0] == '*') xs --;
        if (p[2][1] == '*') ye ++;
        if (p[1][2] == '*') xe ++;
        // 当然边界的话循环的时候可以只判断边界，由于这题数据不是很大，所以后面直接硬核模拟整个也没问题
        
        int cnt = 0; // 计数
        for (int i = ys;i < ye;i ++)
        {
            for (int j = xs;j < xe;j ++)
            {
                if (chk(j, i)) cnt ++; // 检查
            }
        }
        printf("%d\n",cnt);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        char c;int n;
        scanf(" %c%d",&c,&n);
        string str;
        while (n != 0)
        {
            str = (char) (n % 2 + '0') + str;
            n /= 2;
        }
        while (str.size() != 7) str = '0' + str;
        if (c == '+')
        {
            cout << '0' + str << endl;
            string f;
            for (int i = 0;i < 7;i ++) f += (char) ('0' + 1 - str[i] + '0');
            cout << '0' + f << endl;
            cout << '0' + str << endl;
        } else {
            cout << '1' + str << endl; // 先输出原码
            string f;
            for (int i = 0;i < 7;i ++) f += (char) ('0' + 1 - str[i] + '0');
            cout << (f = '1' + f) << endl; // 反码，同时也把符号位加上，方便之后的补码计算
            int j = 1; // 进位，由于补吗要加1，所以从个位开始，就有进位了
            int i = 7; // 设置index到个位
            
            while (j) // 只要j还有进位，那就一直加
            {
                if (i == -1) { // 特殊判断-0，这个时候就不要在往前搞了，直接跳出
                    f[0] = '0';
                    break;
                }
                f[i] ++; // '0' + 1 = '1'; '1' + 1 = '2';
                j --; // 进位剪掉
                if (f[i] == '2') { // 溢出来了
                    j ++; // 进位
                    f[i] = '0'; // 置0
                }
                i --; // index前移
            }
            cout << f << endl; // 输出
        }
    }
    return 0;
}
*/

/// 任何一个正整数一定能分解成若干个不重复且不相邻的斐波那契数之和+贪心
/// https://www.zhihu.com/question/68360587?sort=created
/*int main()
{
    ll a[] = {1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931,1779979416004714189,2880067194370816120,4660046610375530309,7540113804746346429};
    int T;
    scanf("%d",&T);
    ll n,k;
    ll v;
    while (T --)
    {
        scanf("%lld %lld",&n,&k);
        if (k > n) {
            printf("No\n");
            continue;
        }
        while (k --)
        {
            v = *(upper_bound(a, a + 91, n) - 1);
            n -= v;
            if (n == 0) break;
        }
        if (n == 0) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
*/

/*
ll a[100010];
ll b[100010];
int k[100010];

ll v;
int n,m;

void update(ll i)
{
    ll c1 = 0, c2 = 0;
    i /= 2;
    ll h = 0;
    if (i * 2 <= n && k[i * 2]) c1 = a[i * 2];
    if (i * 2 + 1 <= n && k[i * 2 + 1]) c2 = a[i * 2 + 1];
    a[i] = c1 + c2 + 1;
    h = b[i];
    b[i] = a[i] * (a[i] - 1) / 2;
    while (k[i])
    {
        i /= 2;
        //printf(">>%d\n",i);
        c1 = c2 = 0;
        if (i * 2 <= n && k[i * 2]) c1 = a[i * 2];
        if (i * 2 + 1 <= n && k[i * 2 + 1]) c2 = a[i * 2 + 1];
        a[i] = c1 + c2 + 1;
        h = b[i];
        b[i] = a[i] * (a[i] - 1) / 2;
        //printf("%d %d\n",h,b[i]);
    }
    v -= h;
    v += b[i];
}

void add(ll i)
{
    v -= b[i];
    update(i);
}

void remove(ll i)
{
    v += b[i];
    update(i);
}

int main()
{
    int T;
    scanf("%d",&T);
    ll t;
    while (T --)
    {
        scanf("%d %d",&n,&m);
        mem(k,-1);
        k[0] = 0;
        k[1] = 0;
        for (int i = n;i >= 1;i --)
        {
            t = i * 2 + 1;
            if (t > n) t = 0;
            else t = a[t];
            a[i] = t;
            t = i * 2;
            if (t > n) t = 0;
            else t = a[t];
            a[i] += t + 1;
            b[i] = a[i] * (a[i] - 1) / 2;
        }
        v = b[1];
        //printf("%lld %lld\n",a[1],b[1]);
        for (int i = 0;i < m;i ++)
        {
            scanf("%lld",&t);
            k[t] = !k[t];
            if (k[t]) add(t);
            else remove(t);
            printf("%lld\n",v);
        }
    }
    return 0;
} */

/*
int r[100010];
int x[100010];
int y[100010];

//判断重叠
int cf(int a, int b)
{
    if (((x[b] - r[b] >= x[a] - r[a] && x[b] - r[b] <= x[a] + r[a]) || (x[b] + r[b] >= x[a] - r[a] && x[b] + r[b] <= x[a] + r[a])) && ((y[b] - r[b] >= y[a] - r[a] && y[b] - r[b] <= y[a] + r[a]) || (y[b] + r[b] >= y[a] - r[a] && y[b] + r[b] <= y[a] + r[a])))
    {
        return 1;
    }
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    if (((x[b] - r[b] >= x[a] - r[a] && x[b] - r[b] <= x[a] + r[a]) || (x[b] + r[b] >= x[a] - r[a] && x[b] + r[b] <= x[a] + r[a])) && ((y[b] - r[b] >= y[a] - r[a] && y[b] - r[b] <= y[a] + r[a]) || (y[b] + r[b] >= y[a] - r[a] && y[b] + r[b] <= y[a] + r[a])))
    {
        return 1;
    }
    return 0;
}

// 计算
int ck(int a, int b)
{
    if (cf(a,b))
    {
        return 0;
    }
    int mix = -1;
    //直接暴力x
    for (int i = x[a] - r[a];i <= x[a] + r[a];i ++)
    {
        for (int j = x[b] - r[b];j <= x[b] + r[b];j ++)
        {
            if (mix == -1) mix = abs(i - j);
            else mix = min(mix,abs(i - j));
            if (mix == 0) goto x_done;
        }
    }
    x_done:
    //暴力y
    int miy = -1;
    for (int i = y[a] - r[a];i <= y[a] + r[a];i ++)
    {
        for (int j = y[b] - r[b];j <= y[b] + r[b];j ++)
        {
            if (miy == -1) miy = abs(i - j);
            else miy = min(miy,abs(i - j));
            if (miy == 0) goto y_done;
        }
    }
    y_done:
    return mix + miy;
}

int main()
{
    int T;
    scanf("%d",&T);
    int n,m;
    int op;
    int a,b,c,d;
    while (T --)
    {
        scanf("%d %d",&n,&m);
        for (int i = 1;i <= n;i ++)
        {
            scanf("%d %d %d",x + i,y + i,r + i);
        }
        for (int v = 0;v < m;v ++)
        {
            scanf("%d",&op);
            if (op == 1)
            {
                scanf("%d %d %d %d",&a,&b,&c,&d);
                x[a] = b;
                y[a] = c;
                r[a] = d;
            } else {
                scanf("%d %d",&a,&b);
                int miin = -1;
                for (int i = a;i <= b - 1;i ++)
                {
                    for (int j = i + 1;j <= b;j ++)
                    {
                        if (miin == -1) miin = ck(i,j);
                        else miin = min(miin,ck(i,j));
                        if (miin == 0) goto ok;
                    }
                }
                ok:
                printf("%d\n",miin);
            }
        }
    }
    return 0;
}
*/

/*
int a[1010];
int idx = 1;

void ck(int i)
{
    int p = i / 2;
    if (p == 0) return;
    if (a[i] < a[p]) {
        a[i] ^= a[p];
        a[p] ^= a[i];
        a[i] ^= a[p];
    }
    ck(p);
}

void it(int num)
{
    a[idx] = num;
    ck(idx ++);
}

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int in;
    for (int i = 0;i < n;i ++) {
        scanf("%d",&in);
        it(in);
    }
    scanf(" ");
    string str;
    while (m --)
    {
        getline(cin,str);
        int n1 = 0,n2 = 0;
        int f = 1;
        int f1 = 1;
        int f2 = 1;
        for (int i = 0;str[i] != 0;i ++)
        {
            if (str[i] == '-') {
                if (f) f1 = -1;
                else f2 = -1;
            } else if (str[i] >= '0' && str[i] <= '9')
            {
                if (f) n1 = n1 * 10 + str[i] - '0';
                else n2 = n2 * 10 + str[i] - '0';
            } else {
                f = 0;
            }
        }
        n1 *= f1;
        n2 *= f2;
        //printf(">%d %d\n",n1,n2);
        if (str.find("root") != string::npos)
        {
            if (n1 == a[1]) printf("T");
            else printf("F");
            printf("\n");
        } else if (str.find("siblings") != string::npos)
        {
            int ok = 0;
            for (int i = 2;i <= n;i ++)
            {
                if (a[i] == n1)
                {
                    if (i % 2)
                    {
                        if (a[i - 1] == n2) ok = 1;
                    } else {
                        if (i + 1 <= n && a[i + 1] == n2) ok = 1;
                    }
                    if (ok) break;
                }
            }
            if (ok) printf("T\n");
            else printf("F\n");
        } else if (str.find("child") != string::npos)
        {
            int ok = 0;
            for (int i = 1;i <= n;i ++)
            {
                if (a[i] == n1)
                {
                    int p = i / 2;
                    if (p >= 1 && a[p] == n2) ok = 1;
                    if (ok) break;
                }
            }
            if (ok) printf("T\n");
            else printf("F\n");
        } else if (str.find("parent") != string::npos)
        {
            int ok = 0;
            for (int i = 1;i <= n;i ++)
            {
                if (a[i] == n2)
                {
                    int p = i / 2;
                    if (p >= 1 && a[p] == n1) ok = 1;
                    if (ok) break;
                }
            }
            if (ok) printf("T\n");
            else printf("F\n");
        }
         
    }
    
    return 0;
}
*/

/*
int main()
{
    const int mod = 998244353;
    int n;
    scanf("%d",&n);
    int x,y;
    set<int> pp;
    set<int> pet;
    ll v = 0;
    int k,m;
    set<int>::iterator up,upp;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %d",&x,&y);
        if (x == 0)
        {
            if (pp.size() == 0) pet.insert(y);
            else {
                up = pp.upper_bound(y); // 找一个> y的元素
                upp = up;
                if (upp == pp.end()) -- upp; // 如果找到的是end，那就得--，以免炸了
                m = *upp; // 取出题意中的那个b
                if (up != pp.begin()) -- up; // 如果找到的不是end，那就--，获得<= y的一个元素
                k = *(up); // 取出题意中的a
                if (y - k <= m - y)
                {
                    v = (v + abs(k - y)) % mod;
                    pp.erase(up);
                } else {
                    v = (v + abs(m - y)) % mod;
                    pp.erase(upp);
                }
            }
        } else {
            if (pet.size() == 0) pp.insert(y);
            else {
                up = pet.upper_bound(y);
                upp = up;
                if (upp == pet.end()) -- upp;
                m = *upp;
                if (up != pet.begin()) -- up;
                k = *(up);
                if (y - k <= m - y)
                {
                    v = (v + abs(k - y)) % mod;
                    pet.erase(up);
                } else {
                    v = (v + abs(m - y)) % mod;
                    pet.erase(upp);
                }
            }
        }
//        for (auto i = pp.begin();i != pp.end();i ++) printf("%d ",*i);
//        printf("\n");
//        for (auto i = pet.begin();i != pet.end();i ++) printf("%d ",*i);
//        printf("\n");
    }
    printf("%lld\n",v);
    return 0;
}
*/

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll v;
    ll m;
    set<ll> p;
    for (int i = 2;i * i <= n;i ++)
    {
        if (n % i) continue;
        v = n / i;
        m = 1 + i * (v - 1);
        p.insert((1 + m) * v / 2);
        m = 1 + v * (i - 1);
        p.insert((1 + m) * i / 2);
    }
    p.insert((1 + n) * n / 2);
    printf("1");
    for (set<ll>::iterator i = p.begin();i != p.end();i ++)
    {
        printf(" %lld",*i);
    }
    printf("\n");
    return 0;
}
*/

/*ull k1,k2;
int x[100001],y[100001];
ull value[100001];

ull creat()
{
    ull k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= k3 << 23;
    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}

int main()
{
    int T;
    int n,m;
    scanf("%d",&T);
    while (T --)
    {
        scanf("%d%d%lld%lld",&n,&m,&k1,&k2);
        ull maax = 0;
        map<pair<int,int>,map<ull,ull> > k;
        map<pair<int,int>,map<ull,ull> > v;
        ull t;
        pair<int,int> p;
        for (int i = 0;i < m;i ++)
        {
            x[i] = creat() % n + 1;
            y[i] = creat() % n + 1;
            p = make_pair(min(x[i], y[i]),max(x[i], y[i]));
            value[i] = creat();
            if ((t = ++ k[p][value[i]]) != 1) maax = mx(v[p][value[i]] = sqrt(pow(value[i],t)),maax);
            else maax = mx(v[p][value[i]] = value[i],maax);
        }
        printf("%llu\n",maax);
    }
    return 0;
}
*/

/*
string str;
string a['Z' + 1];
int n;

int cal(char a1, char a2, char a3, char b1, char b2, char b3)
{
    if (a1 == b1 && a2 == b2 && a3 == b3) return 0;
    if (a2 == b1 && a3 == b2) return 2;
    if (a3 == b1) return 3;
    return 4;
}

map<string,int> dp[100000];

int dfs(int i,string vct)
{
    string p = a[str[i + 1]];
    sort(p.begin(),p.end());
    if (i == n - 2) {
        int miin = 100;
        do {
            miin = min(cal(vct[0],vct[1],vct[2],p[0],p[1],p[2]),miin);
        } while (next_permutation(p.begin(), p.end()));
        return miin;
    }
    int v = -1;
    do {
        if (v == -1) v = cal(vct[0],vct[1],vct[2],p[0],p[1],p[2]) + (dp[i + 1][vct] == 0 ? (dp[i + 1][p] = dfs(i + 1,p)) : dp[i + 1][vct]);
        else v = min(cal(vct[0],vct[1],vct[2],p[0],p[1],p[2]) + (dp[i + 1][vct] == 0 ? (dp[i + 1][p] = dfs(i + 1,p)) : dp[i + 1][vct]),v);
    } while (next_permutation(p.begin(), p.end()));
    return v;
}

int main()
{
    cin >> str;
    n = (int) str.size();
    int all = n;
    a['Y'] = "QQQ";
    a['V'] = "QQW";
    a['G'] = "QQE";
    a['C'] = "WWW";
    a['X'] = "QWW";
    a['Z'] = "EWW";
    a['T'] = "EEE";
    a['F'] = "QEE";
    a['D'] = "WEE";
    a['B'] = "QWE";
    string p = a[str[0]];
    sort(p.begin(),p.end());
    int miin = -1;
    do {
        if (miin == -1) miin = dfs(0,p);
        else miin = min(miin,dfs(0,p));
    } while (next_permutation(p.begin(), p.end()));
    printf("%d\n",all + miin + 4);
    return 0;
}
*/

/*
int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

int main()
{
    int n,m,k;
    while (~scanf("%d %d %d",&n,&m,&k))
    {
        int a[110][110] = {0};
        int x,y;
        for (int i = 0;i < k;i ++)
        {
            scanf("%d %d",&x,&y);
            a[y][x] = 1;
        }
        pair<int,int> f;
        int xx,yy;
        int count = 0;
        int maax = 0;
        for (int i = 1;i <= m;i ++)
        {
            for (int j = 1;j <= n;j ++)
            {
                if (a[i][j] == 1)
                {
                    queue<pair<int,int> > q;
                    q.push(make_pair(j,i));
                    a[i][j] = 0;
                    count = 1;
                    while (!q.empty())
                    {
                        f = q.front();
                        for (int k = 0;k < 4;k ++)
                        {
                            xx = dx[k] + f.first;
                            yy = dy[k] + f.second;
                            if (xx >= 1 && yy >= 1 && xx <= n && yy <= m)
                            {
                                if (a[yy][xx]){
                                    q.push(make_pair(xx, yy));
                                    count ++;
                                    a[yy][xx] = 0;
                                }
                            }
                        }
                        q.pop();
                    }
                    maax = max(maax, count);
                }
            }
        }
        printf("%d\n",maax);
    }
    return 0;
}
*/

/*
const int mod = 1000000007;

ll f(int k)
{
    ll a = 1;
    while (k != 0)
    {
        a *= k % 10;
        k /= 10;
    }
    return a;
}

int main()
{
    int T;
    scanf("%d",&T);
    int a,b;
    ll t;
    ll s;
    while (T --)
    {
        s = 1;
        scanf("%d %d",&a,&b);
        for (int i = a;i <= b;i ++)
        {
            t = f(i);
            if (t == 0) {
                s = 0;
                break;
            }
            s = (s * t) % mod;
            if (s == 0) break;
        }
        printf("%lld\n",s);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int x,y,z,s,k;
    while (T --)
    {
        scanf("%d %d %d",&x,&y,&z);
        s = x + y;
        k = s - z;
        if (k < 0) {
            printf("-1\n");
            continue;
        }
        if (k == 0)
        {
            if (s + 1 <= 2000000000) printf("%d\n",s + 1);
            else printf("-1\n");
        } else {
            if (k > x && k > z) printf("%d\n",k);
            else printf("-1\n");
        }
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        int n,m;
        scanf("%d %d",&n,&m);
        char c[100010];
        int vis[100010] = {0};
        int stp[100010];
        int in;
        int r[100010] = {0};
        for (int i = 0;i < n;i ++)
        {
            scanf(" ");
            for (int j = 0;j < m;j ++)
            {
                scanf("%c",c + i * m + j);
            }
        }
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < m;j ++)
            {
                scanf("%d",&in);
                stp[i * m + j] = in;
                switch (c[i * m + j])
                {
                    case 'r':
                        if (j + in < m) r[i * m + j + in] ++;
                        break;
                    case 'l':
                        if (j - in >= 0) r[i * m + j - in] ++;
                        break;
                    case 'u':
                        if (i - in >= 0) r[(i - in) * m + j] ++;
                        break;
                    case 'd':
                        if (i + in < n) r[(i + in) * m + j] ++;
                        break;
                }
            }
        }
        int ok = 0;
        int s = 0;
        for (int i = 0;i < m * n;i ++)
        {
            if (r[i] == 0) {
                ok ++;
                s = i;
            }
            if (ok >= 2) break;
            //printf("%d ",r[i]);
        }
        if (ok <= 1) {
            int x = s % m,y = s / m;
            int o = 1;
            while (o)
            {
                if (vis[x + y * m]) break;
                vis[x + y * m] = 1;
                in = stp[x + y * m];
                switch (c[y * m + x])
                {
                    case 'r':
                        if (x + in < m) x += in;
                        else o = 0;
                        break;
                    case 'l':
                        if (x - in >= 0) x -= in;
                        else o = 0;
                        break;
                    case 'u':
                        if (y - in >= 0) y -= in;
                        else o = 0;
                        break;
                    case 'd':
                        if (y + in < n) y += in;
                        else o = 0;
                        break;
                }
            }
            int ok2 = 1;
            for (int i = 0;i < n * m;i ++)
            {
                if (!vis[i])
                {
                    ok2 = 0;
                    break;
                }
            }
            if (ok2) printf("Yes\n");
            else printf("No\n");
        }
        else printf("No\n");
    }
    return 0;
}
*/

/*int main()
{
    int T;
    scanf("%d",&T);
    int n,k;
    char str[2000010];
    while (T --)
    {
        scanf("%d %d",&n,&k);
        scanf("%s",str);
        
        int l = 1,r = n;
        int m;
        int c = 0;
        while (l < r)
        {
            m = (l + r) / 2;
            c = 0;
            for (int i = 0;i < n;i += m,c ++)
            {
                while (i < n && str[i] == '0') i ++;
                if (i >= n) break;
            }
            if (c <= k) r = m;
            else l = m + 1;
        }
        printf("%d\n",l);
    }
    return 0;
}
*/

/*int main()
{
    int T;
    scanf("%d",&T);
    string str;
    while (T --)
    {
        cin >> str;
        ll l = str.size();
        ll c = l * (l + 1) / 2;
        ll l0 = 0;
        ll l8 = 0;
        ll c6 = 0;
        ll c9 = 0;
        for (int i = 0;i < l;i ++)
        {
            if (str[i] == '6') c6 ++;
            else if (str[i] == '9') c9 ++;
            else if (str[i] == '0') l0 ++;
            else if (str[i] == '8') l8 ++;
        }
        c = c - c6 * c9 - l0 * (l0 + 1) / 2 - l8 * (l8 + 1) / 2;
        if (l0 != 0 || l8 != 0) c ++;
        else if (c6 * c9 != 0) c ++;
        printf("%lld\n",c);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k,m;
    scanf("%d %d %d",&n,&k,&m);
    double v[10010];
    for (int i = 0;i < n;i ++)
    {
        int in,maax = -1,miin = 1000000;
        double sum = 0;
        for (int j = 0;j < k;j ++) {
            scanf("%d",&in);
            if (maax == -1) maax = in;
            else maax = max(maax,in);
            miin = min(miin,in);
            sum += in;
        }
        sum -= (maax + miin);
        v[i] = sum / (k - 2);
    }
    sort(v,v + n);
    int f = 1;
    while (m --)
    {
        if (f) f = 0;
        else printf(" ");
        printf("%.3f",v[n - m - 1]);
    }
    printf("\n");
    return 0;
}
*/


/*
int str[1000010],p[10010];
int n;
int m;

void make(int *n)
{
    n[0] = 0;
    n[1] = 0;
    for (int i = 1,k = 0;i < m;i ++)
    {
        if (p[i] == p[k])
        {
            n[i + 1] = ++ k;
        } else {
            n[i + 1] = (k = n[k]);
        }
    }
}

int kmp()
{
    int nxt[10010];
    int ok = -1;
    make(nxt);
//    for (int i = 0;i < m + 1;i ++)
//    {
//        printf("%d ",nxt[i]);
//    }
//    printf("\n");
    //int f = 0;
    for (int i = 0,j = 0;i < n;i ++)
    {
//        cout << i << " " << j << endl;
        if (str[i] == p[j]) {
            j ++;
            if (j == m) {
                ok = i - m + 2;
                break;
                //f = 1;
                //j = nxt[j];
            }
        }
        else {
            j = nxt[j];
            if (str[i] == p[j]) j ++;
            else j = 0;
        }
        
    }
    return ok;
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        scanf("%d %d",&n,&m);
        for (int i = 0;i < n;i ++) scanf("%d",str + i);
        for (int i = 0;i < m;i ++) scanf("%d",p + i);
        printf("%d\n",kmp());
    }
    return 0;
}
*/

/*int main()
{
    char str[1000010];
    scanf("%s",str);
    string k = "";
    int s = 0;
    int c = 0;
    for (int i = 1,j = 0;str[i];i ++)
    {
        if (str[j] != str[i]) {
            j = 0;
            s = 0;
            c = 0;
            k = "";
            if (str[j] == str[i]) i --;
        } else {
            s = i - j;
            if (j < s) k += str[i];
            j ++;
            c ++;
            if (c == s) c = 0;
        }
    }
    if (c != 0 || s != k.size() || k == "") printf("-1\n"); // 没找到
    else cout << k << endl; // 输出最小周期的子串
    return 0;
}*/


/*int cmp(pair<int,int> a,pair<int,int> b)
{
    return a.first * b.second > a.second * b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    pair<int,int> a[100010];
    itn in;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&in);
        (a + i) -> first = in;
        scanf("%d",&in);
        (a + i) -> second = in;
    }
    sort(a,a + n,cmp);
    ll all = 0;
    ll cnt = 0;
    for (int i = 0;i < n;i ++)
    {
        cnt += a[i].second;
        all += a[i].first * cnt;
    }
    printf("%lld\n",all);
    return 0;
}*/

/*struct z {
    int c,m,e,id;
} a[310];

int sum(z k)
{
    return k.c + k.m + k.e;
}

int cmp(z a,z b)
{
    if (sum(a) == sum(b)) {
        if (a.c == b.c) return a.id < b.id;
        return a.c > b.c;
    }
    return sum(a) > sum(b);
}

int main()
{
    int n;
    scanf("%d",&n);
    z *t;
    for (int i = 1;i <= n;i ++)
    {
        t = a + i;
        scanf("%d %d %d",&t -> c,&t -> m,&t -> e);
        t -> id = i;
    }
    sort(a + 1,a + n + 1,cmp);
    for (int i = 1;i <= 5;i ++)
    {
        printf("%d %d\n",a[i].id,sum(a[i]));
    }
    return 0;
}
*/


/*int main()
{
    string str;
    getline(cin,str);
    ll c = 0;
    for (int i = 0;str[i];i ++)
    {
        if (str[i] != ' ' && str[i] != '\n') c ++;
    }
    printf("%lld\n",c);
    return 0;
}*/


//int main()
//{
//    itn n;
//    scanf("%d",&n);
//    int a[1000010];
//    int l[1000010],r[1000010];
//    int ok[1000010] = {0};
//    for (int i = 1;i <= n;i ++)
//    {
//        scanf("%d",a + i);
//    }
//    for (int i = 1;i <= n;i ++)
//    {
//        scanf("%d %d",l + i,r + i);
//        if (l[i] == -1 && r[i] == -1) ok[i] = 1;
//    }
//
//    return 0;
//}

/*
int main()
{
    int n,m;
    ll p1,s1,s2;
    ll a[100010];
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++)
    {
        scanf("%lld",a + i);
    }
    scanf("%d %lld %lld %lld",&m,&p1,&s1,&s2);
    a[p1] += s1;
    ll t1 = 0,t2 = 0;
    for (int i = 1;i < m;i ++)
    {
        t1 += a[i] * (m - i);
    }
    for (int i = m + 1;i <= n;i ++)
    {
        t2 += a[i] * (i - m);
    }
    cout << t1 << " " << t2 << endl;
    if (s2 == 0) printf("1");
    else if (t1 >= t2) {
        ll miin = t1 - t2;
        int idx = m;
        ll v;
        for (int i = m;i <= n;i ++)
        {
            if ((v = abs(s2 * (i - m) + t2 - t1)) < miin)
            {
                miin = v;
                idx = i;
            }
        }
        printf("%d",idx);
    } else {
        ll miin = t2 - t1;
        int idx = m;
        ll v;
        for (int i = m;i >= 1;i --)
        {
            if ((v = abs(s2 * (m - i) + t1 - t2)) <= miin)
            {
                miin = v;
                idx = i;
            }
        }
        printf("%d",idx);
    }
        
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    ll c = 0;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",a + i);
        if (i == 0) c = a[i];
        else if (a[i] > a[i - 1]) c += a[i] - a[i - 1];
    }
    printf("%lld\n",c);
    return 0;
}
*/

/*int n;
int a[110];
int dp[50010] = {0};

void dfs(int x)
{
    if (x >= 25000) return;
    int s;
    for (int i = 0;i < n;i ++)
    {
        s = x + a[i];
        if (dp[s]) continue;
        if (x != 0) dp[s] = 1;
        dfs(s);
    }
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        mem(dp,0);
        scanf("%d",&n);
        for (int i = 0;i < n;i ++)
        {
            scanf("%d",a + i);
        }
        dfs(0);
        int c = 0;
        for (int i = 0;i < n;i ++)
        {
            if (!dp[a[i]]) c ++;
        }
        printf("%d\n",c);
    }
    return 0;
}
*/

/*int a[1000010],lll[1000010],rrr[1000010];
int cd[1000010];

int check(int l,int r)
{
    if (l == -1 && r == -1) return 1;
    return l != -1 && r != -1 && a[l] == a[r] && check(lll[l],rrr[r]) && check(lll[r], rrr[l]);
}

int sz(int x)
{
    int s = 1;
    if (lll[x] != -1) s += sz(lll[x]);
    if (rrr[x] != -1) s += sz(rrr[x]);
    cd[x] = s;
    return s;
}

int main()
{
    int n;
    scanf("%d",&n);
    
    for (int i = 1;i <= n;i ++)
    {
        scanf("%d",a + i);
    }
    for (int i = 1;i <= n;i ++)
    {
        scanf("%d %d",lll + i,rrr + i);
    }
    sz(1);
    int maax = -1;
    for (int i = 1;i <= n;i ++)
    {
        if (check(lll[i], rrr[i])) maax = max(maax,cd[i]);
    }
    printf("%d\n",maax);
    return 0;
}
*/

//int a[510];
//int nn = 0;
//int d[40000010] = {0};
//
//void dfs(int s)
//{
//    if (s == nn)
//    {
//
//
//        return;
//    }
//    for (int i = s;i <= nn;i ++)
//    {
//
//    }
//}
//
//int main()
//{
//    itn n,m;
//    scanf("%d%d",&n,&m);
//    set<int> arr;
//    int in;
//
//    for (int i = 0;i < n;i ++)
//    {
//        scanf("%d",&in);
//        d[in] ++;
//        arr.insert(in);
//    }
//
//    for (auto i = arr.begin();i != arr.end();i ++)
//    {
//        a[nn ++] = *i;
//    }
//
//
//
//
//    return 0;
//}

//int dx[] = {0,1,0,-1,0,0,0};
//int dy[] = {0,0,1,0,-1,0,0};
//int dz[] = {1,0,0,0,0,-1,0};
//
//typedef pair<pair<int,int>,int> pos;
//
//pos getPair(int x,int y,int z)
//{
//    return make_pair(make_pair(x, y), z);
//}
//
//void getPos(pos p,int &x,int &y,int &z)
//{
//    x = p.first.first;
//    y = p.first.second;
//    z = p.second;
//}
//
//int main()
//{
//    int n,m;
//    scanf("%d %d",&n,&m);
//
//    map<pair<pos,int>,int> a;
//    int x,y,z,v;
//    struct lk {
//        pair<pos,int> n;
//        lk *nxt;
//    } *g[1010] = {NULL};
//    lk *l;
//    pair<pos,int> in[1010];
//    for (int i = 1;i <= n;i ++)
//    {
//        scanf("%d%d%d%d",&x,&y,&z,&v);
//        in[i] = make_pair(getPair(x, y, z),v);
//        a[in[i]] = i;
//        l = (lk*) malloc(sizeof(lk));
//        l -> nxt = g[i];
//        l -> n = in[i];
//        g[i] = l;
//    }
//    int xx,yy,zz,d,t;
//    lk **s;
//    for (int i = 1;i <= n;i ++)
//    {
//        getPos(in[i].first, x, y, z);
//        t = a[in[i]];
//        if (g[t] == NULL) continue;
//        for (int j = 1;j <= n;j ++)
//        {
//            if (i == j) continue;
//
//
////            printf("/////////////////////////////\n");
////            for (int i = 1;i <= n;i ++) {
////                l = g[i];
////                if (l != NULL)
////                {
////                    printf("%d,%d: ",i,a[in[i]]);
////                    while (l != NULL)
////                    {
////                        getPos(l -> n.first, x, y, z);
////                        printf(" <%d %d %d %d>,",x,y,z,l -> n.second);
////                        l = l -> nxt;
////                    }
////                    printf("\n");
////                }
////            }
//
//            getPos(in[j].first, xx, yy, zz);
//            d = abs(xx - x) + abs(yy - y) + abs(zz - z);
//            printf("--%d %d %d-%d\n",xx,yy,zz,a[in[j]]);
//            printf("--%d %d %d-%d\n",x,y,z,t);
//            if ((d == 0 || d == 1))
//            {
//                if (abs(in[i].second - in[j].second) <= m)
//                {
//                    s = g + a[in[j]];
//                    l = *s;
//                    if (l != NULL)
//                    {
//                        while (l != NULL)
//                        {
//                            a[l -> n] = t;
//                            if (l -> nxt == NULL) break;
//                            l = l -> nxt;
//                        }
//                        printf("%d\n",t);
//                        l -> nxt = g[t];
//                        g[t] = *s;
//                        *s = NULL;
//                    }
//
//                }
//            }
//        }
//
////        for (auto i = a.begin();i != a.end();i ++)
////        {
////            printf(">>%d %d %d %d\n",i -> first.first.first.first,i -> first.first.first.second,i -> first.first.second,i -> second);
////        }
//    }
//
//    for (int i = 1;i <= n;i ++) {
//
//        l = g[i];
//        if (l != NULL)
//        {
//            printf("%d: ",i);
//            while (l != NULL)
//            {
//                getPos(l -> n.first, x, y, z);
//                printf(" <%d %d %d %d>,",x,y,z,l -> n.second);
//                l = l -> nxt;
//            }
//            printf("\n");
//        }
//    }
//
//    set<int> all;
//    for (auto i = a.begin();i != a.end();i ++)
//    {
//        printf("<%d %d %d %d\n",i -> first.first.first.first,i -> first.first.first.second,i -> first.first.second,i -> second);
//        all.insert(i -> second);
//    }
//
//
//    printf("%lu\n",all.size());
//
//    return 0;
//}

/*
int main()
{
    int n;
    scanf("%d",&n);
    set<int> a;
    int in;
    set<int>::iterator k;
    while (n --)
    {
        scanf("%d",&in);
        k = a.upper_bound(in);
        if (k != a.end()) a.erase(k);
        a.insert(in);
    }
    printf("%lu\n",a.size());
    return 0;
}
*/

/*int father[100010];
int mother[100010];
int sex[100010];

int mode;
int ok = 0;

set<int> parents;

void upper(int id, int dps)
{
    if (dps == 5 || ok) return;
    
    if (mode) parents.insert(id);
    else {
        ok = parents.find(id) != parents.end();
        if (ok) return;
    }
    if (father[id] != -1) upper(father[id], dps + 1);
    if (mother[id] != -1) upper(mother[id], dps + 1);
}

int main()
{
    int n;
    scanf("%d",&n);
    int id,m,f;
    char s;
    mem(father,-1);
    mem(mother,-1);
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %c %d %d",&id,&s,&f,&m);
        if (s == 'M') s = 1;
        else s = 0;
        sex[f] = 1;
        sex[m] = 0;
        sex[id] = s;
        father[id] = f;
        mother[id] = m;
    }
    int t;
    scanf("%d",&t);
    int id2;
    while (t --)
    {
        scanf("%d %d",&id,&id2);
        if (sex[id] == sex[id2]) {
            printf("Never Mind\n");
            continue;
        }
        parents.clear();
        mode = 1;
        ok = 0;
        upper(id, 0);
        mode = 0;
        upper(id2, 0);
        if (ok) printf("No\n");
        else printf("Yes\n");
    }
    
    return 0;
}
*/

/*
int a[1100000] = {0};

inline void insert(int in)
{
    int i = 1;
    int v = 0;
    while (a[i] != 0) {
        v = in < a[i];
        i *= 2;
        i += v;
    }
    a[i] = in;
}

int main()
{
    int n;
    scanf("%d",&n);
    int in = 0;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&in);
        insert(in);
    }
    int ok = 1,k = 1;
    for (int i = 0;i < n;i ++)
    {
        while (a[k] == 0)
        {
            k ++;
            ok = 0;
        }
        if (i != 0) printf(" ");
        printf("%d",a[k ++]);
    }
    printf("\n");
    if (ok) printf("YES\n");
    else printf("NO\n");
    return 0;
}
*/

//inline int a2n(char a[3])
//{
//    return (a[0] - 'A' + 1) * 26 * 26 + (a[1] - 'A' + 1) * 26 + a[2] - 'A' + 1;
//}
//
//inline char *n2a(int n,char *a)
//{
//    int i = 2;
//    while (n != 0)
//    {
//        a[i --] = n % 26 + 'A' - 1;
//        n /= 26;
//    }
//    return a;
//}
//
//struct Node {
//    int n;
//    int w;
//    Node *nxt;
//} *g[20000] = {NULL};
//
//int main()
//{
//    int n,k;
//    char s_i[4],e_i[4];
//    int s,e;
//    char in[4],in2[4];
//    int e_in,t,t2;
//
//    int em[20000];
//    scanf("%d %d %s %s",&n,&k,s_i,e_i);
//    s = a2n(s_i);
//    e = a2n(e_i);
//    for (int i = 0;i < n - 1;i ++)
//    {
//        scanf("%s %d",in,&e_in);
//        em[a2n(in)] = e_in;
//    }
//
//    Node *node;
//    for (int i = 0;i < k;i ++)
//    {
//        scanf("%s %s %d",in,in2,&e_in);
//        t = a2n(in);
//        t2 = a2n(in2);
//        node = (Node*) malloc(sizeof(Node));
//        node -> n = t2;
//        node -> w = e_in;
//        node -> nxt = g[t];
//        g[t] = node;
//
//        node = (Node*) malloc(sizeof(Node));
//        node -> n = t;
//        node -> w = e_in;
//        node -> nxt = g[t2];
//        g[t2] = node;
//    }
//    #define debug
//    queue<int> q;
//    q.push(s);
//    int dis[20000];
//    int ems[20000] = {0};
//    vector<int> path[20000];
//    int paths[20000] = {0};
//    mem(dis,-1);
//    mem(paths,0);
//    dis[s] = 0;
//    paths[s] = 1;
//    path[s].push_back(s);
//    int tg,cr,apd;
//    while (!q.empty())
//    {
//        cr = q.front();
//        printf("%s ",n2a(cr,in));
//        node = g[cr];
//        while (node != NULL)
//        {
//            tg = node -> n;
//            apd = dis[cr] + node -> w;
//            if (dis[tg] == -1 || apd < dis[tg])
//            {
//                paths[tg] = paths[cr];
//                path[tg] = path[cr];
//                path[tg].push_back(tg);
//                dis[tg] = apd;
//                ems[tg] = ems[cr] + em[tg];
//                q.push(tg);
//            } else if (apd == dis[tg]) {
//
//
//                #ifdef debug
//                    for (int i = 0;i < 20000;i ++)
//                    {
//                        if (dis[i] != -1) {
//                            printf("%s: ",n2a(i, in));
//                            printf("%d, %d, %d\n",dis[i],paths[i],ems[i]);
//                        }
//                    }
//                printf("///\n");
//                #endif
//
//                if (path[cr].size() + 1 > path[tg].size())
//                {
//                    path[tg] = path[cr];
//                    path[tg].push_back(tg);
//                    ems[tg] = ems[cr] + em[tg];
////                    paths[tg] = paths[cr];
//                    q.push(tg);
//                } else if (path[cr].size() + 1 == path[tg].size())
//                {
//                    if (ems[cr] + em[tg] > ems[tg])
//                    {
//                        path[tg] = path[cr];
//                        path[tg].push_back(tg);
//                        ems[tg] = ems[cr] + em[tg];
////                        paths[tg] = paths[cr];
//                        q.push(tg);
//                    }
//                }
//            }
//            node = node -> nxt;
//        }
//        q.pop();
//    }
//#ifdef debug
//    for (int i = 0;i < 20000;i ++)
//    {
//        if (dis[i] != -1) {
//            printf("%s: ",n2a(i, in));
//            printf("%d, %d, %d\n",dis[i],paths[i],ems[i]);
//        }
//    }
//#endif
//    int f = 1;
//    for (auto i = path[e].begin();i != path[e].end();i ++)
//    {
//        if (f) f = 0;
//        else printf("->");
//        printf("%s",n2a(*i,in));
//    }
//    printf("\n%d %d %d\n",paths[e],dis[e],ems[e]);
//    return 0;
//}

/*
int main()
{
    string str;
    cin >> str;
    string m1 = "XiaoQiao";
    string m2 = "XiaoHuiHui";
    int a = 0,b = 0;
    
    for (int i = 0;str[i];i ++)
    {
        if (str[i] == m1[a]) a ++;
        if (str[i] == m2[b]) b ++;
    }
    
    if (a == m1.size() && b == m2.size()) printf("Happy\n");
    else printf("emm\n");
    retunr 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    ll x,y,a[100010];
    for (int i = 0;i < n;i ++)
    {
        scanf("%lld %lld",&x,&y);
        a[i] = y * (x - y) * (x - y);
    }
    sort(a,a + n);
    ll sum = 0;
    for (int i = 1;i < n;i ++)
    {
        sum += a[i] - a[i - 1];
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
ll a,b;

inline double y1(double x)
{
    return -x / 2 + a / 4.0;
}

inline double y2(double x)
{
    return -3 * x + b;
}

inline ll finf(double x,double y)
{
    ll z = 0;
    for (ll i = floor(x);i <= ceil(x);i ++)
    {
        for (ll j = floor(y);j <= ceil(y);j ++)
        {
            if (j <= y1(i) && j <= y2(i))
            {
                z = max(z,i + j);
            }
        }
    }
    return z;
}

int main()
{
    int t;
    scanf("%d",&t);
    while (t --)
    {
        scanf("%lld %lld",&a,&b);
        double x = (4 * b - a) / 10.0,
        y = (3 * a - 2 * b) / 10.0;
        ll z = 0;
        if (x >= 0 && y >= 0)
        {
//            printf("%f %f\n",x,y);
            z = finf(x,y);
        } else if (x < 0 && y >= 0)
        {
            z = b;
        } else if (x >= 0 && y < 0)
        {
            z = floor(a / 2.0);
        }
        
        printf("%lld\n",z);
    }
    return 0;
}
*/

//int main()
//{
//    int a[1000] = {0};
//    a[1] = -1; //后手
//    a[2] = 1; //先手
//    printf("XiaoQiao\n");
//    fir (int i = 2;i <= 100;i ++)
//    {
//        int aa = i / 2;
//        int bb = i - aa;
//        if (a[aa] != a[bb]) {
//            a[i] = 1;
//            printf("XiaoHuiHui\n");
//        } else {
//            if (a[aa] == 1)
//            {
//                printf("XiaoQiao\n");
//                a[i] = -1;
//            } else if (a[aa] == -1)
//            {
//                printf("XiaoHuiHui\n");
//                a[i] = 1;
//            }
//        }
//
//    }
//    reutnr 0;
//}

/*
const long long mod = 1e9+7;

ll a[100010] = {0};

long long func(int x) {
    if (x == 1 || x == 0){
        return 1;
    }
    return (x * (a[x - 1] == 0 ? (a[x - 1] = func(x - 1)) : a[x - 1]) + (x - 1) * (a[x - 2] == 0 ? (a[x - 2] = func(x - 2)) : a[x - 2])) % mod;
}

int n;

int main() {
    cin>>n;
    cout << func(n);
    return 0;
}
*/

/*
int  main()
{
    ll k;
    scanf("%lld",&k);
    if (k % 2) printf("-1\n");
    else printf("1\n");
    return 0;
}
*/

//ll s2l(char *a,int l)
//{
//    ll d = 1;
//    ll s = 0;
//    for (int i = 0;i < l;i ++)
//    {
//        s += (a[l - i - 1] - '0') * d;
//        d *= 10;
//    }
//    return s;
//}
//
//int main()
//{
//    int T;
//    scanf("%d",&T);
//    char n[20];
//    ll sum = 0;
//    ll l,m,r,rs;
//    int s;
//    while (T --)
//    {
//        sum = 0;
//        scanf("%s",n);
//        s = (int) strlen(n);
//        for (int i = 0;i < s - 2;i ++)
//        {
//            l = s2l(n, i);
//            m = s2l(n + i, 3);
//            r = s2l(n + i + 3,s - i - 3);
//            printf("%lld %lld %lld\n",l,m,r);
//            if (i == 0)
//            {
//                if (s2l(n, 3) < 520) continue;
//            }
//            printf("++r %.0lf\n",pow(10,s - i - 3));
//            rs = pow(10,s - i - 3);
//            if (m > 520) {
//                sum += (1 + l) * rs;
//            } else {
//                sum += l * rs;
//                if (m == 520)
//                {
//                    sum += r + 1;
//                }
//            }
//        }
//        printf("%lld\n",sum);
//    }
//    return 0;
//}

/*
int main()
{
    int T;
    scanf("%d",&T);
    ll c;
    ll s;
    int a;
    while (T --)
    {
        scanf("%lld",&c);
        int nok = 1;
        ll x = c * c;
        for (ll i = c - 1;i >= 1;i --)
        {
            s = x - i * i;
            a = sqrt(s);
            if (a * a == s) {
                nok = 0;
//                printf("%d %d %d\n",a,i,c);
                break;
            }
        }
        if (nok) printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}
*/

/*
int main()
{
    int x,y;
    scanf("%d %d",&x,&y);
    int m = min(x,y);
    if (m % 2) {
        printf("ii\n");
    } else {
        if ((x + y) % 2) printf("ii\n");
        else printf("gg\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    int arr[100010];
    ll sum[100010];
    scanf("%d %d",&n,&k);
    for (int i = 0;i < n;i ++) scanf("%d",arr + i);
    sort(arr,arr + n,greater<int>());
    sum[1] = arr[0];
    sum[0] = 0;
    for (int i = 2;i <= n;i ++)
    {
        sum[i] = sum[i - 1] + arr[i - 1];
    }
//    for (int i = 0;i <= n;i ++)
//        printf("%lld ",sum[i]);
    ll maax = 0;
    int a,b;
    for (int i = 0;i < k;i ++)
    {
        scanf("%d %d",&a,&b);
//        printf("%lld\n",sum[b] - sum[a - 1]);
        maax = max(maax,sum[b] - sum[a - 1]);
    }
    printf("%lld\n",maax);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    double x1,x2,x3,y1,y2,y3;
    double s[100010];
    int a[100010];
    double A,B,C;
    int p = 0;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %lf %lf %lf %lf %lf %lf",a + i,&x1,&y1,&x2,&y2,&x3,&y3);
        if (i == 0) p = a[i];
        A = y1 - y2;
        B = x1 - x2;
        C = B * y1 - A * x1;
        s[i] = fabs(A * x3 - B * y3 + C);
    }
    sort(a,a + n);
    sort(s,s + n);
//
//    for (int i = 0;i < n;i ++)
//    {
//        printf("%d %lf\n",a[i],s[i]);
//    }
    
    for (int i = 0;i < n;i ++)
    {
        if (a[i] == p)
        {
            printf("%.0f\n",s[i]);
            break;
        }
    }
    return 0;
}
*/

/*
int main()
{
    int n,L,t;
    scanf("%d%d%d",&n,&L,&t);
    int s = 0;
    int p,d;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %d",&p,&d);
        if (d == 1)
        {
            if (p + t < L) s ++;
        } else if (d == 2)
        {
            if (p - t > 0) s ++;
        }
    }
    printf("%d\n",s + 1);
    
    return 0;
}
*/

/*
int a[110][110];
int d[110][110] = {0};

int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

int xe,ye;

int n,m;

void dfs(int x,int y,int dps)
{
    if ((x == xe - 1 && y == ye - 1) || (d[y][x] != -1 && d[y][x] <= dps))
    {
        if (d[y][x] > dps || d[y][x] == -1) d[y][x] = dps;
        return;
    }
    d[y][x] = dps;
    for (int i = 0;i < 4;i ++)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if (xx >= 0 && yy >= 0 && xx < m && yy < n && a[yy][xx] != 1)
        {
            dfs(xx,yy,dps + 1);
        }
    }
}

int main()
{
    scanf("%d %d",&n,&m);
    scanf("%d %d",&ye,&xe);
    mem(d,-1);
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < m;j ++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    dfs(0, 0, 0);
    printf("%d\n",d[ye - 1][xe - 1]);
    return 0;
}
*/

/*
int n;
set<int> a;


inline bool jd(int y)
{
    a.clear();
    if (y < 1000) a.insert(0);
    while (y != 0)
    {
        a.insert(y % 10);
        y /= 10;
    }
    return a.size() == n;
}

int main()
{
    int y;
    scanf("%d %d",&y,&n);
    int i = 0;
    for (;!jd(y);y ++,i ++);
    printf("%d %04d\n",i,y);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int tag[1010] = {0};
    int k,in;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&k);
        for (int j = 0;j < k;j ++)
        {
            scanf("%d",&in);
            tag[in] ++;
        }
    }
    int maax = -1,maax_tag = 0;
    for (int i = 1;i <= 1000;i ++)
    {
        if (tag[i] >= maax)
        {
            maax = tag[i];
            maax_tag = i;
        }
    }
    printf("%d %d\n",maax_tag,maax);
    return 0;
}
*/

/*
int main()
{
    cio
    string s;
    string p2 = "",p14 = "";
    int i = 0;
    while (cin >> s)
    {
        if (s == ".") break;
        i ++;
        if (i == 2) p2 = s;
        else if (i == 14) p14 = s;
    }
    if (p2 == "") cout << "Momo... No one is for you ...\n";
    else if (p2 != "" && p14 == "") cout << p2 << " is the only one for you...\n";
    else if (p2 != "" && p14 != "") cout << p2 << " and " << p14 << " are inviting you to dinner...\n";
    return 0;
}
*/


//int main()
//{
//    int n,r;
//    scanf("%d %d",&n,&r);
//    double x[110];
//    double y[110];
//    for (int i = 1;i <= n;i ++)
//    {
//        scanf("%lf %lf",x + i,y + i);
//    }
//    double xm = (x[1] + x[2]) / 2,
//        ym = (y[1] + y[2]) / 2;
//    double x0 = xm + sqrt((r * r - (x[1] - xm) * (x[1] - xm) - (y[1] - ym) * (y[1] - ym)) / ((x[1] - x[2]) * (x[1] - x[2]) / ((y[2] - y[1]) * (y[2] - y[1])) + 1)),
//    y0 = (x[1] - x[2]) * (x0 - (x[1] + x[2]) / 2) / (y[2] - y[1]) + (y[1] + y[2]) / 2;
//    double x0_ = xm - sqrt((r * r - (x[1] - xm) * (x[1] - xm) - (y[1] - ym) * (y[1] - ym)) / ((x[1] - x[2]) * (x[1] - x[2]) / ((y[2] - y[1]) * (y[2] - y[1])) + 1)),
//    y0_ = (x[1] - x[2]) * (x0_ - (x[1] + x[2]) / 2) / (y[2] - y[1]) + (y[1] + y[2]) / 2;
//
//
//    printf("%f %f %f %f",x0,y0,x0_,y0_);
//    return 0;
//}

/*
int main()
{
    int n;
    scanf("%d",&n);
    string str;
    getchar();
    cio
    getline(cin, str);
    char a[1110][1110] = {0};
    ulong s = str.size();
    int i = 0;
    int v = 0;
    for (i = 0;v < s;i ++)
    {
        for (int j = 0;j < n && v < s;j ++,v ++)
        {
            a[j][i] = str[v];
        }
    }
//    if (s < n) n = s;
    for (int k = 0;k < n;k ++)
    {
        for (int j = 0;j < i;j ++)
        {
            if (a[k][i - j - 1] == 0) printf(" ");
            else printf("%c",a[k][i - j - 1]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*(int main()
{
    int n;
    scanf("%d",&n);
    char in;
    double a;
    while (n --)
    {
        scanf(" %c %lf",&in,&a);
        if (in == 'M') in = 1;
        else in = 0;
        if (in) printf("%.2f\n",a / 1.09);
        else printf("%.2f\n",a * 1.09);
    }
    
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    sort(a,a + n);
    int mid = n / 2;
    int l = 0,
    r = 0;
    for (int i = 0;i < mid;i ++)
    {
        l += a[i];
    }
    for (int i = mid;i < n;i ++)
    {
        r += a[i];
    }
    printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d\n",n - mid,mid,r - l);
    return 0;
}
*/

/*
int n;
char a[110][110];
int vis[110][110] = {0};

int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};

void dfs_h(int x,int y,char c)
{
    vis[y][x] = 1;
    for (int i = 0;i < 4;i ++)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if (xx >= 0 && xx < n && y >= 0 && y < n && a[yy][xx] == c && !vis[yy][xx])
        {
            dfs_h(xx, yy, c);
        }
    }
}

int jd_c(char a,char b)
{
    if (a == b) return 1;
    if (a == 'R' && b == 'G') return 1;
    if (b == 'R' && a == 'G') return 1;
    return 0;
}

void dfs_c(int x,int y,char c)
{
    vis[y][x] = 0;
    for (int i = 0;i < 4;i ++)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if (xx >= 0 && xx < n && y >= 0 && y < n && jd_c(a[yy][xx], c) && vis[yy][xx])
        {
            dfs_c(xx, yy, c);
        }
    }
}

int main()
{
    scanf("%d",&n);
    for (int i = 0;i < n;i ++)
    {
        scanf(" ");
        for (int j = 0;j < n;j ++)
        {
            scanf("%c",&a[i][j]);
        }
    }
    int sum_h = 0;
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            if (vis[i][j] == 0)
            {
                sum_h ++;
                dfs_h(j, i, a[i][j]);
            }
        }
    }
    int sum_c = 0;
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            if (vis[i][j] == 1)
            {
                sum_c ++;
                dfs_c(j, i, a[i][j]);
            }
        }
    }
    printf("%d %d\n",sum_h,sum_c);
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    int a[1000010] = {0};
    int i1,i2;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %d",&i1,&i2);
        a[i2] = i1;
    }
    ll sum = 0;
    
    for (int i = 0;i <= k * 2;i ++)
    {
        if (i <= 1000000) sum += a[i];
        else break;
    }
    ll maax = sum;
    for (int i = k + 1;i <= 1000000;i ++)
    {
        if (i - k - 1 >= 0) sum -= a[i - k - 1];
        if (i + k <= 1000000) sum += a[i + k];
        if (sum > maax) {
            maax = sum;
        }
    }
    printf("%lld\n",maax);
    return 0;
}
*/

////深搜
/*
struct Node {
    int to;
    int id;
    Node *nxt;
} *g[50010] = {NULL};

int vis[50010] = {0};
vector<int> ans;

int dfs(int k)
{
    vis[k] = 1;
    int d = 0;
    Node *node = g[k];
    int to;
    while (node != NULL)
    {
        to = node -> to;
        if (vis[to])
        {
            node = node -> nxt;
            continue;
        }
        if (!dfs(to))
        {
            d ++;
            ans.push_back(node -> id);
        }
        node = node -> nxt;
    }
    return d % 2;
}

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int u,v;
    Node *node;
    for (int i = 1;i <= m;i ++)
    {
        scanf("%d %d",&u,&v);
        node = (Node*) malloc(sizeof(Node));
        node -> to = v;
        node -> id = i;
        node -> nxt = g[u];
        g[u] = node;
        
        node = (Node*) malloc(sizeof(Node));
        node -> to = u;
        node -> id = i;
        node -> nxt = g[v];
        g[v] = node;
    }
    
    for (int i = 1;i <= n;i ++)
    {
        if (!vis[i])
        {
            if (!dfs(i)) {
                printf("-1");
                return 0;
            }
        }
    }
    printf("%lu\n",ans.size());
    sort(ans.begin(),ans.end());
    for (auto i = ans.begin();i != ans.end();i ++)
    {
        printf("%d\n",*i);
    }
    return 0;
}
*/


/*
int main()
{
    int n,k;
    scanf("%d %d",&n,&k);
    int a[410][410];
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    ll s[410][410];
    ll last;
    for (int i = 0;i < n;i ++)
    {
        last = 0;
        for (int j = 0;j < n;j ++)
        {
            s[i][j] += last + a[i][j];
            last = s[i][j];
        }
    }
    ll sum;
    ll maax = 0;
    int l,r;
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            l = max(0,j - k);
            r = min(n - 1,j + k);
            sum = s[i][r] - s[i][l] + a[i][l];
            for (int y = i - 1,v = k - 1;y >= 0 && v >= 0;y --,v --)
            {
                l = max(0,j - v);
                r = min(n - 1,j + v);
                sum += s[y][r] - s[y][l] + a[y][l];
            }
            
            for (int y = i + 1,v = k - 1;y < n && v >= 0;y ++,v --)
            {
                l = max(0,j - v);
                r = min(n - 1,j + v);
                sum += s[y][r] - s[y][l] + a[y][l];
            }
            maax = max(maax,sum);
        }
    }
    printf("%lld\n",maax);
    return 0;
}
*/

///// 最小生成树 prime

/*
int x[2010];
int y[2010];

int cal(int i, int j)
{
    return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);
}

int main()
{
    int n,c;
    scanf("%d %d",&n,&c);
    for (int i = 0;i < n;i ++)
    {
        scanf("%d %d",x + i,y + i);
    }
    
    int v[2010] = {1}; // 已经记录下的树的点，初始情况是0号点在里边
    int min = -1;
    int dis[2010]; // 代表当前这棵树与别的点的最小值
    int s = 0; // 起始点
    int d; // 暂时记录一下距离，就这题得用
    for (int i = 0;i < n;i ++)
    {
        dis[i] = (d = cal(s,i)) >= c ? d : -1; // 计算其余各点到树的距离，注意这题得>=c
    }
    int dot; // 找到的最小点
    int sum = 0;
    int ok = 1; // 有解
    for (int i = 0;i < n - 1;i ++) // 循环n-1次，也就是n-1条边
    {
        min = -1;
        dot = -1; // 一开始没有找到最小点
        for (int j = 0;j < n;j ++)
        {
            if (!v[j] && dis[j] != -1 && (min == -1 || dis[j] < min)) // 找最小，忽略不联通的边
            {
                min = dis[j]; // 找最小
                dot = j; // 找到的最小点记录
            }
        }
        if (dot == -1) {
            ok = 0; // 无解
            break; // 点都没找着emmm
        }
        v[dot] = 1; // 加入已找到点套餐
        sum += min; // 计算权值
        
        // 开始重新计算各点到已生成的树的距离
        for (int j = 0;j < n;j ++)
        {
            if (!v[j] && ((d = cal(dot,j)) < dis[j] || dis[j] == -1) && d >= c) // 重新找最小的，当然只要找新加入的点到各未加入的点的距离即可，同样要注意得>=c
            {
                dis[j] = d; // 更新权值
            }
        }
    }
    if (ok) printf("%d\n",sum);
    else printf("-1\n");
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    printf("%d\n",n*(n-1)/2 + m*(m-1)/2);
    return 0;
}
*/

/*
inline bool jd(char *str,int n)
{
    int ok = 1;
    for (int i = 0;i < n / 2;i ++)
    {
        if (str[i] != str[n - i - 1])
        {
            ok = 0;
            break;
        }
    }
    return ok;
}

int main()
{
    char str[110];
    scanf("%s",str);
    int n = (int) strlen(str);
    if (jd(str,n) && jd(str,(n - 1) / 2) && jd(str + (n + 3) / 2 - 1,n - (n + 3) / 2) + 1) printf("Yes\n");
    else printf("No\n");
    return 0;
}
*/

/*
int main()
{
    int l;
    scanf("%d",&l);
    double t = l / 3.0;
    printf("%.12f\n",t*t*t);
    return 0;
}
*/

/*
int a[200010];

int main()
{
    int n;
    scanf("%d",&n);
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",a + i);
    }
    ll s[200010] = {0};
    for (int i = 0;i < n;i ++)
    {
        s[a[i]] ++;
    }
    ll sum = 0;
    for (int i = 0;i < 200010;i ++)
    {
        sum += (s[i] - 1) * s[i] / 2;
    }
    for (int k = 0;k < n;k ++)
    {
        int i = a[k];
        printf("%lld\n",sum - (s[i] - 1) * s[i] / 2 + (s[i] - 2) * (s[i] - 1) / 2);
    }
    return 0;
}
*/

//class Calculator {
//private:
//    int x,y;
//public:
//    Calculator(int x,int y):x(x),y(y) {}
//    int add() {
//        return x + y;
//    }
//    int sub() {
//        return x - y;
//    }
//
//    ~Calculator()
//    {
//        cout << "Destoried" << endl;
//    }
//};
//
//int main()
//{
//    int x,y;
//    cin >> x >> y;
//    Calculator *c = new Calculator(x,y);
//    cout << c -> add() << endl << c -> sub() << endl;
//    delete c;
//    return 0;
//}

/*
int main()
{
    int w,h,d;
    scanf("%d %d %d",&w,&h,&d);
    if (w - d * 2 > 0 && h - d * 2 > 0)
    {
        int s = (w - d * 2) * (h - d * 2);
        printf("%d\n",s);
    }
    else printf("0\n");
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    map<string,ll> name;
    string str;
    ll c['Z' + 10] = {0};
    while (T --) {
        cin >> str;
        name[str] ++;
        c[str[0]] ++;
    }
    ll sum = 0;
    for (auto i = name.begin();i != name.end();i ++)
    {
        sum -= (i -> second - 1) * i -> second;
    }
    
    for (char i = 'A';i <= 'Z';i ++)
    {
        sum += (c[i] - 1) * c[i];
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int c['z' + 1] = {0};
    for (int i = 0;str[i];i ++) {
        c[str[i]] ++;
    }
    int ok = -1;
    for (int i = 'a';i <= 'z';i ++)
    {
        if (c[i] == 0) continue;
        if (ok == -1) ok = c[i] % 2;
        else if (ok != c[i] % 2) {
            ok = -1;
            break;
        }
    }
    if (ok == -1) printf("2\n");
    else printf("%d\n",ok);
    return 0;
}
*/

/*
int a[10] = {0};

inline bool judge(int c)
{
    int ok = 1;
    if (c == 0) return !a[c];
    while (c != 0)
    {
        if (a[c % 10]) {
            ok = 0;
            break;
        }
        c /= 10;
    }
    return ok;
}

int main()
{
    int n;
    scanf("%d",&n);
    int in;
    for (int i = 0;i < n;i ++)
    {
        scanf("%d",&in);
        a[in] = 1;
    }
    
    int ch;
    scanf("%d",&ch);
    int m = 10000;
    for (int i = ch;i <= 999;i ++)
    {
        if (judge(i)) {
            m = min(i - ch,m);
            break;
        }
    }
    for (int i = ch;i >= 0;i --)
    {
        if (judge(i)) {
            m = min(ch - i,m);
            break;
        }
    }
    if (m == 10000) printf("%d\n",ch);
    else printf("%d\n",m);
    return 0;
}
*/

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll i2 = 0,i5 = 0;
    while (n % 2 == 0)
    {
        i2 ++;
        n /= 2;
    }
    while (n % 5 == 0) {
        i5 ++;
        n /= 5;
    }
    ll s2 = 1,s5 = 1;
//    printf("%d %d\n",i2,i5);
    set<ll> all;
    for (ll i = 0;i <= i2;i ++)
    {
        s5 = 1;
        for (ll j = 0;j <= i5;j ++)
        {
            all.insert(s2 * s5);
            s5 *= 5;
        }
        s2 *= 2;
    }
    printf("%lu\n",all.size());
    for (auto i = all.begin();i != all.end();i ++)
    {
        printf("%lld\n",*i);
    }
    return 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    int in;
    int f[100010] = {0};
    for (int i = 0;i < n;i ++) {
        scanf("%d",&in);
        f[in + 1] += f[in] + 1;
    }
    int m = 0;
    for (int i = 1;i <= n + 1;i ++)
    {
        m = max(m,f[i]);
    }
    printf("%d\n",n - m);
    return 0;
}
*/

/*
int main()
{
    double x,y,r,tx,ty,s;
    scanf("%lf %lf %lf %lf %lf %lf",&x,&y,&r,&tx,&ty,&s);
    tx += s / 2;
    ty += s / 2;
    
    double xx = abs(x - tx) - s / 2;
    double yy = abs(y - ty) - s / 2;
    
    if (yy < 0) yy = 0;
    if (xx < 0) xx = 0;
    
    double k = xx * xx + yy * yy - r * r;
    if (abs(k) <= 1e-6) printf("1\n");
    else if (k > 0) printf("0\n");
    else if (k < 0) printf("2\n");
    return 0;
}
*/

/*
int main()
{
    ll sum = 0;
    int n;
    scanf("%d",&n);
    ll x[1010];
    ll y[1010];
    for (int i = 0;i < n;i ++) scanf("%lld %lld",x + i,y + i);
    for (int i = 0;i < n;i ++)
    {
        for (int j = i + 1;j < n;j ++)
        {
            sum = (sum + abs(x[i] - x[j]) + abs(y[i] - y[j])) % 998244353;
        }
    }
    ll s = 0;
    for (int i = 0;i < n - 2;i ++)
    {
        s = (s + sum) % 998244353;
    }
    printf("%lld\n",s);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    ll k[35] = {0};
    int j = 0;
    for (int i = 0;i < n;i ++)
    {
        j = 0;
        while (a[i] != 0)
        {
            k[j ++] += a[i] % 2;
            a[i] /= 2;
        }
    }
    ll sum = 0;
    ll v = 1;
    for (int i = 0;i < 35;i ++) {
        sum += k[i] * k[i] * v;
        v *= 2;
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int ok = 0;
    if (str.size() == 6)
    {
        if (str[2] == str[3] && str[4] == str[5]) ok = 1;
    }
    if (ok) printf("Yes\n");
    else printf("No\n");
    return 0;
}
*/

/*
int main() {
    int x;
    scanf("%d",&x);
    ll v = 0;
    while (x >= 500) {
        x -= 500;
        v += 1000;
    }
    while (x >= 5) {
        x -= 5;
        v += 5;
    }
    printf("%lld\n",v);
    return 0;
}
*/

/*
int main()
{
    int k,n;
    int a[200010];
    scanf("%d %d",&k,&n);
    for (int i = 0;i < n;i ++) {
        scanf("%d",a + i);
    }
    sort(a,a + n);
    int maax = 0;
    for (int i = 1;i < n;i ++)
    {
        maax = max(a[i] - a[i - 1],maax);
    }
    maax = max(maax,k - a[n - 1] + a[0]);
    printf("%d\n",k - maax);
    return 0;
}
*/

/*
int main()
{
    int n,x,y;
    scanf("%d %d %d",&n,&x,&y);
    vector<int> dis;
    int d;
    for (int i = 1;i <= n;i ++)
    {
        for (int j = i + 1;j <= n;j ++)
        {
            d = 0;
            if (i < x) {
                if (j <= x) d += j - i;
                else {
                    d += x - i;
                    if (j > x && j < y) d += min(j - x,y - j + 1);
                    else d += j - y + 1;
                }
            } else if (i >= x && i <= y) {
                if (j <= y) d += min(j - i,y - x + 1 - (j - i));
                else {
                    d += j - y;
                    d += min(y - i,i - x + 1);
                }
            } else {
                d += j - i;
            }
//            printf("%d %d: %d\n",i,j,d);
            dis.push_back(d);
        }
    }
    int k[2010] = {0};
    for (auto i = dis.begin();i != dis.end();i ++)
    {
        k[*i] ++;
    }
    for (int i = 1;i < n;i ++)
    {
        printf("%d\n",k[i]);
    }
    return 0;
}
*/

/*
int main()
{
    int x,y,A,B,C;
    scanf("%d %d %d %d %d",&x,&y,&A,&B,&C);
    
    int a[100010];
    int b[100010];
    int c[100010];
    for (int i = 0;i < A;i ++) scanf("%d",a + i);
    for (int i = 0;i < B;i ++) scanf("%d",b + i);
    for (int i = 0;i < C;i ++) scanf("%d",c + i);
    sort(a, a + A, greater<int>());
    sort(b, b + B, greater<int>());
    sort(c, c + C, greater<int>());
    int ea = x - 1;
    int eb = y - 1;
    for (int i = 0;i < C;i ++)
    {
        if (ea >= 0 && eb >= 0)
        {
            if (a[ea] <= b[eb])
            {
                if (a[ea] < c[i]) {
                    a[ea] = c[i];
                    ea --;
                }
            } else {
                if (b[eb] < c[i]) {
                    b[eb] = c[i];
                    eb --;
                }
            }
        } else {
            if (ea < 0 && eb < 0) break;
            if (ea < 0) {
                if (b[eb] < c[i]) {
                    b[eb] = c[i];
                    eb --;
                }
            }
            if (eb < 0) {
                if (a[ea] < c[i]) {
                    a[ea] = c[i];
                    ea --;
                }
            }
        }
        
    }
    ll sum = 0;
    for (int i = 0;i < x;i ++) sum += a[i];
    for (int i = 0;i < y;i ++) sum += b[i];
    printf("%lld\n",sum);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[110];
    int b[110];
    int pb[110];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    for (int i = 0;i < n;i ++) {
        scanf("%d",b + i);
        pb[b[i]] = i;
    }
    int mc = -1;
    int c;
    int ct = 0;
    for (int i = 0;i < n;i ++)
    {
        if (a[i] != b[i]) {
            int k = pb[a[i]];
            int j = a[i];
            int t = -1;
            c = 1;
            while (a[k] != -1)
            {
                t = a[k];
                a[k] = j;
                a[i] = -1;
                j = t;
                k = pb[t];
                c ++;
            }
            a[k] = t;
            ct ++;
            mc = max(mc,c);
        }
    }
    printf("%d %d\n",ct,mc);
    return 0;
}
*/

/*
int main()
{
    string a,b,c;
    cin >> a >> b >> c;
    if (a == "bubble" || a == "tapioka") a = "";
    if (b == "bubble" || b == "tapioka") b = "";
    if (c == "bubble" || c == "tapioka") c = "";
    if (a == "" && b == "" && c == "") printf("nothing\n");
    else {
        int f = 1;
        if (a != "") {
            cout << a;
            f = 0;
        }
        if (b != "") {
            if (f) f = 0;
            else printf(" ");
            cout << b;
        }
        
        if (c != "") {
            if (f) f = 0;
            else printf(" ");
            cout << c;
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[55];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    int ok = 1;
    for (int i = 0;i < n;i ++)
    {
        for (int j = 0;j < n;j ++)
        {
            for (int k = 0;k < n;k ++)
            {
                if (i != k && i != j && k != j) {
                    ok = fabs((a[i] - a[j]) / a[k] - (a[i] - a[j]) / (double) a[k]) <= 1e-6;
                    if (!ok) goto end;
                }
            }
        }
    }
end:
    if (ok) printf("yes\n");
    else printf("no\n");
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    itn in;
    while (T --)
    {
        scanf("%d",&n);
        priority_queue<int,vector<int>,greater<int> > k;
        for (itn i = 0;i < n;i ++) {
            scanf("%d",&in);
            k.push(in);
        }
        if (n == 1) {
            printf("%d\n",in);
            continue;
        }
        itn sum = 0;
        int a;
        while (!k.empty())
        {
            if (k.size() == 1) break;
            a = k.top();
            k.pop();
            a += k.top();
            sum += a;
            k.pop();
            k.push(a);
        }
        printf("%d\n",sum);
    }
    
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    ll n;
    while (T --)
    {
        scanf("%lld",&n);
        ll b,x,k;
        ll maax = 0;
        for (itn i = 1;i * i <= n;i ++)
        {
            if (n % i == 0) {
                b = (i + 1) * n;
                k = (b / i) ^ b;
                maax = max(maax,k);
                
                x = n / i;
                b = (x + 1) * n;
                k = (b / x) ^ b;
                maax = max(maax,k);
            }
        }
        printf("%lld\n",maax);
    }
    return 0;
}
*/

//int t(int *a,int n)
//{
//    int re = 0,cur = 0,l = 0;
//    for (int i = 1;i <= n;i ++)
//    {
//        cur += a[i - 1];
//        if (cur < 0) {
//            cur = 0;
//            l = i;
//        }
//        re = max(re,(i - l) * cur);
//    }
//    return re;
//}
//
//int main()
//{
//    int a[1000];
//    int n;
//    scanf("%d",&n);
//    for (int i = 0;i < n;i ++) scanf("%d",a + i);
//    printf("%d\n",t(a,n));
//    return 0;
//}

/// 二进制状态压缩
/*
int n,m;
bitset<510> a[20];

int main()
{
    int T;
    scanf("%d",&T);
    string str;
    while (T --)
    {
        scanf("%d %d",&n,&m);
        for (int i = 0;i < m;i ++)
        {
            cin >> str;
            a[i] = bitset<510>(str);
        }
        int ans = -1;
        int mu = 1 << m;
        for (int i = 0;i < mu;i ++)
        {
            bitset<510> k(0);
            int v = i;
            int c = 0;
            for (int j = 0;j < m && v > 0;j ++)
            {
                if (v & 1) {
                    k |= a[j];
                    c ++;
                }
                v >>= 1;
            }
            if (k.count() == n)
            {
                if (ans == -1) ans = c;
                else ans = min(ans, c);
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    itn T;
    scanf("%d",&T);
    while (T --)
    {
        cin >> str;
        int k = 0;
        itn ok = 1;
        for (int i = 0;str[i];i ++)
        {
            if (str[i] == 'm')
            {
                if (k == 0) k = 1;
                else {
                    ok = 0;
                    break;
                }
            } else if (str[i] == 'q')
            {
                if (k == 1) k = 0;
                else {
                    ok = 0;
                    break;
                }
            } else {
                ok = 0;
                break;
            }
        }
        if (ok && !k) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
*/



//int n,m;
//const int mod = 998244355;
//ll all = 0;
//int f[2010];
//
//int main()
//{
//    scanf("%d %d",&n,&m);
//    int a[2010];
//    for (int i = 0;i < n;i ++) scanf("%d",a + i);
//    f[0] = 0;
//    for (int i = 0;i < n;i ++) f[i + 1] = f[i] + a[i];
//
////    for (int i = 1;i <= n;i ++) printf("%d ",f[i]);
//
//
//    return 0;
//}

//pair<int,int> a[100010];
//int n,m;
//
//int dp[50][100010];
//
//int dfs(int d,int start)
//{
////    printf("%d\n",d);
//    if (d == m) return 1;
//    if (start == n - 1) return 0;
//    int sum = 0;
//    int k = start == -1 ? -1 : a[start].second;
//    int v = start == -1 ? -1 : a[start].first;
//    for (int i = start + 1;i < n;i ++)
//    {
//        if (a[i].second > k && a[i].first > v) {
//            sum += (dp[d + 1][i] == -1) ? (dp[d + 1][i] = dfs(d + 1,i)) : dp[d + 1][i];
//        }
//    }
//    return sum;
//}
//
//
//int main()
//{
//    mem(dp,-1);
//    scanf("%d %d",&n,&m);
//    int in;
//    for (int i = 0;i < n;i ++){
//        scanf("%d",&in);
//        a[i].first = in;
//        a[i].second = i;
//    }
//    sort(a,a + n);
//    printf("%d\n",dfs(0,-1));
//    return 0;
//}



//priority_queue<int,vector<int>,greater<int> > q;
//
//int a[110][110];
//int m[110];
//int n,k;
//
//void dfs(int d,int v)
//{
//    if (d == n) {
//        q.push(v);
//        return;
//    }
//    for (int i = 0;i < m[d];i ++)
//    {
//        dfs(d + 1,v + a[d][i]);
//    }
//}
//
//int main()
//{
//
//    scanf("%d %d",&n,&k);
//
//    for (int i = 0;i < n;i ++)
//    {
//        scanf("%d",m + i);
//        for (itn j = 0;j < m[i];j ++) scanf("%d",&a[i][j]);
//    }
//    dfs(0,0);
//    int ans = 0;
//    for (int i = 0;i < k;i ++)
//    {
//        ans += q.top();
//        q.pop();
//    }
//
//    printf("%d\n",ans);
//
//    return 0;
//}

/*
struct Node
{
    int to,w;
    ll ch;
    Node *nxt;
} *g[1000010] = {NULL};

int vis[1000010] = {0};
int to;
ll t;

ll dfs(int n,int w)
{
    vis[n] = 1;
    Node *node;
    node = g[n];
    ll sum = w;
    while (node != NULL)
    {
        to = node -> to;
        if (!vis[to]) {
            node -> ch = dfs(to,node -> w);
            sum += node -> ch;
        }
        node = node -> nxt;
    }
    return sum;
}

ll all;
ll miin = -1;

void dfs(int n)
{
    vis[n] = 1;
    Node *node;
    node = g[n];
    while (node != NULL)
    {
        to = node -> to;
        if (!vis[to]) {
            printf("%d -> %d = %lld,%lld\n",n,node -> to,node -> ch - node -> w,all - node -> ch);
            t = max(node -> ch - node -> w,all - node -> ch);
            if (miin == -1) miin = t;
            else miin = min(miin,t);
            dfs(to);
        }
        node = node -> nxt;
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    int u,v,w;
    Node *node;
    for (int i = 0;i < n - 1;i ++)
    {
        scanf("%d %d %d",&u,&v,&w);
        node = (Node*) malloc(sizeof(Node));
        node -> w = w;
        node -> to = v;
        node -> ch = 0;
        node -> nxt = g[u];
        g[u] = node;
        
        node = (Node*) malloc(sizeof(Node));
        node -> w = w;
        node -> to = u;
        node -> ch = 0;
        node -> nxt = g[v];
        g[v] = node;
    }
    all = dfs(1,0);
    
    mem(vis,0);
    
    dfs(1);
    printf("%lld\n",miin);
    
    
    return 0;
}
 */


/*
int main()
{
    int n,x;
    scanf("%d %d",&n,&x);
    n --;
    int k = (n - 1) / (x - 1) - 1;
    priority_queue<int> q;
    for (int i = 0;i < x;i ++)
    {
        q.push(n);
    }
    int t = n;
    for (int i = 0;i < k;i ++)
    {
        t = q.top() - 1;
        q.pop();
        for (int i = 0;i < x;i ++) q.push(t);
    }
    
    printf("%d",n + 1 - t);
    
    while (!q.empty())
    {
        printf(" %d",q.top() - t);
        q.pop();
    }
    printf("\n");
    return 0;
}
*/

/*
int main()
{
    int n,t;
    scanf("%d %d",&n,&t);
    int a[100010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    int l = 1 << n;
    int j;
    int v;
    int sum;
    bitset<1000> b;
    b.set();
    for (int i = 0;i < l;i ++)
    {
        bitset<1000> now;
        j = i;
        v = 0;
        sum = 0;
        while (j != 0)
        {
            if (j & 1) {
                sum += a[v];
                now[v] = 1;
            }
            j >>= 1;
            v ++;
        }
        if (sum == t) b &= now;
    }
    printf("%lu\n",b.count());
    for (int i = 0;i < 1000;i ++)
    {
        if (b[i]) printf("%d\n",a[i]);
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[110];
    int tt = 0;
    for (int i = 0;i < n;i ++) {
        scanf("%d",a + i);
        tt += a[i];
    }
    itn ok = 0;
    for (int i = 0;i < n;i ++)
    {
        if (a[i] * 4 * m >= tt) {
            ok ++;
        }
    }
    if (ok >= m) printf("Yes\n");
    else printf("No\n");
    return 0;
}
*/

/*
int t = 0;
string num = "";
int l = 0;
int k;

void f(int n,int d,string str)
{
    if (d == l) {
        t ++;
        if (t == k) num += str + (char) (n + '0');
        return;
    }
    int s = (n == 0 ? 0 : n - 1);
    int e = (n == 9 ? n : n + 1);
    for (int i = s;i <= e;i ++)
    {
        if (t != k) f(i,d + 1,str + (char)(n + '0'));
    }
}

int main()
{
    
    scanf("%d",&k);
    
    while (t != k)
    {
        for (int i = 1;i < 10;i ++)
        {
            if (t == k) break;
            f(i,0,string());
        }
        l ++;
    }
    cout << num << endl;
    
    return 0;
}
*/

//int main()
//{
////    ll n;
////    scanf("%lld",&n);
//    for (int n = 2;n <= 100;n ++)
//    {
//        printf("%d: \n",n);
//        int c = 0;
//        for (int k = 2;k <= n;k ++)
//        {
//            ll m = n;
//            while (m > 1)
//            {
//                if (m % k == 0) m /= k;
//                else m -= k;
//            }
//            if (m == 1) {
//                if ((n - 1) % k != 0 && k != 2 && k != n) printf(">>>>>%d\n",k);
//            }
//        }
////        printf("%d\n",c);
//    }
//    return 0;
//}

// 骗分
/*
struct Node {
    int n;
    Node *nxt;
} *g[50010] = {NULL};

int n;
int a[50010];

int d[2010][2010] = {0};

int s;

void dfs(int n,int from,int dis)
{
    d[n][s] = dis;
    d[s][n] = dis;
    Node *node = g[n];
    while (node != NULL)
    {
        if (node -> n != from) dfs(node -> n,n,dis + 1);
        node = node -> nxt;
    }
}

int main()
{
    scanf("%d",&n);
    for (int i = 0;i < n;i ++) scanf("%d",a + 1 + i);
    int u,v;
    Node *node;
    for (int i = 0;i < n - 1;i ++)
    {
        scanf("%d %d",&u,&v);
        node = (Node*) malloc(sizeof(Node));
        node -> n = v;
        node -> nxt = g[u];
        g[u] = node;
        
        node = (Node*) malloc(sizeof(Node));
        node -> n = u;
        node -> nxt = g[v];
        g[v] = node;
    }
    for (int i = 1;i <= n;i ++)
    {
        s = i;
        dfs(i,i,0);
    }
    int maax = -1;
    for (int i = 1;i <= n;i ++)
    {
        for (int j = 1;j <= n;j ++)
        {
            maax = max(maax,d[i][j] * max(a[i],a[j]));
        }
    }
    printf("%d\n",maax);
    
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    if (n == 2) {
        printf("5\n");
        printf("1 1\n1 2\n1 3\n2 3\n2 2\n2 1\n");
    } else {
        int end = n * (n + 1);
        printf("%d\n",end - 1);
        int x = n + 1,y = 1;
        int mode = 0;
        for (int i = 0;i < end;i ++)
        {
            printf("%d %d\n",y,x);
            switch (mode) {
                case 0:
                    x --;
                    y ++;
                    if (y == n) {
                        mode = 5;
                    } else {
                        mode = 1;
                    }
                    break;
                case 1:
                    x --;
                    y --;
                    if (y == 1) mode = 2;
                    else if (x == 1) mode = 6;
                    break;
                case 2:
                    x ++;
                    mode = 3;
                    break;
                case 3:
                    x ++;
                    y ++;
                    if (x == n + 1) mode = 4;
                    else if (y == n - 1) mode = 0;
                    break;
                case 4:
                    y ++;
                    if (n % 2) {
                        if (y <= n - 2) mode = 0;
                        else if (y == n) mode = 5;
                    } else {
                        if (y <= n - 3) mode = 0;
                        else if (y == n) mode = 5;
                    }
                    break;
                case 5:
                    x --;
                    if (n % 2) {
                        if (x <= n - 1) mode = 1;
                    } else {
                        mode = 1;
                    }
                    break;
                case 6:
                    y --;
                    mode = 3;
                    break;
            }
        }
    }
    return 0;
}
*/


///  类复制考点
//class Cal {
//private:
//    double r;
//    double h;
//public:
//    Cal(double r,double h):r(r),h(h){
//        cout << "Inited" << endl;
//    }
//
//    Cal(const Cal& c)
//    {
//        cout << "Copied" << endl;
//        this -> r = c.r;
//        this -> h = c.h;
//    }
//
//    double execute()
//    {
//        return pi * r * r * h;
//    }
//
//    ~Cal()
//    {
//        cout << "Destoried" << endl;
//    }
//
//
//};
//
//Cal fun(double r,double h)
//{
//    Cal *a = new Cal(r,h);
//    cout << a -> execute() << endl;
//    return Cal(r,h);
//}
//
//Cal fun(Cal &a)
//{
//    cout << "Before copy!" << endl;
//    return a;
//}
//
//
//int main()
//{
//    Cal c(12,34);
//    cout << c.execute() << endl;
//    cout << fun(23,34).execute() << endl;
//    cout << fun(c).execute() << endl;
//    return 0;
//}

/*
template<typename T> class Swap {
    T *a,*b;
public:
    Swap(T &a,T &b)
    {
        this -> a = &a;
        this -> b = &b;
    }
    
    void exec()
    {
        
        for (int i = 0;i < sizeof(T);i ++)
        {
            *((char*) this -> a + i) ^= *((char*) this -> b + i);
            *((char*) this -> b + i) ^= *((char*) this -> a + i);
            *((char*) this -> a + i) ^= *((char*) this -> b + i);
        }
    }
};


int main()
{
    double a,b;
    cin >> a >> b;
    Swap<double> s(a,b);
    s.exec();
    cout << a << " " << b << endl;
    return 0;
}
*/

/*
int main()
{
    int n,x;
    scanf("%d %d",&n,&x);
    int a[1010];
    int m = 1;
    int maax = 1;
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    sort(a,a + n);
    for (int i = 1;i < n;i ++)
    {
        if (a[i] - a[i - 1] <= x) m ++;
        else m = 1;
        maax = max(m,maax);
    }
    printf("%d\n",maax);
    return 0;
}
*/

/*
int main()
{
    cio
    string str;
    itn b;
    cin >> str >> b;
    int n = (int) str.size();
    int e[200010];
    int en = 0;
    for (int i = 0;str[i];i ++)
    {
        if (str[i] == 'E') {
            e[en ++] = i;
        }
    }
    for (int i = 0;str[i];i ++)
    {
        if (str[i] == 'E') {
            e[en ++] = i + n;
        }
    }
    if (en == 0) {
        printf("0\n");
        return 0;
    }
    int p[100010];
    for (int i = 0,k = 0;str[i];i ++)
    {
        if (str[i] == 'P')
        {
            while (i > e[k]) k ++;
            p[i] = e[k] - i;
        }
    }
    ll s = 0;
    for (int i = 0;str[i];i ++) {
        if (str[i] == 'E') {
            s += b;
            if (b == n) {
                if (i + b > n) {
                    s --;
                }
            }
        } else {
            if (b - p[i] > 0) {
                s += b - p[i];
                if (b == n) {
                    if (i + b > n) {
                        s --;
                    }
                }
            }
        }
    }
    printf("%lld\n",s);
    return 0;
}
*/

/*
vector<int> g[2010];

int dp[2010] = {0};
const int mod = 1000000007;
int nums[2010] = {0};
int n,l;

int dfs(int n)
{
    if (n > l) {
        return dp[n] = (nums[n] = 1);
    }
    ll s = 0;
    for (auto i = g[n].begin();i != g[n].end();i ++) {
        s = (s + (dp[*i] == 0 ? dp[*i] = dfs(*i) : dp[*i])) % mod;
    }
    return (int) s;
}

int main()
{
    scanf("%d%d",&n,&l);
    int k,t;
    for (int i = 1;i <= l;i ++) {
        scanf("%d",&k);
        for (int j = 0;j < k;j ++)
        {
            scanf("%d",&t);
            g[i].push_back(t);
        }
    }
    k = dfs(1);
    int all = 0;
    for (int i = 0;i < 2010;i ++)
    {
        if (nums[i]) all ++;
    }
    printf("%d %d\n",k,all);
    return 0;
}
*/

/*
vector<int> g[50010];
int a[50010];
int maax_n;
int maax = -1;

int vis[50010] = {0};

void dfs(int n, int d) {
    vis[n] = 1;
    if (d > maax) {
        maax = d;
        maax_n = n;
    }
    vector<int> c = g[n];
    for (auto i = c.begin();i != c.end();i ++) {
        if (!vis[*i]) dfs(*i,d + 1);
    }
}

void dfs2(int s,int n,int d)
{
    vis[n] = 1;
    maax = max(d * max(a[s],a[n]),maax);
    vector<int> c = g[n];
    for (auto i = c.begin();i != c.end();i ++) {
        if (!vis[*i]) dfs2(s,*i,d + 1);
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) scanf("%d",a + i);
    int u,v;
    for (int i = 0;i < n - 1;i ++) {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1,0);
    maax = -1;
    mem(vis,0);
    int s = maax_n;
    dfs(s,0);
    int e = maax_n;
    mem(vis,0);
    maax = -1;
    dfs2(s, s, 0);
    mem(vis,0);
    dfs2(e, e, 0);
    printf("%d\n",maax);
    return 0;
}
*/

/*
int main()
{
    itn T;
    scanf("%d",&T);
    while (T --) {
        itn h,a,H,A;
        scanf("%d %d %d %d",&h,&a,&H,&A);
        if (A == 0 || a >= H) {
            printf("-1\n");
            continue;
        }
        if (a == 0) {
            printf("0\n");
            continue;
        }
        int HH;
        int k = 0;
        int t = 0;
        while (h > 0) {
            t = 0;
            HH = H;
            do {
                if (!t) {
                    HH -= a;
                    t = 1;
                } else {
                    h -= A;
                    t = 0;
                }
            } while (HH > 0);
            if (h > 0) k ++;
        }
        printf("%d\n",k);
    }
    return 0;
}
*/

/*
int main()
{
    itn t;
    scanf("%d",&t);
    while (t --) {
        int a,b;
        scanf("%d %d",&a,&b);
        if (a > b) swap(a,b);
        int c = b - a;
        if (c == 0) printf("%d\n",a);
        else {
            if (c <= a) printf("%d\n",b + 1);
            else {
                int k = 0;
                do {
                    a *= 2;
                    c = b - a;
                    k ++;
                } while (c > a);
                printf("%d\n",k + b + 1);
            }
        }
    }
    return 0;
}
*/

/*
int j(int n)
{
    if (n == 0) return 1;
    for (int i = n - 1;i >= 1;i --) n *= i;
    return n;
}

int type = 0;
int t[20];
int vis[10] = {0};

set<map<int,int>> all;
ll ss = 0;
int l;

void dfs(int a,int b,int c,int d,int n,map<int,int> k) {
    if (n == 0) {
        
        if (all.find(k) == all.end()) {
//            cout << j(l) / (j(a) * j(b) * j(c) * j(d)) << endl;
            ss += j(l) / (j(a) * j(b) * j(c) * j(d));
            all.insert(k);
        }
        return;
    }
    for (int i = 0;i < type;i ++) {
        if (!vis[i]) {
            if (a - t[i] >= 0) {
                vis[i] = 1;
                k[i] = 'a';
                dfs(a - t[i],b,c,d,n - 1,k);
                vis[i] = 0;
            }
            if (b - t[i] >= 0) {
                vis[i] = 1;
                k[i] = 'b';
                dfs(a,b - t[i],c,d,n - 1,k);
                vis[i] = 0;
            }
            if (c - t[i] >= 0) {
                vis[i] = 1;
                k[i] = 'c';
                dfs(a,b,c - t[i],d,n - 1,k);
                vis[i] = 0;
            }
            if (d - t[i] >= 0) {
                vis[i] = 1;
                k[i] = 'd';
                dfs(a,b,c,d - t[i],n - 1,k);
                vis[i] = 0;
            }
        }
    }
}

int main()
{
    int na,nb,nc,nd,c;
    scanf("%d %d %d %d %d",&na,&nb,&nc,&nd,&c);
    int u,v;
    int g[20] = {0};
    set<int> h[20];
    for (int i = 1;i <= 12;i ++) {
        g[i] = i;
        h[i].insert(i);
    }
    
    for (int i = 0;i < c;i ++) {
        scanf("%d %d",&u,&v);
        
        if (g[u] != g[v]) {
            int l = g[v];
            for (auto j : h[l]) {
                h[g[u]].insert(j);
                g[j] = g[u];
            }
            h[l].clear();
        }
        
//        for (int j = 1;j <= 12;j ++) printf("%d ",g[j]);
//        printf("\n");
//        for (int j = 1;j <= 12;j ++) {
//            printf("%d:",j);
//            for (auto k : h[j]) {
//                printf("%d ",k);
//            }
//            printf("\n");
//        }
    }
    
    
    int k = 0;
    for (int i = 0;i < 20;i ++) {
        k = (int) h[i].size();
        if (k > 1) t[type ++] = k;
    }
    
    k = 12;
    for (int i = 0;i < type;i ++) {
//        printf("%d ",t[i]);
        k -= t[i];
    }
//    printf("\n");
    l = k;
    
    if (k == 12) {
        printf("%d\n",j(12) / (j(na) * j(nb) * j(nc) * j(nd)));
    } else {
        dfs(na,nb,nc,nd,type,map<int,int>());
        printf("%lld\n",ss);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --) {
        int n;
        int la = -1;
        int lb = -1;
        int ok = 1;
        int a,b;
        scanf("%d",&n);
        while (n --) {
            scanf("%d %d",&a,&b);
            if (b > a) ok = 0;
            if (a < la) ok = 0;
            if (b < lb) ok = 0;
            if (ok && b - lb > a - la) ok = 0;
            la = a;
            lb = b;
        }
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    while (T --) {
        itn n,x;
        int a[100010];
        scanf("%d%d",&n,&x);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        sort(a,a + n,greater<int>());
        int k = 0;
        ll sum = 0;
        for (int i = 0;i < n;i ++) {
            sum += a[i];
            if (sum / (double) (i + 1) >= x) k ++;
            else break;
        }
        printf("%d\n",k);
    }
    return 0;
}
*/

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    int n;
//    ll miin = -1,niin = -1;
//    ll sum;
//    ll lb;
//    ll a[300010],b[300010];
//    while (T --) {
//        scanf("%d",&n);
//        sum = 0;
//        lb = -1;
//        for (int i = 0;i < n;i ++) {
//            scanf("%lld %lld",a + i,b + i);
//            if (i != 0) {
//                sum += max(0ll,a[i] - lb);
//            }
//            lb = b[i];
//        }
//        sum += max(0ll,a[0] - lb);
//
//        miin = a[0];
//        niin = b[n - 1];
//
//        for (int i = 1;i < n;i ++) {
//            if (a[i] <= miin) {
//                miin = a[i];
//                niin = min(niin,b[i - 1]);
//            }
//        }
//        sum += miin;
//        sum -= max(0ll,miin - niin);
//        printf("%lld\n",sum);
//    }
//    return 0;
//}

/// Dijkstra
/*
struct Node {
    ll n,w;
    bool operator< (const Node &other) const {
        return w > other.w;
    }
};

vector<Node> g[2][100010];

ll dis[2][100010];
int vis[2][100010] = {0};

void dij(int mode,int s) {
    mem(dis[mode],-1);
    
    priority_queue<Node> q;
    q.push({s,dis[mode][s] = 0});
    Node current;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[mode][current.n]) continue;
        vis[mode][current.n] = 1;
        for (auto to : g[mode][current.n]) {
            if (dis[mode][to.n] == -1 || dis[mode][to.n] > dis[mode][current.n] + to.w) {
                q.push({to.n,dis[mode][to.n] = dis[mode][current.n] + to.w});
            }
        }
    }
}

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int u,v,w;
    struct Edge {int u,v,w;} edges[200010];
    for (int i = 0;i < m;i ++) {
        scanf("%d%d%d",&u,&v,&w);
        g[0][u].push_back({v,w});
        g[1][v].push_back({u,w});
        edges[i + 1] = {u,v,w};
    }
    
    dij(0, 1);
    dij(1, n);
    
    int q;
    scanf("%d",&q);
    ll o = dis[0][n];
    while (q --) {
        scanf("%d",&v);
        if (dis[1][edges[v].u] != -1 && dis[0][edges[v].v] != -1 && dis[0][edges[v].v] + edges[v].w + dis[1][edges[v].u] < o) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
int cmp(string a,string b) {
    if (a.size() == b.size())
    {
        for (int i = 0;a[i];i ++) {
            if (a[i] == b[i]) continue;
            return a[i] < b[i];
        }
    }
    return a.size() < b.size();
}

int main()
{
    int n,q;
    scanf("%d%d",&n,&q);
    string a[1010];
    for (int i = 0;i < n;i ++) {
        cin >> a[i];
    }
    int l,L;
    string in,miin,v;
    int ok;
    for (int i = 0;i < q;i ++) {
        scanf("%d",&l);
        cin >> in;
        miin = "-1";
        for (int j = 0;j < n;j ++) {
            ok = 1;
            L = (int) a[j].size();
            if (L < l) ok = 0;
            for (int k = l - 1,p = L - 1;ok && k >= 0;k --, p --) {
                if (in[k] != a[j][p]) {
                    ok = 0;
                    break;
                }
            }
            if (ok) {
                if (miin == "-1") miin = a[j];
                else if (cmp(a[j],miin)) miin = a[j];
            }
        }
        cout << miin << endl;
    }
    
    
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[1010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    ll s = -1;
    ll ss = 0;
    sort(a,a + n);
    for (int i = a[0];i < a[n - 1];i ++) {
        ss = 0;
        for (int j = 0;j < n;j ++) {
            if (a[j] < i) ss += (a[j] - i) * (a[j] - i);
            else if (a[j] - 17 > i) ss += (a[j] - i - 17) * (a[j] - i - 17);
        }
        if (s == -1) s = ss;
        else s = min(ss,s);
    }
    printf("%lld\n",s);
    return 0;
}
*/

/// 并查集(new)
/*
int g[1010];
int d[1010];

int find(int a)
{
    if (g[a] == a) return a;
    return g[a] = find(g[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        g[y] = x; // 改变b节点的根的根为a的根
        if (d[x] == d[y]) { // 俩根深度一样
            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
        }
    } else g[x] = y;
}

ll x[1010];
ll y[1010];
ll z[1010];

inline ll dis(int a,int b)
{
    return (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]) + (z[a] - z[b]) * (z[a] - z[b]);
}

void init(int n)
{
    for (int i = 0;i < n;i ++) {
        g[i] = i;
        d[i] = 1;
    }
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --) {
        ll n,h,r;
        scanf("%lld%lld%lld",&n,&h,&r);
 
        init(n);
        
        for (int i = 0;i < n;i ++) scanf("%lld%lld%lld",x + i,y + i,z + i);
        for (int i = 0;i < n;i ++) {
            for (int j = 0;j < n;j ++) {
                if (dis(i,j) <= r * r * 4) {
//                    printf("%d %d\n",i,j);
                    bind(i,j);
                }
            }
        }
//        for (int i = 0;i < n;i ++) printf("%d ",g[i]);
        for (int i = 0;i < n;i ++) {
            if (z[i] <= r) {
                for (int j = 0;j < n;j ++) {
                    if (h - z[j] <= r && find(i) == find(j)) {
                        printf("Yes\n");
                        goto ok;
                    }
                }
            }
        }
        printf("No\n");
        ok:
        continue;
    }
    
    return 0;
}
*/

/*
int main()
{
    int n;
    ll t;
    scanf("%d%lld",&n,&t);
    pair<ll,int> a[100010];
    int u,v;
    for (int i = 0;i < n;i ++) {
        scanf("%d%d",&u,&v);
        a[i].first = u;
        a[i].second = v;
    }
    sort(a, a + n);
    int s = 1;
    for (int i = 0;i < n;i ++) {
        a[i].first += a[i].second * t;
    }
    for (int i = n - 1;i >= 1;i --) {
        if (a[i - 1].first >= a[i].first) {
            a[i - 1].first = a[i].first;
        } else s ++;
    }
    printf("%d\n",s);
    return 0;
}
*/

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int a[1010];
//    int b[1010];
//    for (int i = 0;i < n;i ++) scanf("%d",a + i);
//    for (int i = 0;i < n;i ++) scanf("%d",b + i);
//    int miin;
//    int maax = -1;
//    for (int i = 0;i < n;i ++) {
//        miin = INT_INF;
//        for (int j = 0;j < n;j ++) {
//            miin = min(miin,abs(a[i] - b[j]));
//        }
//        maax = max(maax,miin);
//    }
//    printf("%d\n",maax);
//    return 0;
//}

/*
int main() {
    
    int n,m;
    scanf("%d%d",&n,&m);
    char *a[3010];
    for (int i = 0;i < 3010;i ++) a[i] = new char[3010];
    
    for (int i = 0;i < n;i ++) {
        scanf(" ");
        for (int j = 0;j < m;j ++) {
            scanf("%c",&a[i][j]);
        }
    }

    int ot;
    int it[3010] = {0};
    ll sum = 0;
    for (int i = n - 1;i >= 0;i --) {
        ot = 0;
        for (int j = m - 1;j >= 0;j --) {
            if (a[i][j] == 'O') ot ++;
            else if (a[i][j] == 'I') it[j] ++;
            else sum += ot * it[j];
        }
    }
    
    printf("%lld\n",sum);
    
    
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    pair<int,int> a[100010];
    int c[100010];
    int s,v;
    for (int i = 0;i < n;i ++) {
        scanf("%d%d",&s,&v);
        a[i].first = v;
        a[i].second = s;
    }
    for (int i = 0;i < m;i ++) scanf("%d",c + i);
    sort(a, a + n, greater<pair<int,int> >());
    sort(c, c + m, greater<int>());
    s = 0;
    for (int i = 0,j = 0;i < n && j < m;) {
        if (a[i].second <= c[j]) {
            s ++;
            i ++;
            j ++;
        } else {
            i ++;
        }
    }
    printf("%d\n",s);
    return 0;
}
*/


//vector<int> g[200010];
//
//int c[200010];
//multiset<int> all;
//int dvis[200010] = {0};
//int vis[200010] = {0};
//
//void dfs(int n,int d)
//{
//    if (d != 0) {
//        if (!dvis[d]) {
//            all.insert(dvis[d] = c[n]);
//        } else if (dvis[d] != -1) {
//            all.erase(all.find(dvis[d]));
//            dvis[d] = -1;
//        }
//    }
//    vis[n] = 1;
//    for (auto i : g[n]) {
//        if (!vis[i]) dfs(i,d + 1);
//    }
//}
//
//int main()
//{
//    int n,m;
//    scanf("%d%d",&n,&m);
//    int u,v;
//    for (int i = 0;i < n - 1;i ++) {
//        scanf("%d%d",&u,&v);
//        g[u].push_back(v);
//        g[v].push_back(u);
//    }
//    for (int i = 1;i <= n;i ++) {
//        scanf("%d",c + i);
//    }
//    set<int> k;
//    for (int i = 1;i <= n;i ++) {
//        all.clear();
//        mem(vis,0);
//        mem(dvis,0);
//        dfs(i,0);
//        k.clear();
//        for (auto j : all) k.insert(j);
//        printf("%lu\n",k.size());
//    }
//
//    return 0;
//}

//int main()
//{
//    int n;
//    string str;
//    scanf("%d",&n);
//    cin >> str;
//    char k,v;
//    int j;
//    ll sum = 0;
//    for (int i = 0;i < n - 1;) {
//        if (str[i] == str[i + 1])
//        {
//            k = str[i];
//            for (j = i + 1;j < n;j ++) {
//                if (str[j] != k) {
//                    v = str[j];
//                    str.erase(str.begin() + j);
//                    str.insert(str.begin() + i + 1, v);
//                    sum += j - i - 1;
//                    break;
//                }
//            }
//            if (j == n) {
//                printf("-1\n");
//                return 0;
//            }
////            cout << str << endl;
//        } else i ++;
//    }
//    printf("%lld\n",sum);
//    return 0;
//}

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int m = n * 2;
//    int x[100010];
//    int y[100010];
//    int c[3][100010] = {0};
//    for (int i = 0;i < m;i ++) {
//        scanf("%d%d",x + i,y + i);
//    }
//
//    int miin = 0,min_x = 0,min_y = 0,t;
//    ll sum = 0;
//    for (int k = 0;k < m;k ++) {
//        miin = INT_INF;
//        for (int i = 1;i <= 2;i ++) {
//            for (int j = 1;j <= n;j ++) {
//                if (c[i][j]) continue;
//                if ((t = abs(y[k] - i) + abs(x[k] - j)) < miin) {
//                    miin = t;
//                    min_x = j;
//                    min_y = i;
//                }
//            }
//        }
//        c[min_y][min_x] = 1;
//        sum += miin;
//    }
//    printf("%lld\n",sum);
//    return 0;
//}

/*
int main()
{
    string str;
    cin >> str;
    int ok = 0;
    for (int i = 0;str[i];i ++) if (str[i] == '7') ok = 1;
    if (ok) printf("Yes\n");
    else printf("No\n");
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll s = 0;
    for (int i = 1;i <= n;i ++) {
        if (i % 3 == 0 && i % 5 == 0) continue;
        if (i % 3 == 0) continue;
        if (i % 5 == 0) continue;
        s += i;
    }
    printf("%lld\n",s);
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    scanf("%d",&n);
    ll sum = 0;
    for (int i = 1;i <= n;i ++) {
        for (int j = 1;j <= n;j ++) {
            for (int k = 1;k <= n;k ++) {
                sum += gcd(gcd(i,j),k);
            }
        }
    }
    printf("%lld\n",sum);
    return 0;
}
*/


/*
int main()
{
    int n;
    string str;
    scanf("%d",&n);
    cin >> str;
    int rb[4010];
    int br[4010];
    int rg[4010];
    int gr[4010];
    int bg[4010];
    int gb[4010];
    
    int r[4010] = {0};
    int g[4010] = {0};
    int b[4010] = {0};
    
    int tr = 0,tg = 0,tb = 0;
    for (int i = n - 1;i >= 0;i --) {
        if (str[i] == 'R') {
            tr ++;
            rb[i] = tb;
            rg[i] = tg;
            r[i] = 1;
        }
        if (str[i] == 'G') {
            tg ++;
            gb[i] = tb;
            gr[i] = tr;
            g[i] = 1;
        }
        if (str[i] == 'B') {
            tb ++;
            br[i] = tr;
            bg[i] = tg;
            b[i] = 1;
        }
    }
    
    ll sum = 0;
    
    for (int i = 0;i < n;i ++) {
        for (int j = i + 1;j < n;j ++) {
//            printf("%d ",j);
            if (str[i] == 'R') {
                if (str[j] == 'B') {
                    sum += bg[j];
                    if (j + j - i < n && g[j + j - i]) sum --;
                }
                if (str[j] == 'G') {
                    sum += gb[j];
                    if (j + j - i < n && b[j + j - i]) sum --;
                }
            }
            if (str[i] == 'B') {
                if (str[j] == 'R') {
                    sum += rg[j];
                    if (j + j - i < n && g[j + j - i]) sum --;
                }
                if (str[j] == 'G') {
                    sum += gr[j];
                    if (j + j - i < n && r[j + j - i]) sum --;
                }
            }
            if (str[i] == 'G') {
                if (str[j] == 'B') {
                    sum += br[j];
                    if (j + j - i < n && r[j + j - i]) sum --;
                }
                if (str[j] == 'R') {
                    sum += rb[j];
                    if (j + j - i < n && b[j + j - i]) sum --;
                }
            }
        }
    }
    printf("%lld\n",sum);
    return 0;
}
*/


//int g[510][510] = {0};
//
//int dis[510];
//int vis[110] = {0};
//int n;
//
//void dij()
//{
//    mem(dis,-1);
//    priority_queue<int> q;
//    q.push(1);
//    dis[1] = 0;
//
//}
//
//int main()
//{
//    int m;
//    scanf("%d%d",&m,&n);
//    scanf(" ");
//    string str;
//    int in;
//    int l,a[510];
//    for (int k = 1;k <= m;k ++) {
//        getline(cin,str);
//        stringstream ss(str);
//        l = 0;
//        while (ss >> in) {
//            a[l ++] = in;
//        }
//        for (int i = 0;i < l;i ++) {
//            for (int j = i + 1;j < l;j ++) {
//                g[a[i]][a[j]] = k;
//                g[a[j]][a[i]] = k;
//            }
//        }
//    }
//    dij();
//
//    return 0;
//}


// 静态变量、友元函数
/*
class A {
public:
    A(int a){ this -> a = a;};
    static void kk() // 静态类，和java一样
    {
        printf("aaa%d\n",a);
        
    }
private:
    static int a;
    friend void p(); // 友元函数，类也类似
};

int A::a = 2; // static必须在外面初始化

void p()
{
    printf("%d\n",A::a);
}

void f()
{
    static int h;
    cout << h ++ << endl;
}

int main()
{
    A a(1);
    p();
    printf("");
    f();
    f();
    return 0;
}
*/

/*
class Cal {
public:
    friend double get(Cal &c);
    Cal(double r,double h):r(r),h(h){}
private:
    int r,h;
};

double get(Cal &c) {
    return pi * c.r * c.r * c.h;
}

int main()
{
    double r,h;
    cin >> r >> h;
    Cal k(r,h);
    cout << get(k) << endl;
    return 0;
}
*/

//int main()
//{
//    int n;
//    int a[1010];
//    int b[1000010];
//    int m;
////    set<int> k;
//    int ok = 0;
//    int d = 0;
//    while (~scanf("%d",&n)) {
//        for (int i = 0;i < n;i ++) scanf("%d",a + i);
//        sort(a,a + n);
//        m = 0;
//        for (int i = 0;i < n - 3;i ++) {
//            for (int j = i + 1;j < n - 2;j ++) {
//                b[m ++] = a[i] + a[j];
//            }
//        }
//        ok = 0;
//        sort(b,b + m);
//        for (int i = n - 1;i >= 3;i --) {
//            for (int j = i - 1;j >= 2;j --) {
//                if (binary_search(b, b + m, a[i] - a[j]))
//                {
//                    ok = 1;
//                    d = a[i];
//                    goto end;
//                }
//            }
//        }
//        end:
//        if (ok) printf("%d\n",d);
//        else printf("no solution\n");
//    }
//    return 0;
//}


/*int nums[1010];
int n;

inline int b_find(int l,int r,int a) {
    int m = (l + r - 1) / 2;
    while (l <= r) {
        if (m < n && m >= 0 && nums[m] == a) {
            return 1;
        }
        else {
            if (nums[m] > a) {
                l = m + 1;
            } else {
                r = m - 1;
            }
            m = (l + r) / 2;
        }
    }
    return 0;
}

int main()
{
    int a,b,c,d;
    while (~scanf("%d",&n))
    {
        for (int i = 0;i < n;i ++) scanf("%d",nums + i);
        sort(nums, nums + n);
        for (d = n - 1;d >= 0;d --)
        {
            for (c = n - 2;c >= 0;c --)
            {
                for (b = n - 3;b >= 0;b --)
                {
                    a = nums[d] - nums[c] - nums[b];
                    if (!(nums[d] == nums[c] || nums[d] == nums[b] || nums[d] == a ||
                        nums[c] == nums[b] || nums[c] == a ||
                        nums[b] == a) && binary_search(nums, nums + n, a))
                    {
                        printf("%d\n",nums[d]);
                        goto ok;
                    }
                }
            }
        }
        printf("no solution\n");
        ok:;
    }
    return 0;
}
*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int c,a,b;
    while (~scanf("%d%d%d",&c,&a,&b))
        if (c % gcd(a,b)) printf("NO\n");
        else printf("YES\n");
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[1010];
    int b[1010];
    while (~scanf("%d",&n)) {
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        for (int i = 0;i < n;i ++) scanf("%d",b + i);
        sort(a, a + n);
        sort(b, b + n);
        int m = -INT_INF;
        int k;
        for (int v = n - 1;v >= 0;v --) {
            k = -200 * n;
            for (int i = n - 1,j = v;i >= 0 && j >= 0;j --,i --) {
                if (a[i] > b[j]) {
                    k += 400;
                } else if (a[i] == b[j]) k += 200;
            }
            m = max(m,k);
        }
        
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    string table,str;
    while (T --) {
        cin >> table >> str;
        char c['z' + 1];
        for (int i = 'a';i <= 'z';i ++) c[table[i - 'a']] = i;
        int j = 0;
        int n = (int) str.size();
        
        for (int i = ceil(n / 2.0);str[i];i ++) {
            if (str[i] == c[str[j]]) j ++;
            else {
                j = 0;
                if (str[i] == c[str[j]]) j ++;
            }
        }
        
        for (int i = 0;i < n - j;i ++) {
            printf("%c",str[i]);
        }
        for (int i = 0;i < n - j;i ++) {
            printf("%c",c[str[i]]);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    string x;
    while (cin >> str)
    {
        if (str == "0") break;
        x = str[0];
        for (int i = 1;str[i];i ++) {
            if (str[i - 1] == str[i]) {
                if (str[i] != '9') x += str[i] + 1;
                else x += "10";
            }
            x += str[i];
        }
        cout << x << endl;
    }
    return 0;
}
*/

/// 规律+快速幂
/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}


int main()
{
    ll n;
    scanf("%lld",&n);
    if (n <= 1) printf("0\n");
    else if (n == 2) printf("1\n");
    else {
        ll a = quickpow(2, n - 3);
        n %= mod;
        a = (a * n) % mod;
        a = (a * (n - 1)) % mod;
        printf("%lld\n",a);
    }
    return 0;
}
*/

/// 单调栈
/*
using namespace std;
int main()
{
    int n;
    int in;
    while (~scanf("%d",&n)) {
        stack<int> a;
        int ans = 0;
        for (int i = 0;i < n;i ++) {
            scanf("%d",&in);
            while (!a.empty() && a.top() > in) ans ++,a.pop();
            if (in != 0 && (a.empty() || a.top() < in)) a.push(in);
        }
        while (!a.empty()) ans ++,a.pop();
        printf("%d\n",ans);
    }
    return 0;
}
*/

/// 阶乘位数公式
/*
int main()
{
    int a;
    while (~scanf("%d",&a)) {
        if (a == 0) printf("1\n");
        else printf("%d\n",(int) (log10(sqrt(2 * pi * a)) + a * log10(a / exp(1))) + 1);
    }
    return 0;
}
*/

/*
ll n;
ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % n;
        a = a * a % n;
        b >>= 1;
    }
    return ans;
}

int main()
{
    while (~scanf("%lld",&n))
    {
        if (n % 2 == 0) printf("2^? mod %lld = 1\n",n);
        else {
            for (ll i = 1;;i ++) {
                if (quickpow(2, i) == 1) {
                    printf("2^%lld mod %lld = 1\n",i,n);
                    break;
                }
            }
        }
    }
    return 0;
}
*/

/*
//int T(int k,int n)
//{
//    if (k == 0) return n;
//    int sum = 0;
//    for (int i = 1;i <= n;i ++)
//    {
//        sum += T(k - 1,i);
//    }
//    return sum;
//}

int main()
{
    int k,n;
    int a[1020][1020] = {0};
    int v[1020] = {0};
    const int mod = 100007;
    for (int i = 0;i <= 1010;i ++) a[0][i] = i;
    v[0] = 1010;
    while (~scanf("%d%d",&k,&n)) {
        for (int i = 1;i <= k;i ++) {
            for (int j = v[i] + 1;j <= n;j ++) {
                a[i][j] = (a[i][j - 1] + a[i - 1][j]) % mod;
            }
            if (v[i] < n) v[i] = n;
        }
        printf("%d\n",a[k][n]);
    }
    return 0;
}
*/

/*
int main()
{
    int a[20010];
    int b[10010];
    for (int i = 1;i <= 20005;i ++) a[i] = i;
    printf("#include<stdio.h>\nint main(){int a[] = {0,");
    for (itn n = 1;n <= 10000;n ++) {
        int c = 0;
        while (1)
        {
            for (int i = 1;i <= n;i ++) {
                b[i] = a[i];
            }
            for (int i = 1,j = 1;i <= 2 * n;i += 2,j ++) {
                a[i] = a[n + j];
            }
            for (int i = 2,j = 1;i <= 2 * n;i += 2,j ++) {
                a[i] = b[j];
            }
            c ++;
            int ok = 1;
            for (int i = 1;i <= 2 * n;i ++) {
                if (a[i] != i) {
                    ok = 0;
                    break;
                }
            }
            if (ok) break;
        }
        printf("%d,",c);
    }
    printf("};int n;while (~scanf(\"%%d\",&n)){printf(\"%%d\\n\",a[n]);}return 0;}");
    return 0;
}
*/

/*
int main()
{
    int n,T;
    int a[100010];
    int miin,maax;
    scanf("%d",&T);
    int ok = 0;
    int pos = 0;
    while (T --) {
        scanf("%d",&n);
        for (int i = 0;i < n;i ++) {
            scanf("%d",a + i);
        }
        if (n == 1) {
            printf("0\n");
            continue;
        }
        sort(a, a + n);
        maax = a[n - 1];
        miin = a[0];
        if (maax > 0 && abs(maax) > abs(miin)) {
            ok = 0;
            for (int i = n - 2;i >= 0 && a[i] > 0;i --) {
                int c = maax - a[i];
                if (ceil(c / 2.0) <= a[i]) {
                    pos = i;
                    ok = 1;
                }
            }
            if (ok) {
                int m = ceil((maax - a[pos]) / 2.0);
                if (pos > 0) m = max(m,max(abs(miin),abs(a[pos - 1])));
                printf("%d\n",m);
            } else {
                int m = abs(miin);
                m = max(m,abs(a[n - 2]));
                printf("%d\n",m);
            }
        } else {
            ok = 0;
            for (int i = 1;i < n && a[i] < 0;i ++) {
                int c = a[i] - miin;
                if (ceil(c / 2.0) <= abs(a[i])) {
                    pos = i;
                    ok = 1;
                }
            }
            if (ok) {
                int m = ceil((a[pos] - miin) / 2.0);
                if (pos < n - 1) m = max(m,max(abs(maax),abs(a[pos + 1])));
                printf("%d\n",m);
            } else {
                int m = abs(maax);
                m = max(m,abs(a[1]));
                printf("%d\n",m);
            }
        }
    }
    
    return 0;
}
*/

/*
struct h {
    int time,x;
    double t;
};

int cmp(h &a,h &b)
{
    if (a.time == b.time) {
        if (a.t == b.t) {
            return a.x < b.x;
        }
        return a.t > b.t;
    }
    return a.time > b.time;
}

int main()
{
    int n;
    scanf("%d",&n);
    int t,x;
    double tp;
    vector<h> k;
    while (n --) {
        scanf("%d%d%lf",&t,&x,&tp);
        if (tp >= 38) k.push_back({t,x,tp});
    }
    sort(k.begin(), k.end(), cmp);
    printf("%d\n",(int) k.size());
    for (auto i : k) {
        printf("%08d %08d %.1f\n",i.time,i.x,i.t);
    }
    
    return 0;
}
*/

/*
int main() {
    string s1,s2;
    cin >> s1 >> s2;
    if (s1 == s2) printf("-1\n");
    else printf("%lu\n",max(s1.size(),s2.size()));
    return 0;
}
 */

/*
int main()
{
    itn n;
    scanf("%d",&n);
    int a[100010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    ll k = 0;
    ll sum = 0;
    for (int i = 0;i < n;i ++)
    {
        sum += a[i];
        sum -= k;
        k ++;
    }
    k = 0;
    ll sum2 = 0;
    for (int i = n - 1;i >= 0;i --)
    {
        sum2 += a[i];
        sum2 -= k;
        k ++;
    }
    printf("%lld\n",max(sum,sum2));
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    if (n == 1) printf("1\n1\n");
    else if (n == 2) {
        printf("2\n0\n11\n");
    } else {
        printf("%d\n",n - 1);
        string s = "1";
        for (int i = 0;i < n - 1;i ++) {
            if (i != 0) s += '0';
            cout << s;
            printf("1\n");
        }
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int a,b;
    int n;
    int s = 0;
    while (T --) {
        s = 0;
        scanf("%d",&n);
        while (n --) {
            scanf("%d%d",&a,&b);
            if (b - a >= 2) s ++;
        }
        printf("%d\n",s);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    int T;
    scanf("%d",&T);
    int a[200010];
    int s = 0;
    int m;
    while (T --) {
        scanf("%d%d",&n,&k);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        sort(a, a + n);
        s = 0;
        m = 1;
        for (int i = 0;i < n;i ++) {
            while (a[i] - a[s] > k) {
                s ++;
            }
            m = max(m,i - s + 1);
        }
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
int main()
{
    ll n,m;
    scanf("%lld%lld",&n,&m);
    int a[500010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    sort(a, a + n);
    int s = 0;
    ll k = 0;
    for (int i = 0;i < n;i ++) {
        k += a[i];
        if (k > m) break;
        s ++;
    }
    printf("%d\n",s);
    return 0;
}
*/

//int a[1000010];
//int vis[1000010] = {0};
//vector<int> g[1000010];
//ll val[1000010];
//
//void dfs(int f,int n)
//{
//    a[n] = f;
//    vis[n] = 1;
//    for (auto i : g[n]) {
//        if (vis[i]) continue;
//        dfs(n,i);
//        val[n] += val[i];
//    }
//}
//
//void update(int n,int v)
//{
//    int u = v;
//    while (a[n] != 0) {
//        val[n] += u;
//        n = a[n];
//    }
//}
//
//int main()
//{
//    int n,m,k;
//    scanf("%d%d%d",&n,&m,&k);
//    for (int i = 1;i <= n;i ++) scanf("%lld",val + i);
//    int u,v;
//    for (int i = 0;i < n - 1;i ++) {
//        scanf("%d%d",&u,&v);
//        g[u].push_back(v);
//        g[v].push_back(u);
//    }
//    dfs(0,k);
//    int op;
//    int node;
//    for (int i = 0;i < m;i ++) {
//        scanf("%d",&op);
//        if (op == 1) {
//            scanf("%d%d",&node,&v);
//            update(node,v);
//        } else {
//            scanf("%d",&node);
//            printf("%lld\n",val[node]);
//        }
//    }
//    return 0;
//}


/*int* gg[10010] = {NULL};

int g(int n,int k)
{
    return gg[n / 100000][n % 100000] = k;
}

int g(int n)
{
    return gg[n / 100000][n % 100000];
}

int find(int a)
{
    if (g(a) == a) return a;
    return g(a,find(g(a)));
}

inline void bind(int a,int b)
{
    g(find(a),find(b));
}

int main()
{
    int T;
    scanf("%d",&T);
    int n;
    int a,b,c;
    struct K {
        int a,b;
    };
    vector<K> zz;
    while (T --) {
        for (int i = 0;i < 10010;i ++) {
            if (gg[i] != NULL) {
                delete[] gg[i];
            }
            gg[i] = new int[100010];
        }
        zz.clear();
        scanf("%d",&n);
        while (n --) {
            scanf("%d%d%d",&a,&b,&c);
            a --;
            b --;
            if (c == 1) {
                bind(a,b);
            } else {
                zz.push_back({a,b});
            }
        }
        int ok = 1;
        for (auto i : zz) {
            if (find(i.a) == find(i.b)) {
                ok = 0;
                break;
            }
        }
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll a[500010];
    for (int i = 0;i < n;i ++) scanf("%lld",a + i);
    sort(a,a + n);
    n --;
    for (int i = 0;i < n;i ++) {
        a[i] = a[i + 1] - a[i];
    }
    ll s = 0;
    ll last = 0;
    ll l = 0;
    const int mod = 1000000007;
    for (int i = 0;i < n;i ++) {
        l = (l + ((i + 1) * ((a[i] * a[i]) % mod) % mod + (2 * a[i] * last) % mod) % mod) % mod;
        s = (s + l) % mod;
        last = (last + ((i + 1) * a[i]) % mod) % mod;
    }
    printf("%lld\n",s);
    return 0;
}
*/

//
//int main()
//{
//    int n,q;
//    scanf("%d%d",&n,&q);
//    int t[100010],s[100010];
//    for (int i = 0;i < n;i ++) {
//        scanf("%d%d",s + i,t + i);
//    }
//    int a,b,c;
//    int k;
//    for (int i = 0;i < q;i ++) {
//        scanf("%d%d%d",&a,&b,&c);
//        k = 0;
//        for (int i = 0;i < n;i ++) {
//            if (s[i] >= a && t[i] >= b && t[i] + s[i] >= c) k ++;
//        }
//        printf("%d\n",k);
//    }
//    return 0;
//}
//

/*
map<int,int> dis[500010];
vector<int> g[500010];
int vis[500010];

void dfs(int s,int n,int d)
{
    dis[s][n] = d;
    dis[n][s] = d;
    vis[n] = 1;
    for (auto i : g[n]) {
        if (vis[i]) continue;
        dfs(s,i,d + 1);
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    for (int i = 0;i < n - 1;i ++) {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int i = 1;i <= n;i ++) {
        mem(vis,0);
        dfs(i,i,0);
    }
    int a,b,c;
    int miin = 0,mm = 0;
    int t;
    for (int i = 0;i < m;i ++) {
        scanf("%d%d%d",&a,&b,&c);
        for (int i = 1;i <= n;i ++) {
            t = dis[i][a] + dis[i][b] + dis[i][c];
            if (i == 1) {
                miin = t;
                mm = i;
            } else if (t < miin) {
                miin = t;
                mm = i;
            }
        }
        printf("%d %d\n",mm,miin);
    }
    return 0;
}
*/

/*
int main()
{
    double  r;
    scanf("%lf",&r);
    printf("%.20f\n",2 * pi * r);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int in;
    ll sum = 0;
    for (int i = 0;i < m;i ++) {
        scanf("%d",&in);
        sum += in;
    }
    if (n >= sum) printf("%lld\n",n - sum);
    else printf("-1\n");
    
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[200010] = {0};
    int in;
    for (int i = 0;i < n - 1;i ++) {
        scanf("%d",&in);
        a[in] ++;
    }
    for (int i = 1;i <= n;i ++) {
        printf("%d\n",a[i]);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    ll sum = 0;
    ll init = n + 1;
    ll init_plus = n - 2;
    const int mod = 1000000007;
    for (int i = 1;i <= n + 1;i ++) {
        if (i >= k) sum = (sum + init) % mod;
        init = init + init_plus;
        init_plus = init_plus - 2;
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    pair<int,int> a[2010];
    int in;
    for (int i = 0;i < n;i ++) {
        scanf("%d",&in);
        a[i].first = in;
        a[i].second = i;
    }
    sort(a, a + n, greater<pair<int,int> >());
    
    
    return 0;
}
*/


/*
class A {
public:
    int x;
    A(int x):x(x) {}
};

class B {
public:
    int x;
    B(int x):x(x) {}
};

class C {
public:
    A a;
    B b;
    C(int a,int b):a(a),b(b) {}
    C(A a,B b):a(a.x),b(b.x) {}
    
    int plus() {
        return a.x + b.x;
    }
};


int main()
{
    A a(1);
    B b(2);
    C c(a,b);
    cout << a.x << "+" << b.x << "=" << c.plus() << endl;
    C cc(3,4);
    cout << cc.a.x << "+" << cc.b.x << "=" << cc.plus() << endl;
    
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    int a[200010];
    int b[200010];
    int k,f,m,s;
    while (T --) {
        scanf("%d",&n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        k = 0;
        s = (a[0] / abs(a[0])) * -1;
        f = 1;
        m = 0;
        for (int i = 0;i < n;i ++) {
            if (a[i] / abs(a[i]) != s) {
                if (f == 1) f = 0;
                else b[k ++] = m;
                m = a[i];
                s = a[i] / abs(a[i]);
            } else {
                m = max(m,a[i]);
            }
        }
        b[k ++] = m;
        ll sum = 0;
        for (int i = 0;i < k;i ++) sum += b[i];
        printf("%lld\n",sum);
    }
    return 0;
}
*/

/*
void solve()
{
    int n;
    int k;
    ll s;
    int mid;
    scanf("%d",&n);
    if (n % 4 == 0)
    {
        printf("YES\n2");
        k = 2;
        mid = n / 2 - 1;
        s = 2;
        for (int i = 0;i < mid;i ++)
        {
            k += 2;
            printf(" %d",k);
            s += k;
        }
        k = 1;
        fir (int i = 0;i < mid;i ++)
        {
            s -= k;
            printf(" %d",k);
            k += 2;
        }
        printf(" %lld\n",s);
    } else printf("NO\n");
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T --)
    {
        solve();
    }
    return 0;
}
*/

/*
const int maxn = 2e5+10;
int a[maxn],c[maxn*2];
int main(){
    int T;
    for(scanf("%d",&T);T;T--){
        int n,k;
        scanf("%d%d",&n,&k);
        for(int i = 2; i <= 2*k; i++) c[i] = 0;
        for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
        for(int i = 1; i <= n/2; i++){
            c[2] += 2;
            c[min(a[i],a[n-i+1])+1]--;
            c[a[i]+a[n-i+1]]--;
            c[a[i]+a[n-i+1]+1]++;
            c[max(a[i],a[n-i+1])+k+1]++;
        }
        int ans = 2*n;
        for(int i = 2; i <= 2*k; i++){
            c[i] = c[i]+c[i-1];
            printf("%d ",c[i]);
            ans = min(ans,c[i]);
        }
        printf("\n%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    ll n;
    ll k;
    while (T --) {
        scanf("%lld",&n);
        k = 4;
        while (n % (k - 1)) k <<= 1;
        printf("%lld\n",n / (k - 1));
    }
    return 0;
}
*/


/// long long组合数带mod模版，Lucas定理
//ll quick_mod(ll a, ll b)
//{
//    ll ans = 1;
//    a %= mod;
//    while(b)
//    {
//        if(b & 1)
//        {
//            ans = ans * a % mod;
//            b--;
//        }
//        b >>= 1;
//        a = a * a % mod;
//    }
//    return ans;
//}
//
//ll C(ll n, ll m)
//{
//    if(m > n) return 0;
//    ll ans = 1;
//    for(int i=1; i<=m; i++)
//    {
//        ll a = (n + i - m) % mod;
//        ll b = i % mod;
//        ans = ans * (a * quick_mod(b, mod-2) % mod) % mod;
//    }
//    return ans;
//}
//
//ll Lucas(ll n, ll m)
//{
//    if(m == 0) return 1;
//    return C(n % mod, m % mod) * Lucas(n / mod, m / mod) % mod;
//}


/*const int mod = 998244353;

ll a[5010][1010] = {0};

int main()
{
    // 杨辉三角，组合数预处理
    a[0][0] = 1;
    for(int i = 1;i <= 5000;i ++)
    {
        a[i][0] = 1;
        for (int j = 1;j <= min(i, 1000);j ++)
        {
            a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % mod;
        }
    }
    
    
    int T;
    int x,y,t;
    ll j;

    for (scanf("%d",&T);T --;) {
        scanf("%d%d%d",&x,&y,&t);
        if (x + y > t) {
            printf("0\n");
            continue;
        }
        if(x > y) swap(x,y);
        j = (a[t][y] * a[t - y][x]) % mod;

        printf("%lld\n",j);
    }
    return 0;
}*/


/*int main()
{
    int T;
    int n,k;
    int a[200010];
    for (scanf("%d",&T);T --;) {
        scanf("%d%d",&n,&k);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        
    }
    return 0;
}
*/

/*int main()
{
    int n;
    scanf("%d",&n);
    int a[1010];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    sort(a,a + n);
    int count = 0;
    int aa,bb;
    for (int i = 0;i < n;i ++) {
        for (int j = i + 1;j < n;j ++) {
            for (int k = j + 1;k < n;k ++) {
                aa = a[j] - a[i];
                bb = a[k] - a[j];
                if (bb >= aa) {
                    if (bb <= aa * 2) count ++;
                    else break;
                }
            }
        }
    }
    printf("%d\n",count);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int x[100010],y[100010];
    for (int i = 0;i < n;i ++) scanf("%d%d",x + i,y + i);
    int dis[100010];
    int k = 0;
    ll all = 0;
    for (int i = 1;i < n - 1;i ++) {
        dis[k ++] = abs(x[i] - x[i - 1]) + abs(y[i] - y[i - 1]) + abs(x[i + 1] - x[i]) + abs(y[i + 1] - y[i]) - abs(x[i + 1] - x[i - 1]) - abs(y[i + 1] - y[i - 1]);
        all += abs(x[i] - x[i - 1]) + abs(y[i] - y[i - 1]);
    }
    all += abs(x[n - 1] - x[n - 2]) + abs(y[n - 1] - y[n - 2]);
    sort(dis, dis + k);
    printf("%lld\n",all - dis[k - 1]);
    return 0;
}
*/

/*char a[60][60];
int n,m;

int checkV(int x,int y)
{
    if (a[y][x] == '#') return 0;
    if (y - 1 < 0 || a[y - 1][x] == '#')
    {
        if (y + 2 < n && a[y + 1][x] == '.' && a[y + 2][x] == '.') return 1;
    }
    return 0;
}

int checkH(int x,int y)
{
    if (a[y][x] == '#') return 0;
    if (x - 1 < 0 || a[y][x - 1] == '#')
    {
        if (x + 2 < m && a[y][x + 1] == '.' && a[y][x + 2] == '.') return 1;
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i = 0;i < n;i ++) {
        scanf(" ");
        for (int j = 0;j < m;j ++) {
            scanf("%c",&a[i][j]);
        }
    }
    vector<pair<int, int>> all;
    for (int i = 0;i < n;i ++) {
        for (int j = 0;j < m;j ++) {
            if (checkH(j, i) || checkV(j, i)) all.push_back(make_pair(i + 1,j + 1));
        }
    }
    printf("%lu\n",all.size());
    for (auto i : all) {
        printf("%d %d\n",i.first,i.second);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    map<set<string>,int> all;
    set<string> in;
    string a,b,c;
    for (int i = 0;i < n;i ++)
    {
        cin >> a >> b >> c;
        in.clear();
        in.insert(a);
        in.insert(b);
        in.insert(c);
        all[in] ++;
    }
    int m = -1;
    for (auto i : all) {
        m = max(m,i.second);
    }
    printf("%d\n",m);
    return 0;
}
*/

/*
int cmp(pair<int,int> &a,pair<int, int> &b)
{
    if (a.first == b.first) {
        return a.second < b.second;
    }
    return a.first > b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    int u,v;
    pair<int,int> cow[10010];
    set<int> avb;
    for (int i = 1;i <= 10000;i ++) avb.insert(i);
    for (int i = 0;i < n;i ++) {
        scanf("%d%d",&u,&v);
        cow[i].first = u;
        cow[i].second = v;
    }
    sort(cow, cow + n, cmp);
    ll sum = 0;
    set<int>::iterator it;
    for (int i = 0;i < n && !avb.empty();i ++) {
        it = avb.lower_bound(cow[i].second);
        if (it != avb.end()) {
            if (*it == cow[i].second) {
                sum += cow[i].first;
                avb.erase(it);
            } else {
                if (it != avb.begin()) {
                    sum += cow[i].first;
                    avb.erase(-- it);
                }
            }
        }
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll a,b;
    int T;
    for (scanf("%d",&T);T --;) {
        scanf("%lld %lld",&a,&b);
        printf("%lld\n",(quickpow(2, a - 1) * b) % mod);
    }
    return 0;
}
*/

/*
void tg(string str,ll *chr)
{
    for (int i = 0;str[i];i ++) {
        chr[str[i]] ++;
    }
}

void out(ll *a)
{
    for (int i = 'A';i <= 'z';i ++) {
        if (a[i] != 0) printf("%c: %lld\n",i,a[i]);
    }
}

void pl(ll *a,ll *b,ll *tg) {
    for (int i = 'A';i <= 'z';i ++) {
        tg[i] = a[i] + b[i];
    }
}

void cpy(ll *a,ll *tg) {
    for (int i = 'A';i <= 'z';i ++) {
        tg[i] = a[i];
    }
}

int main()
{
    string s,t;
    cin >> s >> t;
    itn n;
    scanf("%d",&n);
    ll a['z' + 1] = {0},b['z' + 1] = {0},c['z' + 1] = {0};
    tg(s,a);
    tg(t,b);
    if (n == 1) {
        out(a);
    } else if (n == 2) {
        out(b);
    } else for (int i = 3;i <= n;i ++) {
        pl(a,b,c);
        cpy(b,a);
        cpy(c,b);
    }
    out(c);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[110];
    int b[110];
    int c[110];
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    for (int i = 0;i < n;i ++) scanf("%d",b + i);
    for (int i = 0;i < n;i ++) scanf("%d",c + i);
    int miin;
    int maax = -INT_INF;
    int zz;
    for (int i = 0;i < n;i ++) {
        miin = INT_INF;
        for (int j = 0;j < n;j ++) {
            zz = INT_INF;
            for (int k = 0;k < n;k ++) {
                if (abs(a[i] + b[j] + c[k]) < abs(zz)) {
                    zz = a[i] + b[j] + c[k];
                } else if (abs(a[i] + b[j] + c[k]) == abs(zz)) {
                    zz = max(zz,a[i] + b[j] + c[k]);
                }
            }
            miin = min(miin,zz);
        }
        maax = max(maax,miin);
    }
    printf("%d\n",maax);
    return 0;
}

*/

/*
int main()
{
    int T;
    int n,m,s,*k;
    int a[100010];
    
    for (scanf("%d",&T);T --;)
    {
        scanf("%d%d",&n,&m);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        s = ++ a[0];
        m --;
        sort(a, a + n);
        k = lower_bound(a, a + n, s);
        
//        for (int i = 0;i < n;i ++) printf("%d ",a[i]);
//        printf("\n");
        
        for (int *i = a + n - 1;i > k && m > 0;i --,m --) {
            (*i) ++;
        }
        
//        for (int i = 0;i < n;i ++) printf("%d ",a[i]);
//        printf("\n");
        
        for (int *i = a;i < k && m > 0;i ++, m --) {
            (*i) ++;
        }
        
        sort(a, a + n);
//        for (int i = 0;i < n;i ++) printf("%d ",a[i]);
//        printf("\n");
        
        k = lower_bound(a, a + n, s);
        printf("%lu\n",a + n - k);
    }
    return 0;
}
*/

/*int cont = 0;
int i;

void dfs(int dps,int k)
{
    if (k < 0) return;
    if (dps >= i * 2) {
        if (dps == i * 2 && k == 0) cont ++;
        return;
    }
    dfs(dps + 1,k - 1);
    dfs(dps + 2,k);
    dfs(dps + 1,k + 1);
}

int main()
{
    int n = 100;
    for (i = 0;i <= n;i ++) {
        cont = 0;
        dfs(0,0);
        printf("%d: %d\n",i,cont);
    }
    return 0;
}
*/

/// 逆元：a / b % mod = a * qp(b,mod - 2) % mod;
/*const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    const int mod = 998244353;
    int n;
    scanf("%d",&n);
    ll a[100010] = {0};
    a[0] = 1;
    a[1] = 2;
    for (int i = 2;i <= n;i ++) {
        a[i] = ((6 * i - 3) * a[i - 1] % mod- (i - 2) * a[i - 2] % mod + mod) % mod * quickpow(i + 1,mod - 2) % mod;
    }
    printf("%lld\n",a[n]);
    return 0;
}
*/


/// a % c = d
/// b % c = d
/// (a - b) % c = 0
/*int main()
{
    string str;
    cin >> str;
    int k;
    int last = 0;
    int a[2020] = {0};
    a[0] = 1;
    ll ans = 0;
    int l = 1;
    for (int i = (int) str.size() - 1;i >= 0;i --) {
        k = str[i] ^ 48;
        last = (last + k * l) % 2019;
        l = (l * 10) % 2019;
        ans += a[last] ++;
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*class Object {
protected:
    int i;
    string type;
public:
    Object(int index,string type):i(index),type(type)
    {
        cout << "You create a " << type << "! Indexed " << i << "." << endl;
    }
    
    ~Object()
    {
        cout << i << "-th " << type << " was Destoried!" << endl;
    }
};

class Window : public Object {
    
public:
    Window(int index):Object(index,"Window") {}
    
    void open() {
        cout << "Window " << i << " opened!" << endl;
    }
};

class Wheel : public Object {
public:
    Wheel(int index):Object(index,"Wheel") {}
    
    void run()
    {
        cout << "Wheel " << i << " is running!" << endl;
    }
};

class Door : public Object  {
public:
    Door(int index):Object(index,"Door") {}
    
    void open() {
        cout << "Door " << i << " opened!" << endl;
    }
};

class Car {
    Door *doors[4];
    Wheel *wheels[4];
    Window *windows[4];
    string name;
public:
    Car(string name):name(name)
    {
        for (int i = 0;i < 4;i ++) {
            doors[i] = new Door(i);
            wheels[i] = new Wheel(i);
            windows[i] = new Window(i);
        }
        cout << "You create a Car!" << endl;
    }
    
    void call()
    {
        cout << "My name is " << name << "." << endl;
    }
    
    void run()
    {
        for (int i = 0;i < 4;i ++) {
            wheels[i] -> run();
        }
    }
        
    void openDoor(int i) {
        doors[i] -> open();
    }
        
    void openWindow(int i) {
        windows[i] -> open();
    }
    
    ~Car()
    {
        for (int i = 0;i < 4;i ++) {
            delete doors[i];
            delete wheels[i];
            delete windows[i];
        }
        cout << "Your car \"" << name << "\" was destroied!" << endl;
    }
};

int main()
{
    Car c("Jack");
    c.call();
    c.openDoor(0);
    c.run();
    c.openWindow(1);
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    if (T == 1) printf("Yang\n");
    else printf("Shi\n");
    return 0;
}

*/

/*int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i <= sqrt(n);i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int T;
    scanf("%d",&T);
    ll j;
    int i,p;
    while (T --) {
        scanf("%d",&p);
        if (isZhi(p)) {
            printf("%d\n",p);
            continue;
        }
        j = 1;
        for (i = 1;i <= p;i ++) {
            j = (j * i) % p;
            if (j == 0) {
                printf("%d\n",i);
                break;
            }
            
            if (p % i == 0) {
                if (p / i > i && isZhi(p / i)) {
                    printf("%d\n",p / i);
                    break;
                }
            }
        }
    }
    return 0;
}
*/

/// 数组模拟链表
/*
int a[500010];
int nxt[500010];
int ed;

int main()
{
    int n,q;
    memset(nxt, -1, sizeof(nxt));
    scanf("%d%d",&n,&q);
    int in;
    int start = 1;
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
        if (i != n) nxt[i] = i + 1;
    }
    ed = n + 1;
    int op,k;
    for (int i = 0;i < q;i ++) {
        scanf("%d",&op);
        if (op == 1) {
            scanf("%d%d",&k,&in);
            a[ed] = in;
            nxt[ed] = nxt[k];
            nxt[k] = ed ++;
        } else {
            scanf("%d",&in);
            k = start;
            for (int i = 1;i < in;i ++) {
                k = nxt[k];
            }
            printf("%d\n",a[k]);
        }
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[200010];
    int nxt[200010];
    int pre[200010];
    memset(nxt, -1, sizeof(nxt));
    memset(pre, -1, sizeof(pre));
    int in;
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
        if (i != n) nxt[i] = i + 1;
        if (i != 1) pre[i] = i - 1;
    }
    for (int i = 0;i < n;i ++) {
        scanf("%d",&in);
        printf("%d %d\n",(pre[in] != -1) ? a[pre[in]] : -1,nxt[in] != -1 ? a[nxt[in]] : -1);
        if (nxt[in] != -1) pre[nxt[in]] = pre[in];
        if (pre[in] != -1) nxt[pre[in]] = nxt[in];
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100];
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) scanf("%d",a + i);
    int miin = INT_INF;
    int d = 0;
    for (int i = 1;i <= n - 2;i ++) {
        int mx = max(a[i],a[i + 2]);
        if (mx < miin) {
            miin = mx;
            d = i;
        }
    }
    printf("%d %d\n",d,miin);
    return 0;
}
*/

/*vector<pair<char,string>> g['z' + 1];

int main()
{
    string str;
    cin >> str;
    int n;
    scanf("%d",&n);
    string in;
    while (n --) {
        cin >> in;
        g[in[0]].push_back(make_pair(in[in.size() - 1],in));
    }
    vector<pair<char,string>> k = g[str[str.size() - 1]];
    if (k.size() == 0) printf("?\n");
    else {
        int ok = 0;
        string a;
        for (auto i : k) {
            if (g[i.first].size() == 0) {
                ok = 1;
                a = i.second;
                break;
            } else if (i.second[0] == i.second[i.second.size() - 1]) {
                if (g[i.first].size() == 1) {
                    ok = 1;
                    a = i.second;
                    break;
                }
            }
        }
        if (ok) cout << a << "!" << endl;
        else cout << k[0].second << endl;
    }
    
    return 0;
}
*/

/*
int main()
{
    cio
    string str;
    getline(cin, str);
    int w = 0;
    for (int i = 0;str[i];i ++) if (str[i] == ' ') w ++;
    int n;
    cin >> n;
    vector<string> all;
    for (int i = 0;i < n;i ++) {
        cin >> str;
        all.push_back(str);
    }
    vector<string> a,b;
    int size,s = 0;
    int t = 1;
    while (!all.empty()) {
        size = (int) all.size();
        s = (s + w) % size;
        if (t) a.push_back(all[s]);
        else b.push_back(all[s]);
        t = !t;
        all.erase(all.begin() + s);
    }
    cout << a.size() << endl;
    for (auto i : a) cout << i << endl;
    cout << b.size() << endl;
    for (auto i : b) cout << i << endl;
    return 0;
}
*/

/*
int main()
{
    ll n,m,a;
    scanf("%lld%lld%lld",&n,&m,&a);
    if (m == n && m == 1) printf("0\n");
    if (a % m == 0 || a % n == 0) printf("1\n");
    else {
        ll mx = max(m,n);
        ll mn = min(m,n);
        int ok = 0;
        for (int i = 1;i <= mn;i ++) {
            if (a % i == 0) {
                if (a / i < mx) {
                    ok = 1;
                    break;
                }
            }
        }
        a = m * n - a;
        for (int i = 1;i <= mn;i ++) {
            if (a % i == 0) {
                if (a / i < mx) {
                    ok = 1;
                    break;
                }
            }
        }
        if (ok) printf("2\n");
        else printf("3\n");
    }
    return 0;
}
*/

/*
ll case1(ll a1,ll b1,ll a2,ll b2,ll a3,ll b3)
{
    ll h = max(max(b1,b2),b3);
    ll w = a1 + a2 + a3;
    return h * w;
}

ll case2(ll a1,ll b1,ll a2,ll b2,ll a3,ll b3)
{
    ll s;
    if (b2 == b3) {
        ll w = max(a2 + a3,a1);
        ll h = b2 + b1;
        s = w * h;
    } else {
        ll w;
        ll h;
        if (b2 > b3) {
            swap(b2,b3);
            swap(a2,a3);
        }
        w = a3 + max(a2,a1);
        h = max(b3,b2 + b1);
        s = w * h;
        w = max(a2 + a3,a1);
        h = b3 + b1;
        s = min(s,w * h);
    }
    return s;
}

int main()
{
    int T;
    ll a1,b1,a2,b2,a3,b3;
    for (scanf("%d",&T);T --;)
    {
        scanf("%lld%lld%lld%lld%lld%lld",&a1,&b1,&a2,&b2,&a3,&b3);
        ll m1 = case1(a1,b1,a2,b2,a3,b3);
        m1 = min(m1,case1(b1,a1,a2,b2,a3,b3));
        m1 = min(m1,case1(b1,a1,b2,a2,a3,b3));
        m1 = min(m1,case1(a1,b1,b2,a2,a3,b3));
        m1 = min(m1,case1(b1,a1,a2,b2,b3,a3));
        m1 = min(m1,case1(a1,b1,a2,b2,b3,a3));
        m1 = min(m1,case1(a1,b1,b2,a2,b3,a3));
        m1 = min(m1,case1(b1,a1,b2,a2,b3,a3));
        
        ll m2 = case2(a1,b1,a2,b2,a3,b3);
        m2 = min(m2,case2(b1,a1,a2,b2,a3,b3));
        m2 = min(m2,case2(a1,b1,b2,a2,a3,b3));
        m2 = min(m2,case2(b1,a1,b2,a2,a3,b3));
        m2 = min(m2,case2(a1,b1,a2,b2,b3,a3));
        m2 = min(m2,case2(b1,a1,a2,b2,b3,a3));
        m2 = min(m2,case2(a1,b1,b2,a2,b3,a3));
        m2 = min(m2,case2(b1,a1,b2,a2,b3,a3));
        
    
        m2 = min(m2,case2(a1,b1,a3,b3,a2,b2));
        m2 = min(m2,case2(b1,a1,a3,b3,a2,b2));
        m2 = min(m2,case2(a1,b1,b3,a3,a2,b2));
        m2 = min(m2,case2(b1,a1,b3,a3,a2,b2));
        m2 = min(m2,case2(a1,b1,a3,b3,b2,a2));
        m2 = min(m2,case2(b1,a1,a3,b3,b2,a2));
        m2 = min(m2,case2(a1,b1,b3,a3,b2,a2));
        m2 = min(m2,case2(b1,a1,b3,a3,b2,a2));
        
        m2 = min(m2,case2(a2,b2,a1,b1,a3,b3));
        m2 = min(m2,case2(b2,a2,a1,b1,a3,b3));
        m2 = min(m2,case2(a2,b2,b1,a1,a3,b3));
        m2 = min(m2,case2(b2,a2,b1,a1,a3,b3));
        m2 = min(m2,case2(a2,b2,a1,b1,b3,a3));
        m2 = min(m2,case2(b2,a2,a1,b1,b3,a3));
        m2 = min(m2,case2(a2,b2,b1,a1,b3,a3));
        m2 = min(m2,case2(b2,a2,b1,a1,b3,a3));
        
        m2 = min(m2,case2(a2,b2,a3,b3,a1,b1));
        m2 = min(m2,case2(b2,a2,a3,b3,a1,b1));
        m2 = min(m2,case2(a2,b2,b3,a3,a1,b1));
        m2 = min(m2,case2(b2,a2,b3,a3,a1,b1));
        m2 = min(m2,case2(a2,b2,a3,b3,b1,a1));
        m2 = min(m2,case2(b2,a2,a3,b3,b1,a1));
        m2 = min(m2,case2(a2,b2,b3,a3,b1,a1));
        m2 = min(m2,case2(b2,a2,b3,a3,b1,a1));
        
        m2 = min(m2,case2(a3,b3,a1,b1,a2,b2));
        m2 = min(m2,case2(b3,a3,a1,b1,a2,b2));
        m2 = min(m2,case2(a3,b3,b1,a1,a2,b2));
        m2 = min(m2,case2(b3,a3,b1,a1,a2,b2));
        m2 = min(m2,case2(a3,b3,a1,b1,b2,a2));
        m2 = min(m2,case2(b3,a3,a1,b1,b2,a2));
        m2 = min(m2,case2(a3,b3,b1,a1,b2,a2));
        m2 = min(m2,case2(b3,a3,b1,a1,b2,a2));
        
        m2 = min(m2,case2(a3,b3,a2,b2,a1,b1));
        m2 = min(m2,case2(b3,a3,a2,b2,a1,b1));
        m2 = min(m2,case2(a3,b3,b2,a2,a1,b1));
        m2 = min(m2,case2(b3,a3,b2,a2,a1,b1));
        m2 = min(m2,case2(a3,b3,a2,b2,b1,a1));
        m2 = min(m2,case2(b3,a3,a2,b2,b1,a1));
        m2 = min(m2,case2(a3,b3,b2,a2,b1,a1));
        m2 = min(m2,case2(b3,a3,b2,a2,b1,a1));
        
        printf("%lld\n",min(m1,m2));
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int a[1000010];
    int s = 0;
    for (int i = 0;i < n;i ++) {
        scanf("%d",a + i);
        s += a[i];
    }
    sort(a, a + n);
    int g = 0;
    for (int i = 0;i < n && m > s;i ++) {
        s += 9 - a[i];
        a[i] = 9;
        g ++;
    }
    printf("%d\n",g);
    return 0;
}
*/

/*int vis[15] = {0};
int n;

int all;

void dfs(int d)
{
    if (vis[d]) dfs(d + 1);
    if (d > n) {
        all ++;
        return;
    }
    for (int i = 1;i <= n;i ++) {
        if (!vis[i] && !vis[d]) {
            vis[i] = 1;
            vis[d] = 1;
            dfs(d + 1);
            vis[i] = 0;
            vis[d] = 0;
        }
    }
}*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll a[100010];
    a[1] = 1;
    a[2] = 2;
    int mod = 1000000007;
    for (int i = 3;i <= n;i ++) {
        a[i] = (a[i - 1] + a[i - 2] * (i - 1) % mod) % mod;
    }
    printf("%lld\n",a[n]);
    return 0;
}
*/


//int vis[30] = {0};
//int del[30] = {0};
//vector<int> g[30];
//int a[30];
//
//int mx = -1;
//int mx_n = 0;
//
//int n,l;
//
//void dfs(int n,int d)
//{
//    vis[n] = 1;
//    if (d > mx) {
//        mx = d;
//        mx_n = n;
//    }
//    for (auto i : g[n]) {
//        if (!vis[i] && !del[i]) dfs(i,d + 1);
//    }
//}
//
//int k = 0;
//
//int make(int ok) {
//
//        mem(vis,0);
//        mx = -1;
//        dfs(ok,0);
//        int s = mx_n;
//
//        mem(vis,0);
//        mx = -1;
//        dfs(s,0);
////        printf("%d->%d\n",s,e);
//        return mx;
//}
//
//int main()
//{
//    scanf("%d%d",&n,&l);
//    for (int i = 1;i <= n;i ++) scanf("%d",a + i);
//    int u,v;
//    for (int i = 0;i < n - 1;i ++) {
//        scanf("%d%d",&u,&v);
//        g[u].push_back(v);
//        g[v].push_back(u);
//    }
//
//    int all = 1 << n;
//    int k;
//    int mn = INT_INF;
//    int mm = -1;
//    int x;
//    for (int i = 0;i < all;i ++) {
//        k = i;
//        mem(del,0);
//        x = 0;
//        for (int j = 1;k != 0;j ++) {
//            if ((del[j] = k & 1) == 1) {
//                x += a[j];
//            }
//            k >>= 1;
//        }
////        for (int i = 1;i <= n;i ++) printf("%d ",a[i]);
////        printf("\n");
////        for (int i = 1;i <= n;i ++) printf("%d ",del[i]);
////        printf("\n");
////        printf("%d\n",x);
//        mm = -1;
//        int t;
//        int ok = 1;
//        for (int j = 1;j <= n;j ++) {
//            if (!del[j]) {
//                t = make(j);
//                if (mm != -1 && t != mm) {
//                    ok = 0;
//                    break;
//                } else mm = t;
//            }
//        }
//        if (mm < l && ok) mn = min(mn,x);
//    }
//    printf("%d\n",mn);
//
//
////    make();
////    printf("%d\n",k);
//
//    return 0;
//}

/*
int a[5000010];
int b[5000010];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    for (int i = 0;i < m;i ++) scanf("%d",b + i);
    int f = 1;
    int i = 0,j = 0;
    for (;i < n && j < m;)
    {
        if (f) f = 0;
        else printf(" ");
        if (a[i] <= b[j]) {
            printf("%d",a[i]);
            i ++;
        } else {
            printf("%d",b[j]);
            j ++;
        }
    }
    for (;i < n;i ++) printf(" %d",a[i]);
    for (;j < m;j ++) printf(" %d",b[j]);
    printf("\n");
    return 0;
}
*/

//int t[1000010];
//
//void merge(int *a,int *e)
//{
//    int n = (int) (e - a);
//    int k = 0;
//    int m = n / 2;
//    int i = 0,j = m;
//
//    for (;i < m && j < n;) {
//        if (a[i] <= a[j]) {
//            t[k ++] = a[i ++];
//        } else {
//            t[k ++] = a[j ++];
//        }
//    }
//    for (;i < m;i ++) t[k ++] = a[i];
//    for (;j < n;j ++) t[k ++] = a[j];
//    for (int i = 0;i < n;i ++) {
//        a[i] = t[i];
//    }
//}
//
//void merge_sort(int *a,int *e)
//{
//    int n = (int) (e - a);
//    int j;
//    for (int i = 2;i < n;i *= 2) {
//        for (j = 0;j + i < n;j += i) {
//
//        }
//    }
//}
//
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int a[1000010];
//    for (int i = 0;i < n;i ++) scanf("%d",a + i);
//
//    return 0;
//}

/*
int main()
{
    int k,a,b;
    scanf("%d%d%d",&k,&a,&b);
    int x = a / k;
    int y = x * k;
    if (y <= b && y >= a) printf("OK\n");
    else {
        y = (x + 1) * k;
        if (y <= b && y >= a) printf("OK\n");
        else printf("NG\n");
    }
    
    
    return 0;
}
*/

/*
int main()
{
    ll x;
    scanf("%lld",&x);
    ll k = 100;
    ll f = 0;
    while (k < x) {
        k *= 1.01;
        f ++;
    }
    printf("%lld\n",f);
    return 0;
}
*/

/*
int n,m,q;
int mx = -1;

struct Score {
    int a,b,c,d;
} arr[100];

void dfs(int k,int d,vector<int> A) {
    if (d == n) {
        int s = 0;
        for (int j = 0;j < q;j ++) {
            if (A[arr[j].b - 1] - A[arr[j].a - 1] == arr[j].c) {
                s += arr[j].d;
            }
        }
        mx = max(mx,s);
        return;
    }
    for (int i = k;i <= m;i ++) {
        A.push_back(i);
        dfs(i,d + 1,A);
        A.erase(A.end() - 1);
    }
}

int main()
{
    scanf("%d%d%d",&n,&m,&q);
    
    int a,b,c,d;
    for (int i = 0;i < q;i ++) {
        scanf("%d%d%d%d",&a,&b,&c,&d);
        arr[i].a = a;
        arr[i].b = b;
        arr[i].c = c;
        arr[i].d = d;
    }
    dfs(1,0,vector<int>());
    printf("%d\n",mx);
    return 0;
}
*/

/*
int main()
{
    ll a,b,n;
    scanf("%lld%lld%lld",&a,&b,&n);
    ll x;
    if (b <= n) x = b - 1;
    else x = n;
    printf("%lld\n",a * x / b - a * (x / b));
    return 0;
}
*/

/*
int main()
{
    uint n;
    scanf("%u",&n);
    bitset<32> b;
    uint i = 0;
    while (n != 0) {
        b[i ++] = n & 1;
        n >>= 1;
    }
    int f = 1;
    for (int i = 31;i >= 0;i --) {
        if (!f) b[i].flip();
        if (f && b[i]) {
            b[i].flip();
            f = 0;
        }
    }
    uint k = 0;
    for (uint i = 0,j = 31;i < 32;i ++,j --) {
        k += b[i] * (1 << j);
    }
    printf("%u\n",k);
    return 0;
}
*/

/*int main()
{
    int h,m,s;
    scanf("%d:%d:%d",&h,&m,&s);
    s += 33;
    if (s >= 60) {
        s -= 60;
        m ++;
    }
    m += 22;
    if (m >= 60) {
        m -= 60;
        h ++;
    }
    h += 1;
    ll b = 19 * 60 * 60;
    ll e = 21 * 60 * 60;
    ll k = h * 60 * 60 + m * 60 + s;
    if (k >= e) printf("too late\n");
    else if (k >= b) printf("arrive late\n");
    else if (k < b) printf("arrive on time\n");
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int a[100010];
    scanf("%d%d",&n,&m);
    for (int i = 0;i < n;i ++) scanf("%d",a + i);
    sort(a,a + n);
    int l = 1;
    int r = a[n - 1];
    int s,x;
    int mm = 0;
    while (l <= r) {
        x = (l + r) / 2;
        s = 0;
        for (int i = 0;i < n;i ++) {
            s += a[i] / x;
        }
        if (s >= m) {
            mm = max(mm,x);
            l = x + 1;
        } else {
            r = x - 1;
        }
    }
    printf("%d\n",mm);
    return 0;
}
*/

/*
int main()
{
    ll k,l;
    scanf("%lld%lld",&k,&l);
    int x = log2(l);
    ll m = log2(l);
    while (x <= k && x > 0 && l != 0) {
        l -= (1ll << x);
        x = log2(l);
    }
    if (l == 0) {
        printf("Yes\n%lld\n",1ll << m);
    } else printf("No\n");
    return 0;
}
*/

/// lca
/*
int bcj[100010];
int d[100010];

int find(int a)
{
    if (bcj[a] == a) return a;
    return bcj[a] = find(bcj[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        bcj[y] = x; // 改变b节点的根的根为a的根
        if (d[x] == d[y]) { // 俩根深度一样
            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
        }
    } else bcj[x] = y;
}

vector<int> g[100010];
int h[100010] = {0};

void dfs(int n,int d)
{
    h[n] = d;
    for (auto i : g[n]) {
        
        dfs(i,d + 1);
    }
    
}

map<pair<int,int>,int> dis;

vector<int> query[100010]; //所有查询的内容
int ancestor[100010]; //已访问节点集合的祖先
bool vs[100010] = {0};      //访问标志
void Tarjan(int x) //Tarjan算法求解LCA
{
    for (auto i : g[x])
    {
        Tarjan(i);         //访问子树
        bind(x, i); //将子树节点与根节点x的集合合并
        ancestor[find(x)] = x;//合并后的集合的祖先为x
    }
    vs[x] = 1; //标记为已访问
    for (auto i : query[x]) //与根节点x有关的查询
        if (vs[i]){
            pair<int,int> v = make_pair(min(x,i),max(x,i));
            dis[v] = ancestor[find(i)]; //如果查询的另一个节点已访问，则输出结果
        }
}

int main()
{
    int a[100010];
    mem(a,-1);
    int n,q;
    scanf("%d%d",&n,&q);
    
    for (int i = 1;i <= n;i ++) {
        bcj[i] = i;
        d[i] = 1;
        ancestor[i] = i;
    }
    
    int u = -1,v;
    for (int i = 0;i < n - 1;i ++) {
        scanf("%d%d",&u,&v);
        a[v] = u;
        g[u].push_back(v);
    }
    int k = u;
    int root = -1;
    while (k != -1) {
        root = k;
        k = a[k];
    }
    
    dfs(root,0);
//    for (int i = 1;i <= n;i ++) printf("%d ",h[i]);
    
    vector<pair<int,int>> all;
    
    for (int i = 0;i < q;i ++) {
        scanf("%d%d",&u,&v);
        query[u].push_back(v);
        query[v].push_back(u);
        all.push_back(make_pair(u, v));
    }
    
    Tarjan(root);
    int kk,x;
    for (auto i : all) {
        
        kk = dis[make_pair(min(i.first,i.second), max(i.first,i.second))];
        if (kk == i.first || kk == i.second) {
            printf("NO\n%d\n",abs(h[i.second] - h[i.first]));
        } else {
            x = h[i.first] + h[i.second] - h[kk] * 2;
            if (x <= 4) printf("NO\n");
            else printf("YES\n");
            printf("%d\n",x);
        }
    }
    
    
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    int s[110] = {0};
    int d;
    int in;
    for (int i = 0;i < k;i ++) {
        scanf("%d",&d);
        for (int j = 0;j < d;j ++) {
            scanf("%d",&in);
            s[in] ++;
        }
    }
    int c = 0;
    for (int i = 1;i <= n;i ++) if (s[i] == 0) c ++;
    printf("%d\n",c);
    return 0;
}
*/

/*
vector<int> g[100010];
int vis[100010] = {0};

int a[100010];
int c = 0;

void dfs(int n) {
    vis[n] = 1;
    int ok = 1;
    for (auto i : g[n]) {
        if (a[i] >= a[n]) ok = 0;
        if (!vis[i]) dfs(i);
    }
    if (ok) c ++;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
    }
    int u,v = 1;
    for (int i = 0;i < m;i ++) {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int i = 1;i <= n;i ++) {
        if (!vis[i]) dfs(i);
    }
    printf("%d\n",c);
    return 0;
}
*/

/*
int main()
{
    ll x;
    scanf("%lld",&x);
    for (ll a = -500;a <= 500;a ++) {
        for (ll b = -500;b <= 500;b ++) {
            if (a * a * a * a * a - b * b * b * b * b == x) {
                printf("%lld %lld\n",a,b);
                return 0;
            }
        }
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[200010];
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
    }
    int x[200010];
    for (int i = 1;i <= n;i ++) {
        x[i] = i - a[i];
    }
    sort(x + 1, x + 1 + n);
    ll c = 0;
    for (int i = 1;i <= n;i ++) {
        if (a[i] + i == i - a[i]) c --;
        int *l = lower_bound(x + 1, x + n + 1, a[i] + i);
        int *e = upper_bound(x + 1, x + n + 1, a[i] + i);
        c += e - l;
    }
    printf("%lld\n",c);
    return 0;
}
*/

// 优先队列https://ac.nowcoder.com/acm/contest/5207/H
// 仅仅考虑最高的奶牛即可
/*
int cmp(const pair<int,int> &a,const pair<int,int> &b)
{
    return a.second < b.second;
}

int main()
{
    int n,d;
    scanf("%d%d",&n,&d);
    pair<int,int> a[50010];
    int x,h;
    for (int i = 0;i < n;i ++) {
        scanf("%d%d",&x,&h);
        a[i].first = h;
        a[i].second = x;
    }
    sort(a, a + n,cmp);
    priority_queue<pair<int, int>> q;
    int vis[50010] = {0};
    for (int i = 0;i < n;i ++) {
        while (!q.empty() && q.top().second < a[i].second - d) q.pop();
        if (!q.empty() && q.top().first >= 2 * a[i].first) vis[i] ++;
        q.push(a[i]);
    }
    while (!q.empty()) q.pop();
    
    for (int i = n - 1;i >= 0;i --) {
        while (!q.empty() && q.top().second > a[i].second + d) q.pop();
        if (!q.empty() && q.top().first >= 2 * a[i].first) vis[i] ++;
        q.push(a[i]);
    }
    
    int c = 0;
    for (int i = 0;i < n;i ++) if (vis[i] == 2) c ++;
    printf("%d\n",c);
    return 0;
}
*/

/*int n;

int p(int a,int b) {
    return (a + n + b) % n;
}

int chk(int *a,int i,int j,int k) {
    int i1 = 0,i2 = 0,i3 = 0;
    for (int v = -2;v <= 2;v ++) {
        if (p(a[0],v) == i) i1 = 1;
        if (p(a[1],v) == j) i2 = 1;
        if (p(a[2],v) == k) i3 = 1;
    }
    return i1 && i2 && i3;
}

int main()
{
    scanf("%d",&n);
    int a[3],b[3];
    scanf("%d%d%d",a,a + 1,a + 2);
    scanf("%d%d%d",b,b + 1,b + 2);
    for (int i = 0;i < 3;i ++) {
        a[i] --;
        b[i] --;
    }
    int c = 0;
    for (int i = 0;i < n;i ++) {
        for (int j = 0;j < n;j ++) {
            for (int k = 0;k < n;k ++) {
                if (chk(a, i, j, k) || chk(b, i, j, k)) c ++;
            }
        }
    }
    printf("%d\n",c);
    return 0;
}
*/

/*
int main()
{
    int n,X,Y,Z,x,y,z;
    scanf("%d%d%d%d",&n,&X,&Y,&Z);
    int a[20010],b[20010];
    for (int i = 0;i < n;i ++) scanf("%d%d",a + i,b + i);
    sort(a, a + n);
    sort(b, b + n);
    // 以温度下限a[i]枚举温度
    int m = -1;
    
    for (int i = 0,j = 0;i < n;i ++) {
        while (j < n && a[i] > b[j]) j ++;
        x = n - i - 1;
        z = j;
        y = n - x - z;
        printf("%d %d %d\n",x,y,z);
        m = max(m,x * X + y * Y + z * Z);
    }
    printf("%d\n",m);
    return 0;
}
*/

//int main()
//{
//    string size[] = {"large","small"},
//    color[] = {"brown", "white","spotted"},
//    sound[] = {"noisy","silent"};
//    struct Des {
//        string size;
//        string color;
//        string sound;
//        int operator < (const Des &o) const
//        {
//            return size + color + sound < o.size + o.color + o.sound;
//        }
//    };
//    set<Des> a;
//    for (int i = 0;i < 2;i ++) {
//        for (int j = 0;j < 3;j ++) {
//            for (int k = 0;k < 2;k ++) {
//                a.insert({size[i],color[j],sound[k]});
//            }
//        }
//    }
//
//    int n,k;
//    scanf("%d%d",&n,&k);
//    string in[10];
//
//    for (int i = 0;i < n;i ++) {
//        for (int j = 0;j < 8;j ++) cin >> in[j];
//        a.erase(a.find({in[4],in[5],in[6]}));
//    }
//    int j = 1;
//    for (auto i : a) {
//        if (j == k) {
//            cout << i.size << " " << i.color << " " << i.sound << endl;
//            break;
//        }
//        j ++;
//    }
//    return 0;
//}

/*
int cnt[3000010] = {0};

int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    ll x,y,a,b;
    for (int i = 0;i < k;i ++) {
        scanf("%lld%lld%lld%lld",&x,&y,&a,&b);
        for (int i = 1;i <= y;i ++) {
            cnt[(a * i + b) % n] += x;
        }
    }

    for (int i = 0;i < 2 * n;i ++) {
        if (cnt[i % n] > 1) {
            cnt[(i + 1) % n] += cnt[i % n] - 1;
            cnt[i % n] = 1;
        }
    }

    for (int i = 0;i < n;i ++) if (cnt[i] == 0) {
        printf("%d\n",i);
        break;
    }
    return 0;
}
*/

/// 并查集+离散化 使用unique函数，比set快
/*
int g[2000010];
int d[2000010];

int dis[2000010];

int find(int a)
{
    if (g[a] == a) return a;
    return g[a] = find(g[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        g[y] = x; // 改变b节点的根的根为a的根
        if (d[x] == d[y]) { // 俩根深度一样
            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
        }
    } else g[x] = y;
}

int main()
{
    int T;
    scanf("%d",&T);
    int n,a,b,c,len;
    struct Q {
        int a,b,c;
    };
    vector<pair<int,int>> m;
    vector<Q> k;
    while (T --) {
        m.clear();
        k.clear();
        len = 0;
        scanf("%d",&n);
        while (n --) {
            scanf("%d%d%d",&a,&b,&c);
            k.push_back({a,b,c});
            dis[len ++] = a;
            dis[len ++] = b;
        }
        
        sort(dis, dis + len);
        len = (int) (unique(dis, dis + len) - dis);
        
        for (int i = 0;i < len;i ++) {
            g[i] = i;
            d[i] = 1;
//            printf("%d ",dis[i]);
        }
//        printf("\n");
        
        for (auto i : k) {
            a = (int) (lower_bound(dis, dis + len, i.a) - dis);
            b = (int) (lower_bound(dis, dis + len, i.b) - dis);
            if (i.c) bind(a,b);
            else m.push_back(make_pair(a, b));
        }
        
        int ok = 1;
        for (auto i : m) {
            if (find(i.first) == find(i.second)) {
                ok = 0;
                break;
            }
        }
        if (ok) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

///分层图
/*
int dis[1000010];

int vis[1000010] = {0};

struct ST {
    int n; // 去哪个站
    int w; // 一站的钱
    
    bool operator< (const ST &other) const {
        return w > other.w;
    }
};
vector<ST> g[1000010];

void dij(int s) {
    mem(dis,-1);
    
    priority_queue<ST> q;
    q.push({s,dis[s] = 0});
    
    ST current;
    int k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        for (auto to : g[current.n]) {
            k = dis[current.n] + to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
}

int main()
{
    int n,m,s,t;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    int a,b,c;
    int ci[1010];
    for (int i = 1;i <= m;i ++) {
        scanf("%d%d%d%d",&a,&b,&c,ci);
        for (int j = 0;j < c;j ++) {
            if (j != 0) {
                scanf("%d",ci + j);
                g[ci[j - 1] + n * i].push_back({ci[j] + n * i,b});
                g[ci[j] + n * i].push_back({ci[j - 1] + n * i,b});
            }
            
            g[ci[j]].push_back({ci[j] + n * i,a});
            g[ci[j] + n * i].push_back({ci[j],0});
        }
    }
    dij(s);
    printf("%d\n",dis[t]);
//
//
//    for (int i = 1;i <= n;i ++) printf("%d ",vis[i]);
//    printf("\n");
//
//
//    for (int i = 1;i <= n;i ++) printf("%d ",dis[i]);
//    printf("\n");
//
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    int a;
    for (int i = 0;i < n;i ++) {
        scanf("%d",&a);
    }

    n -= k --;
    printf("%d\n",1 + (int) ceil(n / (double) k));
    return 0;
}
*/

/*
struct Node {
    int n,w;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

const int MAXN = 1000000;

vector<Node> g[MAXN];
int dis[MAXN];
int vis[MAXN] = {0};

void dij(int s) {
    mem(dis,-1);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0});
    
    Node current;
    int k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        for (auto to : g[current.n]) {
            k = dis[current.n] + to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
}

int main()
{
    int m,n;
    scanf("%d%d ",&m,&n);
    string str;
    int in;
    int f,ff = -1;
    for (int i = 1;i <= m;i ++) {
        getline(cin, str);
        stringstream ss(str);
        f = 1;
        while (ss >> in) {
            if (f) {
                f = 0;
                ff = in;
            } else {
                g[i * n + ff].push_back({i * n + in,0});
                ff = in;
            }
            g[i * n + in].push_back({in,0});
            g[in].push_back({in + i * n,1});
        }
    }
    dij(1);
    
//    for (int i = 1;i <= n;i ++) {
//        printf("%d ",dis[i]);
//    }
//    printf("\n");
    
    if (dis[n] == -1) printf("NO\n");
    else printf("%d\n",dis[n] - 1);
    return 0;
}
*/

/*
inline int chk(int a,int b,int c) {
    if (a + b > c && a + c > b && b + c > a) {
        return 1;
    }
    return 0;
}

int main()
{
    int n;
    scanf("%d",&n);
    int a[1000];
    for (int i = 0;i < n;i ++) {
        scanf("%d",a + i);
    }
    int ok = 0;
    for (int i = 0;i < n;i ++) {
        for (int j = i + 1;j < n;j ++) {
            for (int k = j + 1;k < n;k ++) {
                if (chk(a[i],a[j],a[k])) {
                    printf("%d %d %d\n",a[i],a[j],a[k]);
                    ok = 1;
                    goto end;
                }
            }
        }
    }
    end:
    if (!ok) printf("No solution\n");
    return 0;
}
*/

/*
int main()
{
    double h,l,H,L;
    scanf("%lf%lf%lf%lf",&h,&l,&H,&L);
    if (h * L / H <= l) printf("%.8f\n",0.5 * h * h * L / H);
    else printf("%.8f\n",0.5 * l * l * H / L + l * (h - l * H / L));
    return 0;
}
*/

//
//int n;
//ll ok = -1;
//
//ll chk(int i,ll t)
//{
//    if (t % n == i) {
//        return t;
//    }
//    ll v;
//    v = t / n;
//    if (i < t % n) v ++;
//    v *= n;
//    v += i;
//    return v;
//}
//
//void prt(int j,int x)
//{
//    for (int i = 0;i < n;i ++) {
//        if (i < j) printf("%d ",x - 1);
//        else printf("%d ",x);
//    }
//    printf("\n");
//}
//
//int main()
//{
//    scanf("%d",&n);
//    int a[100010];
//    ll x = 0;
//    for (int i = 0;i < n;i ++) {
//        scanf("%d",a + i);
//        x += a[i];
//    }
//    int l = floor(x / (double) n),
//    r = ceil(x / (double) n);
//    l --;
//    r ++;
////    if (l < 1) l = 1;
//    ll t = 0;
//    for (int i = l;i < r;i ++) {
//        t = 0;
//        for (int j = 0;j < n;j ++) {
//            t += abs(a[j] - (i + 1));
//        }
//        printf("\nt = %lld\n",t);
//        // chk once
//        prt(0,i + 1);
//        x = chk(0,t);
//        if (ok == -1) ok = x;
//        else ok = min(ok,x);
//        printf("%lld\n",x);
//        // chk rest
//        for (int j = 0;j < n;j ++) {
//            t -= abs(a[j] - (i + 1));
//            t += abs(a[j] - i);
//            printf("\nt = %lld\n",t);
//            x = chk((j + 1) % n,t);
//            if (ok == -1) ok = x;
//            else ok = min(ok,x);
//            prt(j + 1,i + 1);
//            printf("%lld\n",x);
//        }
//    }
//    printf("%lld\n",ok);
//
//    return 0;
//}
//
//
///*
//int n;
//ll ok = -1;
//
//void chk(int i,ll t)
//{
//    ll v;
//    if (t % n == i) {
//        v = t;
//    } else {
//        v = t / n;
//        if (i < t % n) v ++;
//        v *= n;
//        v += i;
//    }
//
//    if (ok == -1) ok = v;
//    else ok = min(ok,v);
//}
//
//int main()
//{
//    scanf("%d",&n);
//    int a[100010];
//    ll x = 0;
//    for (int i = 0;i < n;i ++) {
//        scanf("%d",a + i);
//        x += a[i];
//    }
//    int l = floor(x / (double) n),
//    r = ceil(x / (double) n);
//    l --;
//    r ++;
//    if (l < 1) l = 1;
//    ll t = 0;
//    for (int i = l;i < r;i ++) {
//        t = 0;
//        for (int j = 0;j < n;j ++) {
//            t += abs(a[j] - (i + 1));
//        }
//        // chk once
//        chk(0,t);
//        // chk rest
//        for (int j = 0;j < n;j ++) {
//            t -= abs(a[j] - (i + 1));
//            t += abs(a[j] - i);
//            chk((j + 1) % n,t);
//        }
//    }
//    printf("%lld\n",ok);
//
//    return 0;
//}
//
//*/


/*
ll p[200010];
pair<ll,ll> a[200010];
void pl(int l,int r,int k){
    p[l]+=k;
    p[r+1]-=k;
    return;
}

int cmp(const pair<ll,ll> &a,const pair<ll,ll> &b)
{
    return a.first > b.first;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    vector<pair<int,int>> k;
    for (int i = 0;i < m;i ++) {
        scanf("%d%d",&u,&v);
        k.push_back(make_pair(u,v));
        pl(u,v,1);
    }
    
    for (int i = 1;i <= n;i ++) {
        a[i].first = p[i] + a[i - 1].first;
        a[i].second = i;
    }
    
    sort(a + 1, a + n,cmp);
    ll b[200010];
    for (int i = 1;i <= n;i ++) {
        b[a[i].second] = n - i + 1;
    }
    ll s[200010];
    s[1] = b[1];
    
    for (int i = 2;i <= n;i ++) {
        s[i] = s[i - 1] + b[i];
    }
    ll x = 0;
    for (auto i : k) {
        x += s[i.second] - s[i.first - 1];
    }
    printf("%lld\n",x);
    return 0;
}
*/

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    int a,b,n;
//    while (T --) {
//        scanf("%d%d%d",&n,&a,&b);
//        for (int i = 0;i < n - 2;i ++)
//        {
//
//        }
//    }
//    return 0;
//}


/*
int main()
{
    string str;
    cin >> str;
    int hasD = 0;
    double a = 0,t;
    ll u = 0,v = 0;
    for (int i = 0;str[i];i ++) {
        if (str[i] == '+') {
//            printf("%lld %lld\n",u,v);
            if (hasD) {
                t = (1 + v) / 2.0;
                t *= u;
                a += t;
            } else {
                a += u;
            }
            u = 0;
            v = 0;
            hasD = 0;
        } else if (str[i] == 'd') {
            hasD = 1;
        } else {
            if (!hasD) {
                u *= 10;
                u += str[i] ^ 48;
            } else {
                v *= 10;
                v += str[i] ^ 48;
            }
        }
    }
    if (hasD) {
        t = (1 + v) / 2.0;
        t *= u;
        a += t;
    } else {
        a += u;
    }
    if (a == ceil(a)) printf("%.0f\n",a);
    else printf("%.1f\n",a);

    return 0;
}
*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int T;
    scanf("%d",&T);
    int n,a,b;
    while (T --) {
        scanf("%d%d%d",&n,&a,&b);
//        n -= 2;
        n /= gcd(a,b);
        if (n % 2) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n,m,x;
    scanf("%d%d%d",&n,&m,&x);
    int c[20];
    int k[20][20];
    for (int i = 0;i < n;i ++) {
        scanf("%d",c + i);
        for (int j = 0;j < m;j ++) {
            scanf("%d",&k[i][j]);
        }
    }
    int u = 1 << n;
    int y,ss[100];
    ll mm;
    ll kk;
    
        kk = -1;
        for (int j = 0;j < u;j ++) {
            y = j;
            mem(ss,0);
            mm = 0;
            for (int v = 0;v < n;v ++) {
                if (y & 1)
                {
                    for (int i = 0;i < m;i ++)
                        ss[i] += k[v][i];
                    mm += c[v];
                }
                if (y != 0) y >>= 1;
            }
            int ok = 1;
            for (int i = 0;i < m;i ++) {
                if (ss[i] < x) {
                    ok = 0;
                    break;
                }
            }
            if (ok) {
                if (kk == -1) kk = mm;
                kk = min(kk,mm);
            }
        }
        printf("%lld\n",kk);
    return 0;
}
*/

/*
int n;

int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

vector<string> a(20);

int w,h,k;

int ok = 0;

void dfs(int d)
{
    if (ok || d >= k) return;
    int xx,yy,x,y;
    for (x = 0;x < w;x ++) {
        for (y = 0;y < h;y ++) {
            if (a[y][x] == 'R')
            {
                for (int j = 0;j < 4;j ++) {
                    xx = x;
                    yy = y;
                    do {
                        xx += dx[j];
                        yy += dy[j];
                    } while (xx >= 0 && xx < w && yy >= 0 && yy < h && a[yy][xx] != 'X' && a[yy][xx] != 'R');
                    xx -= dx[j];
                    yy -= dy[j];
                    if (a[yy][xx] == 'D') {
                        ok = 1;
                        return;
                    }
                    swap(a[yy][xx],a[y][x]);
                    dfs(d + 1);
                    swap(a[yy][xx],a[y][x]);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d%d",&w,&h,&k);
    char in;
    for (int i = 0;i < h;i ++) {
        scanf(" ");
        for (int j = 0;j < w;j ++) {
            scanf("%c",&in);
            a[i] += in;
        }
    }
    dfs(0);
    if (ok) printf("YES\n");
    else printf("NO\n");
    return 0;
}
*/

/*
class Cal {
protected:
    double a,b;
public:
    
    Cal(double a,double b):a(a),b(b)
    {}
    
    double add()
    {
        return a + b;
    }
    
    double sub()
    {
        return a - b;
    }
};

class Senior : public Cal {
public:
    double multy()
    {
        return a * b;
    }
    
    double div()
    {
        return a / b;
    }
};

int main()
{
    double a,b;
    cin >> a >> b;
    Senior *s = (Senior*) new Cal(a,b);
    cout << s -> add() << endl;
    cout << s -> sub() << endl;
    cout << s -> multy() << endl;
    cout << s -> div() << endl;
    delete s;
    return 0;
}
*/

/// ----------- prime模版 -----------
/*
struct Node {
    int n;
    ll w;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

vector<Node> g[200010];

ll dis[200010];
int vis[200010] = {0};

void prime(int s)
{
    mem(dis,-1);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0});
    
    Node current;
    ll k;
    
    ll ans = 0;
    
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        ans += current.w;
        
        for (auto to : g[current.n]) {
            k = to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
    
    printf("%lld\n",ans);
}
*/
/// ---------------------------------

/*
char a[1010][1010];
int vis[1010][1010] = {0};
int vis2[1010][1010] = {0};

int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};
int n,m;
int sum = 0;

void dfs(int x,int y,int d)
{
//    printf(">>%d %d\n",x,y);
    if (vis2[y][x]) return;
    vis2[y][x] = 1;
    sum ++;
    int xx,yy;
    for (int i = 0;i < 4;i ++) {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < n && yy >= 0 && yy < n) {
            if ((a[y][x] ^ 48) ^ (a[yy][xx] ^ 48)){
                dfs(xx,yy,d + 1);
            }
        }
    }
}

void dfs2(int x,int y)
{
    if (vis[y][x]) return;
    vis[y][x] = sum;
    int xx,yy;
    for (int i = 0;i < 4;i ++) {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < n && yy >= 0 && yy < n) {
            if ((a[y][x] ^ 48) ^ (a[yy][xx] ^ 48)){
                dfs2(xx,yy);
            }
        }
    }
}

int main()
{

    scanf("%d%d",&n,&m);
    for (int i = 0;i < n;i ++) {
        scanf("%s",a[i]);
    }
    for (int i = 0;i < n;i ++) {
        for (int j = 0;j < n;j ++) {
            if (!vis[i][j]) {
                sum = 0;
                dfs(j,i,0);
                dfs2(j,i);
            }

        }
    }

    int u,v;
    for (int i = 0;i < m;i ++) {
        scanf("%d%d",&u,&v);
        printf("%d\n",vis[u - 1][v - 1]);
    }

//    for (int i = 0;i < n;i ++) {
//        for (int j = 0;j < n;j ++) {
//            printf("%c",a[i][j]);
//        }
//        printf("\n");
//    }

    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    ll n,k;
    while (T --)
    {
        scanf("%lld%lld",&n,&k);
        if (n % 2) {
            // odd
            ll x = 0;
            for (ll i = 2;i <= n;i ++) {
                if (n % i == 0) {
                    x = i;
                    break;
                }
            }
            n += x;
            printf("%lld\n",n + (k - 1) * 2);
        } else {
            printf("%lld\n",n + k * 2);
        }
    }
    return 0;
}
*/

/*
int n;
int s[100010];
int vis[100010] = {0};
int b[100010];
int m = 1;

void dfs(int x,int d,int k)
{
    
    if (vis[x] && k == 1) return;
    vis[x] = 1;
    int o = -1,oo = -1;
    if (d != 0) {
        o = d;
        if (s[x] > b[d - 1]) b[d ++] = s[x];
        else {
            int *t = upper_bound(b, b + d, s[x]);
            if ((t - b) + 1 != d + 1) {
                d = (int) (t - b) + 1;
                oo = *t;
                *t = s[x];
            }
        }
        
    } else {
        b[d ++] = s[x];
    }
    m = max(m,d);
    printf(">>%d %d=\n",x,d);
    for (int i = 0;i < d;i ++) printf("%d ",b[i]);
    printf("\n");
    for (int j = 2,i = x * j;i <= n;j ++,i = x * j)
    {
        printf("..x=%d,j=%d,i=%d\n",x,j,i);
        dfs(i,d,k + 1);
    }
    if (o != -1) {
        d = o;
    }
    if (oo != -1) {
        b[d - 1] = oo;
    }
}

int main()
{
    int T;
    scanf("%d",&T);
    
//    int d[100010];
    while (T --) {
        m = 1;
        mem(vis,0);
        scanf("%d",&n);
        for (int i = 1;i <= n;i ++) {
            scanf("%d",s + i);
        }
        printf("-----------\n");
        dfs(1,0,0);
        printf("%d\n",m);
//        for(int i = 1;i <= n;i ++)
//        {
//            d[i] = 1;
//            for(int j = 1;j < i;j ++)
//            {
//                if(s[j] <= s[i] && i % j == 0 && (d[j] + 1) >= d[i])
//                    d[i] = d[j] + 1;
//            }
//            m = max(m,d[i]);
//        }
//
//        printf("%d\n",m);
        
        
    }
    return 0;
}
*/

/*
int n;
int s[100010];
int vis[100010] = {0};
int a[100010];
int b[100010];
int m = 1;

void dfs(int x,int d)
{
    m = max(m,d);
    for (int j = 2,i = x * j;i <= n;i = x * j,j ++)
    {
//        printf(">>%d\n",i);
        if (s[i] > s[x])
            dfs(i,d + 1);
    }
}

int main()
{
    int T;
    scanf("%d",&T);
    
//    int d[100010];
    while (T --) {
        m = 1;
        scanf("%d",&n);
        for (int i = 1;i <= n;i ++) {
            scanf("%d",s + i);
        }
        for (int i = 1;i <= n / 2;i ++) dfs(i,1);
        printf("%d\n",m);
//        for(int i = 1;i <= n;i ++)
//        {
//            d[i] = 1;
//            for(int j = 1;j < i;j ++)
//            {
//                if(s[j] <= s[i] && i % j == 0 && (d[j] + 1) >= d[i])
//                    d[i] = d[j] + 1;
//            }
//            m = max(m,d[i]);
//        }
//
//        printf("%d\n",m);
        
        
    }
    return 0;
}
*/

/*
vector<int> g[100010];
int vis[100010] = {0};
int f = 1;

void dfs(int n)
{
    if (vis[n]) return;
    vis[n] = 1;
    if (f) f = 0;
    else printf(" ");
    printf("%d",n);
    for (auto i : g[n]) {
        dfs(i);
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    for (int i = 0;i < m;i ++) {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
    }
    for (int i = 1;i <= n;i ++) {
        sort(g[i].begin(),g[i].end());
    }
    dfs(1);
    printf("\n");
    mem(vis,0);
    queue<int> q;
    q.push(1);
    f = 1;
    int t;
    while (!q.empty())
    {
        t = q.front();
        q.pop();
        if (vis[t]) continue;
        vis[t] = 1;
        if (f) f = 0;
        else printf(" ");
        printf("%d",t);
        for (auto i : g[t]) {
            q.push(i);
        }
    }
    printf("\n");
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n,m;
    while (T --) {
        scanf("%d%d",&n,&m);
        if (n == 1) printf("0\n");
        else if (n == 2) printf("%d\n",m);
        else {
            printf("%d\n",m * 2);
        }
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n,k;
    int a[50],b[50];
    while (T --)
    {
        scanf("%d%d",&n,&k);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        for (int i = 0;i < n;i ++) scanf("%d",b + i);
        sort(a,a + n);
        sort(b,b + n,greater<int>());
        for (int i = 0,j = 0;i < k && j < n;j ++) {
            if (b[i] > a[i]) {
                swap(a[i],b[i]);
                i ++;
            }
        }
        int sum = 0;
        for (int i = 0;i < n;i ++) sum += a[i];
        printf("%d\n",sum);

    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    ll sum = 0;
    while (T --) {
        scanf("%d",&n);
        sum = 0;
        for (ll i = 1,j = 2;i <= n / 2;i ++,j += 2) {
            sum += i * j * 4;
        }
        printf("%lld\n", sum);
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    scanf("%d",&T);
    int n;
    int a[200010];
    struct A
    {
        int length;
        int index;

        bool operator< (const A &other) const {
            if (other.length == length) return index > other.index;
            return length < other.length;
        }
    };
    A f;
    int i = 1;
    int x;
    while (T --) {
        scanf("%d",&n);
        priority_queue<A> q;
        q.push({n,1});
        i = 1;
        while (!q.empty()) {
            f = q.top();
            q.pop();
            x = (f.index * 2 + f.length - 1) / 2;
            a[x] = i ++;
            if (x > f.index) {
                q.push({x - f.index,f.index});
            }
            if (x < f.index + f.length - 1) {
                q.push({f.index + f.length - 1 - x,x + 1});
            }
        }
        x = 1;
        for (int i = 1;i <= n;i ++) {
            if (x) x = 0;
            else printf(" ");
            printf("%d",a[i]);
        }
        printf("\n");
    }
    return 0;
}
*/


//
//int main()
//{
//    ull n;
//    scanf("%llu",&n);
//    string str_in;
//    cin >> str_in;
//
////    ull u = 0;
////    int a['z' + 1] = {0};
////    for (int i = 0;str_in[i];i ++) a[str_in[i]] ++;
////    for (int i = 'a';i <= 'z';i ++) if (a[i]) u ++;
//
//
//    string str1,str2 = "";
//    str2 += str_in[0];
//    for (int i = 1;i < n;i ++) {
//        if (i % 2) {
//            str1 = "";
//            for (int j = 0;str2[j];j ++) {
//
//                str1 += str_in[i];
//                str1 += str2[j];
//            }
//            str1 += str_in[i];
//        } else {
//            str2 = "";
//            for (int j = 0;str1[j];j ++) {
//
//                str2 += str_in[i];
//                str2 += str1[j];
//            }
//            str2 += str_in[i];
//        }
//    }
//    string str;
//    if (n % 2) {
//        str = str2;
//    } else {
//        str = str1;
//    }
//    map<ull,int> dp;
//    map<int,int> last;
//    map<int,int> h;
//    int mod = 998244353;
//    n = str.size();
//    for (int i = 1;i <= n;++ i) {
//        last[i]=h[str[i]];
//        h[str[i]]=i;
//    }
//    for(int i=1;i<=n;++i){
//        if (!last[i]) dp[i] = dp[i - 1] * 2 + 1;
//        else dp[i] = dp[i-1]+dp[i-1]-dp[last[i]-1];
//        if (dp[i] < 0) dp[i] += mod;
//        dp[i] %= mod;
//    }
//    printf("%d\n",dp[n]);
//
//    return 0;
//}
//

/*
int quickpow(int a, int b)
{
    int ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

int x = 1;
int dp[1010][1010];

int main()
{
    
    
    int n,m;
    map<int,int> c;
    scanf("%d%d",&n,&m);
    int a = 2;
    while (m > 1) {
        while (m % a == 0) {
            m /= a;
            c[a] ++;
        }
        a ++;
    }
    
    for (auto i : c) {
//        printf("%d: %d\n",i.first,i.second);
        x *= quickpow(i.first, i.second / 2);
    }
    
    int mod = 998244353;
    dp[0][0] = 1;
    for (int i = 1;i <= n;i ++)
        for (int j = 0;j <= x;j ++)
            if (j >= i) dp[i][j] = (dp[i][j - i] + dp[i - 1][j]) % mod;
            else dp[i][j] = dp[j][j];
    printf("%d\n",dp[n][x]);
    return 0;
}
*/

/*
pair<int,int> find(ll n)
{
    ll m = 10,M = -1;
    while (n != 0) {
        m = min(m,n % 10);
        M = max(M,n % 10);
        n /= 10;
    }
    return make_pair((int)m, (int)M);
}

int main()
{
    ll n,k;
    int t;
    pair<int, int> x;
    int v;
    scanf("%d",&t);
    while (t --) {
        scanf("%lld%lld",&n,&k);
        for (int i = 0;i < k - 1;i ++) {
            x = find(n);
            v = x.first * x.second;
            if (v == 0) break;
            n += v;
        }
        printf("%lld\n",n);
        
    }
//    scanf("%d",&n);
//    for (int i = 0;i < 100;i ++) {
//        pair<int,int> j = find(n);
//        printf("%d %d = ",n,j.first*j.second);
//        printf("%d\n",n += j.first*j.second);
//    }
    return 0;
}
*/

/*
int main()
{
    int T,n;
    int a[200010];
    int k;
    int t;
    int m;
    for (scanf("%d",&T);T --;)
    {
        scanf("%d",&n);
        for (int i = 0;i < n;i ++) scanf("%d",a + i);
        sort(a,a + n);
        k = 0;
        t = 0;
        m = 0;
        for (int i = 0;i < n;i ++) {
            m = max(m,a[i]);
            t ++;
            if (m == t) {
                m = 0;
                t = 0;
                k ++;
            }
        }
        printf("%d\n",k);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    n --;
    k -= n;
    n ++;
    if (n < k) {
        printf("YES\n");
        int f = 1;
        for (int i = 0;i < n - 1;i ++){
            if (f) f = 0;
            else printf(" ");
            printf("1");
        }
        if (f) f = 0;
        else printf(" ");
        printf("%d\n",k);
        printf("%d\n",n);
    } else printf("NO\n");
    return 0;
}
*/

//ll a,b,c,d;
//void solve()
//{
//    ll x = 0;
//    ll l,r;
//    for (ll i = c + 1;i <= c + d;i ++)
//    {
//        l = max(a , i - c);
//        r = min(b , i - b);
//        if (r < l) continue;
//        x += (r - l + 1) * (min(d + 1 , i) - c);
//    }
//    printf("%lld\n",x);
//}
//
//int main()
//{
//    scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
//    solve();
//    return 0;
//}


//int main()
//{
//    int T;
//    scanf("%d",&T);
//    string str;
//    int s;
//    while (T --) {
//        cin >> str;
//        s = (int) str.size();
//        rp(i,0,s) {
//
//        }
//    }
//    return 0;
//}

//int main()
//{
//    int T;
//    scanf("%d",&T);
//    string str;
//    int x,l,X;
//    int lt,rt;
//    vector<int> k;
//    int s;
//    while (T --) {
//        cin >> str;
//        k.clear();
////        x = 0;
//        l = 0;
//        s = (int) str.size();
//        rp(i,0,s) {
//            if (str[i] == 'x') {
////                x ++;
//            } else {
//                l ++;
//                k.pb(i);
//            }
//        }
//        X = 0;
//
//        int ans = 0;
//        REP (i,0,s) {
//            if (str[i] == 'x') {
//                X ++;
////                x --;
////                if (X >= 3) {
////                    lt = X - 2;
////                    rt = l - 1;
////                    if (rt >= 1) {
////                        if (lt < rt) {
////                            str[i] = 'l';
////                            X --;
////                        } else {
////                            str[*(k.end() - 1)] = 'x';
////                            k.erase(k.end() - 1);
////                            l --;
////                        }
////                        ans ++;
////                    }
////
////                }
//            } else {
//                if (X >= 3) {
//
//                }
//                l --;
//            }
//            cout << str << endl;
//        }
//        printf("%d\n",ans);
//    }
//    return 0;
//}


//int a[1000][1000];
/*
int main()
{
    fre("/Users/jackli/Downloads/problem_520/small.csv");
//    freopen("/Users/jackli/Downloads/problem_520/k.csv", "w+", stdout);
//    int m = 1830;
    string str;
    string s;
    int w = 0;
    int h = 0;
    FILE *f = fopen("a.raw","w");
    while (getline(cin,str))
    {
        s = "";
        for (int i = 0;str[i];i ++) {
            if (str[i] == ',') s += ' ';
            else s += str[i];
        }
        stringstream ss(s);
        double x;
//        int f = 1;
        w = 0;
        uchar a;
        while (ss >> x) {
//            m = min(x,m);
//            if (f) f = 0;
//            else printf(",");
//            if (x - m < 5600) printf("");
//            else printf("0000");
//            printf("%d",x - m);
//            fwrite(&x, sizeof(int), 1, f);
//            a[w][h] = x;
            
            a = x;
            if (a) a = 255;
            fwrite(&a, sizeof(uchar), 1, f);
            
            w ++;
        }
        h ++;
//        printf("\n");
    }
//    for (int i = 0;i < w;i ++) {
//        for (int j = 0;j < h;j ++) {
//            fwrite(&a[i][j] - 2000, sizeof(int), 1, f);
//        }
//    }
//
    printf("%d %d\n",w,h);
    return 0;
}
*/

//int main()
//{
////    fre("/Users/jackli/Downloads/problem_520/small.csv");

//fclose(f);
//    return 0;
//}


/*
int main()
{
    int n;
    scanf("%d",&n);
    while (n >= 10) {
        n %= 10;
    }
//    printf("%d\n",n);
    if (n == 2 || n == 4 || n == 5 || n == 7 || n == 9) printf("hon\n");
    else if (n == 0 || n == 1 || n == 6 || n == 8) printf("pon\n");
    else if (n == 3) printf("bon\n");
    return 0;
}
*/

/*
int main()
{
    int k;
    string s;
    cin >> k >> s;
    if (s.size() <= k) cout << s << endl;
    else {
        REP (i,0,k) {
            printf("%c",s[i]);
        }
        printf("...\n");
    }
    return 0;
}
*/

/*
int main()
{
    double a,b,h,m;
    scanf("%lf%lf%lf%lf",&a,&b,&h,&m);
    double ha = m + h * 60;
    ha *= 0.5;
    double ma = 6 * m;
    double c = abs(ha - ma);
    c = min(360 - c,c);
    double ans = a * a + b * b - 2 * a * b * cos(c * pi / 180);
    printf("%.20f\n",sqrt(ans));
    return 0;
}
*/

/*
vector<int> g[100010];

int dis[100010];
int vis[100010] = {0};
int f[100010];
struct Node {
    int n,w,f;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

void dij(int s) {
    mem(dis,-1);
    mem(f,-1);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0,-1});
    
    Node current;
    int k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        f[current.n] = current.f;
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        for (auto to : g[current.n]) {
            k = dis[current.n] + 1;
            if (dis[to] == -1 || dis[to] > k) {
                q.push({to,dis[to] = k,current.n});
            }
        }
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    REP (i,0,m) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    dij(1);
    int ok = 1;
    rep (i,1,n) {
        if (dis[i] == -1) {
            ok = 0;
            break;
        }
    }
    if (ok) {
        printf("Yes\n");
        rep (i,2,n) {
            printf("%d\n",f[i]);
        }
    } else printf("No\n");
    return 0;
}
*/
 
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    ll a,b;
//    double x[200010];
//    double k[200010];
//    REP (i,0,n) {
//        scanf("%lld%lld",&a,&b);
//        x[i] = a / (double) b;
//        k[i] = (-b) / (double) a;
//    }
//    sort(k, k + n);
//    REP (i,0,n) {
//
//    }
//    return 0;
//}

//class A {
//    int a,b;
////    friend class B;
//public:
//
//    A(int a,int b):a(a),b(b){}
//    void aa()
//    {
//        cout << "aaa" << endl;
//    }
//};
//
//class B : private A {
//public:
//    B(int a,int b):A(a,b)
//    {
//
//    }
//
//    void out()
//    {
////        cout << a << b << endl;
//        aa();
//    }
//};
//
//int main()
//{
//    B b(1,2);
//    b.out();
//
//    return 0;
//}

/*
int x[100];
int y[100];

int getDis(int x1,int y1,int x2,int y2)
{
    return abs(x1 - x2) + abs(y1 - y2);
}

int n;

int main()
{
    int w,h;
    int xs,ys;
    int a[100];

    _T_(T) {
        scanf("%d%d",&w,&h);
        scanf("%d%d",&xs,&ys);
        scanf("%d",&n);
        REP(i,0,n) scanf("%d%d",x + i,y + i);
        int sum = 0;
        int m = INT_INF;
        REP(i,0,n) a[i] = i;
        do {
            sum = 0;
            REP(i,1,n) {
                sum += getDis(x[a[i - 1]], y[a[i - 1]], x[a[i]], y[a[i]]);
            }
            sum += getDis(xs, ys, x[a[0]], y[a[0]]);
            sum += getDis(xs, ys, x[a[n - 1]], y[a[n - 1]]);
            m = min(m,sum);
        } while (next_permutation(a, a + n));
        printf("The shortest path has length %d\n",m);
    }
    return 0;
}
*/

/*
int main()
{
    int x,y;
    scanf("%d%d",&x,&y);
    double v = y * log(x) - x * log(y);
    if (fabs(v) < 1e-10) printf("=\n");
    else if (v < 0) printf("<\n");
    else printf(">\n");
    return 0;
}
*/

/*
vector<int> g[100010];

int cnt = 0;
int dfn[100010] = {0};
int low[100010] = {0};

int sum = 0;

void Tarjan(int n,int from)
{
    dfn[n] = low[n] = ++ cnt;
    for (auto i : g[n]) {
        if (!dfn[i]) {
            Tarjan(i,n);
            low[n] = min(low[n],low[i]);
            if (low[i] > dfn[n]) sum ++;
        } else if (i != from) low[n] = min(low[n],low[i]);
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    REP(i,0,m) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    Tarjan(1,0);
    printf("%d\n",m - sum);
    return 0;
}
*/

/*
int main()
{
    double gg = 0,mm = 0,all = 0;
    int sg = 0,sm = 0,sa = 0;
    int m,s;
    _T_(T) {
        cin >> m >> s;
        if (m == 0) {
            sm ++;
            mm += s;
        } else {
            sg ++;
            gg += s;
        }
        sa ++;
        all += s;
    }
    printf("%.1f",all / sa);
    if (sg != 0) {
        printf(" %.1f",gg / sg);
    } else printf(" X");
    if (sm != 0) {
        printf(" %.1f",mm / sm);
    } else printf(" X");
    printf("\n");
    return 0;
}
*/

/*
int main()
{
    ll a,b;
    cin >> a >> b;
    ll c = a + b;
    int f = 0;
    if (c < 0) f = 1;
    c = abs(c);
    if (c == 0) {
        printf("0\n");
        return 0;
    }
    char x[100];
    int i = 0;
    while (c > 0) {
        x[i ++] = (c % 10) ^ 48;
        c /= 10;
    }
    if (f) printf("-\n");
    pre(j,i - 1,0) {
        printf("%c\n",x[j]);
    }
    return 0;
}
*/

/*
int main()
{
    string a,b;
    cin >> a;
    while (cin >> b) {
        if (b == "-1") break;
        if (b.size() != a.size()) {
            printf("No\n");
            continue;
        }
        int x = 0;
        int t = 0;
        for (int i = 0;b[i];i ++) {
            if (a[i] != b[i]) {
                t ++;
                x = abs(a[i] - b[i]);
            }
            if (t >= 2) {
                break;
            }
        }
        if (t >= 2 || x > 1) printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}
*/

/*
string all[3] = {"JianDao","Bu","ChuiZi"};

string ying(string x)
{
    if (x == all[0]) return all[2];
    else if (x == all[1]) return all[0];
    else return all[1];
}

string shu(string x)
{
    if (x == all[2]) return all[0];
    else if (x == all[0]) return all[1];
    else return all[2];
}

int main()
{
    int n;
    int k[20];
    cin >> n;
    READ(k,0,n);
    string str;
    int t = 0;
    int i = 0;
    while (cin >> str) {
        if (str == "End") break;
        t ++;
        if (t <= k[i]) {
            cout << ying(str) << endl;
        } else {
            cout << shu(str) << endl;
            t = 0;
            i ++;
            if (i >= n) i = 0;
        }
    }
    return 0;
}
*/

/*
int main()
{
    int n,p;
    int a[100010];
    scanf("%d%d",&n,&p);
    READ(a,0,n);
    sort(a,a + n);

//    REP(i,0,n) printf("%d ",a[i]);
//    printf("\n");

    int *l,*r;
    ll sum = 0;
    REP (i,0,n) {

        l = upper_bound(a + i + 1, a + n, abs(a[i] - p));
        if (l >= a + n) continue;
        r = lower_bound(a + i + 1, a + n, a[i] + p);
        if (r == a + i) continue;
        r --;
        if (r < l) continue;
//        printf("..%d\n",a[i]);
//        printf(">>%d %d\n",abs(a[i] - p),a[i] + p);
//        printf("%d %d %lu\n",*l,*r,r - l + 1);
        sum += r - l + 1;
    }
    printf("%lld\n",sum);
    return 0;
}
*/

//int main()
//{
//    int n,k;
//    scanf("%d%d",&n,&k);
//    ll x = 1;
//    ll mod = 1;
//    ll p = 0;
//    REP (i,0,k) {
//        mod *= 10;
//    }
//
//    ll m = 1000000000;
//
//    rep (i,1,n) {
//        x *= i;
//        while (x % 10 == 0) {
//            x /= 10;
//            p ++;
//        }
//        x %= m;
//    }
//    x %= mod;
//    string a = "%0";
//    a += (k ^ 48);
//    a += "lld %lld\n";
//    printf(a.c_str(),x,p);
//    return 0;
//}

/*
int main()
{
    ll n,m,k;
    ll x,ans;
    _T_(T) {
        scanf("%lld%lld%lld",&n,&m,&k);
        if (n < 2) {
            printf("0\n");
            continue;
        }
        x = n / 2;
        ans = x * (n - x) * m * k;
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
vector<int> g[200010];

int vis[200010] = {0};
int dis[200010] = {0};

int ans = 0;
void dfs(int n,int d,int f) {
    if (d == 1) {
        ans += g[n].size() - 1;
        return;
    }
    for (auto i : g[n]) {
        if (i != f) dfs(i,d + 1,n);
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    int u,v;
    REP(i,0,n - 1) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    dfs(1,0,-1);
    rep(i,1,n) {
        ans = 0;
        dfs(i,0,-1);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    const int mod = 1e9 + 7;
//    map<pair<int,int>,int> all;
    int n;
    scanf("%d",&n);
    ll a[200010];
    read_ll(a,1,n);
    ll ans = 0;
    a[0] = 0;

    ll b[200010];
    b[0] = 0;
    for (int i = 1,j = n;i <= n;i ++,j --) b[i] = (a[i] * j) % mod;

    ll c[200010];
    c[1] = b[1];
    c[0] = 0;
    rep(i,2,n) c[i] = c[i - 1] + b[i];

    ll x;
    ll p;
    rep(i,1,n) {
        p = c[n] - c[i - 1];
        x = (p * i % mod) * a[i];
        ans = (ans + x % mod) % mod;
    }
    printf("%lld\n",ans);
    
//    rep(l,1,n) {
//        rep(r,l,n) {
//            rep(i,l,r) {
//                rep(j,i,r) {
////                    printf("%lld %lld\n",a[i],a[j]);
//                    all[make_pair(a[i], a[j])] ++;
//                    ans += a[i] * a[j] % mod;
//                }
//            }
//        }
//    }
//    for (auto i : all) {
//        printf("%d %d: %d\n",i.first.first,i.first.second,i.second);
//    }
//    printf("%lld\n",ans);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int a[110][110];
    REP(i,0,n) {
        REP(j,0,m) {
            scanf("%d",&a[i][j]);
        }
    }
    int h,w;
    scanf("%d%d",&h,&w);
    int b[110][110];
    REP(i,0,h) {
        REP(j,0,w) {
            scanf("%d",&b[i][j]);
        }
    }
    
    vector<ll> ans[210];
    int v = 0;
    ll k;
    rep(i,0,n - h) {
        rep(j,0,m - w) {
            k = 0;
            REP(y,0,h) {
                REP(x,0,w) {
                    k += b[y][x] * a[i + y][j + x];
                }
            }
            ans[i].pb(k);
        }
        v ++;
    }
    int f = 1;
    REP(i,0,v) {
        f = 1;
        for (auto j : ans[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%lld",j);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
#define MAX 1000000000
    int l = -MAX;
    int r = MAX;
    int m;
    string resp;
    while (l <= r) {
        m = (l + r) / 2;
        cout << m << endl;
        cin >> resp;
        if (resp == "big") {
            r = m - 1;
        } else if (resp == "small") {
            l = m + 1;
        } else return 0;
    }
    return 0;
}
*/

/*
int main()
{
    int n,m;
    string str;
    scanf("%d",&n);
    REP(i,0,n) cin >> str;
    scanf("%d",&m);
    REP(i,0,m) cin >> str;
    if (n > m) printf("Cuber QQ\n");
    else printf("Quber CC\n");
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    REP(i,0,k - 1) printf("b");
    printf("a");
    REP(i,0,n - k) printf("z");
    printf("\n");
    return 0;
}
*/

/*
struct Node {
    string name;
    map<string,Node*> nxt;
};

int ans = 0;
const string k = "joe.";

inline bool judge(string str)
{
    int x = 0,ok = 1;
    if (str.size() < 4) return false;
    for (auto j = str.rbegin();j != str.rend() && x < 4;j ++,x ++) {
        if (k[x] != *j) {
            ok = 0;
            break;
        }
    }
    return ok;
}

void dfs(Node *root) {
    if (root -> nxt.size() == 0) {
        if (judge(root -> name)) ans ++;
        return;
    }
    for (auto i : root -> nxt) {
        dfs(i.second);
    }
}

int main()
{
    string str,child;
    int last;
    Node *root = new Node();
    root -> name = "/";
    
    Node *crt;
    Node *node;
    
    _T_(n) {
        cin >> str;
        crt = root;
        last = 1;
        for (int i = 0;str[i];i ++) {
            if (str[i] == '/') {
                if (i + 1 != 1) {
                    child = str.substr(last,i - last);
                    if (crt -> nxt.find(child) != crt -> nxt.end()) {
                        crt = crt -> nxt[child];
                    } else {
                        node = new Node();
                        node -> name = child;
                        crt -> nxt[child] = node;
                        crt = node;
                    }
                }
                last = i + 1;
                
            }
        }
        child = str.substr(last);
        if (crt -> nxt.find(child) == crt -> nxt.end()) {
            node = new Node();
            node -> name = child;
            crt -> nxt[child] = node;
            crt = node;
        }
    }
    
    dfs(root);
    printf("%d\n",ans);
    return 0;
}

*/

//
//int n;
//
//
//    void up(int i)
//    {
//        int p = i / 2;
//        while (p != 0 && a[i] < a[p])
//        {
//            swap(a[i], a[p]);
//            i = p;
//            p /= 2;
//        }
//    }
//
//    void down(int i)
//    {
//        int k = i * 2;
//        if (k + 1 <= n && a[k + 1] < a[k]) k ++;
//        while (k <= n && a[i] > a[k])
//        {
//            swap(a[i], a[k]);
//            i = k;
//            k *= 2;
//            if (k + 1 <= n && a[k + 1] < a[k]) k ++;
//        }
//    }
//
//    void push(int num)
//    {
//        a[++ n] = num;
//        up(n);
//    }
//
//    void pop()
//    {
//        if (n > 0)
//        {
//            swap(a[1], a[n --]);
//            down(1);
//        }
//    }
//
//    int top()
//    {
//        return a[1];
//    }

/*
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = (x<<1) + (x<<3) + (ch^48);
        ch = getchar();
    }
    return x * f;
}

int n,k;

int a[5000010];

int partition(int *nums, int left, int right)
{
    int temp = nums[left];
    while (left < right)
    {
        while (left < right && temp >= nums[right]) right --;
        nums[left] = nums[right];
        while (left < right && temp < nums[left]) left ++;
        nums[right] = nums[left];
    }
    nums[left] = temp;
    return left;
}

int quickSort_k(int *nums, int left, int right, int k)
{
    if (left <= right)
    {
        int pos = partition(nums, left, right);
        if (pos == k - 1) return nums[pos];
        else if (pos > k - 1) return quickSort_k(nums, left, pos - 1, k);
        else if (pos < k - 1) return quickSort_k(nums, pos + 1, right, k);
    }
    return -1;
}


int main()
{
    _T_(T)
    {
        scanf("%d%d",&n,&k);
        REP(i,0,n) {
            a[i] = read();
        }
        printf("%d\n",quickSort_k(a, 0, n - 1, n - k + 1));
    }
    return 0;
}
*/

/*
class A {
public:
    A(){cout << "123" << endl;}
    
    void f(){cout << 'a' << endl;}
};

class B {
public:
    B(){cout << 33333 << endl;}
    
    void f(){cout << 'b' << endl;}
};

class C: public A,public B {
public:
    C()
    {
        cout << 2333 << endl;
    }
};

int main()
{
    C c;
    c.A::f();
    c.B::f();
    
    return 0;
}
*/


/*
int main()
{
    fre("/Users/jackli/Documents/IdeaProjects/ExamQuery/stuff/_exam_data_20_2.csv");
    FILE *exam = fopen("/Users/jackli/Documents/IdeaProjects/ExamQuery/stuff/exam_data_20_2.csv", "w");
    FILE *major = fopen("/Users/jackli/Documents/IdeaProjects/ExamQuery/stuff/exam_major_20_2.csv", "w");
    int id = 1;

    string line, str, save;
    getline(cin, line);


    map<string,set<int>> all;


    while (getline(cin, line)) {
        int d = 0;
        str = "";
        save = to_string(id) + ",";
        for (int i = 0;line[i];i ++) {
            if (line[i] == ',') {
                d ++;
                if (d == 4) {
                    str = "";
                } else if (d == 5) {
                    all[str].insert(id);
                    str = "";
                }
            } else
            if (d == 4) {
                if (line[i] != ';') {
                    str += line[i];
                } else {
                    all[str].insert(id);
                    str = "";
                }
            }
            if (d != 4) save += line[i];
        }
//        cout << save << endl;
        fprintf(exam, "%s\n",save.c_str());
        id ++;

    }
    
    id = 1;
    for (auto i : all) {
        line = to_string(id ++) + "," + i.first + ",";
        for (auto j : i.second) {
            line += to_string(j) + ";";
        }
        fprintf(major, "%s\n",line.c_str());
    }
    
    
    fclose(major);
    fclose(exam);
    return 0;
}

*/

/*
ll cal(ll x,ll y,ll z) {
    return x * x + y * y + z * z;
}

int main()
{
    int n;
    scanf("%d",&n);
    ll x,y,z;
    ll m = -1;
    REP(i,0,n) {
        scanf("%lld%lld%lld",&x,&y,&z);
        if (m == -1) m = cal(x,y,z);
        else m = min(m,cal(x,y,z));
    }
    printf("%.3f\n",sqrt(m));
    
    return 0;
}
*/

/*
int main()
{
    ll n,m,x,y;
    _T_(T) {
        scanf("%lld%lld%lld%lld",&n,&m,&x,&y);
        if (x <= y) printf("%lld\n",m);
        else {
            printf("%lld\n",min(m,(n + (m - 1) * y) / x));
        }
    }
    return 0;
}
*/


/// unique函数
/*
int cmp(const string &a,const string &b)
{
    return a.size() < b.size();
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    string str;
    vector<string> k;
    REP(i,0,m) {
        cin >> str;
        k.pb(str);
    }
    sort(k.begin(),k.end());
    auto end = unique(k.begin(), k.end());
    sort(k.begin(),end,cmp);
    int x = 0;
    int f = 1;
    int t;
    for (auto i = k.begin();i != end;i ++) {
        t = (int) i -> size();
        if (f) f = 0;
        else t ++;
        
        if (n >= t) {
            n -= t;
            x ++;
        } else break;
    }
    printf("%d\n",x);
    return 0;
}
*/

/// prime记路径+离散化
/*
int cmp(const pair<int,int> &a,const pair<int,int> &b) {
    if (a.second == b.second) {
        return a.first > b.first;
    }
    return a.second > b.second;
}

struct Node {
    int f;
    int n;
    ll w;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

vector<Node> g[200010];
vector<int> h[200010];

ll dis[200010];
int vis[200010] = {0};

void prime(int s)
{
    mem(dis,-1);
    
    priority_queue<Node> q;
    q.push({-1,s,dis[s] = 0});
    
    Node current;
    ll k;
    
    
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        if (current.f != -1) {
            h[current.n].pb(current.f);
            h[current.f].pb(current.n);
        }
        
        for (auto to : g[current.n]) {
            k = to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({current.n,to.n,dis[to.n] = k});
            }
        }
    }
}

int vis2[200010] = {0};
int d[200010] = {0};


void dfs(int n) {
    if (vis2[n]) return;
    
//    printf(">>%d\n",n);
    
    vis2[n] = 1;
    for (auto i : h[n]) {
        d[n] ++;
        dfs(i);
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    pair<int,int> pth[200010];
    rep(i,1,m) {
        scanf("%d%d",&u,&v);
        pth[i] = make_pair(min(u,v), max(u,v));
    }
    sort(pth + 1,pth + m + 1,cmp);
    rep(i,1,m) {
//        printf("%d %d %d\n",pth[i].first,pth[i].second,m - i + 1);
        g[pth[i].first].pb({-1,pth[i].second,m - i + 1});
        g[pth[i].second].pb({-1,pth[i].first,m - i + 1});
    }
    prime(1);
    dfs(1);
    int md = -1;
    rep(i,1,n) md = max(md,d[i]);
    printf("%d\n",md);
    return 0;
}
*/

//int main()
//{
//    const int mod = 998244353;
////    ll x = 1000000000000000000ll;
////    cout << (x%mod) * 10 % mod << endl;
//    int n,m,k;
//    scanf("%d%d%d",&n,&m,&k);
//    ll a[510][510];
//
//    ll sr[510] = {0};
//    ll sc[510] = {0};
//
//    rep (i,1,n) {
//        rep (j,1,m) {
//            scanf("%lld",&a[i][j]);
//            sc[j] = (a[i][j] + sc[j]) % mod;
//            sr[i] = (a[i][j] + sr[i]) % mod;
//        }
//    }
//
////    rep (i,1,n) printf("%lld ",sr[i]);
////    printf("\n");
////    rep (i,1,m) printf("%lld ",sc[i]);
////    printf("\n");
//
//    ll sum = 0;
//    ll sub = 0;
//
//    char in;
//    ll ti;
//    int x;
//
//    char l = 'x';
//    // x init
//    // 'r' r
//    // 'c' c
//
//    ll t[510][510] = {0};
//
//    queue<pair<int,ll>> nodes;
//
//    ll tr[510] = {0};
//    ll tc[510] = {0};
//    pair<int,ll> top;
//
//    REP(i,0,k) {
//        scanf(" %c%d%lld",&in,&x,&ti);
//        if (i != 0) {
//            if (l != in) {
//
//                if (in == 'r') {
//                    while (!nodes.empty()) {
//                        top = nodes.front();
//                        nodes.pop();
//
//                        sub = (sub + (a[x][top.first] % mod) * ((top.second - t[x][top.first]) % mod) % mod) % mod;
//
////                        cout << "..." << t[x][top.first] << endl;
////                        cout << ">>" << top.second - t[x][top.first] << endl;
//
////                        printf(">>%lld\n",(ti - top.second));
//                        t[x][top.first] = top.second;
//                    }
//                } else if (in == 'c') {
//                    while (!nodes.empty()) {
//                        top = nodes.front();
//                        nodes.pop();
//
//                        sub = (sub + (a[top.first][x] % mod) * ((top.second - t[top.first][x]) % mod) % mod) % mod;
//
////                        cout << "..." << t[top.first][x] << endl;;
////                        cout << ">>" << top.second - t[top.first][x] << endl;
//                        t[top.first][x] = top.second;
//                    }
//                }
//
//            }
//        }
//        l = in;
//        nodes.push(make_pair(x, ti));
//
//        if (in == 'r') {
//            sum = (sum + ((sr[x] * ((ti - tr[x]) % mod)) % mod)) % mod;
////            nodes.push(make_pair(x, ti - tr[x]));
//            tr[x] = ti;
//        } else if (in == 'c') {
//            sum = (sum + ((sc[x] * ((ti - tc[x]) % mod)) % mod)) % mod;
//
//            tc[x] = ti;
//        }
//    }
////    printf("%lld %lld\n",sum,sub);
//    printf("%lld\n",((sum + mod) - sub) % mod);
//    return 0;
//}


//int main()
//{
//    int a[10];
//    int cnt;
//    int ok = 0;
//    int t;
//    int l[] = {0,20,12,32,40,24,44,52,60,16,36,64,56,72,76,80,28,84,68,88,92,96};
//    _T_(T) {
//        cnt = 0;
//        REP(i,0,10) {
//            scanf("%d",a + i);
//            cnt += a[i];
//        }
//
//
//
//        int x[100] = {0};
//        if (a[0] >= 2) {
//            x[0] = 1;
//        }
//        if (a[2] >= 1 && a[0] >= 1) {
//            x[20] = 1;
//        }
//        if (a[1] >= 1 && a[2] >= 1) {
//            x[12] = 1;
//        }
//        if (a[3] >= 1 && a[2] >= 1) {
//            x[32] = 1;
//        }
//        if (a[4] >= 1 && a[0] >= 1) {
//            x[40] = 1;
//        }
//        if (a[2] >= 1 && a[4] >= 1) {
//            x[24] = 1;
//        }
//        if (a[4] >= 2) {
//            x[44] = 1;
//        }
//        if (a[5] >= 1 && a[2] >= 1) {
//            x[52] = 1;
//        }
//        if (a[6] >= 1 && a[0] >= 1) {
//            x[60] = 1;
//        }
//        if (a[1] >= 1 && a[6] >= 1) {
//            x[16] = 1;
//        }
//        if (a[3] >= 1 && a[6] >= 1) {
//            x[36] = 1;
//        }
//        if (a[6] >= 1 && a[4] >= 1) {
//            x[64] = 1;
//        }
//        if (a[5] >= 1 && a[6] >= 1) {
//            x[56] = 1;
//        }
//        if (a[7] >= 1 && a[2] >= 1) {
//            x[72] = 1;
//        }
//        if (a[7] >= 1 && a[6] >= 1) {
//            x[76] = 1;
//        }
//        if (a[8] >= 1 && a[0] >= 1) {
//            x[80] = 1;
//        }
//        if (a[2] >= 1 && a[8] >= 1) {
//            x[28] = 1;
//        }
//        if (a[8] >= 1 && a[4] >= 1) {
//            x[84] = 1;
//        }
//        if (a[6] >= 1 && a[8] >= 1) {
//            x[68] = 1;
//        }
//        if (a[8] >= 2) {
//            x[88] = 1;
//        }
//        if (a[9] >= 1 && a[2] >= 1) {
//            x[92] = 1;
//        }
//        if (a[9] >= 1 && a[6] >= 1) {
//            x[96] = 1;
//        }
//        ok = 0;
//        if (cnt >= 3) {
//            for (auto i : l) {
//                if (x[i]) {
//                    t = i;
//                    if (t == 0) a[0] -= 2;
//                    else {
//                        while (t != 0) {
//                            a[t % 10] --;
//                            t /= 10;
//                        }
//                    }
//                    pre(j,9,0) {
//                        while (a[j] != 0) {
//                            printf("%d",j);
//                            a[j] --;
//                        }
//                    }
//                    if (i == 0) printf("00\n");
//                    else printf("%d\n",i);
//                    ok = 1;
//                    break;
//                }
//            }
//        } else {
//            pre(i,100,0) {
//                if (x[i]) {
//                    ok = 1;
//                    printf("%d\n",i);
//                    break;
//                }
//            }
//        }
//
//
//        if (!ok) {
//            if (a[8] >= 1) printf("8\n");
//            else if (a[4] >= 1) printf("4\n");
//            else if (a[0] >= 1) printf("0\n");
//            else printf("-1\n");
//        }
//    }
//    return 0;
//}

//
//
//inline bool has(int *a,int n) {
//    if (n == 0) return a[0] >= 2;
//    if (n == 44) return a[4] >= 2;
//    if (n == 88) return a[8] >= 2;
//    int ok = 1;
//    while (n != 0) {
//        if (a[n % 10] < 1) {
//            ok = 0;
//            break;
//        }
//        n /= 10;
//    }
//    return ok;
//}
//
//int main()
//{
//    int a[10];
//    int cnt;
//    int b[10];
//    string x;
//    int n;
//    ll ans = -1;
//    _T_(T) {
//        cnt = 0;
//        REP(i,0,10) {
//            scanf("%d",a + i);
//        }
//        vector<string> all;
//        rep(i,0,99) {
//            if (i % 4 == 0 && has(a,i)) {
//                x = "";
//                REP(i,0,10) b[i] = a[i];
//                n = i;
//                if (n == 0) b[0] -= 2;
//                else while (n != 0) {
//                    b[n % 10] --;
//                    n /= 10;
//                }
//                pre(j,9,0) {
//                    while (b[j] != 0) {
//                        x += b[j] ^ 48;
//                        b[j] --;
//                    }
//                }
//
//
//                all.pb(x);
//            }
//        }
//
//    }
//}
//

/*
 /// 还得看看
int main()
{
    int n;
    int a[1010];
    int b[1010];
    int cnt;
    _T_(T) {
        scanf("%d",&n);
        REP(i,0,n) scanf("%d",a + i);
        REP(i,0,n) scanf("%d",b + i);
        sort(a,a + n);
        sort(b,b + n);
        int m = -INT_INF;
        pre (k,n - 1,0) {
            cnt = 0;
            for (int i = n - 1,j = k;i >= 0 && j >= 0;j --,i --) {
                if (a[i] > b[j]) {
                    cnt ++;
                }
            }
            m = max(m,cnt);
        }
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    ll sum = 0;
    ll sub = 0;
    _T_(T) {
        scanf("%d",&n);
        sum = 0;
        sub = 0;
        REP(i,0,n) {
            scanf("%d",a + i);
            if (i != 0) {
                if (a[i] < a[i - 1]) {
                    sum += a[i - 1] - 1;
                    sub += a[i] - 1;
                }
            }
        }
        sum += a[n - 1] - 1;
        printf("%lld\n",sum - sub);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    itn j;
    int m = 0;
    _T_(T) {
        cin >> str;
        j = 0;
        m = 0;
        for (int i = 1;str[i];i ++) {
            if (str[i] == str[j]) j ++;
            else {
                m = max(m,j);
                j = 0;
                if (str[i] == str[j]) j ++;
            }
        }
        m = max(m,j);
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
int main()
{
    const int r = 91;
    ull f[100];
    f[1] = 1;
    f[2] = 2;
    
    ull a = 1,b = 1,c;
    rep(i,3,r) {
        c = a + b;
        a = b;
        b = c;
        f[i] = f[i - 1] + c;
    }
    
//    rep(i,1,r) printf("%llu ",f[i]);
    ull x,*i;
    _T_(T) {
        scanf("%llu",&x);
        i = upper_bound(f + 1, f + 1 + r, x);
        printf("%lu\n", i - f - 1);
    }
    return 0;
}
*/

//struct Node {
//    int n,w;
//};
//
//vector<Node> g[1000010];
//int a[1000010];
//int vis[1000010];
//int dis[1000010];
//
//vector<ll> all;
//
//void dfs(int x,int k)
//{
//    if (vis[x]) return;
//    vis[x] = 1;
//    dis[x] = k + a[x];
//    for (auto i : g[x]) {
//        dfs(i.n,k + i.w);
//    }
//}
//
//int main()
//{
//    itn n;
//    int u,w;
//    _T_(T) {
//        scanf("%d",&n);
//        rep(i,2,n) {
//            scanf("%d%d",&u,&w);
//            g[u].pb({i,w});
//            g[i].pb({u,w});
//        }
//        rep(i,1,n) scanf("%d",a + i);
//        mem(vis,0);
//        dfs(1,0);
////        rep(i,1,n) printf("%d ",dis[i]);
////        printf("\n");
//        sort(dis + 1,dis + n + 1,greater<int>());
//
//    }
//    return 0;
//}

//const int mod = 1000000007;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int main()
//{
//    printf("%lld",((36*7)*quickpow(128,mod-2))%mod);
//    return 0;
//}

//const int N=5000080;
//const int inf=1e9+1;
//const ll mod=1e9+7;
//using namespace std;
//int n,x,y,z,ans=0,A,B;
//ll jie[N],jieni[N];
//ll qpow(ll a,ll x)
//{
//    ll res=1,u=x;
//    while(u){
//        if(u&1) res=(res*a)%mod;
//        a=(a*a)%mod;
//        u>>=1;
//    }
//    return res;
//}
//ll Cnm(int n,int m)
//{
//    ll res=(jie[n]*jieni[n-m])%mod;
//    res=(res*jieni[m])%mod;
//    return res;
//}
//int main()
//{
//    int i,t,n,m,k;
//    jie[0]=1;
//    jieni[0]=1;
//    for(i=1;i<=100000;i++)
//    {
//        ll o=i;
//        jieni[i]=(jieni[i-1]*qpow(o,mod-2))%mod;
//        jie[i]=(jie[i-1]*i)%mod;
//    }
//    scanf("%d",&t);
//    while(t--)
//    {
//        scanf("%d %d %d",&n,&m,&k);
//        if(n-k<m) printf("0\n");
//        else{
//
//        ll A=0ll,B=0ll,ans;
//        A=Cnm(n,k)%mod;
//        for(i=m;i<=n;i++) B=(B+Cnm(n,i))%mod;
//
//            cout << A << endl << B << endl;
//        B=qpow(B,mod-2)%mod;
//        ans=A*B%mod;
//        printf("%lld\n",ans);
//    }
//    }
//    return 0;
//}

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll cnt = 0;
//    ll i = 2;
    ll p = n;
    map<ll,int> all;
    for (ll i = 2;i * i <= n && p != 1;i ++) {
        while (p % i == 0) {
            p /= i;
            all[i] ++;
        }
    }
    if (p != 1) all[p] ++;
    
    int k;
    int x;
    for (auto i : all) {
//        printf("%lld: %d\n",i.first,i.second);
        k = i.second;
        x = sqrt(k * 2 + 0.25) - 0.5;
        cnt += x;
    }
    printf("%lld\n",cnt);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[200010];
    int b[200010];
    rep(i,1,n) scanf("%d%d",a + i,b + i);
    sort(a + 1,a + n + 1);
    sort(b + 1,b + n + 1);
    if (n % 2) {
        printf("%d\n",b[(n + 1) / 2] - a[(n + 1) / 2] + 1);
    } else {
        printf("%d\n",b[n / 2] + b[n / 2 + 1] - a[n / 2] - a[n / 2 + 1] + 1);
    }
    
}
*/

//class A {
//protected:
//    int a,b;
//public:
//    A(int a,int b):a(a),b(b) {
//
//    }
//
//    void out()
//    {
//        printf("%d\n",a + b);
//    }
//};
//
//class B : public A {
//    int c;
//public:
//    B(int a,int b,int c):A(a,b),c(c) {
//
//    }
//
//    void out() {
//        cout << a  << " " << b  << " " << c << endl;
//    }
//};
//
//int main()
//{
//    A a(1,2);
//    B b(1,2,3);
//    A *c = new B(1,2,3);
//    B *d = (B*) c;
//    c -> out();
//    d -> out();
//}


/*int main()
{
    int n;
    int a;
    int b;
    
    int sum = 0;
    _T_(T) {
        sum = 0;
        scanf("%d",&n);
        REP(i,0,n) {
            scanf("%d %d",&a,&b);
            sum += a * b;
        }
        printf("%d\n",sum);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int t;
    scanf("%d",&n);
    int c = 0;
    int nn = 0;
    while (n --) {
        scanf("%d",&t);
        if (t % 2) {
            if (t != 1) {
                c += 1;
                nn ++;
            }
        } else nn ++;
    }
    if (nn != 0) c += nn - 1;
    if (c % 2) printf("Alice\n");
    else printf("Bob\n");
    return 0;
}
*/

/*
inline bool has7(int n)
{
    int ok = 0;
    while (n != 0)
    {
        if (n % 10 == 7) {
            ok = 1;
            break;
        }
        n /= 10;
    }
    return ok;
}

int main()
{
    int x,h,m;
    int n;
    _T_(T) {
        scanf("%d %d:%d",&x,&h,&m);
        n = 0;
        while (!has7(h) && !has7(m)) {
            if (m >= x) m -= x;
            else {
                if (h == 0) h = 23;
                else h --;
                m += 60 - x;
            }
            n ++;
        }
        printf("%d %02d:%02d\n",n,h,m);
    }
    
    return 0;
}
*/

/*
int main()
{
    ll a[1000010];
    a[1] = 2;
    const int mod = 1000000007;
    rep(i,2,1000000) {
        a[i] = ((a[i - 1] * 3) % mod + 2) % mod;
    }
    
    int n;
    _T_(T) {
        scanf("%d",&n);
        printf("%lld\n",a[n]);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll a[n];
    REP(i,0,n) {
        scanf("%lld",a + i);
    }
    ll last = a[0];
    ll sum = a[0];
    REP(i,1,n) {
        last = max(a[i],a[i] + last);
        sum = max(sum,last);
    }
    printf("%lld\n",sum);
    return 0;
}
*/

/*
ll a[1000010];
ll s[1000010];
int main()
{
    int n,k;
    
    scanf("%d%d",&n,&k);
    rep(i,1,n) scanf("%lld",a + i);
    
    s[1] = a[1];
    s[0] = 0;
    rep(i,2,n) s[i] = a[i] + s[i - 1];
    int l,r;
    REP (i,0,k) {
        scanf("%d%d",&l,&r);
        printf("%lld\n",s[r] - s[l - 1]);
    }
    return 0;
}
*/

/*int main()
{
    const int mod = 1000000007;
    ll c[110][110];
    c[1][0] = 1;
    c[1][1] = 1;
    for (int i = 2;i <= 100;i ++) {
        c[i][0] = 1;
        c[i][i] = 1;
        for (int j = 1;j < i;j ++) {
            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
        }
    }

    int n,m;
    int a[] = {1,2,3,5,9};
    int s[] = {1,6,31,156,781,3906,19531,97656,488281,2441406,12207031,61035156,305175781};
    int *v,l,k;
    _T_(T) {
        scanf("%d%d",&n,&m);
        k = (int) c[n][m];
        v = upper_bound(s, s + 13, k);
        v --;
        l = (int) (v - s) + 1;
        k = k - *v;
        vector<int> x;
        while (k != 0) {
            x.pb(k % 5);
            k /= 5;
        }
        REP(i,0,l - x.size()) {
            printf("%d",a[0]);
        }
        for (auto i = x.rbegin();i != x.rend();i ++) {
            printf("%d",a[*i]);
        }
        printf("\n");
    }

}
*/

/// 快速组合数
/*
const int MAXN = 3000010;
const int mod = 911451407;

ll da[MAXN];

void init()
{
    int i;
    da[0] = 1;
    da[1] = 1;
    for(i = 2;i < MAXN;i ++)
        da[i] = i * da[i - 1] % mod;
}

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}


ll c(ll a, ll b)
{
    return (da[a] % mod) * (quickpow(da[b] * da[a - b] % mod,mod - 2)) % mod;
}

int main()
{
    init();
    int l,x;
    _T_(T) {
        scanf("%d%d",&l,&x);
//        printf("%d %d\n",l + x - 2,x - 1);
        printf("%lld\n",c(l + x - 2,x - 1));
    }
    return 0;
}
*/

/*
int tp(char k)
{
    if (k >= 'A' && k <= 'Z') return 1;
    return 0;
}

int main()
{
    string str;
    cin >> str;
    int t = 1;
    int cnt = 0;
    for (int i = 0;str[i];i ++) {
        if (tp(str[i]) != t) {
            t=tp(str[i]);
            cnt ++;
        }
    }
    printf("%d\n",cnt);
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    _T_(T) {
        scanf("%d",&n);
        REP(i,0,n) scanf("%d",a + i);
        sort(a,a + n);
        ll cnt = 0;
        ll last = 0;
        REP(i,0,n - 1) {
            last += a[i];
            cnt += last;
        }
        printf("%.2f\n",cnt / (double) n);
    }
    return 0;
}
*/

/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n;
    ll x;
    _T_(T){
        scanf("%d",&n);
        x = quickpow(2, n - 1);
        x = x * n % mod;
        printf("%lld\n",x);
    }
    return 0;
}
*/

/*
int main()
{
    int n,a,b;
    _T_(T) {
        scanf("%d%d%d",&n,&a,&b);
        if (n % 2) {
            // odd
            if (a > b) {
                if (b % 2) printf("DOWN\n");
                else printf("UP\n");
            } else {
                if (a % 2 == 0) printf("DOWN\n");
                else printf("UP\n");
            }
        } else {
            // even
            printf("ALL\n");
        }
    }
    return 0;
}
*/

/*
int main()
{
    int x,m,n;
    _T_(T) {
        scanf("%d%d%d",&x,&m,&n);
        
        priority_queue<int,vector<int>,greater<int>> q;
        stack<int> tmp;
        int k = 1;
        q.push(k);
        m --;
        int t;
        while (!q.empty() && k < n) {
            t = k - q.top();
            if (t > 12) q.pop();
            else {
                while (t >= 7 && t <= 12) {
                    if (m <= 0) break;
                    for (int i = 0;i < x && m > 0;i ++,m --) q.push(k);
                    tmp.push(q.top());
                    q.pop();
                    if (q.empty()) break;
                    t = k - q.top();
                }
                while (!tmp.empty()) {
                    q.push(tmp.top());
                    tmp.pop();
                }
            }
            k ++;
        }
//        printf(">>%d\n",k);
        int cnt = 0;
        while (!q.empty()) {
//            printf("..%d\n",q.front());
            t = k - q.top();
            if (t >= 7 && t <= 12) cnt ++;
            q.pop();
        }
        printf("%d\n",cnt);
    }
    reutnr 0;
}
*/

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int w[510];
    vector<int> ws;
    rep(i,1,n) scanf("%d",w + i);
    int u,v;
    ll a = 0;
    ll b = 0;
    int x = -1;
    while (m --)
    {
        scanf("%d%d",&u,&v);
        if (w[u] != -1 && w[v] != -1) {
            a += w[u] ^ w[v];
        } else {
            if (w[u] != -1) {
                ws.pb(w[u]);
                x = v;
            }
            if (w[v] != -1) {
                ws.pb(w[v]);
                x = u;
            }
        }
    }
    sort(ws.begin(),ws.end());
//    if (ws.size() != 0) {
//        w[x] = *ws.begin();
//        for (auto i : ws) {
//            a += w[x] ^ i;
//        }
//    }
    
    int k = log2(*(ws.end() - 1)) + 1;
    int bin[40][2] = {0};
    int h;
    int j;
    for (auto i : ws) {
        j = i;
        h = 0;
        while (j != 0) {
            bin[h ++][j & 1] ++;
            j >>= 1;
        }
        for (;h < k;h ++) bin[h][0] ++;
    }
    ll fin = 0;
    //    for (int i = 0;i < 40;i ++) printf("%d ",bin[i][0]);
    //    printf("\n");
    //    for (int i = 0;i < 40;i ++) printf("%d ",bin[i][1]);
    //    printf("\n");
    for (ll i = 0;i < 40;i ++) {
        if (bin[i][0] < bin[i][1]) {
            fin += 1LL << i;
        }
    }
//    printf("%lld\n",fin);
    
    for (auto i : ws) {
        a += fin ^ i;
    }
    w[x] = (int) fin;
    
    
    rep(i,1,n) b += w[i];
    printf("%lld\n%lld\n",a,b);
    return 0;
}
*/

/*
int main()
{
    int L;
    scanf("%d",&L);
    double x1,x2,x3,y1,y2,y3,z1,z2,z3;
    double X,Y,Z;
    scanf("%lf%lf%lf",&X,&Y,&Z);
    scanf("%lf%lf%lf",&x1,&y1,&z1);
    scanf("%lf%lf%lf",&x2,&y2,&z2);
    scanf("%lf%lf%lf",&x3,&y3,&z3);
    double A = (y2 - y1)*(z3 - z1) - (z2 -z1)*(y3 - y1);
    double B = (x3 - x1)*(z2 - z1) - (x2 - x1)*(z3 - z1);
    double C = (x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1);
    double D = -(A * x1 + B * y1 + C * z1);
    double k = abs(A * X + B * Y + C * Z + D) / sqrt(A * A + B * B + C * C);
    printf("%.10f\n",k * k * k * pi / 6.0 / L);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int id;
    int r,g,b;
    pair<ll,int> a[110];
    REP (i,0,n) {
        scanf("%d%d%d%d",&id,&r,&g,&b);
        a[id] = make_pair(r + g * 2 + b * 3,id);
    }
    sort(a + 1,a + n + 1);
    printf("%d %lld\n",a[n].second,a[n].first);
    
    return 0;
}
*/

/*
ll mod = 2;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll y,p;
    _T_(T) {
        scanf("%lld%lld",&y,&p);
        double k = y / (double) p;
        if (y / p == k) printf("-1\n");
        else if (p == 1) printf("-1\n");
        else {
            mod = p;
            printf("%lld\n",quickpow(y, p - 2) % mod);
        }
    }
    return 0;
}
*/

/*
const int MAXN = 1000010;
const int mod = 1000000007;

int p[MAXN];
int nd[MAXN] = {0};

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

struct Node {
    int n,w;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

vector<Node> g[MAXN];
int dis[MAXN];
int vis[MAXN] = {0};


ll sum = 0;

void dij(int s) {
    mem(dis,-1);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0});
    
    Node current;
    int k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        for (auto to : g[current.n]) {
            k = dis[current.n] + to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    REP(i,0,m) {
        scanf("%d%d",&u,&v);
        g[u].pb({v,1});
        g[v].pb({u,1});
    }
    dij(1);
    
    rep(i,2,n) {
        nd[dis[i]] ++;
    }
    
    
    rep(i,1,n) {
        if (nd[i]) {
            sum = (sum + ((nd[i] % mod) * (quickpow(2, i) % mod) % mod)) % mod;
        }
    }
    
    printf("%lld\n",sum);
    return 0;
}
*/


/*
int main()
{
    int a[110];
    int n;
    int ok = 1;
    int f;
    int *m;
    
    _T_(T) {
        scanf("%d",&n);
        ok = 1;
        REP(i,0,n) scanf("%d",a + i);
        f = a[0] % n;
        REP(i,1,n) {
            if (a[i] % n != f) {
                ok = 0;
                break;
            }
        }
        
        int okk = 1;
        REP(i,1,n) if (a[i] != a[i - 1]) {
            okk = 0;
            break;
        }
        if (okk) printf("Yes\n");
        else if (ok) {
            sort(a,a + n);
            m = upper_bound(a, a + n, a[0]);
            if (a[0] >= (m - a) - 1) printf("Yes\n");
            else printf("No\n");
        }
        else printf("No\n");
        
    }
    return 0;
}
*/

//struct Node {
//    int st,ed;
//};
//
//int main()
//{
//    int n;
//    int a[100010];
//    int vis[100010];
//    _T_(T) {
//        mem(vis,0);
//        scanf("%d",&n);
//        REP(i,0,n) scanf("%d",a + i);
//        vector<Node> all;
//        int s = -1;
//
//        REP(i,0,n) {
//            if (a[i] == -1) {
//                if (s == -1) s = i;
//            } else {
//                if (s != -1) {
//                    all.pb({s,i});
//                    s = -1;
//                }
//            }
//        }
//        if (s != -1) {
//            all.pb({s,n});
//        }
//        ll ans = 0;
//        int reduced = 0;
//        int l;
//
//        for (auto i : all) {
//            l = i.ed - i.st;
////            printf("%d -> %d\n",i.st,i.ed);
//            ans += l / 2;
//
//            if (l % 2) {
//                reduced = 0;
//
//                // left
//                if (i.st != 0) {
//                    if (a[i.st - 1] == 0 && vis[i.st - 1] == 0) {
//                        vis[i.st - 1] = 1;
//                        reduced = 1;
//                    }
//                }
//
//                // right
//                if (!reduced) {
//                    if (i.ed != n) {
//                        if (a[i.ed] == 0 && vis[i.ed] == 0) {
//                            vis[i.ed] = 1;
//                            reduced = 1;
//                        }
//                    }
//                }
//
//                if (!reduced) ans --;
//            }
//
//        }
//
//        REP(i,0,n) if (a[i] == 1) ans ++;
//        printf("%lld\n",ans);
//    }
//
//    reutnr 0;
//}

/*
int main()
{
    int n;
    string str;
    int cnt = 0;
    int ok;
    _T_(T) {
        scanf("%d",&n);
        ok = 0;
        REP(j,0,n) {
            cnt = 0;
            cin >> str;
            for (int i = 0;str[i];i ++) {
                if (str[i] == '1') cnt ++;
            }
            if (cnt % 2) ok = 1;
        }
        
        if (ok) printf("sdzNB\n");
        else printf("kgNB\n");
    }
    return 0;
}
*/

/*
class A {
    
public:
    int x;
    A(int x):x(x){}
    
};

class B : public A {
    int x;
public:
    B(int x):x(x),A(10){}
    void show(){
        printf("%d\n",A::x);
    }
    
    friend void aaa();
    void bbb();
};

void aaa()
{
    printf("123\n");
}

void B::bbb()
{
    aaa();
}


int main()
{
    B b(100);
    b.show();
    b.bbb();
    return 0;
}
*/

//
//vector<int> g[100010];
//
//int vis[100010] = {0};
//int c[100010];
//int deep[100010];
//
//int dfs(int n,int d) {
//    if (vis[n]) return 0;
//    vis[n] = 1;
//    deep[n] = d;
//    int x = 0;
//    for (auto i : g[n]) {
//        x += dfs(i,d + 1);
//    }
//    c[n] = x;
//    return x + 1;
//}
//
//vector<int> all;
//
//void dfs2(int n, int d)
//{
//    if (vis[n]) return;
//    vis[n] = 1;
//
//    for (auto i : g[n]) {
//        if (!vis[i]) {
//            all.pb(d + c[i]);
//            dfs2(i,d + c[n] - c[i] - 1);
//        }
//    }
//
//
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int u,v;
//    REP(i,0,n - 1) {
//        scanf("%d%d",&u,&v);
//        g[u].pb(v);
//        g[v].pb(u);
//    }
//    dfs(1,0);
//    mem(vis,0);
//    dfs2(1,0);
//
//    rep(i,1,n) printf("%d ",c[i]);
//    printf("\n");
//    rep(i,1,n) printf("%d ",deep[i]);
//    printf("\n");
//    for (auto i : all) {
//        printf("%d ",i);
//    }
//    reutnr 0;
//}
//

//class AirCondition {
//    string brand;
//    string type;
//    double in;
//    double out;
//public:
//    AirCondition(string brand,string type,double prize_in,double prize):brand(brand),type(type),in(prize_in),out(prize) {}
//
//    double getPrize() {
//        return out;
//    }
//
//    double getBasic() {
//        return in;
//    }
//
//    string getName() const
//    {
//        return brand + "-" + type;
//    }
//
//    bool operator<(AirCondition o) const {
//        return brand + "-" + type < o.brand + "-" + type;
//    }
//};
//
//struct ACInf {
//    int num;
//    double out;
//    double in;
//
//    ACInf():num(0),out(0),in(0){}
//};
//
//void print_ac(map<AirCondition,ACInf> &ac_inf)
//{
//    const AirCondition *a;
//    const ACInf *b;
//    for (auto i : ac_inf) {
//        a = &(i.first);
//        b = &(i.second);
//        printf("--------Information of %s air-conditioner--------\n",a -> getName().c_str());
//        printf("sold: %d\n",b -> num);
//        printf("average: %f\n",b -> out / b -> num);
//        printf("profit: %f\n",b -> out - b -> in);
//    }
//
//}
//
//class Employee {
//    int id;
//    string name;
//    double basic;
//    vector<AirCondition> acs;
//
//public:
//    double plug;
//    Employee(int id, string name, double basic, int num):
//        id(id),name(name),basic(basic),plug(0) {}
//
//    unsigned long getNum() {
//        return acs.size();
//    }
//
//    vector<AirCondition> &getAirs() {
//        return acs;
//    }
//
//    void print()
//    {
//        printf("--------Information of employee--------\n");
//        printf("id: %d\n",id);
//        printf("name: %s\n",name.c_str());
//        printf("sold: %lu\n",acs.size());
//        printf("income: %f\n",basic + plug);
//    }
//
//
//};
//
//class Manager : Employee {
//public:
//    Manager(int id, string name, double basic, double plug):
//        Employee(id, name, basic, 0) {
//            this -> plug = plug;
//        }
//};
//
//
//
//int main()
//{
//    // generate data
//
//    // make type & prize
//    vector<AirCondition> acs;
//    for (int i = 1;i <= 5;i ++) {
//        for (int j = 1;j <= 10;j ++) {
//            int out = rand() % 10000;
//            acs.push_back(AirCondition("AC" + to_string(i),to_string(j),rand() % (out - 1000),out));
//        }
//    }
//
//    map<AirCondition,ACInf> ac_inf;
//
//    vector<Employee> emps;
//    int num,type;
//    for (int i = 1;i <= 20;i ++) {
//        num = rand() % 300;
//        emps.push_back(Employee(i,"emp" + to_string(i),(max(2,rand() % 5)) * 1000,num));
//        for (int j = 1,last = 0;j <= num;last = j,j += max(1,rand() % (max(1,num - j)))) {
//            type = rand() % acs.size();
//            for (int k = 0;k < j - last;k ++)
//            {
//                emps[i - 1].getAirs().push_back(acs[type]);
//            }
//            ac_inf[acs[type]].num += j - last;
//            ac_inf[acs[type]].in += acs[type].getBasic() * (j - last);
//            ac_inf[acs[type]].out += acs[type].getPrize() * (j - last) * ((j - last) > 10 ? 0.95 : 1);
//
//            if (num > 100) emps[i - 1].plug += 0.03 * (acs[type].getPrize() * (j - last) * ((j - last) > 10 ? 0.95 : 1) - acs[type].getBasic() * (j - last));
//        }
//    }
//
//    vector<Manager> mgrs;
//    for (int i = 1;i <= 10;i ++) {
//        mgrs.push_back(Manager(i,"mgr" + to_string(i),rand() % 10000,rand() % 1000));
//    }
//
//
//
//    // out
//
//    long long max_num = -1;
//    Employee max_emp(-1,"emp",rand() % 10000,rand() % 100);
//
//    for (auto i : emps) {
//        i.print();
//        if (((long long) i.getNum()) > max_num) {
//            max_num = i.getNum();
//            max_emp = i;
//        }
//    }
//
//    print_ac(ac_inf);
//
//
//    printf("-----Best employee----\n");
//    max_emp.print();
//
//    return 0;
//}

/*string trim(string str) {
    string f;
    int ok = 0;
    for (int i = 0;str[i];i ++) {
        if (!ok) {
            if (str[i] != ' ' && str[i] != '\n' && str[i] != '\r' && str[i] != '\b') {
                f += str[i];
                ok = 1;
            }
        } else f += str[i];
        
    }
    
    if (f.size() != 0)
    while (*(f.end() - 1) == ' ' || *(f.end() - 1) == '\n' || *(f.end() - 1) == '\r' || *(f.end() - 1) == '\b') f.erase(f.end() - 1);
    return f;
}

int main()
{
    fre("/Users/jackli/sum.txt");
    string line;
    
    while (getline(cin,line))
    {
        line = trim(line);
        if (line != "") printf("<p style='text-indent: 0;'>%s</p>\n",line.c_str());
    }
}
*/

/*
int main()
{
    int n,ta;
    scanf("%d%d",&n,&ta);
    int tb = ta;
    int a,b;
    scanf("%d%d",&a,&b);
    int x = 0,y = 0;
    ll u,v;
    ll t[100010];
    ll na[100010];
    REP (i,0,n) scanf("%lld",t + i);
    REP (i,0,n) scanf("%lld",na + i);
    REP (i,0,n) {
        u = t[i];
        v = na[i];
        if (v < a) {
            if (u <= ta) {
                ta -= u;
                x ++;
            }
        }
        
        if (v < b) {
            if (u <= tb) {
                tb -= u;
                y ++;
            }
        } else {
            if (u * 2 <= tb) {
                tb -= u * 2;
                y ++;
            }
        }
    }
//    cout << ta << endl << tb << endl;
    printf("%d %d\n",x,y);
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    ll sum = 0;
    REP(i,0,n) {
        scanf("%d",a + i);
        if (i != 0) {
            if (a[i] < a[i - 1]) {
                sum += a[i - 1];
                sum -= a[i];
            }
        }
    }
    sum += a[n - 1];
    printf("%lld\n",sum);
    return 0;
}
*/

/*
int main()
{
 
    int v1,v2,t,s,l;
    scanf("%d%d%d%d%d",&v1,&v2,&t,&s,&l);
    int h = 0,m = 0;
    int p = -1;
    int ans = 0;
    while (h < l && m < l) {
        if (m - h >= t && p == -1) p = 0;
        if (p == -1) m += v1;
        else {
            p ++;
            if (p == s) p = -1;
        }
        h += v2;
        ans ++;
    }
    string a;
    if (h >= l && m >= l) a = "Tie";
    else if (h >= l) a = "Hong";
    else if (m >= l) a = "Ming";
    printf("%s %d\n",a.c_str(),ans);
    return 0;
}
*/

/*
const int MAXN = 1e7;
int x[MAXN + 10];
int k[MAXN + 10] = {0};
int s[MAXN + 10];

int main()
{
    
    rep(i,1,MAXN) x[i] = i;
    REP(i,2,MAXN) {
        if (!k[i])
            for (int j = i + i;j <= MAXN;j += i) {
                k[j] = 1;
            }
    }
    
    k[1] = 1;
    s[1] = 0;
    s[0] = 0;
    rep(i,2,MAXN) {
        s[i] = s[i - 1] + (k[i] == 0 ? 1 : 0);
    }
    
    int a,b;
    _T_(T) {
        scanf("%d%d",&a,&b);
        printf("%d\n",s[b] - s[a - 1]);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[200010];
    scanf("%d",&n);
    READ(a,0,n);
    sort(a,a + n);
    int m = 0;
    for (int i = 0,j = 0;j < n;j ++) {
        while (a[j] - a[i] > 5) i ++;
        m = max(j - i + 1,m);
    }
    printf("%d\n",m);
    return 0;
}
*/

/*
int dx[] = {0,1,0,-1};
int dy[] = {1,0,-1,0};

int ddx[] = {1,1,-1,-1};
int ddy[] = {1,-1,1,-1};

char a[55][55];
int n,m;
int vis[55][55];

int ans = -1;

void dfs(int x,int y,int d)
{
//    printf(">>%d\n",d);
//    REP(i,0,n) {
//        REP(j,0,m) {
//            cout << vis[i][j];
//        }
//        cout << endl;
//    }
//    cout << endl;
    if (vis[y][x] != -1 && vis[y][x] <= d) return;
    vis[y][x] = d;
    
    if (a[y][x] == 'E') {
        if (ans == -1) ans = d;
        else ans = min(ans,d);
        return;
    }
    
    int xx,yy;
    REP (i,0,4) {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < m && yy >= 0 && yy < n && a[yy][xx] != '*' && a[yy][xx] != 'x') {
            dfs(xx,yy,d + 1);
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    REP(i,0,n) {
        scanf("%s",a[i]);
    }
    int xx,yy;
    int sx = 0,sy = 0;

    REP(i,0,n) {
        REP(j,0,m) {
            if (a[i][j] == 'S') {
                sx = j;
                sy = i;
            } else if (a[i][j] == '*') {
                REP(k,0,4) {
                    xx = j + dx[k];
                    yy = i + dy[k];
                    if (xx >= 0 && xx < m && yy >= 0 && yy < n) {
                        if (a[yy][xx] != '*') a[yy][xx] = 'x';
                    }
                    
                    xx = j + ddx[k];
                    yy = i + ddy[k];
                    if (xx >= 0 && xx < m && yy >= 0 && yy < n) {
                        if (a[yy][xx] != '*') a[yy][xx] = 'x';
                    }
                }
            }
        }
    }
    
//    REP(i,0,n) {
//        REP(j,0,m) {
//            cout << a[i][j];
//        }
//        cout << endl;
//    }
    
    
        mem(vis,-1);
        dfs(sx,sy,0);
        
        if (ans == -1) printf("Impossible\n");
        else printf("%d\n",ans);
    
    
    


//    REP(i,0,n) {
//        REP(j,0,m) {
//            cout << vis[i][j] << ' ';
//        }
//        cout << endl;
//    }
    return 0;
}
*/

/*
int main()
{
    ll a;
    scanf("%lld",&a);
    int l = log2(a) + 1;
    ll x = 0;
    for (ll i = 0;i < l;i ++) {
        x += 1LL << i;
    }
    if (a == 1) printf("0\n");
    else printf("%lld\n",x);
    return 0;
}
*/

/*
int main()
{
    int a[110];
    double sum = 0;
    int mx = -1,mn = INT_INF;
    _T_ (T) {
        int n;
        scanf("%d",&n);
        sum = 0;
        mx = -1;
        mn = INT_INF;
        REP (i,0,n) {
            scanf("%d",a + i);
            mx = max(mx,a[i]);
            mn = min(mn,a[i]);
            sum += a[i];
        }
        printf("MAX:%d\nMIN:%d\nAVG:%.2f\n",mx,mn,sum / n);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    _T_(T) {
        cin >> str;
        int a = 0,c = 0,m = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] == 'A') a ++;
            if (str[i] == 'C') c ++;
            if (str[i] == 'M') m ++;
        }
        if (!a) printf("A\n");
        else if (!c) printf("C\n");
        else if (!m) printf("M\n");
        else printf("-1\n");
    }
    return 0;
}
*/

/*
const int MAXN = 1e5;
int a[MAXN + 10] = {0};
int k[MAXN + 10] = {0};


int main()
{
    mem(a,-1);
    REP(i,2,MAXN) {
        if (!k[i]) {
            for (int j = i + i;j <= MAXN;j += i) {
                k[j] = 1;
                if (j % (i * i) != 0) a[j] = 0;
                else if (a[j] != 0) a[j] = 1;
            }
        }
    }

    vector<int> all;
    rep(i,1,MAXN) {
        if (a[i] == 1 && a[i - 1] == 1) {
            all.pb(i - 1);
            all.pb(i);
        }
    }

    sort(all.begin(),all.end());

    int l,r;
    int ok;
    while (~scanf("%d %d",&l,&r)) {
        ok = 0;
        for (vector<int>::iterator i = all.begin();i != all.end() - 1;i ++) {
            if (*i >= l && *i <= r && *(i + 1) >= l && *(i + 1) <= r && *i == *(i + 1) - 1) {
                printf("%d %d\n",*i,*(i + 1));
                ok = 1;
            }
        }
        if (!ok) puts("no find");
    }


    return 0;
}
*/

/*
int main()
{
    int n;
    ll k;
    const int MAXN = 1e6 + 10;
    ll a[MAXN];
    ll cnt;
    _E_(scanf("%d%lld",&n,&k)) {
        READ_ll(a,0,n);
        sort(a,a + n);
        int i = n / 2;
        cnt = 0;
        pre(j,i - 1,0) {
            cnt += abs((a[j + 1] - k) - a[j]);
            a[j] = a[j + 1] - k;
        }
        REP(j,i + 1,n) {
            cnt += abs((a[j - 1] + k) - a[j]);
            a[j] = a[j - 1] + k;
        }
        printf("%lld\n",cnt);
    }
    return 0;
}
*/


//int t,n,m;
//char a[30][30];
//struct Animal {
//    int x,y;
//    char type;
//    int alive;
//};
//
//set<Animal*> pos[30][30];
//int an = 0;
//Animal animals[900];
//
//int grass_days[30][30] = {0};
//// -2 - *
//// 3 - #
//// [0, 2] - .
//
//
//inline void move()
//{
//    REP(i,0,n) {
//        REP(j,0,m) {
//            pos[i][j].clear();
//        }
//    }
//    Animal *a;
//    REP(i,0,an) {
//        a = animals + i;
//        if (a -> type == 'S') {
//            if (a -> alive) {
//                a -> y ++;
//                if (a -> y == n) a -> y = 0;
//                if (grass_days[a -> y][a -> x] == 3) {
//                    grass_days[a -> y][a -> x] = 0;
//                    a -> alive = 5;
//                    pos[a->y][a->x].insert(a);
//                } else {
//                    if (a -> alive > 0) a -> alive --;
//                    if (a -> alive == 0) {
//                        grass_days[a -> y][a -> x] = -2;
//                    } else {
//                        pos[a->y][a->x].insert(a);
//                    }
//                }
//            }
//        } else if (a -> type == 'W') {
//            if (a -> alive) {
//                a -> x ++;
//                if (a -> x == m) a -> x = 0;
//
//                if (a -> alive > 0) a -> alive --;
//                pos[a->y][a->x].insert(a);
//            }
//        }
//    }
//}
//
//inline void eat()
//{
//    Animal *a = NULL,*b = NULL;
//    set<Animal*>::iterator x;
//    REP(i,0,n) {
//        REP(j,0,m) {
//            if (pos[i][j].size() == 1) {
//                a = *pos[i][j].begin();
//                if (a -> type == 'W') {
//                    if (a -> alive == 0) {
//                        grass_days[a -> y][a -> x] = -2;
//                    }
//                }
//            } else if (pos[i][j].size() == 2) {
//                x = pos[i][j].begin();
//                if ((*x) -> type == 'W') a = *x;
//                if ((*x) -> type == 'S') b = *x;
//                x ++;
//                if ((*x) -> type == 'W') a = *x;
//                if ((*x) -> type == 'S') b = *x;
//
//                a -> alive = 10;
//                b -> alive = 0;
//                grass_days[b -> y][b -> x] = -2;
//            }
//
//        }
//    }
//}
//
//inline void update()
//{
//    REP(i,0,n) {
//        REP(j,0,m) {
//            if (grass_days[i][j] >= 0 && grass_days[i][j] <= 2) {
//                grass_days[i][j] ++;
//            }
//        }
//    }
//}
//
//inline void print()
//{
//    char x[50][50];
//    REP(i,0,n) {
//        REP(j,0,m) {
//            switch (grass_days[i][j]) {
//                case -2:
//                    x[i][j] = '*';
//                    break;
//                case 3:
//                    x[i][j] = '#';
//                    break;
//                default:
//                    x[i][j] = '.';
//                    break;
//            }
//        }
//    }
//
//    REP(i,0,n) {
//        REP(j,0,m) {
//            printf("%c",x[i][j]);
//        }
//        puts("");
//    }
//
//    puts("");
//
//    Animal *a;
//    REP(i,0,an) {
//        a = animals + i;
//        if (!a -> alive) continue;
//        x[a -> y][a -> x] = a -> type;
//    }
//
//    REP(i,0,n) {
//        REP(j,0,m) {
//            printf("%c",x[i][j]);
//        }
//        puts("");
//    }
//
//    puts("-------------");
//}
//
//int main()
//{
//    scanf("%d%d%d",&t,&n,&m);
//    REP(i,0,n) {
//        scanf("%s",a[i]);
//    }
//
//    REP(i,0,n) {
//        REP(j,0,m) {
//            if (a[i][j] == 'S') {
//                animals[an ++] = {j,i,'S',5};
////                pos[i][j].insert({j,i,'S',5});
//            }
//            else if (a[i][j] == 'W') {
//                animals[an ++] = {j,i,'W',10};
////                pos[i][j].insert({j,i,'W',0});
//            }
//        }
//    }
//
//    REP(i,0,t) {
//        update();
//        move();
//        eat();
//        print();
//    }
//
//
//    return 0;
//}

/*
int g[1010];
int d[1010];

int find(int a)
{
    if (g[a] == a) return a;
    return g[a] = find(g[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        g[y] = x; // 改变b节点的根的根为a的根
        if (d[x] == d[y]) { // 俩根深度一样
            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
        }
    } else g[x] = y;
}

void init(int n)
{
    rep(i,1,n) {
        g[i] = i;
        d[i] = 1;
    }
}

int main()
{
    int n,m,t;
    scanf("%d%d%d",&n,&m,&t);
    int u,v;
    init(n);
    while (m --) {
        scanf("%d%d",&u,&v);
        bind(u,v);
    }
    while (t --) {
        scanf("%d%d",&u,&v);
        if (find(u) == find(v)) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
*/

// 01背包1维+记录数量
/*
int main()
{
    int n,s;
    int v[10010],w[10010];
    int dp[10010];
    int cnt[10010];
    _T_(T)
    {
        mem(dp,0);
        mem(cnt,0);
        scanf("%d%d",&n,&s);
        REP(i,0,n) {
            scanf("%d%d",w + i,v + i);
        }

        for (int i = 0; i < n; i++) {
            pre(j,s,w[i]) {
                if (dp[j - w[i]] + v[i] > dp[j]) {
                    dp[j] = dp[j - w[i]] + v[i];
                    cnt[j] = cnt[j - w[i]] + 1;
                }
                
            }
        }
        printf("%d %d\n",dp[s],cnt[s]);
    }
    return 0;
}
*/

/*
char a[510][510];
int vis[510][510] = {0};
int n,m;
int ok = 0;

int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};

void dfs(int x,int y)
{
    if (vis[y][x]) return;
    vis[y][x] = 1;
    if (a[y][x] == 'g') {
        ok = 1;
        return;
    }
    int xx,yy;
    for (int i = 0;i < 4;i ++) {
        xx = x + dx[i];
        yy = y + dy[i];
        if (xx >= 0 && xx < m && yy >= 0 && yy < n && a[y][x] != '#') {
            dfs(xx,yy);
        }
    }
}

int main()
{
    
    scanf("%d%d",&n,&m);
    int sx = 0,sy = 0;
    REP(i,0,n) {
        scanf("%s",a[i]);
        REP(j,0,m) {
            if (a[i][j] == 's') {
                sx = j;
                sy = i;
            }
        }
    }
    dfs(sx,sy);
    puts(ok ? "Yes" : "No");
    return 0;
}
*/

/*
int main()
{
    set<pair<double,double>> cross;
    int n;
    scanf("%d",&n);
    ll k[110];
    ll b[110];
    REP(i,0,n) {
        scanf("%lld%lld",k + i,b + i);
    }
    double m;
    REP(i,0,n) {
        REP(j,i + 1,n) {
            if (k[i] == k[j]) continue;
            m = k[i]-k[j];
            cross.insert(make_pair((b[j]-b[i])/m, (k[i]*b[j]-b[i]*k[j])/m));
        }
    }
    if (cross.size()) printf("%lu\n",cross.size());
    else puts("No Fire Point.");
    return 0;
}
*/

/*
inline bool okk(int *ss,int *tt)
{
    int ok = 0;
    rep(i,'a','z') {
        if (ss[i] == tt[i]) continue;
        if (abs(ss[i] - tt[i]) == 1) ok ++;
        else return 0;
    }
    if (ok == 2 || ok == 0) return 1;
    return 0;
}

int main()
{
    string t,s;
    int tt['z' + 10];
    int ss['z' + 10];
    int cnt;
    _T_(T) {
        cin >> s >> t;
        mem(tt,0);
        mem(ss,0);
        for (int i = 0;t[i];i ++) tt[t[i]] ++;
        for (int i = 0;t[i];i ++) ss[s[i]] ++;
        cnt = 0;
        for (int i = 0,j = (int) t.size() - 1;s[j];j ++,i ++) {
            if (i != 0) {
                ss[s[i - 1]] --;
                ss[s[j]] ++;
            }
            if (okk(ss,tt)) cnt ++;
        }
        printf("%d\n",cnt);
    }
    return 0;
}
*/

//
//inline bool hasVis(string str) {
//    int ok = 0;
//    for (int i = 0;str[i];i ++) {
//        if (str[i] != ' ' && str[i] != '\n' && str[i] != '\r') ok = 1;
//    }
//    return ok;
//}
//
//int main()
//{
//    fre("/Users/jackli/思修-课程题库.csv");
//    string str;
//    getline(cin,str);
//    int idx = 0;
//    string k;
//    int x = 1;
//    int st = 0;
//    string d = "";
//    char c = 'A';
//    st = 0;
//    int tab = 0;
//    while (getline(cin, str))
//    {
//        if (!st) {
//            idx = 0;
//            c = 'A';
//        } else {
//            k += "\n";
//            if (tab) k += "\t   ";
//        }
//        for (int i = 0;str[i];i ++) {
//            if (str[i] == '\"') {
//                if (st) tab = 0;
//                st = !st;
//            }
//            else if (str[i] == ',' && !st) {
//                idx ++;
//                if (idx == 6 || idx == 7) {
//                    k = "";
//                    continue;
//                } else if (idx == 4) {
//                    d = "\n【答案】" + k;
//                    k = "";
//                    continue;
//                } else if (idx == 5) {
//                    if (k != "") d += " 解析：" + k;
//                } else if (idx >= 8) {
//                    if (k != "") {
//                        printf("\n\t%c. ",c ++);
//                        cout << k;
//                        tab = 1;
//                    }
//                    k = "";
//                    continue;
//                }
//                if (idx == 2) printf("\n%d.【",x ++);
//                if (k != "") cout << k;
//                if (idx == 2) printf("】");
//
//                k = "";
//            } else {
//                k += str[i];
//            }
//        }
//        if (!st)  {
//            if (hasVis(k)) {
//                printf("\n\t%c.",c ++);
//                cout << k;
//            }
//
//            cout << endl << d << endl;
//        }
//
////        printf(" >>%d\n",idx);
//    }
//    return 0;
//}

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    scanf("%d",&n);
    ll a[1000010];
    READ_ll(a,0,n);
    sort(a,a+n);
    n = (int) (unique(a, a + n) - a);
    vector<ll> k;
    ll mm = -1;
    ll t;
    REP(i,0,n - 1) {
        k.pb(abs(a[i] - a[i + 1]));
    }
    ll l = *k.begin();
    for (auto i = k.begin() + 1;i != k.end();i ++) {
        l = gcd(l,*i);
    }
    if (l == 1 || a[0] % l == 0) mm = 0;
    else {
        mm = -1;
        REP(i,0,n) {
            if (a[i] > 0) t = l - a[i] % l;
            else t = -a[i] % l;
            if (mm == -1 || t < mm) {
                mm = t;
            }
        }
    }
    printf("%lld %lld\n",l,mm);
    return 0;
}
*/


//int main()
//{
//    int n,m,k;
//    int a,b,c;
//
//    _T_(T) {
//        scanf("%d%d%d",&n,&m,&k);
//
//        REP(i,0,k) {
//            scanf("%d%d%d",&a,&b,&c);
//
//        }
//    }
//    return 0;
//}

/*
ll quick_gcd(ll a, ll b)
{
    if(a == 0) return b;
    if(b == 0) return a;
    if(!(a & 1) && !(b & 1)) // a % 2 == 0 && b % 2 == 0;
        return quick_gcd(a >> 1, b >> 1) << 1;
    else if(!(b & 1))
        return quick_gcd(a, b >> 1);
    else if(!(a & 1))
        return quick_gcd(a >> 1, b);
    else
        return quick_gcd(abs(a - b), min(a, b));
}
int main()
{
    ll a,b;
    int i = 1;
    _T_(T) {
        scanf("%lld%lld",&a,&b);
        printf("Case %d: %lld\n",i ++,a / quick_gcd(a, b) * b);
    }
    
    
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    int l = (int) str.size();
    string x;
    string ans = "";
    rep(i,1,l / 3) {
        x = str.substr(0,i);
        if (x != str.substr(l - i)) {
            continue;
        }
        if (str.substr(i,l - i - 1).find(x) != string::npos) {
            
            ans = x;
        }
    }
    cout << ans << endl;
    return 0;
}
*/

/*
int main()
{
    int n,q;
    scanf("%d%d",&n,&q);
    int a[1000010];
    int vis[2000010];
    rep(i,1,n) {
        scanf("%d",a + i);
        vis[a[i]] = 1;
    }
    int k,x,y;
    REP(i,0,q) {
        scanf("%d%d%d",&k,&x,&y);
        if ((a[x] ^ a[y]) == k) printf("1\n");
        else if (a[x] == a[y] && vis[a[x] ^ k]) {
            printf("2\n");
        } else printf("-1\n");
    }
    return 0;
}
*/

/*
class Solution {
public:
    int solve(int n, int m) {
        // write code here
        if (m <= n) return n - m;
        int l = sqrt(m);
        int r = l + 1;
        int x = (m - l * l < r * r - m) ? l : r;
        return min(m - n,solve(n,x) + 1 + abs(m - x * x));
    }
};

int main()
{
    int a,b;
    cin >> a >> b;
    Solution s;
    cout << s.solve(a, b) << endl;
    return 0;
}
*/

/// ---------- 差分模版 ----------

/*
int p[1000] = {0};
int a[1000];
int n;

void pls(int l,int r,int k)
{
    p[l] += k;
    p[r + 1] -= k;
}

void init()
{
//    p[0] = a[0];
//    rep(i,1,n - 1) {
//        p[i] = a[i] - a[i - 1];
//    }
    REP(i,0,n) {
        pls(i,i,a[i]);
    }
}

int main()
{
    scanf("%d",&n);
    
    READ(a,0,n);
    init();
    
    Tprint(p,0,n);
    printf("\n");
    
    int q;
    scanf("%d",&q);
    int l,r;
    while (q --) {
        scanf("%d%d",&l,&r);
        pls(l,r,1);
    }
    
    int s[1000];
    
    s[0] = p[0];
    rep(i,1,n - 1) {
        s[i] = s[i - 1] + p[i];
    }
    
    rep(i,0,n - 1) printf("%d ",s[i]);
    return 0;
}
*/

/// -------- 二维前缀和模版 --------
/*
int main()
{
    int arr[1000][1000] = {0};
    int sum[1000][1000] = {0};
    int n,m;
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        rep(j,1,m) {
            scanf("%d",&arr[i][j]);
        }
    }
    
    rep(i,1,n) {
        rep(j,1,m) {
            printf("%d ",arr[i][j]);
        }
        printf("\n");
    }
    
    puts("");
    
    sum[1][1] = arr[1][1];
//    rep(i,1,m) sum[0][i] = sum[0][i - 1] + arr[0][i];
//    rep(i,1,n) sum[i][0] = sum[i - 1][0] + arr[i][0];
    
    rep(i,1,n) {
        rep(j,1,m) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j];
        }
    }
    
    // sum up
    rep(i,1,n) {
        rep(j,1,m) {
            printf("%d ",sum[i][j]);
        }
        printf("\n");
    }
    
    // obtain
    int q;
    scanf("%d",&q);
    int a,b,x,y;
    while (q --) {
        scanf("%d%d%d%d",&a,&b,&x,&y);
        printf("%d\n",sum[x][y] - sum[a - 1][y] - sum[x][b - 1] + sum[a - 1][b - 1]);
    }
    
    return 0;
}
*/

/// -------------- 二维差分 --------------

/*
int p[1000][1000] = {0};
int a[1000][1000];

void pls(int a,int b,int x,int y,int k)
{
    p[a][b] += k;
    p[x + 1][y + 1] += k;
    p[x][y + 1] -= k;
    p[x + 1][y] -= k;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        rep(j,1,m) {
            scanf("%d",&a[i][j]);
        }
    }
    
    rep(i,1,n) {
        rep(j,1,m) {
            pls(i,j,i,j,a[i][j]);
        }
    }
    
    rep(i,1,n) {
        rep(j,1,m) {
            printf("%d ",p[i][j]);
        }
        printf("\n");
    }
    printf("\n");
    
    int sum[1000][1000] = {0};
    sum[1][1] = p[1][1];
    
    rep(i,1,n) {
        rep(j,1,m) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + p[i][j];
        }
    }
    
    rep(i,1,n) {
        rep(j,1,m) {
            printf("%d ",sum[i][j]);
        }
        printf("\n");
    }
    
    
    return 0;
}

*/

/*
struct A {
    int a,b,x,y;
};

int main()
{
    int n;
    scanf("%d",&n);
    int a,b,x,y;
    
    A k[100010];
    
    rep(i,0,n - 1) {
        scanf("%d%d%d%d",&a,&b,&x,&y);
        k[i] = {a,b,x,y};
    }
    scanf("%d%d",&x,&y);
    int id = -1;
    rep(i,0,n - 1) {
        if (x >= k[i].a && x <= k[i].a + k[i].x && y >= k[i].b && y <= k[i].y + k[i].b) {
            id = i + 1;
        }
    }
    printf("%d\n",id);
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int a,b;
    double sum;
    _T_(T) {
        scanf("%d%d",&n,&m);
        vector<int> chair;
        vector<int> all;
        rep(i,0,n - 1) {
            scanf("%d%d",&a,&b);
            if (b) chair.pb(a);
            all.pb(a);
        }
        sum = 0;
        sort(all.begin(),all.end(),greater<int>());
        for (auto i = all.begin();i != all.end();i ++) sum += *i;
        rep(i,0,min(m - 1,(int) chair.size() - 1)) sum -= all[i] / 2.0;
        printf("%.1f\n",sum);
    }
    return 0;
}
*/

/*
int a[110][110];
int n,m;

int dp[110][110] = {0};

int dfs(int x,int y)
{
    if (n - x > m - y) return 0;
    if (y >= m || x >= n || x < 0) return 0;
    if (dp[x][y]) return dp[x][y];
    int k = 0;
    k = max(k,dfs(x - 1,y + 1));
    k = max(k,dfs(x,y + 1));
    k = max(k,dfs(x + 1,y + 1));
    return dp[x][y] = (k + a[x][y]);
}

int main()
{
    scanf("%d%d",&n,&m);
    rep(i,0,n - 1) {
        rep (j,0,m - 1) {
            scanf("%d",&a[i][j]);
        }
    }
    cout << dfs(0,0) << endl;
    return 0;
}
*/


/// ---------- 求树的重心 ----------
/// 求法：删掉某一个点i，求剩余连通块的节点个数，求出一个w[i]=max(每个连通块的节点个数)，那么所有点中最小的w[i]，那么这个点i便是树的重心

/// 性质：
/// 1. 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。
/// 2. 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。

/// 3. 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。
/// 4. 一棵树最多有两个重心，且相邻

/*
int num,m;

vector<int> g[50010];
int vis[50010] = {0};
//int ch[50010] = {0};
int w[50010] = {0};

int gravity(int n)
{
    if (vis[n]) return 0;
    vis[n] = 1;
    int c = 0;
    int x = -1;
    int t;
    for (auto i : g[n]) {
        c += (t = gravity(i));
        x = max(t,x);
    }
    x = max(x,num - c - 1);
//    ch[n] = c;
    w[n] = x;
    return c + 1;
}

int main()
{
    
    scanf("%d%d",&num,&m);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    
    gravity(1);
//    Tprint(ch,1,num + 1);
//    puts("");
//    Tprint(w,1,num + 1);
//    puts("");
    int m = INT_INF;
    rep(i,1,num) m = min(m,w[i]);
    int f = 1;
    rep(i,1,num) {
        if (m == w[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i);
        }
    }
    puts("");
    
}
*/

/*
const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll a[2000010];

int main()
{
    a[1] = 1;
    rep(i,2,2000010) a[i] = (a[i - 1] * i) % mod;
    int n;
    while (~scanf("%d",&n)) {
        printf("%lld\n",quickpow(((a[2 * n + 1] * quickpow(a[n], mod - 2)) % mod) * quickpow(a[n], mod - 2) % mod,mod - 2));
    }
    return 0;
}
*/


/*
int main()
{
    int h,m,s;
    int hh,mm,ss;
    scanf("%d:%d:%d",&h,&m,&s);
    scanf("%d:%d:%d",&hh,&mm,&ss);
    ll a = s + m * 60 + h * 60 * 60;
    ll b = ss + mm * 60 + hh * 60 * 60;
    printf("%lld\n",abs(a-b));
    return 0;
}
*/

//ll cal(ll x,ll y,ll a,ll b) {
//    return (x - a) * (x - a) + (y - b) * (y - b);
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int x[2010],y[2010];
//    set<int> xx,yy;
//    rep(i,1,n) {
//        scanf("%d%d",x + i,y + i);
//        xx.insert(x[i]);
//        yy.insert(y[i]);
//    }
//
//    ll s = -1;
//    ll mm = -1;
//    ll m = -1;
//    ll k;
//    rep(i,1,n) {
//        s = -1;
//        mm = -1;
//        rep(j,1,n) {
//            if (i == j) continue;
//
//            k = cal(x[i],y[i],x[j],y[j]);
////            printf("...%lld,%d,%d\n",k,i,j);
//            if (k > mm) {
//                mm = k;
//                s = 1;
//            } else if (k == mm) {
//                s ++;
//            }
////            printf(">>%lld\n",s);
//            m = max(m,s);
//        }
//    }
//    printf("%lld\n",xx.size() == 1 && yy.size() == 1 ? n : m);
//    return 0;
//}

//using namespace std;
//const int maxm = 5e3+2;
//const int maxn = 5e3+2;
//
//int a, b, n,logn;
////int grid[maxm][maxm];
//int maxv[maxm][maxm];
//int gcd(int a,int b)
//{
//    return b==0?a:gcd(b,a%b);
//}
//
//int query (int x, int y){
//    int _max = 0;
//    _max = max(maxv[x][y],
//               max(maxv[x+n-(1<<logn)][y+n-(1<<logn)],
//                   max(maxv[x+n-(1<<logn)][y],
//                       maxv[x][y+n-(1<<logn)])));
//    return _max;
//}
//
//int main()
//{
//    scanf("%d %d %d",&a,&b,&n);
//    for (int i = 0; i < a; i++)
//        for (int j = 0; j < b; j++) {
//            maxv[i][j] = (i + 1) * (j + 1) / gcd(i + 1,j + 1);
//        }
//
//    for (logn = 0;(1 << (logn + 1)) <= n;logn ++);
//
//    for (int k = 0;k < logn;k ++)
//        for (int i = 0;i + (1 << k) < a;i ++)
//            for (int j = 0;j + (1 << k) < b;j ++) {
//                maxv[i][j] = max(maxv[i][j], max(maxv[i+(1<<k)][j+(1<<k)], max(maxv[i+(1<<k)][j], maxv[i][j+(1<<k)])));
//            }
//
//    long long sum=0;
//    for (int i = 0; i <= a-n; i++)
//        for (int j = 0; j <= b-n; j++)
//            sum += query(i,j);
//
//   printf("%lld\n",sum);
//    return 0;
//}

/*
const int MAXN = 200010;

vector<int> g[MAXN];

int n;

int root = 1;
int min_w = -1;
int vis[MAXN] = {0};

int gravity(int s)
{
    if (vis[s]) return 0;
    vis[s] = 1;
    int c = 0;
    int x = -1;
    int t;
    for (auto i : g[s]) {
        c += (t = gravity(i));
        x = max(t,x);
    }
    x = max(x,n - c - 1);
    
    if (min_w == -1 || x < min_w) {
        min_w = x;
        root = s;
    }
    
    return c + 1;
}

vector<int> l;

void dfs(int s)
{
    if (vis[s]) return;
    vis[s] = 1;
    
    if (g[s].size() == 1) {
        // leave
        l.pb(s);
    }
    for (auto i : g[s]) {
        dfs(i);
    }
    
}

int main()
{
    
    scanf("%d",&n);
    int u,v;
    rep(i,1,n - 1) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    
    gravity(1);
    
//    printf(">>%d\n",root);
    
    mem(vis,0);
    dfs(root);
    
    int k = (int) l.size();
    int t = k / 2;
    int md = 0;
    if (k & 1) md = k / 2 + 1;
    else md = k / 2;
    
    vector<pair<int,int>> w;
    for (int i = 1;i <= md;i ++){
        int tt = t + i;
        if(tt > k) tt = k;
        w.push_back(make_pair(l[i - 1],l[tt - 1]));
    }
    printf("%lu\n",w.size());
    for(auto it : w){
        printf("%d %d\n",it.first,it.second);
    }
    
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[10010];
    read(a,1,n);
    priority_queue<pair<int,int>,vector<pair<int, int>>,greater<pair<int, int>>> q;
    q.push(make_pair(a[1],1));
    int b[10010] = {0};
    rep(i,2,n) {
        while (!q.empty() && a[i] > q.top().first) {
            b[q.top().second] = i;
//            printf(">>%d %d\n",q.top().second,i);
            q.pop();
        }
        q.push(make_pair(a[i], i));
    }
    int f = 1;
    rep(i,1,n) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",b[i]);
    }
    printf("\n");
    return 0;
}
*/

/*
ll a[1000010];
int vis[1000010] = {0};

int main()
{
    int n;
    scanf("%d",&n);
    read_ll(a,1,n);
    ll x = 0;
    
    pre(i,n,1) {
        if (a[i] < 0) {
            x += a[i] * i;
            vis[i] = 1;
        }
    }
    rep(i,0,n) {
        if (vis[i]) continue;
        x += a[i];
    }
    printf("%lld\n",x);
    return 0;
}
*/

/// ST表
/*
inline int read_int()
{
    int x = 0,f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}

const int MAXN = 100010;

int st[MAXN][20];
int a[MAXN];

int n,m;

void init() {
    // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
    rep(i,1,n) st[i][0] = a[i];

    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); // 套公式
        }
    }
}

int query(int l, int r)
{
    int x = log2(r - l + 1);
    return max(st[l][x],st[r - (1 << x) + 1][x]);
}

int main()
{
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        a[i] = read_int();
    }
    init();
    int l,r;
    while (m --) {
        scanf("%d%d",&l,&r);
        printf("%d\n",query(l, r));
    }
    return 0;
}
*/


/*class Solution {
public:
    
    ll dfs(int n,int m,ll f)
    {
        if (n == 0) {
            if (m == 0) {
//                printf("%lld\n",f);
                return f;
            }
            return 0;
        }
        ll s = 0;
        for (int i = 0;m - i >= 0 && i <= 9;i ++) {
            if (f == 0 && i == 0) continue;
            s += dfs(n - 1,m - i,f * 10 + i);
        }
        return s;
    }
    
    long long sum(int n, int m) {
        // write code here
        return dfs(n,m,0);
    }
};


int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    Solution s;
    cout << s.sum(n, m) << endl;
    return 0;
}
*/

/*
class Solution {
public:
    
    vector<int> g[100010];
    int f[100010];
    
    
    void dfs(int n,int fa)
    {
        f[n] = fa;
        for (auto i : g[n]) {
            if (i == fa) continue;
            dfs(i,n);
        }
    }
    
    ll ans(int x,ll y) {
        ll a = 0;
        do {
            a += (y + 2 * x) ^ (y + x);
            a %= 998244353;
            x = f[x];
        } while (x != -1);
        return a;
    }
    
    
    long long work(int n, long long seed1, long long seed2, long long seed3, int x) {
        // write code here
        int seed4;
        int u,v;
        rep(i,1,n-1) {
            seed4=(seed1+seed2)%998244353*seed3%998244353;
            u=i+1;
            v=(seed4%i)+1;
            g[u].pb(v);
            g[v].pb(u);
            seed3=seed2;
            seed2=seed1;
            seed1=seed4;
        }
        
        mem(f,-1);
        dfs(1,-1);
        
        ll lastans = 0,
        ret = 0,
        y = 0,z;
        ll xx = 0;
        rep(i,1,n) {
            xx += (z=ans(x,y));
            xx %= 998244353;
            ret = (ret + z) % 998244353;
            lastans = z;
            x = ((x + lastans) ^ ret) % n + 1;
            y = lastans;
        }
        return xx;
    }
};

int main()
{
    ll n,a,b,c,d;
    cin >> n >> a >> b >> c >> d;
    Solution s;
    cout << s.work(n, a, b, c, d) << endl;
    return 0;
}
*/




//
//class Solution {
//public:
//
//    int n;
//    vector<int> a;
//    int k;
//
//    bool check(int m)
//    {
//        ll d = 0;
//        for (auto i : a) {
//            if (i > m) d += ceil((i - m) / (double) (k - 1));
//        }
//        return d <= m;
//    }
//
//    int solve(int n, vector<int>& a, int k) {
//        // write code here
//        this -> n = n;
//        this -> a = a;
//        this -> k = k;
//        int l = 1;
//        int r = 0;
//        for (auto i : a) if (i > r) r = i;
//        int m;
//        while (l < r) {
//            m = (l + r) / 2;
//            if (check(m)) r = m;
//            else l = m + 1;
//        }
//        return l;
//    }
//};
//
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    vector<int> a;
//    int x;
//    while (n --) {
//        scanf("%d",&x);
//        a.pb(x);
//    }
//    int k;
//    scanf("%d",&k);
//    Solution s;
//    cout << s.solve(n, a, k) << endl;
//    return 0;
//}
//

/*
int main()
{
    int n;
    ll k,b;
    scanf("%d%lld%lld",&n,&k,&b);
    ll x,y;
    while (n --) {
        scanf("%lld%lld",&x,&y);
        if (y == k * x + b) puts("Yes");
        else puts("No");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    string str;
    cin >> str;
    int x = 1;
    set<string> a;
    string sub;
    int ok = 1;
    rep(i,1,n) { // len
        a.clear();
        ok = 1;
        for (int j = 0;str[j + i - 1];j ++) { // pos
            if (a.find(sub = str.substr(j,i)) == a.end()) a.insert(sub);
            else {
                ok = 0;
                break;
            }
        }
        if (ok) {
            x = i;
            break;
        }
    }
    printf("%d\n",x);
    return 0;
}
*/



//vector<pair<int, int>> g;
//
//ll ans = -1;
//
//ll dis(ll x1,ll y1,ll x2,ll y2) {
//    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
//}
//
//void dfs(ll d,int x,int y,ll k)
//{
//    if (ans == -1 || ans < k) ans = k;
//    ll t;
//    for (auto i : g) {
//        if (((t = dis(x,y,i.first,i.second)) < d || d == -1) && !(i.first == x && i.second == y)) {
//            dfs(t,i.first,i.second,k + 1);
//        }
//    }
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int u,v;
//    while (n--) {
//        scanf("%d%d",&u,&v);
//        g.pb(make_pair(u,v));
//    }
//    dfs(-1,0,0,0);
//    printf("%lld\n",ans);
//    return 0;
//}


//
//const int MAXN = 10000010;
//
//
//int a[MAXN];
//int query[2][MAXN];
//
//int n,m;
//
//
//void dd(int k,int m)
//{
//    int q[MAXN];
//    int i,j;
//    int front,rear;
//    front=0;
//    rear=-1;
//    for(i=1;i<=k;i++)
//    {
//        for(;front<=rear&&a[i]>=a[q[rear]];rear--);
//        q[++rear]=i;
//    }
//    int idx = 1;
//    query[m][idx ++] = a[q[front]];
//    for(j=1;i<=n;i++,j++)
//    {
//        if(front<=rear&&q[front]<=j)
//            front++;
//        for(;front<=rear&&a[i]>=a[q[rear]];rear--);
//        q[++rear]=i;
//        query[m][idx ++] = a[q[front]];
//    }
//}
//
//int main()
//{
//    int k;
//    scanf("%d%d",&n,&k);
//    read(a,1,n);
//    ll all = 0,ans = 0;
//
//    int v = n % k;
//
//    dd(k,0);
//    dd(v,1);
//
//
//    if (v == 0) {
//
//        for (int i = 1;i + k - 1 <= n;i += k) {
//            ans += query[0][i];
//        }
//        printf("%lld\n",ans);
//        return 0;
//    }
//
//
//    all += query[1][1];
//    for (int i = v + 1;i + k - 1 <= n;i += k) {
//        all += query[0][i];
//    }
//    ans = all;
//
//    for (int i = 1 + k;i + v - 1 <= n;i += k) {
////        printf("sub:[%d,%d]\n    [%d,%d]\n",i - k, i - k + v - 1,i - k + v, i + v - 1);
////        printf("add:[%d,%d]\n    [%d,%d]\n",i - k, i - 1,i, i + v - 1);
//        all -= query[1][i - k];
//        all -= query[0][i - k + v];
//        all += query[0][i - k];
//        all += query[1][i];
//        ans = max(ans,all);
//    }
//
//    printf("%lld\n",ans);
//
//    return 0;
//}


//int a[5010][5010];
//
//int gcd(int a,int b)
//{
//    if (a % b == 0) return b;
//    return gcd(b, a % b);
//}
//
//int main()
//{
//    int n,m,k;
//    scanf("%d%d%d",&n,&m,&k);
//
//
//
//    rep(i,1,n) {
//        rep(j,1,m) {
//            a[i][j] = i / gcd(i,j) * j;
//            printf("%4d",a[i][j]);
//        }
//        printf("\n");
//    }
//
//    return 0;
//}

/*
int main()
{
    string str;
    cin >> str;
    string x = str.substr(0,6);
    for (int i = 0;x[i];i ++) {
        if (x[i] >= 'A' && x[i] <= 'Z') x[i] = x[i] - 'A' + 'a';
    }
    
    if (x == "lovely") puts("lovely");
    else puts("ugly");
    
    return 0;
}
*/

/*
int main()
{
    string str;
    cin >> str;
    char c;
    int x = 0;
    int n;
    int s = (int) str.size();
    _T_(T) {
        scanf(" %c %d",&c,&n);
        if (c == 'A') {
            printf("%c\n",str[(x + n - 1) % s]);
        } else if (c == 'M') {
            
            if (n < 0) {
                n = s + n;
            }
            x = (x + n) % s;
        }
    }
    return 0;
}
*/

/*
int main()
{
    double x[30],y[30];
    double p;
    _T_(T){
        for(int i = 0; i < 20; i++){
            scanf("%lf %lf", x+i, y+i);
        }
        int i1=0,i2=1;
        

        for(int i = 0; i < 20; i++){
            p = (x[(i - 1 + 20) % 20] - x[i]) * (x[(i - 1 + 20) % 20] - x[i])+
                (y[i] - y[(i - 1 + 20) % 20]) * (y[i] - y[(i - 1 + 20) % 20]);
            if(fabs(p - 81) <= 0.1){
                i1=i;
                i2=(i - 1 + 20) % 20;
                break;
            }
        }

        double d1 = (x[(i1 + 1) % 20] - x[i1]) * (x[(i1 + 1) % 20] - x[i1]) +
                    (y[(i1 + 1) % 20] - y[i1]) * (y[(i1 + 1) % 20] - y[i1]);
        double d2 = (x[(i2 - 1 + 20) % 20] - x[i2]) * (x[(i2 - 1 + 20) % 20] - x[i2]) +
                    (y[(i2 - 1 + 20) % 20] - y[i2]) * (y[(i2 - 1 + 20) % 20] - y[i2]);
        
        int i3;

        if(d1<d2){
            i3 = (i2 - 1 + 20) % 20;
            swap(i1,i2);
        } else {
            i3=(i1 + 1) % 20;
        }
        
        double x1,x2,y1,y2;
        x1=x[i3]-x[i1];
        y1=y[i3]-y[i1];
        x2=x[i2]-x[i1];
        y2=y[i2]-y[i1];
        p = x1*y2-x2*y1;
        
        if(p>0) printf("right\n");
        else printf("left\n");
    }

    return 0;
}
*/

/*
class Solution {
public:
    const int mod = 998244353;
 
    int work(long long n) {
        // write code here
        ll ans = 0;
        ll x,k;
        for (ll i = 1;i <= n;) {
            x = n / i;
            k = n / x + 1;
            ans = (ans + ((x % mod) * ((k - i) % mod)) % mod) % mod;
            i = k;
        }
        return (int) ans;
    }
};

int main()
{
    ll n;
    scanf("%lld",&n);
    Solution s;
    cout << s.work(n) << endl;
    return 0;
}
*/


/*
class Solution {
public:
    
    int w[300010];
    
    ll ans = 0;
    
    void dfs(int n,int f)
    {
        if (w[n] == -1) return;
        ans += w[n] ^ f;
        dfs(n * 2,w[n]);
        dfs(n * 2 + 1,w[n]);
    }
    
    long long tree1(vector<int>& a) {
        // write code here
        mem(w,-1);
        int idx = 1;
        for (auto i : a) w[idx ++] = i;
        dfs(1,w[1]);
        return ans;
    }
};

int main()
{
    Solution s;
    vector<int> a;
    int n;
    scanf("%d",&n);
    int t;
    rep(i,1,n) {
        cin >> t;
        a.pb(t);
    }
    cout << s.tree1(a) << endl;
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int x,y;
    int mm = -1;
    int xx,yy;
    _T_(t) {
        scanf("%d%d",&n,&m);
        mm = -1;
        xx = 0;
        yy = 0;
        while (n --)
        {
            scanf("%d%d",&x,&y);
            xx = 0;
            yy = 0;
            int k = m / x;
            if (m % x) k ++;
            yy = y * k;
            if (mm == -1 || mm > yy) mm = yy;
        }
        printf("%d\n",mm);
    }
        
    return 0;
}
*/

/*
double ans = 0;

void dfs(double s,int n,int k)
{
    if (k == 4) {
        ans = max(s,ans);
        return;
    }
    if (n >= 95) dfs(s + 4.3,n - 95,k + 1);
    if (n >= 90) dfs(s + 4.0,n - 90,k + 1);
    if (n >= 85) dfs(s + 3.7,n - 85,k + 1);
    if (n >= 80) dfs(s + 3.3,n - 80,k + 1);
    if (n >= 75) dfs(s + 3.0,n - 75,k + 1);
    if (n >= 70) dfs(s + 2.7,n - 70,k + 1);
    if (n >= 67) dfs(s + 2.3,n - 67,k + 1);
    if (n >= 65) dfs(s + 2.0,n - 65,k + 1);
    if (n >= 62) dfs(s + 1.7,n - 62,k + 1);
    if (n >= 60) dfs(s + 1.0,n - 60,k + 1);
    if (n >= 0) dfs(s,n,k + 1);
    
    
    
}

int main()
{
    int n;
    _T_(T) {
        scanf("%d",&n);
        dfs(0,n,0);
        printf("%.1f\n",ans);
        
        
        
    }
    
    
    return 0;
}

*/

/*
int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

const int MAXN = 1000;
int dp[MAXN + 10][MAXN + 10] = {0};

int main()
{
    rep(i,1,MAXN) {
        rep(j,1,MAXN) {
            dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);
            if (gcd(i,j) == 1) dp[i][j] ++;
        }
    }
    int a,b;
    _T_(T) {
        scanf("%d%d",&a,&b);
        printf("%d\n",dp[a][b]);
    }
    return 0;
}
*/

/*
int a[510][510];
int b[10];
int n,x,y;
int h;

int ans = INT_INF;

void go(int i,int j)
{
    rep(ii,-3,3)
    {
        rep(jj,-3 + abs(ii),3 - abs(ii))
        {
            if (ii == 0 && jj == 0) continue;
            if (i + ii >= 1 && i + ii <= n &&
                j + jj >= 1 && j + jj <= n)
                b[a[i + ii][j + jj]] ++;
        }
    }
    
    int step;
    int c = 1;
    int crt = a[i][j]; // current citizen
    int food = 0;
    while (c != 9)
    {
        if (c == 9) break;
        food += crt;
        if (food >= 8 * c * c)
        {
            step = 3;
            // move
            while (step != 0)
            {
                if (b[step] != 0)
                {
                    crt += step;
                    b[step] --;
                    break;
                }
                step --;
            }
            c ++;
        }
        h ++;
    }
    ans = min(ans, h);
}

void solve()
{
    scanf("%d%d%d",&n,&y,&x);
    rep(i,1,n) {
        rep(j,1,n) {
            scanf("%d",&a[i][j]);
        }
    }
    int l;
    rep(i,1,n) {
        rep(j,1,n) {
            l = abs(j - x) + abs(i - y);
            h = l / 2;
            h += l % 2;
            go(i,j);
        }
    }
    printf("%d\n",ans);
}

int main()
{
    _T_(T) {
        ans = INT_INF;
        mem(b,0);
        solve();
    }
    return 0;
}
*/

//
//const int mod = 1000000007;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//
//ll a[100];
//
//int main()
//{
//    int n;
//    ll x = quickpow(4,mod - 2);
//    _T_(T) {
//        scanf("%d",&n);
//        REP(i,0,n) {
//            scanf("%lld",a + i);
//        }
//        ll ans = a[0] / 2;
//        REP(i,0,n - 1) {
//            ans += ((a[i] * a[i + 1] % mod) *
//                    (mod + x * (quickpow(a[i],mod - 2) - quickpow(a[i + 1],mod - 2)) % mod)) % mod;
//            ans %= mod;
//        }
//        printf("%lld\n",ans);
//    }
//    return 0;
//}


//
//const int mod = 1000000007;
//int main()
//{
//    ll n;
//    ll k,ans;
//    _T_(t) {
//        scanf("%lld",&n);
//        ans = 1;
//        rep(i,2,sqrt(n)) {
//            if (n % i == 0) {
//                k = 1;
//                while (n % i) {
//                    n /= i;
//                    k = (k * i) % mod;
//                }
//                ans = (ans * ((k + 1) % mod)) % mod;
//            }
//        }
//        printf("%lld\n",ans);
//    }
//    return 0;
//}
//
//

/// 欧几里得扩展exgcd
/// ax + by = gcd(a,b)

/*
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll r = exgcd(b, a % b, x, y);
    ll t = y;
    y = x - (a / b) * y;
    x = t;
    return r;
}

int gcd(int a,int b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

const int MAXN = 2000010;

int not_zhi[MAXN] = {0};

int main()
{
    rep(i,2,MAXN) {
        for (int j = i + i;j <= MAXN;j += i) {
            not_zhi[j] = 1;
        }
    }
    vector<int> zhi;
    rep(i,2,MAXN) if (!not_zhi[i]) zhi.pb(i);
    
    int a,b,g;
    ll c,d,e,f;
    _T_(T)
    {
        scanf("%d%d",&a,&b);
        g = gcd(a, b);
        if (g != 1) {
            // u = a / g;
            // v = b / g;
            // a / b = u / v;
            // ((u + 1) - 1) / v = u / v = a / b
            printf("%d %d %d %d\n",a / g + 1,b / g,1,b / g);
        } else if (g == 1) {
            if (!not_zhi[b]) printf("-1 -1 -1 -1\n");
            else {
                d = 1;
                f = 1;
                for (auto i : zhi) {
                    if (b % i == 0) {
                        while (b % i == 0) {
                            d *= i;
                            b /= i;
                        }
                        f = b;
                        break;
                    }
                }
//                cout << d << " " << f << endl;
                if (d == 1 || f == 1) printf("-1 -1 -1 -1\n");
                else {
                    exgcd(f, d, c, e);
                    e = -e;
                    // 在理解下
                    while(c <= 0 || e <= 0){
                        c += d ;
                        e += f ;
                    }
                    printf("%lld %lld %lld %lld\n",c*a,d,e*a,f);
                }
            }
        }
    }
    
    return 0;
}
*/

/*
const int mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

const int MAXN = 1000010;
int a[MAXN] = {0};
int num[MAXN];

int main()
{
    rep(i,1,MAXN) num[i] = i;
    rep(i,2,MAXN) {
        for (int j = i + i;j <= MAXN;j += i) {
            while (num[j] % i == 0) {
                num[j] /= i;
                a[j] ++;
            }
        }
    }
    rep(i,1,MAXN) if (a[i] == 0) a[i] ++;
    
    int c,n;
    _T_(T){
        scanf("%d%d",&n,&c);
        if (n == 1) {
            printf("1\n");
            continue;
        }
        printf("%lld\n",quickpow(c, a[n]));
    }
    return 0;
}*/

/*
const int MAXN = 2e5+10;
char a[MAXN];
bool vis[MAXN];
bool vis2[MAXN];

int n,s;

int main()
{
    mem(a,1);
    a[1] = 0;
    
    _T_(T) {
        s = 0;
        scanf("%d",&n);
        memset(vis, 0, sizeof(bool) * (n + 10));
        memset(vis2, 0, sizeof(bool) * (n + 10));
        int cnt;
        vector<pair<int, int>> ans;
        int f;
        rep(i,2,n) {
            if (!a[i]) continue;
            if (i * 2 > n) break;
            cnt = 1;
            for (int j = i + i;j <= n;j += i) {
                a[j] = 0;
                if (!vis[j]) {
                    cnt ++;
                    if (i != 2) vis[j] = 1;
                }
            }
            if (i != 2) {
                f = -1;
                if (cnt % 2) vis2[i + i] = 1;
                for (int j = i;j <= n;j += i) {
                    if (!vis2[j]) {
                        if (f == -1) {
                            f = j;
                        } else {
                            ans.pb(make_pair(f, j));
                            f = -1;
                        }
                        vis2[j] = 1;
                    }
                }
                if (cnt % 2) vis2[i + i] = 0;
            }
        }
        f = -1;
        for (int i = 2;i <= n;i += 2) {
            if (!vis2[i]) {
                if (f == -1) {
                    f = i;
                } else {
                    ans.pb(make_pair(f, i));
                    f = -1;
                }
            }
        }
        printf("%lu\n",ans.size());
        for (auto i : ans) printf("%d %d\n",i.first,i.second);
    }
}
*/

//int main()
//{
//    string s;
//    cin >> s;
//    string t;
//    set<string> all;
//    char mx;
//    for (int i = 0; s[i]; i ++) {
//        t = "";
//        for (int j = i; s[j]; j ++) {
//            if (j == i) mx = s[j];
//            else mx = max(mx,s[j]);
//            t += mx;
//            cout << t << endl;
//            all.insert(t);
//        }
//    }
//    printf("%lu\n", all.size());
//    return 0;
//}





//const int MAXN = 8e5 + 10;
//
//// ----- begin of 并查集 -----
//int af[MAXN];
//int d[MAXN];
//
//int find(int a)
//{
//    if (af[a] == a) return a;
//    return af[a] = find(af[a]);
//}
//
//inline void bind(int a,int b)
//{
//    int x = find(a), y = find(b);
//    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
//        af[y] = x; // 改变b节点的根的根为a的根
//        if (d[x] == d[y]) { // 俩根深度一样
//            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
//        }
//    } else af[x] = y;
//}
//
//void init(int n)
//{
//    REP(i,0,n) {
//        af[i] = i;
//        d[i] = 1;
//    }
//}
//// ----- end of 并查集 -----
//
//struct Node {
//    int n;
//    struct Node *nxt;
//};
//
//struct Link {
//    struct Node *root;
//    struct Node *end;
//} link[MAXN];
//
//void add_node(int i,int n)
//{
//    struct Node *node = new struct Node();
//    node -> n = n;
//    node -> nxt = NULL;
//    if (link[i].root == NULL) {
//        link[i].root = node;
//        link[i].end = node;
//    } else {
//        link[i].end -> nxt = node;
//        link[i].end = node;
//    }
//}
//
//vector<int> g[MAXN];
//int vis[MAXN];
//
//void dfs_link(int n)
//{
//    if (vis[n]) return;
//    vis[n] = 1;
//    for (auto i : g[n]) {
//        add_node(n, i);
//        dfs_link(i);
//    }
//}
//
//void link_init(int n)
//{
//    REP(i,0,n) {
//        link[n].root = NULL;
//        link[n].end = NULL;
//    }
//    memset(vis,0,sizeof(int) * (n + 5));
//    REP(i,0,n) dfs_link(i);
//}
//
//int main()
//{
//    int n,m;
//    int u,v;
//    int q;
//    int o;
//    Node *node,*t;
//    _T_(T) {
//        scanf("%d%d",&n,&m);
//        init(n + 5);
//        REP(i,0,m) {
//            scanf("%d%d",&u,&v);
//            g[u].pb(v);
//            g[v].pb(u);
//        }
//
//        link_init(n);
//
//
//
//        scanf("%d",&q);
//        REP(i,0,q) {
//            scanf("%d",&o);
//            node = link[i].root;
//            while (node != NULL) {
//                // printf("%d ",node -> n);
//
//
//
//
//
//                t = node -> nxt;
//                delete node;
//                node = t;
//            }
//        }
//    }
//    return 0;
//}


/*
ll mod;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n;
    int k;
    const int MAXN = 1e6;
    ll f[MAXN];
    f[0] = 0;
    f[1] = 1;
    rep(i,2,MAXN-1) {
        f[i] = f[i - 1] + f[i - 2];
    }
    while (1) {
        scanf("%d%d",&n,&k);
        mod = f[n-1] * f[n-1];
        printf("%lld %lld\n",f[k*(n - 1)+1]%mod,quickpow(f[n], k));
    }
    return 0;
}
*/

/*
int main()
{
    int l = 2;
    int x;
    while (~scanf("%d",&x)) {
        l = 2;
        if (x == 1) l ++;
        else if (x == 7) l --;
        rep(i,1,9) {
            scanf("%d",&x);
            if (x == 1) l ++;
            else if (x == 7) l --;
            if (l < 0) l = 0;
            if (l > 6) l = 6;
        }
        if (l == 6) puts("666");
        else puts("777");
    }
    
    return 0;
}
*/

/*
int main()
{
    ll m,n;
    scanf("%lld%lld",&m,&n);
    ll k;
    _T_(T) {
        scanf("%lld",&k);
        if (k > m) {
            puts("0");
            continue;
        }
        printf("%lld\n",n/m);
    }
    return 0;
}
*/


//int a[1010],vis[1010] = {0};
//int k[1010] = {0};
//int m = 0;
//
//vector<int> g[1010];
//
//
//void dfs(int n,int d) {
//    if (vis[n]) return;
//    if (d > m) m = d;
//    vis[n] = 1;
//    k[d] += a[n];
//    for (auto i : g[n]) {
//        dfs(i,d + 1);
//    }
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    rep(i,1,n) {
//        scanf("%d",a + i);
//    }
//    int u,v;
//    REP(i,1,n) {
//        scanf("%d%d",&u,&v);
//        g[u].pb(v);
//        g[v].pb(u);
//    }
//    dfs(1,0);
//    int ok = 0;
//    rep(i,0,m) {
////        printf("%d\n",k[i]);
//        if ((ok = (k[i] & 1))) break;
//    }
//    if (ok) puts("First");
//    else puts("Second");
//    return 0;
//}


// dij + dp + 分层

/*
const int MAXN = 1e5 + 10;

struct ST {
    int n;
    double w;
    int s;

    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

double dis[MAXN][3];
int vis[MAXN][3];
vector<ST> g[MAXN];


void dij(int s) {
    rep(i,1,MAXN) dis[i][0] = dis[i][1] = dis[i][2] = -1;
    mem(vis,0);
    
    
    priority_queue<ST> q;
    q.push({s,dis[s][0] = 0,0});
    
    inr step;
    
    ST current;
    double k,cost;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        
        if (vis[current.n][current.s]) continue;
        vis[current.n][current.s] = 1;
        
        for (auto to : g[current.n]) {
            
            cost = to.w;
            REP(i,0,current.s % 3) {
                cost = 1 / (1 - cost);
            }
            cost = fabs(cost);
            
            step = (current.s + 1) % 3;
            
            k = dis[current.n][current.s] + cost;
            if (dis[to.n][step] == -1 || dis[to.n][step] > k) {
                q.push({to.n,dis[to.n][step] = k,step});
            }
        }
    }
}


int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v,d;
    while (m --) {
        scanf("%d%d%d",&u,&v,&d);
        g[u].pb({v,(double)d});
        g[v].pb({u,(double)d});
    }
    dij(1);
    
    
    double ans = -1;
    for (int i = 0;i < 3;i ++) {
        if (dis[n][i] == -1) continue;
        
        if (ans == -1) ans = dis[n][i];
        else ans = min(ans,dis[n][i]);
    }
    
    if (ans == -1) printf("-1\n");
    else printf("%.3f\n",ans);
    return 0;
}
*/

/*
map<string,int> k;

string trim(string str) {
    string f;
    int ok = 0;
    for (int i = 0;str[i];i ++) {
        if (!ok) {
            if (str[i] != ' ' && str[i] != '\n' && str[i] != '\r' && str[i] != '\b') {
                f += str[i];
                ok = 1;
            }
        } else f += str[i];
        
    }
    
    if (f.size() != 0)
    while (*(f.end() - 1) == ' ' || *(f.end() - 1) == '\n' || *(f.end() - 1) == '\r' || *(f.end() - 1) == '\b') f.erase(f.end() - 1);
    return f;
}

void find(string name,int l)
{
    name = trim(name);
    if (k.find(name) != k.end()) {
        cout << "重复了，名字：" << name << "，序号：";
        printf("%d %d\n",k[name],l + 1);
    } else k[name] = l + 1;
}


int main()
{
    fre("/Users/jackli/Downloads/本部查重.csv");
    string line;
    int d;
    
    string name;
    int l = 0;
    while (getline(cin,line)) {
        d = 0;
        for (int i = 0;line[i];i ++) {
            if (line[i] == ',') {
                d ++;
                if (d == 7) {
                    find(name, l);
                    name = "";
                }
            }
            else if (d == 6) {
                name += line[i];
            } else if (d == 8) {
                if (line[i + 1] && line[i + 2] && line[i] == '\343' && line[i + 1] == '\200' && line[i + 2] == '\201') {
                    find(name,l);
                    name = "";
                    i += 2;
                } else name += line[i];
            }
        }
        find(name,l);
        name = "";
        l ++;
    }
    return 0;
}
*/

/*
class Solution {
public:
    set<int> k;
    
    void init() {
        rep(i,1,10000) {
            k.insert((i * i) % 1000);
        }
    }
    
    bool solve(int x) {
        // write code here
        init();
        return k.find(x) != k.end();
    }
};

int main()
{
    Solution s;
    int x;
    scanf("%d",&x);
    cout << s.solve(x) << endl;
    return 0;
}
*/

/*
const int MAXN = 2000010;
ull f[MAXN + 10];

int main()
{
    int n1,n2,n3;
    f[1] = 1;
    f[2] = 2;
    rep(i,3,MAXN) {
        f[i] = f[i - 1] + f[i - 2];
    }
    int t,i;
    ull A,B,C;
    _T_(T) {
        A = 0;
        B = 0;
        C = 0;
        scanf("%d",&n1);
        rep(i,1,n1) {
            scanf("%d",&t);
            A += t * f[i];
        }
        scanf("%d",&n2);
        rep(i,1,n2) {
            scanf("%d",&t);
            B += t * f[i];
        }
        A *= B;
        scanf("%d",&n3);
        rep(i,1,n3) {
            scanf("%d",&t);
            C += t * f[i];
            
        }
        for (i = 1;i <= n3 && C + f[i] != A;i ++);
        printf("%d\n",i);
        
    }
    return 0;
}
*/


/*const int MAXN = 1e5 + 10;
int n,m;
vector<int> g[MAXN];

int vis[MAXN];
int vis2[MAXN];
int cost[MAXN];
int a[MAXN];
pair<int,int> b[MAXN];

void dfs(int x)
{
//    printf("%d\n",x);
    vis[x] = 1;
    for (auto i : g[x]) {
        if (!vis[i]) {
            if (a[x] >= a[i]) {
                dfs(i);
            } else {
                cost[i] = max(cost[i],a[x]);
//                printf("//%d\n",cost[i]);
            }
        }
    }
}

ll ans;


int main()
{
    int u,v;

    _T_(T) {
        ans = 0;
        scanf("%d%d",&n,&m);
        memset(vis, 0, sizeof(int) * (n + 5));
        memset(vis2, 0, sizeof(int) * (n + 5));
        memset(cost, 0, sizeof(int) * (n + 5));

        rep(i,1,n) {
            scanf("%d",a + i);
            b[i].first = a[i];
            b[i].second = i;
        }

        sort(b + 1,b + 1 + n);

        ans = 0;

        rep(i,1,m) {
            scanf("%d%d",&u,&v);
            g[u].pb(v);
            g[v].pb(u);
        }

        pre(i,n,1) {
//            printf("%d ",b[i].second);
            if (!vis[b[i].second]) {
                ans += b[i].first;
                dfs(b[i].second);
            }
        }






        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int a[MAXN];
vector<int> g[MAXN];
int vis[MAXN];

ll dij(int n)
{
    pair<int, int> f;
    ll ans = 0;
    
    priority_queue<pair<int,int>> q;
    
    q.push(make_pair(a[n], n));
    ans += a[n];
    while (!q.empty()) {
        f = q.top();
        q.pop();
        if (vis[f.second]) continue;
        vis[f.second] = 1;
        
        if (a[f.second] > f.first) ans += a[f.second] - f.first;
        
        for (auto i : g[f.second]) {
            if (!vis[i]) q.push(make_pair(a[f.second], i));
        }
        
    }
    return ans;
}

int main()
{
    int n,m;
    int u,v;
    ll ans = 0;
    
    _T_(T) {
        ans = 0;
        scanf("%d%d",&n,&m);
        
        memset(vis, 0, sizeof(int) * (n + 5));
        rep(i,1,n) g[i].clear();
        
        rep(i,1,n) scanf("%d",a + i);
        rep(i,1,m) {
            scanf("%d%d",&u,&v);
            g[u].pb(v);
            g[v].pb(u);
        }
        
        rep(i,1,n) {
            if (!vis[i]) ans += dij(i);
        }
        
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
struct ZB {
    int a,b,c,d;
};

map<int,vector<ZB>> A;
int n,k;
vector<ZB> x[100];

ll ans = 0;

void dfs(int n,int a,int b,int c,int d)
{
    if (n == k) {
        ans = max(ans,(ll) (100 + a) * (100 + b) * (100 + c) * (100 + d));
        return;
    }
    for (auto i : x[n]) {
        dfs(n + 1,a + i.a,b + i.b,c + i.c,d + i.d);
    }
}

int main()
{
    
    int t,a,b,c,d;
    _T_ (T) {
        scanf("%d%d",&n,&k);
        A.clear();
        k = 0;
        while (n --) {
            scanf("%d%d%d%d%d",&t,&a,&b,&c,&d);
            A[t].pb({a,b,c,d});
        }
        
        
        for (auto i : A) {
            x[k ++] = i.second;
        }
        ans = 0;
        dfs(0,0,0,0,0);
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    ll a[110];
    ll m = -1;
    rep(i,0,n-1) {
        scanf("%lld",a + i);
        m = max(m,a[i]);
    }
//    mm = 50 / mm;
    ll cnt;
    rep(i,0,n - 1) {
        printf("+");
        cnt = ceil(a[i] * 50 / (double) m);
        rep(i,0,cnt-1) printf("-");
        printf("+\n|");
        if (m == a[i]) {
            rep(i,0,cnt-2) printf(" ");
            printf("*");
        }
        else rep(i,0,cnt-1) printf(" ");
        printf("|%lld\n",a[i]);
        printf("+");
        rep(i,0,cnt-1) printf("-");
        printf("+\n");
    }
    
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[510];
    int f[510];
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%d",a + i);
    }
    int dp[510];
    int maxn = 0;
    for(int i = 1; i <= n; i++)
    {
        int k = 1;
        for(int j = i; j <= n; j++) f[k++] = a[j];
        for(int j = 1; j < i; j++) f[k++] = a[j];
        for(int j = 1; j <= n; j++) dp[j] = 1;
        for(int j = 1; j <= n; j++)
        {
            for(int q = 1; q < j; q++)
            {
                if(f[q]<f[j]){
                    dp[j] = max(dp[j],dp[q]+1);
                }
            }
        }
        for(int j = 1; j <= n; j++) maxn = max(maxn,dp[j]);
    }
    cout << n-maxn << endl;
    return 0;
}


*/


/*
class Solution {
public:
    int solve(int n, vector<int>& a) {
        // write code here
        set<int> x;
        for (auto i : a) {
            if (i % 2 == 0) x.insert(i);
        }
        int ans = 0;
        int num;
        set<int>::iterator v;
        while (!x.empty()) {
            num = *(-- x.end());
            while (num % 2 == 0) {
                v = x.find(num);
                if (v != x.end()) x.erase(v);
                ans ++;
                num /= 2;
            }
        }
        return ans;
    }
};


int main()
{
    int n;
    scanf("%d",&n);
    vector<int> x;
    int t;
    rep(i,1,n) {
        scanf("%d",&t);
        x.pb(t);
    }
    Solution s;
    cout << s.solve(n, x) << endl;
    return 0;
}
*/

/*
class Solution
{
public:
    int solve(int n, vector<int>& array)
    {
        // write code here
        int a[100005];
        sort(array.begin(),array.end());
        int m=0,minn = INT_INF;
        for(int i=0; i<n/2; i++)
        {
            a[i]=array[m++];
            a[n-1-i]=array[m++];
        }
        if(n & 1)
            a[n/2]=array[m];
        minn=abs(a[0]-a[n-1]);
        for(int i=1;i<n;i++)
        {
            minn=max(abs(a[i]-a[i-1]),minn);
        }
        return minn;
    }
};
*/




/*
int main()
{
    int n;
    double m = -1;
    double a,b;
    _T_(T)
    {
        m = -1;
        scanf("%d",&n);
        while (n --) {
            scanf("%lf%lf",&a,&b);
            m = max(m,(1 - b) / (a + (1-b)));
        }
        printf("%.5f\n",m);
    }
    

    return 0;
}
*/

/*
int main()
{
    double p;
    _T_(T) {
        scanf("%lf",&p);
        if (p > 1) {
            printf("No\n");
            continue;
        }
        printf("Yes\n");
    }
    
    return 0;
}
*/

//int main()
//{
//    int n,m;
//    _T_(T) {
//        scanf("%d%d",&n,&m);
//
//    }
//
//    return 0;
//}


//
//int main() {
//    int n,m,vis;
//    int x,y;
//    _T_(T) {
//        scanf("%d",&n);
//        vis = m = 0;
//        rep(i,1,n) {
//            scanf("%d%d",&x, &y);
//            if (x == 2) vis = 1;
//            m = max(m,y);
//        }
//        m ++;
//        if (vis) m ++;
//        printf("%d\n",m);
//    }
//    return 0;
//}


/*
int main() {
    ll n,m;
    _T_(T) {
        scanf("%lld%lld",&n,&m);
        if (m >= n / 2) printf("%lld\n",n * (n - 1) / 2);
        else printf("%lld\n",((n - m) * 2 - 1) * m);
    }
    return 0;
}
*/


//int n;
//
//void dfs(int m,int last)
//{
//
//}
//
//
//int main()
//{
//    int m;
//    int space;
//    __T {
//        scanf("%d%d",&n,&m);
//        space = ceil((n - 1) / 11.0);
//        space ++;
//        if (m > n - space) {
//            puts("-1");
//            continue;
//        }
//        dfs(m,1);
//
//
//
//    }
//    return 0;
//}
//

/*
inline int kill(int &hx,int &hy,int x,int y)
{
    int k1,k2;
    k1 = ceil((double) hx / y);
    k2 = ceil((double) hy / x);
    if (k1 < k2) {
        hx = 0;
        hy -= k1 * x;
        return k1;
    }
    hy = 0;
    hx -= k2 * y;
    return k2;
}


int main()
{
    int a[3];
    int x,y,z;
    int hx,hy,hz;
    int turn;
    int ans;
    __T {
        ans = INT_INF;
        rep(i,0,2) scanf("%d",a + i);
        sort(a,a + 3);
        x = a[2];
        y = a[1];
        z = a[0];
        rep(i,1,1000) {
            hx = hy = hz = 1000;
            hx -= y * i;
            hy -= x * i;
            turn = i;
            if (hx > 0 && hy <= 0) {
                turn += kill(hz,hx,z,x);
                ans = min(ans,turn);
                break;
            }
            if (hx <= 0 && hy <= 0) {
                ans = min(ans,turn);
                break;
            }
            turn += kill(hy,hz,y,z);
            if (hz > 0) turn += kill(hz,hx,z,x);
            if (hy > 0) turn += kill(hy,hx,y,x);
            ans = min(ans,turn);
        }
        printf("%d\n",ans);
    }
    return 0;
}
*/

/// xor 最小生成树
/// CF链接: https://codeforces.com/problemset/problem/888/G
/*
const int MAXN = 2e5 + 10;

struct Node {
    Node *l = NULL;
    Node *r = NULL;

    Node(Node *l,Node *r):l(l),r(r) {}
};

Node *root;

void insert(int n)
{
    Node *node = root;
    int x;
    pre(i,30,0) {
        x = ((n & (1 << i)) >> i);
        if (x) {
            // 1
            if (node -> r == NULL) node -> r = new Node(NULL,NULL);
            node = node -> r;
        } else {
            // 0
            if (node -> l == NULL) node -> l = new Node(NULL,NULL);
            node = node -> l;
        }
    }
}

ll ans = 0;

int find(Node *l,Node *r,int nl,int nr,int d)
{
    if (!(l -> l) && !(l -> r) && !(r -> r) && !(r -> l)) {
        return nl ^ nr;
    }
    int k = INT_INF;
    if (l -> l && !(l -> r) && r -> r && !(r -> l)) k = min(k,find(l -> l,r -> r,nl,nr + (1 << d),d - 1));
    if (l -> r && !(l -> l) && r -> l && !(r -> r)) k = min(k,find(l -> r,r -> l,nl + (1 << d),nr,d - 1));
    if (l -> l && r -> l) k = min(k,find(l -> l,r -> l,nl,nr,d - 1));
    if (l -> r && r -> r) k = min(k,find(l -> r,r -> r,nl + (1 << d),nr + (1 << d),d - 1));
    return k;
}

void dfs(Node *node,int n,int d)
{
    if (node -> l != NULL && node -> r != NULL) {
        ans += find(node -> l,node -> r,n,n + (1 << d),d - 1);
    }
    if (node -> l != NULL) dfs(node -> l,n,d - 1);
    if (node -> r != NULL) dfs(node -> r,n + (1 << d),d - 1);
}


int w[MAXN];

int main()
{
    int n;
    scanf("%d",&n);
    root = new Node(NULL,NULL);
    REP(i,0,n) {
        scanf("%d",w + i);
        insert(w[i]);
    }
    dfs(root,0,30);
    printf("%lld\n",ans);
    
    
    return 0;
}
*/


// xor最小生成树改编: https://ac.nowcoder.com/acm/contest/5670/B
/*
const int MAXN = 1e5 + 10;

struct Nd {
    int n,w;
    bool operator<(const Nd &o) const {
        return w > o.w;
    }
};

struct Node {
    Node *l = NULL;
    Node *r = NULL;

    Node(Node *l,Node *r):l(l),r(r) {}
};


vector<Nd> g[MAXN];
int vis[MAXN];
int w[MAXN];

Node *root;

void insert(int n)
{
    Node *node = root;
    int x;
    pre(i,30,0) {
        x = ((n & (1 << i)) >> i);
        if (x) {
            // 1
            if (node -> r == NULL) node -> r = new Node(NULL,NULL);
            node = node -> r;
        } else {
            // 0
            if (node -> l == NULL) node -> l = new Node(NULL,NULL);
            node = node -> l;
        }
    }
}

ll ans = 0;

int find(Node *l,Node *r,int nl,int nr,int d)
{
    if (!(l -> l) && !(l -> r) && !(r -> r) && !(r -> l)) {
        return nl ^ nr;
    }
    int k = INT_INF;
    if (l -> l && !(l -> r) && r -> r && !(r -> l)) k = min(k,find(l -> l,r -> r,nl,nr + (1 << d),d - 1));
    if (l -> r && !(l -> l) && r -> l && !(r -> r)) k = min(k,find(l -> r,r -> l,nl + (1 << d),nr,d - 1));
    if (l -> l && r -> l) k = min(k,find(l -> l,r -> l,nl,nr,d - 1));
    if (l -> r && r -> r) k = min(k,find(l -> r,r -> r,nl + (1 << d),nr + (1 << d),d - 1));
    return k;
}

void update(int n)
{
    if (vis[n]) return;
    vis[n] = 1;

    for (auto i : g[n]) {
        w[i.n] = w[n] ^ i.w;
        insert(w[i.n]);
        update(i.n);
    }
}

void dfs(Node *node,int n,int d)
{
    if (node -> l != NULL && node -> r != NULL) {
        ans += find(node -> l,node -> r,n,n + (1 << d),d - 1);
    }
    if (node -> l != NULL) dfs(node -> l,n,d - 1);
    if (node -> r != NULL) dfs(node -> r,n + (1 << d),d - 1);
}


int main()
{
    int n;
    scanf("%d",&n);
    int u,v,ww;
    REP(i,1,n) {
        scanf("%d%d%d",&u,&v,&ww);
        g[u].pb({v,ww});
        g[v].pb({u,ww});
    }


    // 处理成每个点的权值，两个点之间的xor就是每条边的w
    mem(vis,0);
    w[0] = 1;
    
    root = new Node(NULL,NULL);
    insert(1);
    
    update(0);

    // 跑一遍xor的最小生成树
    dfs(root,0,30);
    printf("%lld\n",ans);


    return 0;
}
*/


//const int MAXN = 50010;
//
//struct Car {
//    int a,p;
//    bool operator ==(const Car &o) const {
//        return a == o.a && p == o.p;
//    }
//};
//
//int cmp(const Car &a,const Car &b) {
//    if (a.p == b.p) {
//        return a.a > b.a;
//    }
//    return a.p > b.p;
//}
//
//Car c[MAXN];
//
//inline bool ok(Car a1,Car a2,Car i)
//{
//    ll deltaPos1 = a1.p - a2.p,
//       deltaPos2 = a2.p - i.p;
//    ll deltaAc1 = a2.a - a1.a,
//       deltaAc2 = i.a - a2.a;
//    return deltaPos2 * deltaAc1 > deltaPos1 * deltaAc2;
//}
//
//int main()
//{
//    int n;
//    int a,p;
//    int lp;
//    Car l;
//    int nn;
//    int stack[MAXN];
//    int ans;
//    _T_(T)
//    {
//        scanf("%d",&n);
//        rep(i,1,n) {
//            scanf("%d%d",&p,&a);
//            c[i].a = a;
//            c[i].p = p;
//        }
//        sort(c + 1,c + n + 1,cmp);
//
//        nn = n;
//        n = 0;
//
//        rep(i,1,nn) {
//            if (!((i >= 2 && c[i - 1] == c[i]) || (i <= nn - 1 && c[i + 1] == c[i]))) c[++ n] = c[i];
//        }
//
//        nn = n;
//        n = 0;
//
//        lp = c[1].p;
//        rep(i,2,nn) {
//            if (lp == c[i].p) continue;
//            c[++ n] = c[i];
//            lp = c[i].p;
//        }
//
////        rep(i,1,n) {
////            printf("%d %d\n",c[i].p,c[i].a);
////        }
//
//        ans = 0;
//        if (n > 0) stack[ans ++] = 1;
//        if (n > 1) stack[ans ++] = 2;
//
//        for (int i = 3; i <= n; i++) {
//            while (ans >= 2) {
//                int id1 = stack[ans - 1], id2 = stack[ans - 2];
//                int dpos1 = c[id1].p - c[i].p, dpos2 = c[id2].p - c[id1].p;
//                int da1 = c[i].a - c[id1].a, da2 = c[id1].a - c[id2].a;
//                if ((ll)dpos1 * da2 > (ll)da1 * dpos2) break;
//                ans--;
//            }
//            stack[ans++] = i;
//        }
//
//
////        rep(i,3,n) {
////            while (ok(stack[ans - 2],stack[ans - 1],c[i]) && ans >= 2) ans --;
////            stack[ans ++] = c[i];
////        }
//
//        printf("%d\n",ans);
//
//    }
//    return 0;
//}

/*
int main()
{
    int n,k;
    ll sum;
    
    scanf("%d%d",&n,&k);
    sum = (n + 1) * n / 2;
    if (sum % n != k) {
        puts("-1");
        return 0;
    }
    if (n % 2 == 0) {
        printf("%d %d",n,k);
        rep(i,1,k-1) {
            printf(" %d %d",i,n - i);
        }
        puts("");
    } else {
        printf("%d",n);
        rep(i,1,n / 2) {
            printf(" %d %d",i,n - i);
        }
        puts("");
    }
    
    return 0;
}
*/

/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

const int MAXN = 2e7 + 2;

ll ans[MAXN];
ll child = 1;
ll mother = 2;


int main()
{
    const ll p = quickpow(mother, mod - 2);

    ll x = p;
    ll bin = 2;

    mother = x;
    ans[1] = (child * mother) % mod;

    rep(i,2,MAXN) {
        bin *= 2;
        bin %= mod;

        x *= p;
        x %= mod;

        mother = mother * x;
        mother %= mod;

        child = child * ((bin - 1 + mod) % mod);
        child %= mod;
        ans[i] = (child * mother) % mod;

        ans[i] ^= ans[i - 1];
    }

    int n;
    __T
    {
        scanf("%d",&n);
        printf("%lld\n",ans[n]);
    }
    return 0;
}
*/



/*
itn n,k;

int a[500010];
int vis[500010];
unordered_map<int, int> mp;

int main()
{
    int t;
    int o;
    int x;
    int cnt;
    int last;
    __T {
        scanf("%d%d",&n,&k);

        last = -1;
        x = 1;
        
        mp.clear();
        
        REP(i,0,n) {
            scanf("%d",a + i);
            mp[a[i]] ++;
            if (mp[a[i]] != 1) {
                if (last == -1) last = i - 1;
            }
            if (last == -1) vis[i] = 1;
            else vis[i] = 0;
            
            if (a[i] > k) x = 0;
        }
        
        mp.clear();
        
        if (!x) {
            puts("NO");
            continue;
        }
        
        

        cnt = 0;
        o = 1;
        
//        printf(">>%d\n",last);

        REP(i,0,n) {

            if (i >= k) {
                t = a[i - k];

                mp[t] --;
                if (mp[t] == 0) cnt --;
            }


            mp[a[i]] ++;
            if (mp[a[i]] == 1) cnt ++;



            if (cnt == k) {
//                printf("%d\n",i); // test
                vis[i] = 1;

//                if (last == -1) {
//                    rep(j,0,i - k) vis[j] = 1;
//                }
                if (i - k >= 0 && !vis[i - k]) {
                    vis[i] = 0;
                } else {
                    last = i;
                }
                
//                printf("<<%d\n",last);
            }
        }

        mp.clear();
        
        REP(i,last + 1,n) {
            mp[a[i]] ++;
            if (mp[a[i]] != 1) {
                o = 0;
                break;
            }
        }
        
//        rep(i,0,n-1) printf("%d ",mp[i]);
//        printf("\n");


        puts(o ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int n,p;
    ll t,ans;
    int a[100010];
    int dp[100010];
    set<ll> x;
    __T {
        mem(dp,0);
        scanf("%d%d",&n,&p);
        rep(i,1,n) {
            scanf("%d",a + i);
            a[i] %= p;
        }
        ans = t = 0;
        x.clear();
        rep(i,1,n) {
            t += a[i];
            t %= p;
            
            if (dp[t] || t == 0) {
                ans ++;
                for (auto j : x) dp[j] = 0;
                x.clear();
                t = 0;
            } else {
                x.insert(t);
                dp[t] ++;
            }
            
            
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
const int MAXN = 1e5+10;

int main()
{
    string str;
    int vis[MAXN];
    int ok = 1;
    __T {
        cin >> str;
        queue<int> star;
        stack<int> left;
        ok = 1;
        memset(vis, 0, sizeof(int) * (str.size() + 5));
        for (int i = 0;str[i];i ++) {
            if (str[i] == '(') left.push(i);
            else if (str[i] == '*') star.push(i);
            else if (str[i] == ')') {
                if (!left.empty()) {
                    vis[left.top()] = 1;
                    left.pop();
                } else if (!star.empty()) {
                    vis[star.front()] = 1;
                    str[star.front()] = '(';
                    star.pop();
                } else ok = 0;
            }
        }
        
        if (!ok) {
            puts("No solution!");
            continue;
        }
        
        while (!star.empty()) star.pop();
        
        pre(i,(int) str.size() - 1,0) {
            if (str[i] == '*' && !vis[i]) star.push(i);
        }
        
        pre(i,(int) str.size() - 1,0) {
            if (str[i] == '(' && !vis[i]) {
                
                if (!star.empty()) {
                    if (star.front() < i) {
                        ok = 0;
                        break;
                    }
                    str[star.front()] = ')';
                    vis[i] = 1;
                    star.pop();
                } else {
                    ok = 0;
                    break;
                }
            }
        }
        
        if (ok) {
            for (int i = 0;str[i];i ++) {
                if (str[i] != '*') printf("%c",str[i]);
            }
            puts("");
        } else {
            puts("No solution!");
            continue;
        }
        
        
    }
    return 0;
}
*/

//const int MAXN = 1e5 + 10;
//
//int g[MAXN];
//int d[MAXN];
//
//int find(int a)
//{
//    if (g[a] == a) return a;
//    return g[a] = find(g[a]);
//}
//
//inline void bind(int a,int b)
//{
//    int x = find(a), y = find(b);
//    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
//        g[y] = x; // 改变b节点的根的根为a的根
//        if (d[x] == d[y]) { // 俩根深度一样
//            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
//        }
//    } else g[x] = y;
//}
//
//void init(int n)
//{
//    rep(i,0,n) {
//        g[i] = i;
//        d[i] = 1;
//    }
//}
//
//
//
//int main()
//{
//    int n;
//    int a1[MAXN];
//    int a2[MAXN];
//    int u,v;
//    int t;
//    __T {
//        scanf("%d",&n);
//        init(n);
//        rep(i,1,n) {
//            scanf("%d",&t);
//            if (t == 1) a1[i] ++;
//            else if (t == 2) a2[i] ++;
//        }
//
//        set<int> k;
//
//        rep(i,1,n-1) {
//            scanf("%d%d",&u,&v);
//
//            u = find(u);
//            v = find(v);
//
//            bind(u,v);
//            t = find(u);
//            if (u != v) {
//                printf("   %d 1:%d 2:%d\n",u,a1[u],a2[u]);
//                printf("   %d 1:%d 2:%d\n",v,a1[v],a2[v]);
//                a1[t] = a1[u] + a1[v];
//                a2[t] = a2[u] + a2[v];
//                printf("==>%d 1:%d 2:%d\n\n",t,a1[t],a2[t]);
//                if (u != t) a1[u] = a2[u] = 0;
//                if (v != t) a1[v] = a2[v] = 0;
//
//
//
//                int cnt1 = 0;
//                int cnt2 = 0;
//                vector<pair<int,int>>
//                rep(i,1,n) {
//                    if ((a1[i] == 1 && a2[i] == 0) || (a1[i] == 0 && a2[i] == 1)) {
//                        cnt1 += a1[i];
//                        cnt2 += a2[i];
//                    } else {
//
//                    }
//                }
//
//            }
//
//
//
//        }
//
//    }
//    return 0;
//}
//
//
//



/*
int main()
{
    int n;
    scanf("%d",&n);
    double sum = 0;
    int t;
    double j = 0;
    rep(i,0,n-1) {
        scanf("%d",&t);
        sum += t;
        if (n & 1) {
            if (i == n / 2) {
                j = t;
            }
        } else {
            if (i == n / 2 - 1) {
                j = t;
            } else if (i == n / 2) {
                j += t;
                j /= 2;
            }
        }
        
    }
    printf("%.0f\n",fabs(sum / n - j));
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

set<int> g1[MAXN];
set<int> g2[MAXN];

int main()
{
    int n;
    scanf("%d",&n);int u,v;
    rep(i,1,n-1) {
        scanf("%d%d",&u,&v);
        g1[u].insert(v);
        g1[v].insert(u);
    }
    rep(i,1,n-1) {
        scanf("%d%d",&u,&v);
        g2[u].insert(v);
        g2[v].insert(u);
    }
    
    set<int>::iterator it;
    
    rep(i,1,n) {
        for (auto j = g1[i].begin();j != g1[i].end();) {
            if ((it = g2[i].find(*j)) != g2[i].end()) {
                g2[i].erase(it);
                g1[i].erase(j ++);
            } else j ++;
        }
    }
    
    ll cnt = 0;
    
    rep(i,1,n) {
        cnt += g1[i].size();
    }
    
    printf("%lld\n",cnt / 2);
    
    return 0;
}
*/


/*
int n,m;

int a[60][60];
int dis[60][60];
int vis[60][60];
int dx[] = {0,1,-1,0};
int dy[] = {1,0,0,-1};



struct ST {
    int x,y;
    int w;
    
    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

void dij(int x,int y) {
    mem(dis,-1);
    
    priority_queue<ST> q;
    q.push({x,y,dis[x][y] = 0});
    
    ST current;
    int k;
    int xx,yy;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.x][current.y]) continue;
        vis[current.x][current.y] = 1;
        
//        printf(">>%d %d %d\n",current.x,current.y,dis[current.x][current.y]);
        
        rep(i, 0, 3) {
            xx = current.x + dx[i];
            yy = current.y + dy[i];
            if (xx >= 1 && yy >= 1 && xx <= n && yy <= m) {
                
                k = dis[current.x][current.y] + a[xx][yy];
//                printf("%d\n",dis[xx][yy]);
                if (dis[xx][yy] == -1 || dis[xx][yy] > k) {
//                    printf("..%d %d\n",xx,yy);
                    q.push({xx,yy,dis[xx][yy] = k});
                }
            }
        }
    }
}


int main()
{
    scanf("%d%d",&n,&m);
    char t;
    int x = 1,y = 1;
    int xx = 1,yy = 2;
    rep(i,1,n) {
        rep(j,1,m) {
            scanf(" %c",&t);
            if (t == 'S') {
                a[i][j] = 0;
                y = j;
                x = i;
            } else if (t == 'E') {
                a[i][j] = 0;
                xx = i;
                yy = j;
            } else if (t >= '0' && t <= '9') {
                a[i][j] = t ^ 48;
            } else {
                a[i][j] = 100;
            }
        }
    }
    
//    rep(i,1,n) {
//    rep(j,1,m) {
//        printf("%d ",a[i][j]);
//    }
//        puts("");
//    }
    
    mem(vis,0);
    dij(x,y);
    printf("%d\n",dis[xx][yy]);
    
    return 0;
}
*/

/*
const int MAXN = 55;

struct ST {
    int n;
    int w;
    
    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

int dis[MAXN];
int vis[MAXN];

int mp[MAXN][MAXN];

int n,k;
int ans = -1;

vector<int> g[MAXN];

vector<int> dij(int s) {
    mem(dis,-1);
    mem(vis,0);
    
    vector<int> path(MAXN);
    
    priority_queue<ST> q;
    q.push({s,dis[s] = 0});
    
    ST current;
    int k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        for (auto to : g[current.n]) {
            if (mp[current.n][to] == -1) continue;
            k = dis[current.n] + mp[current.n][to];
            if (dis[to] == -1 || dis[to] > k) {
                path[to] = current.n;
                q.push({to,dis[to] = k});
            }
        }
    }
    return path;
}

void dfs(int x)
{
    vector<int> from = dij(1);
    if (x == k) {
        ans = max(ans,dis[n]);
        return;
    }
    int i = n;
    int t;
    do {
        t = mp[i][from[i]];
        
        mp[i][from[i]] = -1;
        mp[from[i]][i] = -1;
        
        dfs(x + 1);
        
        mp[i][from[i]] = t;
        mp[from[i]][i] = t;
        
        i = from[i];
    } while (i != 1);
}


int main()
{
    int u,v,w;
    __T {
        scanf("%d%d",&n,&k);
        rep(i,1,n) g[i].clear();
        rep(i,1,n * (n - 1) / 2) {
            scanf("%d%d%d",&u,&v,&w);
            g[u].pb(v);
            g[v].pb(u);
            mp[u][v] = w;
            mp[v][u] = w;
        }
        ans = -1;
        dfs(0);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    {
    n ++;
    pre(i,n,2) {
        rep(j,1,i) {
            if (j != 1) printf(" ");
            printf("*");
        }
        rep(j,1,n-i+1) printf(" ");
        puts("");
    }
    rep(i,1,n) {
        rep(j,1,i) {
            if (j != 1) printf(" ");
            printf("*");
        }
        rep(j,1,n-i+1) printf(" ");
        puts("");
    }
    }
    
    return 0;
}
*/

/*
int main()
{
    int n;
    while (~scanf("%d",&n))
    pre(i,n,1) {
        rep(j,1,i-1) {
            printf(" ");
        }
        printf("*");
        rep(j,1,n-i) {
            printf(" ");
        }
        puts("");
    }
}
*/

/*
int main()
{
    int n;
    _E_(scanf("%d",&n))
    if (1 & n) {
        REP(i,0,n/2) {
            REP(j,0,i) printf(" ");
            printf("*");
//            cout << n - 2 - i * 2 << endl;
            rep(j,1,n-2-i*2) printf(" ");
            printf("*");
            REP(j,0,i) printf(" ");
            puts("");
        }
        
        rep(i,1,n/2) printf(" ");
        printf("*");
        rep(i,1,n/2) printf(" ");
        puts("");
        
        pre(i,n/2-1,0) {
            REP(j,0,i) printf(" ");
            printf("*");
            rep(j,1,n-2-i*2) printf(" ");
            printf("*");
            REP(j,0,i) printf(" ");
            puts("");
        }
    } else {
                REP(i,0,n/2) {
                    REP(j,0,i) printf(" ");
                    printf("*");
        //            cout << n - 2 - i * 2 << endl;
                    rep(j,1,n-2-i*2) printf(" ");
                    printf("*");
                    REP(j,0,i) printf(" ");
                    puts("");
                }
                
                
                
                pre(i,n/2-1,0) {
                    REP(j,0,i) printf(" ");
                    printf("*");
                    rep(j,1,n-2-i*2) printf(" ");
                    printf("*");
                    REP(j,0,i) printf(" ");
                    puts("");
                }
    }
}
*/

/*
int main()
{
    string str;
    while (getline(cin, str))
    {
        int cntA = 0;
        int cntB = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] == 'A') cntA ++;
            else if (str[i] == 'B') cntB ++;
        }
        if (cntA > cntB) puts("A");
        else if (cntA < cntB) puts("B");
        else if (cntA == cntB) puts("E");
    }
    
    return 0;
}
*/

/*
int main()
{
    double w,h;
    while (cin >> w >> h)
    {
        double bmi = w / (h * h) * 10000;
        if (bmi < 18.5) cout << "Underweight" << endl;
        else if (bmi <= 23.9) cout << "Normal" << endl;
        else if (bmi <= 27.9) cout << "Overweight" << endl;
        else cout << "Obese" << endl;
    }
    
}

*/

/*
int main()
{
    string str;
    while (cin >> str) {
        for (int i = 0;str[i];i ++) {
            if (str[i] >= 'A' && str[i] <= 'Z') {
                str[i] -= 'A';
                str[i] += 'a';
            } else if (str[i] >= 'a' && str[i] <= 'z') {
                str[i] -= 'a';
                str[i] += 'A';
            }
        }
        cout << str << endl;
    }
    
}
*/

/*
int main()
{
    double a,b,d,t;
    __T {
        scanf("%lf%lf%lf%lf",&a,&b,&d,&t);
        d -= 0.0000000001;
        printf("%.20f\n",d);
    }
    return 0;
}
*/



/*
int main() {
    __T {
        int n;
        scanf("%d", &n);
        vector<int> ans;
        for(int i = 0; i < n; i ++){
            int a,b;
            scanf("%d %d", &a, &b);
            ans.push_back((ceil(100.0/a)-1)*b);
        }
        sort(ans.begin(),ans.end());
        int sum = 1;
        for(int i = 1; i < ans.size(); i ++){
            if(ans[i] == ans[0]) sum ++;
            else break;
        }
        double k = 1.0 - (sum*1.0/(2*n));
        printf("%.8f\n", k);
    }

    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

struct ST {
    int n;
    ll w;
    int mod;

    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

char dir[MAXN];
ll dis[MAXN][3];
int vis[MAXN][3];
int x;
vector<ST> g[MAXN];

// 0 - l
// 1 - r
// 2 - m

ll dij(int s,int d,int t) {
    rep(i,1,MAXN) dis[i][0] = dis[i][1] = dis[i][2] = -1;
    mem(vis,0);
    
    
    priority_queue<ST> q;
    
    q.push({s,dis[s][d] = 0,d});
    
    int step;
    
    ST current;
    double k,cost;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        
        if (vis[current.n][current.mod]) continue;
        vis[current.n][current.mod] = 1;
        
        for (auto to : g[current.n]) {
            if (to.mod == 2) {
                cost = to.w;
                step = 0;
                if (current.mod != step) cost += x;
                k = dis[current.n][current.mod] + cost;
                if (dis[to.n][step] == -1 || dis[to.n][step] > k) {
                    q.push({to.n,dis[to.n][step] = k,step});
                }
                
                cost = to.w;
                step = 1;
                if (current.mod != step) cost += x;
                k = dis[current.n][current.mod] + cost;
                if (dis[to.n][step] == -1 || dis[to.n][step] > k) {
                    q.push({to.n,dis[to.n][step] = k,step});
                }
                
            } else {
                cost = to.w;
                step = to.mod;
                if (current.mod != step) cost += x;
                k = dis[current.n][current.mod] + cost;
                if (dis[to.n][step] == -1 || dis[to.n][step] > k) {
                    q.push({to.n,dis[to.n][step] = k,step});
                }
            }
            
            
        }
    }
    
    ll ans;
    if (dir[t] == 2) {
        ans = min(dis[t][0],dis[t][1]);
    } else {
        ans = dis[t][dir[t]];
    }
    
    return ans;
}


int main()
{
    int n,m;
    int u,v;
    ll d;
    int s,t;
    __T {
        scanf("%d%d%d%d%d",&n,&m,&s,&t,&x);
        scanf("%s",dir+1);
        rep(i,1,n) {
            if (dir[i] == 'L') dir[i] = 0;
            else if (dir[i] == 'R') dir[i] = 1;
            else if (dir[i] == 'M') dir[i] = 2;
        }
        
        rep(i,1,n) g[i].clear();
        
        while (m --) {
            scanf("%d%d%lld",&u,&v,&d);
            g[u].pb({v,d,dir[v]});
            g[v].pb({u,d,dir[u]});
        }
        ll ans;
        if (dir[s] != 2) {
            ans = dij(s,dir[s],t);
        } else {
            ans = min(dij(s,1,t),dij(s,0,t));
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
struct Point {
    int x;
    int y;
};

class Solution {
public:
    const static int MAXN = 1e5 + 10;
    
    vector<int> g[MAXN];
    int w[MAXN];
    int vis[MAXN];
    
    int ans = 0;
    
    void dfs(int n,int d)
    {
        
        if (vis[n] || d < 0) return;
        vis[n] = 1;
        int cnt = 0;
        for (auto i : g[n]) {
            if (!vis[i]) cnt ++;
            dfs(i,d - w[i]);
            
        }
        if (cnt == 0) {
            if (d >= 0) ans ++;
        }
    }

    int solve(int n, vector<Point>& Edge, vector<int>& f) {
        // write code here
        int x = 1;
        for (auto i : f) w[x ++] = i;
        for (auto i : Edge) {
            g[i.x].pb(i.y);
            g[i.y].pb(i.x);
        }
        mem(vis,0);
        dfs(1,2 - w[1]);
        
        return ans;
    }
};


int main()
{
    Solution s;
    itn n;
    scanf("%d",&n);
    int t;
    vector<int> x;
    rep(i,1,n) {
        scanf("%d",&t);
        x.pb(t);
    }
    int u,v;
    vector<Point> k;
    rep(i,1,n-1) {
        scanf("%d%d",&u,&v);
        k.pb({u,v});
    }
    cout << s.solve(n, k, x) << ednl;
    
    return 0;
}
*/

/// 矩阵模版 快速幂
/*
const int mod = 1e9 + 7;

class Matrix
{
    const static int MAXN = 10;
    ll a[MAXN][MAXN];
    
public:
    int w;
    int h;
    
    Matrix(int h,int w):w(w),h(h)
    {
        mem(a,0);
    }
    
    Matrix(const char format[], ...) {
        
        va_list args;
        w = 0;
        h = 0;
        
        char buf[1000];
        
        va_start(args, format);
        vsprintf(buf, format, args);
        va_end(args);
        
        stringstream ss(buf);
        stringstream num;
        ll n;
        string line;
        while (getline(ss, line)) {
            num.clear();
            num << line;
            w = 0;
            while (num >> n) {
                a[h + 1][++ w] = n;
            }
            h ++;
        }
    }
    
    void E()
    {
        if (w == h) {
            mem(a,0);
            rep(i,1,w) a[i][i] = 1;
        }
    }
    
    void print()
    {
        int f = 1;
        rep(i,1,h) {
            f = 1;
            rep(j,1,w) {
                if (f) f = 0;
                else printf(" ");
                printf("%lld",a[i][j]);
            }
            puts("");
        }
    }
    
    void read_in()
    {
        rep(i,1,h) {
            rep(j,1,w) {
                scanf("%lld",&a[i][j]);
            }
        }
    }
    
    Matrix operator* (const Matrix &B) const
    {
        if (w != B.h) return Matrix(0,0); // invalid
        
        Matrix ans(h,B.w);
        rep(i,1,h) {
            rep(j,1,B.w) {
                rep(k,1,w) {
//                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j]);
                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j] % mod) % mod; // Moduled
                }
            }
        }
        return ans;
    }
    
    const ll* operator[] (int i) const {
        return a[i];
    }
    
    ll* operator[] (int i) {
        return a[i];
    }
};

Matrix quickpow(Matrix a, ll b)
{
    if (a.h != a.w) return Matrix(0,0); // invalid
    
    Matrix ans(a.h,a.w);
    rep(i,1,ans.h) ans[i][i] = 1; // Set ans matrix to E
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}
*/




/*class Solution {
public:
    long long nthElement(long long n, long long b, long long c) {
        // write code here
        return (quickpow(Matrix("%lld %lld\n1 0",b,c),n - 1) * Matrix("%lld\n%lld",1,0))[1][1];
    }
};


int main()
{

    ll n,b,c;
    scanf("%lld%lld%lld",&n,&b,&c);
    Solution s;
    printf("%lld\n",s.nthElement(n, b, c));
    return 0;
}
*/

/*
int main() {
    ll n;
    __T {
        scanf("%lld",&n);
        if (n == 1 || n == 24) puts("Fake news!");
        else {
            puts("Nobody knows it better than me!");
        }
    }
    return 0;
}
*/

//const int mod = 1e9 + 7;
//
//int main()
//{
//    ll n,k;
//    scanf("%lld%lld",&n,&k);
//    ll sum = 0;
//    ll a,b;
//    if (n < k) {
//        a = n;
//        b = n + 1;
//        if (a % 2 == 0) a /= 2;
//        if (b % 2 == 0) b /= 2;
//        a %= mod;
//        b %= mod;
//        sum += a * b;
//        sum %= mod;
//
//        sum += k - 1;
//        sum %= mod;
//        printf("%lld\n",sum);
//    } else {
//        a = k;
//        b = k + 1;
//        if (a % 2 == 0) a /= 2;
//        if (b % 2 == 0) b /= 2;
//        a %= mod;
//        b %= mod;
//        sum += a * b;
//        sum %= mod;
//
//        sum += k - 1;
//        sum %= mod;
//        sum += (k % mod) * ((n - k) % mod);
//        sum %= mod;
//        printf("%lld\n",sum);
//    }
//    return 0;
//}

/*
vector<int> ans;

void gcd(int a,int b) {
    if (b == 0) return;
    rep(i,1,a / b * b) ans.pb(b);
    gcd(b,a % b);
}


int main()
{
    int n,m;
    int f = 1;
    __T {
        scanf("%d%d",&n,&m);
        ans.clear();
        gcd(n,m);
        f = 1;
        printf("%lu\n",ans.size());
        for (auto i : ans) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i);
        }
        printf("\n");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    ll d;
    scanf("%d%lld",&n,&d);
    ll a,b;
    d *= d;
    int x = 0;
    
    while (n --) {
        scanf("%lld%lld",&a,&b);
        if (a * a + b * b <= d) x ++;
    }
    printf("%d\n",x);
    return 0;
}
*/


//int main(){
//
//    ll a;
//    scanf("%lld",&a);
//    if (a >= 30) puts("Yes");
//    else puts("No");
//
//    return 0;
//}

/*
int main() {
    int k;
    scanf("%d", &k);
    ll n = 7;
    int ans = 1;
    if(k % 2 ==0 || k % 5 == 0){
        puts("-1");
        return 0;
    }
    while (1) {
        if(n % k == 0) {
            printf("%d\n", ans);
            return 0;
        }
        ans ++;
        n *= 10;
        n += 7;
        n %= k;
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    string s;
    cin >> s;
    int cnt = 0;
    int ans = 0;
    REP (i,0,n) if (s[i] == 'R') cnt ++;
    REP (i,0,cnt) if (s[i] =='W') ans ++;
    printf("%d\n",ans);
    return 0;
}
*/


/*
const int MAXN = 2e5 + 10;
int n,k;
int a[MAXN];

inline bool check(int m)
{
    int ans = 0;
    rep(i,1,n) {
        if (a[i] != m) ans += a[i] / m;
        if (ans > k) return 0;
    }
    return ans <= k;
}

int main()
{
    scanf("%d%d",&n,&k);
    int l = 1;
    int r = -1;
    rep(i,1,n) {
        scanf("%d",a + i);
        if (i == 1) {
            r = a[i];
        } else {
            
            r = max(r,a[i]);
        }
    }
    
//    rep(i,1,r) {
//        printf("%d: %d\n",i,check(i));
//    }
    
//    if (k == 0) {
//        printf("%d\n",r);
//        return 0;
//    }
    int m;
    int ans = 1;

    while (l < r) {

        m = (l + r) / 2;
        if (check(m)) {
            r = m;
            ans = m;
        } else l = m + 1;
    }
    printf("%d\n",r);
    return 0;
}
*/

/*
const int MAXN = 5e5 + 10;

int a[MAXN];
int rt[MAXN];
int lc[MAXN * 40],rc[MAXN * 40],cnt;
ll sum[MAXN * 40];

map<int,int> vis;

void update(int &u, int x, int y, int p, ll v)
{
    sum[cnt] = sum[u] + v;
    lc[cnt] = lc[u];
    rc[cnt] = rc[u];
    u = cnt;
    cnt ++;
    
    if(x == y) return;
    int m = (x + y) >> 1;
    if(p <= m) update(lc[u],x,m,p,v);
    else update(rc[u],m + 1,y,p,v);
}

ll query(int u, int x, int y, int ql, int qr)
{
    if(ql <= x && y <= qr) return sum[u];
    int m = (x+y) >> 1;
    ll ans = 0;
    if(ql <= m) ans += query(lc[u],x,m,ql,qr);
    if(qr > m) ans += query(rc[u],m + 1,y,ql,qr);
    return ans;
}

int n,q;
int t;

void init()
{
    rep(i,1,n) {
        rt[i] = rt[i - 1];
        if(vis.find(a[i])!=vis.end())
        {
            t = rt[i - 1];
            update(t,1,n,vis[a[i]],-1);
            rt[i] = t;
            update(rt[i],1,n,i,1);
        } else {
            rt[i] = rt[i-1];
            update(rt[i],1,n,i,1);
        }
        vis[a[i]] = i;
    }
}

void sve()
{
    int l,r;
    while (q --){
        scanf("%d%d",&l,&r);
        printf("%lld\n",query(rt[r],1,n,l,r));
    }
}

int main(){
    
    cnt = 1;
    scanf("%d%d",&n,&q);
    rep(i,1,n) scanf("%d",a + i);
    init();
    sve();
    return 0;
    
}
*/

/*
int main()
{
    int s;
    scanf("%d",&s);
    printf("%.3f\n",2*sqrt(s/pi));
    return 0;
}
*/

/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll n,m,k,a,b;
    scanf("%lld%lld%lld%lld%lld",&n,&m,&k,&a,&b);
    ll pa = quickpow(n + m + 1, k);
    ll pb = quickpow(n + m, k);
    
    ll aa = ((b * n % mod - a * n % mod - a * m % mod) * pb % mod + ((a * (n + m) % mod) % mod * pa) % mod) % mod;
    ll bb = b * pa % mod;
    printf("%lld\n",(aa * quickpow(bb, mod - 2) % mod + mod) % mod);
    return 0;
}
*/


//int main()
//{
//    map<char,set<char>> ch[30];
//
//    string line;
//    __T {
//        getline(cin,line);
//        if (line[1] == '.') {
//
//        } else {
//
//        }
//    }
//    return 0;
//}
//
//const int MAXN = 1e5 + 5;
//
//int main()
//{
//
//    ll f[100010];
//    rep(i,1,5) {
//        f[i] = 0;
//    }
//    f[6] = 1;
//    f[7] = 1;
//    rep(i,8,MAXN) {
//        switch (i % 3) {
//            case 0:
//                f[i] = f[i - 1] + i / 3 - 1;
//                break;
//            case 1:
//                f[i] = f[i - 1];
//                break;
//            case 2:
//                f[i] = f[i - 1] + i / 3 - 1;
//                break;
//        }
//    }
//
//
//    cout << f[99999] << endl;
//    cout << f[100000] << endl;
//
//    rep(i,2,MAXN) {
//        f[i] += f[i - 1];
//    }
//
//    cout << f[100000];
//
////    int c =1;
////    int l,r;
////    __T {
////        scanf("%d%d",&l,&r);
////        printf("Case #%d: %lld\n",c ++,f[r] - f[l - 1]);
////    }
//
//
//
//
//
//    return 0;
//}


//int main()
//{
//    int last = 0;
//    rep(n,1,100)
//    {
////        int cnt = 0;
////        for(int i = 1; i < n; i++) {
////            int c1, c2, c3;
////            c1 = c2 = c3 = 0;
////            if(i*3+3>n) break;
////            int x1, x2, x3;
////            x1 = i ;
////            x2 = x1+1;
////            x3 = x2+1;
////            for(int j = 1; j <= n/i; j++) {
////                for(int k = 1; k <= n; k++) {
////                    for(int l = 1; l <= n; l++) {
////                        if(j*x1+k*x2+l*x3==n) {
////                            cnt++;
//////                            cout << j << "*" << x1 << " " << k << "*" << x2 << " " << l << "*" << x3 << endl;
////                        }
////                    }
////                }
////            }
////        }
////        cout << n << ": " << cnt << " %3 " << n % 3 << endl;
//        int cnt;
//
//        int ans = 0;
////        printf(">> %d: \n",n);
//        rep(i,3,n / 3 + 1) {
//            cnt = 0;
//            rep(j1,1,n) {
//                rep(j2,1,n) {
//                    rep(j3,1,n) {
//                        if (j1 * (i - 2) + j2 * (i - 1) + j3 * i == n) {
//                            if (i == 5) printf("%d * %d  %d * %d  %d * %d\n",i - 2,j1,i-1,j2,i,j3);
//                            cnt ++;
//                        }
//                    }
//                }
//            }
//            ans += cnt;
//            if (i == 5) {
////                if (n % 3 == 2) printf(">>");
////                else printf("  ");
//                printf("%d: %d\n",n,cnt);
//                puts("");
//            }
//
//        }
////        if (n % 3 == 0) printf(">>");
////        else printf("  ");
////        cout << n << " " << ans << " " << ans - last << endl;
////        last = ans;
//    }
//
//    return 0;
//}

/*
inline void read_lll(lll *X)
{
    *X = 0;
    int w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {
        *X=((*X)<<3)+((*X)<<1)+(ch^48);
        ch=getchar();
    }
    if (w) *X = -*X;
}

void print_lll(lll x)
{
    if (!x) return ;
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    print_lll(x / 10);
    putchar(x % 10 + '0');
}

const int N = 1e5 + 5;
int n;
lll a[N], b[N];
int main()
{
    int T;
    scanf("%d", &T);
    for (int Case = 1; Case <= T; Case++) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) {
            read_lll(a + i);
//            scanf("%d", a + i);
            a[i] += a[i - 1];
        }
        for (int i = 1; i <= n; i++)
            read_lll(b + i);
        lll people = b[1];
        lll  money =  a[1] * people;
        for (int l = 1, r = 2; r <= n; r++) {
            people = min(people, b[r]);
            if (a[r] - a[l] > 0) {
                money += (a[r] - a[l]) * people;
                l = r;
            }
        }
        printf("Case #%d: ",Case);
        // %d %lld\n", b[1], money);
        print_lll(b[1]);
        printf(" ");
        print_lll(money);
        puts("");
    }

    return 0;
}
*/

/*
const int MAXN = 5e5;

int g[MAXN];
int d[MAXN];
int cnt[MAXN];
int cnt_e[MAXN];
int num[MAXN * 2];
int cnt_n;

pair<int,int> pr[MAXN];
unordered_map<int, int> mp;

int find(int a)
{
    if (g[a] == a) return a;
    return g[a] = find(g[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (d[x] >= d[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        g[y] = x; // 改变b节点的根的根为a的根
        if (d[x] == d[y]) { // 俩根深度一样
            if (x != y) d[x] ++; // 作为a的根，自然子树的深度++
        }
    } else g[x] = y;
}

void init(int n)
{
    rep(i,1,n) {
        g[i] = i;
        d[i] = 1;
        cnt[i] = 1;
        cnt_e[i] = 0;
    }
}


int main()
{
    int n;
    int u,v;
    int nu,nv,eu,ev;
    int k;
    ll ans = 0;
    int CASE = 1;
    __T {
        scanf("%d",&n);
        ans = 0;
        cnt_n = 0;
        mp.clear();
        rep(i,1,n) {
            scanf("%d%d",&u,&v);
            pr[i] = make_pair(u, v);
            num[++ cnt_n] = u;
            num[++ cnt_n] = v;
        }
        
        sort(num + 1,num + cnt_n + 1);
        
        cnt_n = (int) (unique(num + 1, num + cnt_n + 1) - (num + 1));
        
        
        init(cnt_n + 5);
        
        rep(i,1,cnt_n) {
            mp[num[i]] = i;
        }
        
        rep(i,1,n) {
            u = mp[pr[i].first];
            v = mp[pr[i].second];
            u = find(u);
            v = find(v);
            
            nu = cnt[u];
            nv = cnt[v];
            
            eu = cnt_e[u];
            ev = cnt_e[v];
            
            
            bind(u,v);
            k = find(u);
            
            
            cnt[u] = cnt[v] = 0;
            if (u != v) cnt[k] = nu + nv;
            else cnt[k] = nu;
            
            cnt_e[u] = cnt_e[v] = 0;
            if (u != v) cnt_e[k] = eu + ev;
            else cnt_e[k] = eu;
            cnt_e[k] ++;
            
//            cout << ">>" << k << endl;
        }
        
        rep(i,1,cnt_n) {
            printf("%d %d\n",cnt[i],cnt_e[i]);
            ans += min(cnt[i],cnt_e[i]);
        }
        printf("Case #%d: %lld\n",CASE ++,ans);
    }
    return 0;
}
*/

/*
inline bool chk(string &a,string &b,string &c) {
    if (a != b && b != c && a != c) return 1;
    if (a == "*" || b == "*" || c == "*") return 1;
    if (a == b && b == c && a == c) return 1;
    return 0;
}

string x[500][10];

int main()
{
    
    string line;
    string d;
    int n;
    int k = 0;
    int CASE = 1;
    int ok = 0;
    __T {
        scanf("%d",&n);
        ok = 0;
        rep(ii,1,n) {
            cin >> line;
            d = "";
            k = 0;
            for (int i = 0;line[i];i ++) {
                if (line[i] == ']') {
                    x[ii][k ++] = d;
                    d = "";
                } else if (line[i] != '[') {
                    d += line[i];
                }
            }
        }
        rep(i,1,n) {
            rep(j,i + 1,n) {
                if (i == j) continue;
                rep(k,j + 1,n) {
                    if (j == k || i == k) continue;
                    if (chk(x[i][0],x[j][0],x[k][0]) &&
                        chk(x[i][1],x[j][1],x[k][1]) &&
                        chk(x[i][2],x[j][2],x[k][2]) &&
                        chk(x[i][3],x[j][3],x[k][3])) {
                        printf("Case #%d: %d %d %d\n",CASE ++,i,j,k);
                        ok = 1;
                        break;
                    }
                }
                if (ok) break;
            }
            if (ok) break;
        }
        
        if (!ok) {
            printf("Case #%d: -1\n",CASE ++);
        }
        
    }
    return 0;
}
*/

/*
const ll mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

const ll MAXN = 6e6 + 10;

ll a[MAXN];

int main()
{
    int n;
    a[0] = 0;
    for (ll i = 1;i <= MAXN;i ++) {
        a[i] = a[i - 1] + quickpow(i * i % mod, mod - 2);
        a[i] %= mod;
    }
    
    ll g,ans;
    __T {
        scanf("%d",&n);
        g = quickpow(n, mod - 2);
        ans = a[n];
        ans *= 3;
        ans %= mod;
        printf("%lld\n",g * ans % mod);
    }
    return 0;
}
*/




/*
const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll n;
    ll ans;
    ll k;
    __T {
        scanf("%lld",&n);
        ans = quickpow(4, n);
        k = quickpow(2, n);
        ans += k;
        ans %= mod;
        ans += quickpow(3, n) * 2 % mod;
        ans %= mod;
        ans *= quickpow(k, mod - 2);
        ans %= mod;
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
inline int get_pos(int i,int j,int w)
{
    return i * w + j;
}

int a[1000010];
int b[1000010];

int main()
{
    int n,k;
    int t;
    int f;
    int w,h;
    __T {
        scanf("%d%d",&n,&k);
        n = (1 << (k + 1)) * n;

        REP(i,0,n) {
            scanf("%d",a + i);
        }
        w = n;
        h = 1;
        t = 1;
        f = 1;
        rep(ii,1,k) {
            if (t) {
                // a -> b
                REP(i,0,h) {
                    REP(j,w / 2,w) {
                        b[get_pos(i + h, j - w / 2,w / 2)] = a[get_pos(i, j,w)];
                        b[get_pos(h - 1 - i,j - w / 2,w / 2)] = a[get_pos(i,w - 1 - j,w)];
                    }
                }
            } else {
                // b -> a
                REP(i,0,h) {
                    REP(j,w / 2,w) {
                        a[get_pos(i + h, j - w / 2,w / 2)] = b[get_pos(i, j,w)];
                        a[get_pos(h - 1 - i,j - w / 2,w / 2)] = b[get_pos(i,w - 1 - j,w)];
                    }
                }
            }
            t = !t;
            w /= 2;
            h *= 2;
        }
        
        if (t) {
            // a
            REP(i,0,w) {
                REP(j,0,h) {
                    if (f) f = 0;
                    else printf(" ");
                    printf("%d",a[get_pos(j, i,w)]);
                }
            }
        } else {
            // b
            REP(i,0,w) {
                REP(j,0,h) {
                    if (f) f = 0;
                    else printf(" ");
                    printf("%d",b[get_pos(j, i,w)]);
                }
            }
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{

    int n;
    string line;
    double ans = 0;
    __T {
        scanf("%d",&n);
        ans = 0;
        scanf(" ");
        rep(i,1,n) {
            getline(cin,line);
            for (int i = 0;line[i];i ++) {
                if (line[i] == '2') {
                    ans ++;
                    break;
                }
            }
        }
        printf("%.10f\n",ans/n);
    }
    return 0;
}
*/


/*
const int C = 13,H = 1,O = 17;

inline int getM(char c)
{
    if (c == 'C') return C;
    else if (c == 'H') return H;
    else if (c == 'O') return O;
    return 0;
}

int main()
{
    ll ans = 0;
    string str;
    cin >> str;
    int kStart = 0;
    
    
    ll x = 0;
    ll dig = -1;
    int dig_s = -1;
    for (int i = 0;str[i];i ++) {
        if (!(str[i] >= '0' && str[i] <= '9')) {
            if (dig != -1) {
                if (kStart) {
                    x += getM(str[dig_s - 1]) * (dig - 1);
                } else {
                    if (str[dig_s - 1] == ')') {
                        ans += x * dig;
                        x = 0;
                    } else
                        ans += getM(str[dig_s - 1]) * (dig - 1);
                }
                
                dig = -1;
                dig_s = -1;
            }
        }
        if (str[i] == '(') {
            if (i - 1 >= 0 && str[i - 1] == ')') {
                ans += x;
                x = 0;
            }
            kStart = 1;
        }
        else if (str[i] == ')') kStart = 0;
        else {
            if (str[i] == 'C' || str[i] == 'H' || str[i] == 'O') {
                if (i - 1 >= 0 && str[i - 1] == ')') {
                    ans += x;
                    x = 0;
                }
                if (kStart) {
                    x += getM(str[i]);
                } else {
                    ans += getM(str[i]);
                }
            } else if (str[i] >= '0' && str[i] <= '9') {
                if (dig_s == -1) {
                    dig_s = i;
                    dig = 0;
                }
                dig = dig * 10 + (str[i] - '0');
            }
        }
    }
//    cout << dig << endl;
//    cout << dig_s << endl;
    
    if (dig != -1) {
        if (str[dig_s - 1] == ')') {
            ans += x * dig;
            x = 0;
        } else
            ans += getM(str[dig_s - 1]) * (dig - 1);
        dig = -1;
        dig_s = -1;
    }
    if (x != 0) ans += x;
    printf("%lld\n",ans);
    return 0;
}
*/

/*
int main()
{
    int u,v,cnt;
    __T {
        scanf("%d",&cnt);
        rep(i,1,cnt-1) {
            scanf("%d%d",&u,&v);
        }
        puts("Yes");
    }
    return 0;
}
*/


/*
map<ll,ll> mp;

string get(char ch) {
    switch (ch) {
        case '0':
            return "0000";
        case '1':
            return "0001";
        case '2':
            return "0010";
        case '3':
            return "0011";
        case '4':
            return "0100";
        case '5':
            return "0101";
        case '6':
            return "0110";
        case '7':
            return "0111";
        case '8':
            return "1000";
        case '9':
            return "1001";
        case 'A':
            return "1010";
        case 'B':
            return "1011";
        case 'C':
            return "1100";
        case 'D':
            return "1101";
        case 'E':
            return "1110";
        case 'F':
            return "1111";
        default:
            return "0000";
    }
}


char get(string ch) {
    if (ch == "0000") return '0';
    else if (ch == "0001") return '1';
    else if (ch == "0010") return '2';
    else if (ch == "0011") return '3';
    else if (ch == "0100") return '4';
    else if (ch == "0101") return '5';
    else if (ch == "0110") return '6';
    else if (ch == "0111") return '7';
    else if (ch == "1000") return '8';
    else if (ch == "1001") return '9';
    else if (ch == "1010") return 'A';
    else if (ch == "1011") return 'B';
    else if (ch == "1100") return 'C';
    else if (ch == "1101") return 'D';
    else if (ch == "1110") return 'E';
    else if (ch == "1111") return 'F';
    return '0';
}

int main()
{
    int n,m,p;
    scanf("%d%d%d",&n,&m,&p);
    ll py = 1 << (m - p); // 物理
//    ll fy = 1 << (n - p);// 虚拟
    ll t;
    REP(i,0,py) {
        scanf("%lld",&t);
        mp[t] = i;
    }
    string q;
    string bin;
    int idx;
    ll k;
    string a,ans;
    __T {
        cin >> q;
        bin = "";
        a = "";
        for (int i = 0;q[i];i ++) {
            bin += get(q[i]);
        }
        
        
        idx = (int) bin.size() - p - 1;
        k = 0;
        for (int i = 0,j = idx;j >= 0;i ++,j --) {
            k += (1LL << i) * (bin[j] - '0');
        }
//        cout << bin << endl;
//        cout << k << endl;
        if (mp.find(k) == mp.end()) {
            puts("interrupt!");
            continue;
        }
        k = mp[k];
        rep(i,0,idx) {
            a += (char) (((k & (1 << (idx - i))) >> (idx - i)) + '0');
        }
        REP(i,idx + 1,bin.size()) {
            a += bin[i];
        }
        ans = "";
//        cout << a << endl;
        for (int i = 0;i < a.size();i += 4) {
            ans += get(a.substr(i,4));
        }
        cout << ans << endl;
    }
    return 0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    ll n,k;
    ll x;
    ll t;
    int ok;
    __T {
        scanf("%lld%lld",&n,&k);
        if (n % k) {
            puts("-1 -1 -1");
            continue;
        }
        n /= k;
//        printf("%lld\n",n);
        x = n / 3;
        
        ok = 0;
        
        for (ll i = 2;i <= 200;i ++) {
            for (ll j = i;j <= 200;j ++) {
                t = n - i - j;
                if (t <= 1 || t >= n) break;
                if (i!=1&&j!=1&&t!=1&&gcd(i,j) == 1 && gcd(i,t) == 1 && gcd(j,t) == 1) {
                    ok = 1;
                    printf("%lld %lld %lld\n",i*k,j*k,t*k);
                    goto end;
                }
            }
        }
        end:
        if (!ok) puts("-1 -1 -1");
    }
    return 0;
}
*/

/*
const int MAXN = 5010;

struct Edge {
    int to;
    ll w;
    int nxt;
};

int g[MAXN];
Edge e[MAXN * 2];
int cnt = 0;

void add_edge(int u,int v,int w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

void add(int u,int v,int w)
{
    add_edge(u, v, w);
    add_edge(v, u, 0);
}



int main()
{
    int n,m,s,t;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    int u,v,w;
    rep(i,1,m) {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
    }
    
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

struct Edge {
    int to;
    int w;
    int nxt;
};

int g[MAXN]; // Please memset it to -1!!!!!!!!
Edge e[MAXN * 2];
int cnt = 0;

void add_edge(int u,int v,int w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}


int dis[MAXN];
int vis[MAXN];

struct ST {
    int n;
    int w;
    
    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

void dij(int s) {
    mem(dis,-1);
    mem(vis,0);
    
    priority_queue<ST> q;
    q.push({s,dis[s] = 0});
    
    ST current;
    int k,to;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        for (int i = g[current.n];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current.n] + e[i].w;
            if (dis[to] == -1 || dis[to] > k) {
                q.push({to,dis[to] = k});
            }
        }
    }
}

int main()
{
    int n,m;
    int u,v,w;
    int s,t;
    __T {
        cnt = 0;
        mem(g,-1);
        scanf("%d%d",&n,&m);
        while (m --) {
            scanf("%d%d%d",&u,&v,&w);
            add_edge(u,v,w);
            add_edge(v,u,w);
        }
        scanf("%d%d",&s,&t);
        dij(s);
        printf("%d\n",dis[t]);
    }
    return 0;
}
*/

//const int mod = 31607;


/*
int main()
{
    ll b,x;
    __T {
        scanf("%lld%lld",&b,&x);
        if (b % x == 1) puts("T");
        else puts("F");
    }
    return 0;
}
*/

/*
const int mod = 1e9 + 7;
const int MAXN = 2e5 + 10;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll a[MAXN];
ll k[MAXN];

int main()
{
    ll n;
    ll p;
    ll sum;
    ll ans,cur;
    rep(i,1,MAXN-1) {
        k[i] = quickpow(i, mod - 2);
    }
    
    
    __T {
        scanf("%lld",&n);
        p = (1 + n) * n / 2;
        p = quickpow(p % mod, mod - 2);
        rep(i,1,n) scanf("%lld",a + i);
        sum = 0;
        rep(i,1,n) {
            sum += k[i];
            sum %= mod;
        }
        ans = 0;
        cur = sum;
        
        rep(i,1,n / 2) {
            ans += ((a[i] + a[n - i + 1]) % mod) * cur % mod;
            ans %= mod;
            
            sum = (sum + mod - k[i]) % mod;
            sum = (sum + mod - k[n - i + 1]) % mod;
            cur += sum;
            cur %= mod;
        }
        
        if (n & 1) {
            ans += a[n / 2 + 1] * cur;
            ans %= mod;
        }
        
        printf("%lld\n",ans * p % mod);
    }
    return 0;
}
*/

//const int MAXN = 10010;
//const int mod = 998244353;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//struct Edge {
//    int to;
//    int w;
//    int nxt;
//};
//
//int g[MAXN]; // Please memset it to -1!!!!!!!!
//Edge e[MAXN * 2];
//int vis[MAXN];
//int cnt = 0;
//
//void add_edge(int u,int v,int w)
//{
//    e[cnt] = {v,w,g[u]};
//    g[u] = cnt ++;
//}
//
//int n,m;
//int cc = 0;
//ll ans = 0;
//
//void dfs(int k,int c,int a)
//{
//    printf("%d\n",k);
//    if (c == n - 1) {
//        cc ++;
//        ans += a;
//        ans %= mod;
//        return;
//    }
//    int to;
//    for (int i = g[k];~i;i = e[i].nxt) {
//        to = e[i].to;
//        if (vis[to]) continue;
//        vis[to] = 1;
//        dfs(to,c + 1,a & e[i].w);
//        vis[to] = 0;
//        dfs(to,c,a);
//    }
//
//}
//
//int main()
//{
//
//    int u,v,w;
//    mem(vis,0);
//    __T {
//        ans = 0;
//        cc = 0;
//        scanf("%d%d",&n,&m);
//        memn(g,-1,int,n + 5);
//        rep(i,1,m) {
//            scanf("%d%d%d",&u,&v,&w);
//            add_edge(u,v,w);
//            add_edge(v,u,w);
//        }
//        dfs(1,0,INT_INF);
//        printf("%lld\n",ans);
//    }
//    return 0;
//}

/*
class Solution {
public:
    const static int MAXN = 1e6+10;
    
    int cnt = 0;
    
    int r[MAXN];
    int pos0[MAXN];

    int solve(int n, int m, vector<int>& a) {
        // write code here
        int t;
        for (int i = 0;i < n;i ++) {
            if (a[i] == 0) {
                pos0[cnt ++] = i;
            }
            else {
                t = i;
                while (a[i] == 1 && i < n) i ++;
                r[t] = -- i;
            }
        }
        if (cnt == 0) return n;
        
        queue<int> q;
        int i;
        int l = 0;
        int k = 0;
        for (i = 0;i < cnt && i < m;i ++) {
            q.push(pos0[i]);
            k++;
        }
        
        t = 0;
        while (a[t]) {
            t ++;
            l ++;
        }
        
        int mm = 0;
        if (q.back() + 1 < n && a[q.back() + 1]) l += r[q.back() + 1] - q.front() + 1;
        else l += k;
        mm = l;
        
        for (;i < cnt;i ++) {
            
            l = pos0[i] - q.front();
            if (pos0[i] + 1 < n && a[pos0[i] + 1]) {
                l += r[pos0[i] + 1] - pos0[i];
            }
            
            q.push(pos0[i]);
            q.pop();
            mm = max(l,mm);
        }
        return mm;
    }
};

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    vector<int> a;
    int t;
    rep(i,1,n) {
        scanf("%d",&t);
        a.pb(t);
    }
    Solution s;
    cout << s.solve(n,m,a) << endl;
    return 0;
}
*/



/*
const int MAXN = 200;

struct Edge {
    int to;
    int nxt;
};

int g[MAXN];
Edge e[MAXN * 2];
int cnt = 0;

void add_edge(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

set<set<int>> k;

int vis1[MAXN];
int vis[MAXN];
int pre[MAXN];

void dfs(int n,int f,int num) {
    if (num <= 0) return;
//    printf(">>%d %d\n",n,num);
    for (int i = g[n];~i;i = e[i].nxt) {
//        printf("--%d\n",e[i].to);
        if (vis[e[i].to]) {
            if (num == 1 && e[i].to == f) {
                set<int> x;
                x.insert(e[i].to);
                x.insert(n);
                int cur = n;
                while (pre[cur] != -1) {
//                    printf("...%d\n",pre[cur]);
                    x.insert(cur = pre[cur]);
                }
                k.insert(x);
            }
            continue;
        }
        vis[e[i].to] = 1;
        pre[e[i].to] = n;
        dfs(e[i].to,f,num - 1);
        vis[e[i].to] = 0;
    }
}

void dfs1(int n,int num)
{
    if (vis1[n]) return;
    vis1[n] = 1;

    pre[n] = -1;

    vis[n] = 1;
    dfs(n,n,num);
    vis[n] = 0;


    for (int i = g[n];~i;i = e[i].nxt) {

        dfs1(e[i].to,num);
    }
}

int main()
{
    mem(g,-1);
    int n,m;
    scanf("%d%d",&n,&m);

    int u,v;
    rep(i,1,m) {
        scanf("%d%d",&u,&v);
        add_edge(u, v);
        add_edge(v, u);
    }
    mem(vis1,0);
    mem(vis,0);
    dfs1(1,5);

    for (auto i : k) {
        for (auto j : i) {
            printf("%d ",j);
        }
        printf("\n");
    }


    return 0;
}
*/

/// 已知一条边，快速求其两边node个数
/*
const int MAXN = 1e5 + 10;

int all = 0;
int nn;

ll ch[MAXN];
ll a[MAXN];

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please memset it to -1!!!!!!!!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

void dfs(int n, int f)
{
    ch[n] ++;
    
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        if (to == f) continue;
        dfs(to, n);
        ch[n] += ch[to];
    }
    
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        if (to == f) continue;
        a[all ++] = ch[to] * (nn - ch[to]);
    }
    
}


int main()
{
    int u,v;
    scanf("%d",&nn);
    init(nn + 5);
    rep(i,1,nn - 1) {
        scanf("%d%d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    mem(ch,0);
    dfs(1,-1);
    sort(a, a + all);
    nn --;
    ll sum = 0;
    int i = 0;
    while (nn) {
        sum += (nn --) * a[i ++];
    }
    printf("%lld\n",sum);
    return 0;
}
*/


/// 已知一条边，快速求其两边node个数
/*
const int MAXN = 1e5 + 10;
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

struct Edge {
    int to;
    ll w;
    int nxt;
};

int g[MAXN]; // Please memset it to -1!!!!!!!!
Edge e[MAXN * 2];
int cnt = 0;

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

int w[MAXN];
int vis[MAXN];

int ch0[MAXN];
int ch1[MAXN];

void init(int n)
{
    rep(i,1,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
        g[i] = -1;
        vis[i] = 0;
        ch0[i] = 0;
        ch1[i] = 0;
    }
}

ll ans = 0;

pair<int,int> dfs(int n,int f)
{
    ch0[n] = 0;
    ch1[n] = 0;
    
    pair<int, int> t;
    
    for (int i = g[n];~i;i = e[i].nxt) {
        if (e[i].to == f) continue;
        t = dfs(e[i].to,n);
        ch0[n] += t.first;
        ch1[n] += t.second;
    }
    
    if (w[n]) ch1[n] ++;
    else ch0[n] ++;
    
    return make_pair(ch0[n], ch1[n]);
}

void dfs2(int n,int f,int c0,int c1)
{
    int to;
    int t;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        if (to == f) continue;
        
        t = ((c0 + ch0[n] - ch0[to]) % mod) * ch1[to] % mod + ((c1 + ch1[n] - ch1[to]) % mod) * ch0[to] % mod;
        t %= mod;
        
        ans += e[i].w * t;
        ans %= mod;
        dfs2(to,n,c0 + ch0[n] - ch0[to],c1 + ch1[n] - ch1[to]);
    }
}

int main()
{
    int n,m;
    int u,v;
    __T {
        scanf("%d%d",&n,&m);
        cnt = 0;
        init(n + 5);
        rep(i,1,n) scanf("%d",w + i);
        rep(i,1,m) {
            scanf("%d%d",&u,&v);
            if (find(u) != find(v)) {
                add_edge(u, v, quickpow(2, i));
                add_edge(v, u, quickpow(2, i));
                bind(u,v);
            }
        }
        ans = 0;
        
        dfs(1,-1);
        
        dfs2(1,-1,0,0);
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int ok;
    int idx;
    int a1,a2,a3;
    __T {
        cin >> str;
        ok = 1;
        idx = 0;
        a1 = 0;
        a2 = 0;
        a3 = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] == 'P') {
                if (idx == 0) idx ++;
                else {
                    ok = 0;
                    break;
                }
            } else if (str[i] == 'A') {
                if (idx == 0) a1 ++;
                else if (idx == 1) a2 ++;
                else if (idx == 2) a3 ++;
            } else if (str[i] == 'T') {
                if (idx == 1) idx ++;
                else {
                    ok = 0;
                    break;
                }
            } else {
                ok = 0;
                break;
            }
        }
        
//        if (a2 == 0) ok = 0;
//        else if (a2 == 1) ok = ok & (a1 == a3);
//        else if (a2 >= 2) {
//            if (a3 != a1 * (a2 - 1) + a1) ok = 0;
//        }
        
        if (idx != 2) ok = 0;
        if (a2 == 0) ok = 0;
        else ok = ok & (a3 == a1 * a2);
        
        if (ok) puts("YES");
        else puts("NO");
    }
    return 0;
}
*/

/*
typedef struct Stu {
    int id;
    int d,c;
} S[4][100010];

int cmp(const Stu &a,const Stu &b) {
    if (a.d + a.c == b.d + b.c) {
        if (a.d == b.d) return a.id < b.id;
        return a.d > b.d;
    }
    return a.d + a.c > b.d + b.c;
}

int main()
{
    dsci(n);
    dscii(l,h);
    
    S a;
    int cnt[4] = {0};
    int id,d,c;
    Stu *t;
    int type;
    while (n --) {
        sci(id);
        scii(d,c);
        if (d < l || c < l) continue;
        
        if (d >= h && c >= h) type = 0;
        else if (d >= h && c < h) type = 1;
        else if (d < h && c < h && d >= c) type = 2;
        else type = 3;
        
        
        t = &a[type][cnt[type] ++];
        t -> id = id;
        t -> d = d;
        t -> c = c;
    }
    
    int all = 0;
    REP(i,0,4) {
        sort(a[i], a[i] + cnt[i],cmp);
        all += cnt[i];
    }
    printf("%d\n",all);
    REP(i,0,4) {
        REP(j,0,cnt[i]) {
            printf("%d %d %d\n",a[i][j].id,a[i][j].d,a[i][j].c);
        }
//        puts("");
    }
    
    re0;
}
*/

/*
const int mod = 1e9 + 7;

int main()
{
    string str;
    cin >> str;
    
    int p = 0;
    ll a = 0;
    ll ans = 0;
    for (int i = 0;str[i];i ++) {
        if (str[i] == 'P') p ++;
        else if (str[i] == 'A') a = (a + p) % mod;
        else if (str[i] == 'T') ans = (ans + a) % mod;
    }
    printf("%lld\n",ans);
    re0;
}
*/

/*
int main()
{
    dscdd(r1,p1);
    dscdd(r2,p2);
    
    double k1 = r1 * r2 * cos(p1 + p2),
    k2 = r1 * r2 * sin(p1 + p2);
    
    if (fabs(k1) < 0.01) k1 = 0;
    if (fabs(k2) < 0.01) k2 = 0;
    
    if (k1 == 0 && k2 == 0) puts("0.00");
    else printf("%.2f%+.2fi\n",k1,k2);
    
    re0;
}
*/

/// 网络流-最大流模板 EK算法 前向星
/// https://www.luogu.com.cn/problem/P3376
/*
const int MAXN = 5000 + 10;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN * 2];
int g[MAXN];
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}


int pre[MAXN]; // record the previous node index and indicating a node whether has been visited.

ll flow[MAXN];
int n,m;

ll getAgtPath(int s,int t) // method to find an augmented path
{
    // bfs
    queue<int> q;
    q.push(s);
    
    int current;
    memn(pre,-1,int,n + 5);
    
    flow[s] = INT_INF;
    pre[s] = 0; // sourse node has been visited
    
    int to;
    while (!q.empty()) {
        current = q.front();
        q.pop();
        
        if (current == t) break;
        
        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            if (pre[to] != -1 || e[i].w <= 0) continue;
            
            pre[to] = i; // record the index of current edge
            
            flow[to] = min(flow[current],e[i].w);
            q.push(to);
        }
    }
    
    if (pre[t] != -1) return flow[t]; // return the terminal's flow
    return -1; // 404 not found
}

ll EKmaxFlow(int s,int t) // source -> terminal
{
    if (s == t) return INT_INF;
    
    
    ll flow = 0;
    ll agt_flow;
    int cur;
    int edge_idx;
    
    while ((agt_flow = getAgtPath(s, t)) != -1) { // find augmented path until all flows are gone.
        
        // modify the w of path
        cur = t;
        while (cur != s) {
            edge_idx = pre[cur];
            
            e[edge_idx].w -= agt_flow;
            e[edge_idx ^ 1].w += agt_flow; // xor can get the reverse edge swiftly
            
            cur = e[edge_idx ^ 1].to;
        }
        
        flow += agt_flow; // add to ans
    }

    return flow;
}

int vis[210][210];

int main()
{
    int s,t;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    init(n + 5);
    mem(vis,-1);
    int u,v,w;
    rep(i,1,m) {
        scanf("%d%d%d",&u,&v,&w);
        if (vis[u][v] == -1) { // record the vised edge
            add_edge(u, v, w);
            add_edge(v, u, 0); // add reversed edge, which w=0;
            vis[u][v] = cnt - 2;
        }
        else {
            e[vis[u][v]].w += w; // increase the weight
        }
    }
    printf("%lld\n",EKmaxFlow(s, t));
    return 0;
}
*/

/// 网络流-最大流模板 Dinic算法 前向星
/// https://www.luogu.com.cn/problem/P3376
/*
const int MAXN = 5010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memn(dis,-1,int,n + 5);

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    int u,v;
    ll w;
    init(n + 5);
    while (m --) {
        scanf("%d%d%lld",&u,&v,&w);
        add_edge(u, v, w);
        add_edge(v, u, 0);
    }
    printf("%lld\n",dinic());
    return 0;
}
*/

/*
int a[2000010];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int k,t,mm;
    int cnt = 0;
    rep(i,1,n) {
        scanf("%d",&k);
        scanf("%d",&mm);
        k --;
        while (k --) {
            scanf("%d",&t);
            mm = min(mm,t);
        }
        a[cnt ++] = mm;
    }
    sort(a,a + cnt);
    int l = 0,r = m - 1;
    int ans = -1;
    for (;r < cnt;r ++,l ++) {
        if (ans == -1) ans = a[r] - a[l];
        else ans = min(ans,a[r]-a[l]);
    }
    printf("%d\n",ans);
    re0;
}
*/

/*
const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

struct Node {
    int base;
    int px,py;
};


int yy[20][3000010];

int av[20][3000010];

ll eulerFunction(ll x)
{
    ll eulerNumbers = x;
    for(ll i = 2; i*i <= x; i++)
    {
        if(x % i == 0)
        {
            eulerNumbers = eulerNumbers / i * (i-1);
            while(x % i == 0)
            {
                x /= i;
            }
        }
    }
    if(x > 1)
    {
        eulerNumbers = eulerNumbers / x * (x-1);
    }
    return eulerNumbers;
}



int main()
{
    ll a,b,c,d,x,y;
    scanf("%lld%lld%lld%lld%lld%lld",&a,&b,&c,&d,&x,&y);
    
    int cnt = 0;
    
    Node p[1000];
    
    ll xx = max(x,y);
    int kx,ky;
    
    for (int i = 2;i * i <= xx;i ++) {
        kx = 0;
        ky = 0;
        
        
        while (x % i == 0) {
            x /= i;
            kx ++;
        }
        
        while (y % i == 0) {
            y /= i;
            ky ++;
        }
        
        if (kx != 0 && ky != 0)
        {
            p[cnt ++] = {(int)i,kx,ky};
        }
    }
    
    if (x == y && x > 1) {
        p[cnt ++] = {(int)x,1,1};
    }
    
    
    ll s,ss;
    
    REP(i,0,cnt) {
//        printf("%d %d %d\n",p[i].base,p[i].px,p[i].py);
        yy[i][c] = (int) quickpow(p[i].base % mod, c * p[i].py);
        
        s = quickpow(p[i].base % mod, p[i].py);
        ss = s * yy[i][c];
        ss %= mod;
        
        rep(j,(int) c + 1,d) {
            
            yy[i][j] = (yy[i][j - 1] * ss) % mod;
            ss *= s;
            ss %= mod;
        }
        
        s = quickpow(p[i].base % mod, p[i].px);

        
        rep(j,(int) a,b) {
            av[i][j] = 0;
        }
        
    }
    
    ll l,r,m;
    ll cc = d - c + 1;;
    ll cl,cr;
    ll v;
    ll ans = 1;
    for (ll i = a;i <= b;i ++) {
        REP(j,0,cnt) {
            l = c * p[j].py;
            r = d * p[j].py;
            m = i * p[j].px;
            
            
            if (m - l < 0) {
                cr = cc;
                av[j][i] += cr;
                
                
            } else {
                cl = min((m - l) / p[j].py + 1,cc);
                cr = cc - cl;
                

                
                v = c + cl - 1;
                v = yy[j][v];
                

                
                ans *= v;
                ans %= mod;
                
                av[j][i] += cr;

            }
            
            
            
        }
    }
    
    ll kkk = 0;
    
    ll aaa;
    
    ll mm = eulerFunction(mod);
    
    REP(i,0,cnt) {
        kkk = 0;
        s = p[i].px;
        aaa = p[i].px * a % mm;
        kkk += aaa * av[i][a] % mm;
        kkk %= mm;
            
        rep(j,(int) a + 1,b) {
            aaa = aaa + s;
            aaa %= mm;
            
            kkk += aaa * av[i][j] % mm;
            kkk %= mm;
        }
        ans *= quickpow(p[i].base % mod, kkk + mm);
        ans %= mod;
        
    }
    
    printf("%lld\n",ans);
    
    return 0;
}
*/

/*
int n,k;
char a[10][10];
int vis[10];
int ans = 0;

void dfs(int j,int cnt)
{
    if (cnt == k) {
        ans ++;
        return;
    }
    if (j == n) {
        return;
    }
    for (int i = 0;i < n;i ++) {
        if (!vis[i]) {
            if (a[i][j] == '#') {
                vis[i] = 1;
                dfs(j + 1,cnt + 1);
                vis[i] = 0;
            }
        }
    }
    dfs(j + 1,cnt);
}

int main()
{
    while (1) {
        scanf("%d%d",&n,&k);
        if (n == -1 && k == -1) break;
        REP(i,0,n) scanf("%s",a[i]);
        ans = 0;
        dfs(0,0);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int dx[] = {1,-1,0,0,0,0};
int dy[] = {0,0,1,-1,0,0};
int dz[] = {0,0,0,0,1,-1};

int a,b,c;

const int MAXN = 50;

struct Node {
    
    int x,y,z;
    int w;
    
    Node(){}
    Node(int x,int y,int z,int w):x(x),y(y),z(z),w(w){}
    
    bool operator< (const Node &o) const {
        return w > o.w;
    }
};

char mp[MAXN][MAXN][MAXN];
int dis[MAXN][MAXN][MAXN];
int vis[MAXN][MAXN][MAXN];


int main()
{
    priority_queue<Node> q;
    Node cur;
    int xx,yy,zz;
    int k;
    int sx,sy,sz,tx,ty,tz;
    while (~scanf("%d%d%d",&a,&b,&c)) {
        if (a == 0 && b == 0 && c == 0) break;
        while (!q.empty()) q.pop();
        sx = sy = sz = tx = ty = tz = 0;
        REP(i,0,a) {
            REP(j,0,b) {
                scanf("%s",mp[i][j]);
                for (int k = 0;mp[i][j][k];k ++) {
                    if (mp[i][j][k] == 'S') {
                        sx = i;
                        sy = j;
                        sz = k;
                    } else if (mp[i][j][k] == 'E') {
                        tx = i;
                        ty = j;
                        tz = k;
                    }
                }
            }
        }
        mem(dis,-1);
        mem(vis,0);
        q.push(Node(sx,sy,sz,dis[sx][sy][sz] = 0));
        
        while (!q.empty()) {
            cur = q.top();
            q.pop();
            
            if (vis[cur.x][cur.y][cur.z]) continue;
            vis[cur.x][cur.y][cur.z] = 1;
            
            REP(i,0,6) {
                xx = cur.x + dx[i];
                yy = cur.y + dy[i];
                zz = cur.z + dz[i];
                
                if (xx >= 0 && yy >= 0 && zz >= 0 &&
                    xx < a && yy < b && zz < c &&
                    mp[xx][yy][zz] != '#') {
                    k = dis[cur.x][cur.y][cur.z] + 1;
                    if (dis[xx][yy][zz] == -1 || k < dis[xx][yy][zz]) {
                        q.push(Node(xx,yy,zz,dis[xx][yy][zz] = k));
                    }
                }
                
            }
        }
        
        if (dis[tx][ty][tz] == -1) {
            printf("Trapped!\n");
            continue;
        }
        printf("Escaped in %d minute(s).\n",dis[tx][ty][tz]);
    }
    return 0;
}
*/


/*
int vis[2000010] = {0};

struct Node {
    int n,cnt;
    Node(){}
    Node(int n,int cnt):n(n),cnt(cnt){}
};

int main()
{
    dscii(n,k);
    
    
    
    queue<Node> q;
    q.push(Node(n,0));
    
    Node cur;
    
    while (!q.empty()) {
        cur = q.front();
        q.pop();
        
        if (cur.n == k) {
            printf("%d\n",cur.cnt);
            re0;
        }
        
        if (cur.n != 0 && cur.n < k && !vis[cur.n * 2]) {
            q.push(Node(cur.n * 2,cur.cnt + 1));
            vis[cur.n * 2] = 1;
        }
        if (cur.n < k && !vis[cur.n + 1]) {
            q.push(Node(cur.n + 1,cur.cnt + 1));
            vis[cur.n + 1] = 1;
        }
        if (cur.n > 0 && !vis[cur.n - 1]) {
            q.push(Node(cur.n - 1,cur.cnt + 1));
            vis[cur.n - 1] = 1;
        }
    }
    re0;
}
*/

/*
const int MAXN = 1e6 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];
int g[MAXN];
int cnt = 0;

int ch[MAXN];

const int mod = 1e9 + 7;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

void dfs(int n,int f)
{
    ch[n] = 1;
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        if (f == to) continue;
        dfs(to,n);
        ch[n] += ch[to];
    }
}

int main()
{
    int n;
    int u,v;
    ll ans;
    __T {
        sci(n);
        init(n + 5);
        REP(i,0,n - 1) {
            scii(u,v);
            add_edge(u, v);
            add_edge(v, u);
        }
        dfs(1,-1);
        ans = 0;
        rep(i,1,n) {
            ans += ch[i];
            ans %= mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

*/

//const int mod = 998244353;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//
//ll gcd(ll a,ll b)
//{
//    if (a % b == 0) return b;
//    return gcd(b, a % b);
//}
//
//
//int main()
//{
//    ll m,p,q;
//    ll pm,pc,qm,qc;
//    ll gq,gp,ans_c,ans_m;
//    ll a,b;
//    __T {
//        scanf("%lld%lld%lld",&m,&p,&q);
//        qm = pm = 100;
//
//        gp = gcd(p,pm);
//        gq = gcd(q,qm);
//
//        qm /= gq;
//        pm /= gp;
//
//        qc = q;
//
//        qc /= gq;
//        p /= gp;
//
//        a = (qc * quickpow(qm, mod - 2) % mod) * (p * quickpow(pm, mod - 2) % mod) % mod;
//
//        q = 100 - q;
//        qm = 100;
//        gq = gcd(q,qm);
//
//        q /= gq;
//        qm /= gq;
//
//        b = (p * quickpow(pm, mod - 2) % mod) * (q * quickpow(qm, mod - 2) % mod) % mod;
//
//        ans_c = (a + b) % mod;
//        ans_c = quickpow(ans_c, m);
//        printf("%lld\n",ans_c);
//    }
//    return 0;
//}

//const int mod = 998244353;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int main()
//{
//    ll m,p,q;
//    __T {
//        scanf("%lld%lld%lld",&m,&p,&q);
//        p = p * quickpow(100,mod - 2) % mod;
//        q = q * quickpow(100,mod - 2) % mod;
//        printf("%lld\n",(m * quickpow(p,mod - 2) % mod * p % mod - (m * quickpow(p, mod - 2) - 1 + mod) % mod * q % mod + mod) % mod);
//    }
//    return 0;
//}

/*
const int MAXN = 1e6 + 10;

int cnt[MAXN] = {0};

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        cnt[u] ++;
        cnt[v] ++;
    }
    int mx = cnt[1];
    int mi = 1;
    rep(i,2,n) {
        if (cnt[i] > mx) {
            mx = cnt[i];
            mi = i;
        }
    }
    printf("%d %d\n",mi,mx);
    return 0;
}
*/

//int main()
//{
//    int n;
//    __T {
//        scanf("%d",&n);
//        for (int i = 1;i <= n - 1;i ++) {
//            for (int j = i + 1;j <= n;j ++) {
//                printf("%d %d\n",i,j);
//            }
//        }
//    }
//    return 0;
//}

/*
int p;

//set<int> a;
//vector<int> b;

//void dfs(int n)
//{
//    if (n == p) {
//        for (auto i : b) printf("%d ",i);
//        puts("");
//        return;
//    }
//    int k = (*(b.end() - 1) * 2) % p;
//    if (k != 0 && a.find(k) == a.end()) {
//        a.insert(k);
//        b.pb(k);
//        dfs(n + 1);
//        b.erase(b.end() - 1);
//        a.erase(a.find(k));
//    }
//
//    k = (*(b.end() - 1) * 3) % p;
//    if (k != 0 && a.find(k) == a.end()) {
//        a.insert(k);
//        b.pb(k);
//        dfs(n + 1);
//        b.erase(b.end() - 1);
//        a.erase(a.find(k));
//    }
//}

int main()
{
    set<int> a;
    vector<int> b;
    int f;
    int k,v;
    __T {
        scanf("%d",&p);
        a.clear();
        b.clear();
        
        a.insert(1);
        b.pb(1);
        
        rep(i,2,p-1) {
            k = *(b.end() - 1);
            v = k * 2 % p;
            if (a.find(v) == a.end()) {
                a.insert(v);
                b.pb(v);
                continue;
            }
            v = k * 3 % p;
            if (a.find(v) == a.end()) {
                a.insert(v);
                b.pb(v);
            } else break;
        }
        
        f = 1;
        
        if (b.size() == p - 1)
        {
            for (auto i : b) {
                if (f) f = 0;
                else printf(" ");
                printf("%d",i);
            }
            puts("");
        } else puts("-1");
    }
    
    
//    rep(i,1,p-1) {
//        a.insert(i);
//        b.pb(i);
//        dfs(2);
//        a.erase(a.find(i));
//        b.erase(b.end() - 1);
//    }
    
    
    
    
    return 0;
}
*/

//const int MAXN = 1e5 + 10;
//
//struct Edge {
//    int to;
//    int nxt;
//} e[MAXN * 2];
//int g[MAXN]; // Please call init() to memset it to -1!
//int cnt = 0;
//
//void init(int n)
//{
//    cnt = 0;
//    memn(g,-1,int,n);
//}
//
//void add_edge(int u,int v)
//{
//    e[cnt] = {v,g[u]};
//    g[u] = cnt ++;
//}
//
//
//int main()
//{
//    dsci(n);
//    int r1 = 1,r2 = 1;
//    int t;
//    rep(i,1,n) {
//        sci(t);
//        if (t == 0) r1 = t;
//        else {
//
//        }
//    }
//    re0;
//}

//int main()
//{
//    int T,n;
//    scanf("%d",&T);
//    while(T--)
//    {
//        scanf("%d",&n);
//        for(int i=2;i<n;i++)
//            for(int j=1;j<=min(i-1,n-i);j++)
//                printf("%d %d\n",j,i);
//        for(int i=1;i<n;i++)
//        {
//            int k=min(i,n-i);
//            for(int j=n-k+1;j<=n;j++)
//                printf("%d %d\n",i,j);
//        }
//    }
//}

/*
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int l,r;
    pair<int,int> k[100010];
    REP(i,0,m) {
        scanf("%d%d",&l,&r);
        k[i] = mpair(l,r);
    }
    sort(k,k + m);
    int ans = k[0].first - 1;
    int mm = k[0].second;
    REP(i,1,m) {
        if (k[i].first > mm) ans = max(ans,k[i].first - mm - 1);
        mm = max(mm,k[i].second);
    }
    ans = max(ans,n - mm);
    printf("%d\n",ans);
    return 0;
}
*/

/*
int main()
{
    dscii(n,m);
    dsciii(k,l,d);
    pair<int,int> row[1010],col[1010];
    rep(i,1,max(n,m)) {
        row[i].second = i;
        col[i].second = i;
    }
    int a,b,x,y;
    while (d --) {
        scii(a,b);
        scii(x,y);
        if (a == x) col[min(b,y)].first ++;
        if (b == y) row[min(a,x)].first ++;
    }
    sort(row + 1,row + n + 1,greater<pair<int,int>>());
    sort(col + 1,col + m + 1,greater<pair<int,int>>());
    
    vector<int> aa,bb;
    
    rep(i,1,k) aa.pb(row[i].second);
    rep(i,1,l) bb.pb(col[i].second);
    
    sort(aa.begin(),aa.end());
    sort(bb.begin(),bb.end());
    
    int f = 1;
    for (auto i : aa) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    
    f = 1;
    for (auto i : bb) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    
    return 0;
}
*/

//int a[100010];
//
//int main()
//{
//    dscii(n,k);
//    int t;
//    vector<int> m,M;
//    deque<int> q;
//    REP(i,0,n) {
//        sci(t);
//
//    }
//
//
//    return 0;
//}



/*
int main()
{
    int n,x,y;
    int j;
    int nn;
    int cnt_x;
    int ii;
    int f;
    vector<int> ans;
    __T {
        sciii(n,x,y);
        if (x + y > n + 1) {
            puts("NO");
            continue;
        }
        puts("YES");
        
        ans.clear();
        nn = n;
        cnt_x = 0;
        
        while (nn - y + cnt_x + 1 > x) {
            j = nn - y + 1;
            for (int i = 1;i <= y;i ++,j ++) {
                ans.pb(j);
            }
            nn -= y;
            cnt_x ++;
        }
        
        for (j = 0,ii = x - cnt_x;ii <= nn;ii ++,j ++) {
            ans.pb(ii);
        }
        nn -= j;
        pre(i,nn,1) ans.pb(i);
        
        f = 1;
        for (auto i = ans.rbegin();i != ans.rend();i ++) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",*i);
        }
        puts("");
    }
}
*/

//struct Edge {
//    ll n;
//    int x1,y1;
//    int x2,y2;
//};
//
//int vis[2010][2010];
//int xx[2010],yy[2010];
//Edge dis[4000010];
//int cnt;
//
//ll get_dis(ll x1,ll y1,ll x2,ll y2) {
//    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
//}
//
//int cmp(const Edge &a,const Edge &b) {
//    return a.n > b.n;
//}
//
//int main()
//{
////    int u,v;
//    int n;
//    __T {
//        sci(n);
//        REP(i,0,n) scanf("%d%d",xx + i,yy + i);
//        cnt = 0;
//        REP(i,0,n) {
//            REP(j,0,n) {
//                dis[cnt ++] = {get_dis(xx[i], yy[i], xx[j], yy[j]),xx[i],yy[i],xx[j],yy[j]};
//            }
//        }
//        sort(dis,dis + cnt,cmp);
//        if ((dis[0].x1 == xx[0] && dis[0].y1 == yy[0]) || (dis[0].x2 == xx[0] && dis[0].y2 == yy[0])) {
//            puts("YES");
//            continue;
//        }
//
//
//    }
//    return 0;
//}


/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int dx[] = {0,0,1,-1,1,-1,1,-1};
int dy[] = {1,-1,0,0,1,-1,-1,1};

set<pair<ll,ll>> vis;

void bfs(ll x,ll y)
{
    queue<pair<ll, ll>> q;
    q.push(mpair(x,y));
    pair<ll,ll> cur,k;
    int f = 1;
    ll xx,yy;
    
    ll ch = 0;
    ll mt = 0;
    
    vis.clear();
    vis.insert(mpair(x,y));
    while (!q.empty()) {
        cur = q.front();
        q.pop();
        
        REP(i,0,8) {
            xx = cur.first + dx[i];
            yy = cur.second + dy[i];
            if (gcd(xx,yy) > 1) {
                
                if (xx == yy && xx != 1) {
                    printf("0/1\n");
                    return;
                }
                
                if (f) ch ++;
                mt ++;
                k = mpair(xx,yy);
                if(vis.find(k) == vis.end()) {
                    q.push(k);
                    vis.insert(k);
                }
            }
        }
        if (f) {
            f = 0;
            ch ++;
        }
        mt ++;
    }
    printf("%lld/%lld\n",ch / gcd(ch,mt),mt / gcd(ch,mt));
}

int main()
{
    ll x,y;
    __T {
        scanf("%lld%lld",&x,&y);
        bfs(x,y);
    }
    return 0;
}
*/

/*
int main()
{
    dscii(n,k);
    int t;
    deque<pair<int,int>> qm,qM;
    vector<int> ansm,ansM;
    rep(i,1,n) {
        sci(t);

        while (!qm.empty() && qm.back().first > t) qm.pop_back();
        while (!qM.empty() && qM.back().first < t) qM.pop_back();

        qm.push_back(mpair(t,i));
        qM.push_back(mpair(t,i));
        
//        for (auto i : qm) {
//            printf("%d ",i.first);
//        }
//        puts("");
        
        if (i >= k) {
            ansm.pb(qm.front().first);
            ansM.pb(qM.front().first);
        }
        
        if (qm.front().second == i - k + 1) {
            qm.pop_front();
        }

        if (qM.front().second == i - k + 1) {
            qM.pop_front();
        }
    }
    int f = 1;
    for (auto i : ansm) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    f = 1;
    puts("");
    for (auto i : ansM) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    return 0;
}
*/

/*
const int mod = 1e9 + 7;

class Matrix
{
    const static int MAXN = 10;

    ll a[MAXN][MAXN];

public:
    int w;
    int h;

    Matrix(int h,int w):w(w),h(h)
    {
        mem(a,0);
    }

    Matrix(const char format[], ...) {

        va_list args;
        w = 0;
        h = 0;

        char buf[1000];

        va_start(args, format);
        vsprintf(buf, format, args);
        va_end(args);

        stringstream ss(buf);
        stringstream num;
        ll n;
        string line;
        while (getline(ss, line)) {
            num.clear();
            num << line;
            w = 0;
            while (num >> n) {
                a[h + 1][++ w] = n;
            }
            h ++;
        }
    }

    void E()
    {
        if (w == h) {
            mem(a,0);
            rep(i,1,w) a[i][i] = 1;
        }
    }

    void print()
    {
        int f = 1;
        rep(i,1,h) {
            f = 1;
            rep(j,1,w) {
                if (f) f = 0;
                else printf(" ");
                printf("%lld",a[i][j]);
            }
            puts("");
        }
    }

    void read_in()
    {
        rep(i,1,h) {
            rep(j,1,w) {
                scanf("%lld",&a[i][j]);
            }
        }
    }

    Matrix operator* (const Matrix &B) const
    {
        if (w != B.h) return Matrix(0,0); // invalid

        Matrix ans(h,B.w);
        rep(i,1,h) {
            rep(j,1,B.w) {
                rep(k,1,w) {
//                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j]); // Not Moduled
                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j] % mod) % mod; // Moduled
                }
            }
        }
        return ans;
    }

    const ll* operator[] (int i) const {
        return a[i];
    }

    ll* operator[] (int i) {
        return a[i];
    }
};

Matrix quickpow(Matrix a, ll b)
{
    if (a.h != a.w) return Matrix(0,0); // invalid

    Matrix ans(a.h,a.w);
    rep(i,1,ans.h) ans[i][i] = 1; // Set ans matrix to E
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

int main()
{
    dscl(n);
    printf("%lld\n",quickpow(Matrix("1 1\n1 0"), n)[1][1] * quickpow(Matrix("1 1\n1 0"), n - 1)[1][1] % mod);
    re0;
}
*/

/*
int a[20]['Z' + 1];
int b['Z' + 1];

int main()
{
    dsci(n);
    string line;
    mem(a,0);
    REP(i,0,n) {
        cin >> line;
        for (int j = 0;line[j];j ++) {
            a[i][line[j]] ++;
        }
    }
    int nn = 1 << n;
    int k;
    int m;
    int ok;
    int ans = 0;
    REP(i,0,nn) {
        k = i;
        m = 0;
        ok = 1;
        mem(b,0);
        for (int x = 0;x < n;x ++) {
            if (k & 1) {
                m ++;
                rep(j,'A','Z') b[j] += a[x][j];
            }
            k >>= 1;
        }
//        printf(">>%d\n",i);
        rep(j,'A','Z') {
//            printf("%d",b[j] % 3);
            if (b[j] % 3) {
                ok = 0;
                break;
            }
        }
//        puts("");
        
        
        if (ok) ans = max(ans,m);
    }
    printf("%d\n",ans);
    return 0;
}
*/

/*
int main()
{
    ll x1,x2,x3,y1,y2,y3;
    ll ABx,ABy;
    ll BCx,BCy;
    __T {
        scll(x1,y1);
        scll(x2,y2);
        scll(x3,y3);
        ABx = x2 - x1;
        ABy = y2 - y1;
        
        BCx = x3 - x2;
        BCy = y3 - y2;
        
        if (ABx * BCy - ABy * BCx > 0)
        {
            puts("Counterclockwise");
        } else puts("Clockwise");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        int k = 0;
        if (n % 2) {
            printf("612423534645156261");
            n -= 3;
            k = 4;
        } else {
            printf("134561");
            n -= 2;
            k = 3;
        }
        for (int i = 0;i < n / 2;i ++) {
            printf("6");
            
            for (int j = 0;j < k;j ++) {
                printf("13");
            }
            printf("4");
            for (int j = 0;j < k - 1;j ++) {
                printf("24");
            }
            printf("5");
            for (int j = 0;j < k - 1;j ++) {
                printf("35");
            }
            printf("6");
            for (int j = 0;j < k - 1;j ++) {
                printf("46");
            }
            printf("1");
            for (int j = 0;j < k - 1;j ++) {
                printf("51");
            }
            for (int j = 0;j < k - 2;j ++) printf("26");
            printf("1");
            k += 2;
        }
        puts("");
    }
    
    return 0;
}
*/


/*
int p[5000000];
char str[5000010];
int cntp = 0;

int pre['z' - 'a' + 1]['z' - 'a' + 1][2];

int n;

inline void add(int k) {
    if (k != n) {
        p[cntp ++] = k;
    }
}


int main()
{
    int k;
    int ok;
    
    __T {
        sci(n);
        scanf("%s",str);
        if (n == 1) {
            printf("No\n");
            continue;
        }
        cntp = 0;
        for (int i = 1;i * i <= n;i ++) {
            if (n % i == 0) {
                add(i);
                if (i != n / i) {
                    add(n / i);
                }
            }
        }
        
        ok = 0;
        
        REP(i,0,cntp) {
            mem(pre,0);
            k = p[i];
            REP(j,0,k) {
                pre[str[j] - 'a'][str[(j + k - 1) % k] - 'a'][0] ++;
            }
            
            for (int j = k,v = 0;str[j];j += k,v = !v) {
                for (int x = 0;x < k;x ++) {
                    if (pre[str[x + j] - 'a'][str[(x + k - 1) % k + j] - 'a'][v]) {
                        pre[str[x + j] - 'a'][str[(x + k - 1) % k + j] - 'a'][v] --;
                        pre[str[x + j] - 'a'][str[(x + k - 1) % k + j] - 'a'][!v] ++;
                    }
                    else goto err;
                }
            }
            ok = 1;
            break;
            err:;
        }
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
*/

/*
int main()
{
    int n,m,t;
    __T {
        sci(n);
        rep(i,1,n) {
            sci(t);
            if (i == 1) m = t;
            else m = max(m,t);
        }
        printf("%d\n",m);
    }
    return 0;
}
*/

/*
inline void out(int &f,string &k) {
    string t;
    int x = 1;
    if (k != "") {
        if (f) f = 0;
        else printf(" ");
        t = "";
        for (int i = 0;k[i];i ++) {
            if (k[i] == '0') {
                if (!x) t += k[i];
            } else {
                t += k[i];
                x = 0;
            }
        }
        if (t == "") printf("0");
        else cout << t;
        k = "";
    }
}

int main()
{
    string str;
    int f,x;
    string k,v;
    while (getline(cin,str)) {
        f = 1;
        k = "";
        for (int i = 0;str[i];i ++) {
            if (str[i] >= '0' && str[i] <= '9') {
                k += str[i];
            } else {
                x = 1;
                out(f,k);
            }
        }
        out(f,k);
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n % 3) puts("Alan");
        else puts("Frame");
    }
    return 0;
}
*/

/*
int isNum(char a)
{
    return a >= '0' && a <= '9';
}

inline int cmp(const string a,const string b)
{
    string na,nb;
    int i,j;
    for (i = 0,j = 0;a[i] && b[j];) {
        if (!isNum(a[i]) && isNum(b[j])) {
//            _C(1);
            return 1;
        } else if (isNum(a[i]) && !isNum(b[j])) {
//            _C(2);
            return 0;
        } else if (!isNum(a[i]) && !isNum(b[j])) {
//            _C(a[i] << " " << b[j]);
            if (a[i] != b[j]) return a[i] > b[j];
            i ++;
            j ++;
        } else if (isNum(a[i]) && isNum(b[j])) {
            na = "";
            nb = "";
            
            while (a[i] && isNum(a[i])) {
                na += a[i];
                i ++;
            }
            while (b[j] && isNum(b[j])) {
                nb += b[j];
                j ++;
            }
            
            if (na.size() > nb.size()) return 1;
            else if (na.size() < nb.size()) return 0;
            else {
                for (int k = 0;na[k];k ++) {
                    if (na[k] > nb[k]) return 1;
                    else if (na[k] < nb[k]) return 0;
                }
            }
        }
    }
    
    if (a[i] && !b[j]) return 1;
    else if (!a[i] && b[j]) return 0;
    return 1;
}

int main()
{
    dsci(n);
    string k;
    cin >> k;
    string str;
    while (n --) {
        cin >> str;
        if (cmp(str,k)) puts("+");
        else puts("-");
    }
    return 0;
}
*/

/*
int main()
{
    dsci(n);
    int a[5010];
    rep(i,1,n) sci(a[i]);
    sort(a + 1,a + 1 + n);
    int d;
    int m = a[n];
    int t;
    int ans = 1;
    rep(i,1,n - 1) {
        rep(j,i + 1,n) {
            d = a[j] - a[i];
            t = 0;
            for (int j = a[i];j <= m;j += d) {
                if (binary_search(a + 1, a + 1 + n, j)) {
                    t ++;
                } else break;
            }
            ans = max(ans,t);
        }
    }
    printf("%d\n",ans);
    return 0;
}
*/

/*
ll a[500010];

int main() {
    dsciii(r,s,p);
    int x,y;
    int t;
    rep(i,1,p) {
        scii(x,y);
        if (y <= s) t = r - x + 1 + s - y + 1;
        else t = r - x + 1 + y - s;
        a[i] = t;
    }

    sort(a + 1,a + 1 + p,greater<ll>());
    ll ans = a[1];
    rep(i,2,p) {
        ans = max(ans,a[i] + i - 1);
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
struct Point {
    int x;
    int y;
};
 

class Solution {
public:
    
    vector<int> g[100010];
    
    int NN[100010];
    int MM[100010];
    
    int ans = 0;
    
    void dfsN(int n,int f,int d)
    {
        NN[n] = d;
        for (auto i : g[n]) {
            if (f == i) continue;
            dfsN(i,n,d + 1);
        }
    }
    
    void dfsM(int n,int f,int d)
    {
        MM[n] = d;
        if (MM[n] <= NN[n]) {
            ans = max(ans,NN[n]);
            if (MM[n] == NN[n]) return;
        }
        for (auto i : g[n]) {
            if (f == i) continue;
            dfsM(i,n,d + 1);
        }
    }
    
    
    int solve(int n, int x, vector<Point>& Edge) {
        // write code here
        if (x == 1) return 0;
        for (auto i : Edge) {
            g[i.x].pb(i.y);
            g[i.y].pb(i.x);
        }
        dfsN(1,-1,1);
        dfsM(x,-1,1);
        return ans;
    }
};

int main()
{
    dscii(n,x);
    
    int u,v;
    vector<Point> a;
    rep(i,1,n - 1)
    {
        scii(u,v);
        a.pb({u,v});
    }
    Solution s;
    printf("%d\n",s.solve(n, x, a));
    return 0;
}

*/

/*
const int MAXN = 100100;

ll dis[MAXN];
int vis[MAXN];

struct ST {
    int n;
    ll w;

    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

vector<ST> g[MAXN];

void dij(int s) {
    mem(dis,-1);
    mem(vis,0);

    priority_queue<ST> q;
    q.push({s,dis[s] = 0});

    ST current;
    ll k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;

        for (auto to : g[current.n]) {
            k = dis[current.n] + to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
}

void add(int u,int v,ll w)
{
    g[u].pb({v,w});
}

int main()
{
    int n;
    ll t;
    int k;
    __T {
        sci(n);
        rep(i,1,MAXN) g[i].clear();
        
        rep(i,1,n) {
            scl(t);
            k = 1;
            while (t != 0) {
                if (t & 1) {
                    add(i, n + k, 1ll << (k - 1));
                    add(n + k, i, 0);
                }
                k ++;
                t >>= 1;
            }
        }
        
        dij(1);
        
        if (~dis[n])
            printf("%lld\n",dis[n]);
        else puts("Impossible");
    }
    re0;
}
*/

/*
const int MAXN = 100010;

struct Edge {
    int to;
    int nxt;
    ll w;
} e[MAXN * 2];

int g[MAXN];
int cnt = 0;

void add(int u,int v,ll w) {
    e[cnt] = {v,g[u],w};
    g[u] = cnt ++;
}

void init()
{
    mem(g,-1);
    cnt = 0;
}

ll dis[MAXN];
ll dis2[MAXN];
int vis[MAXN];

struct ST {
    int n;
    ll w;

    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

void dij(int s) {
    mem(dis,-1);
    mem(dis2,-1);
    mem(vis,0);

    priority_queue<ST> q;
    q.push({s,dis[s] = 0});

    ST current;
    ll k;
    int to;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (dis2[current.n] != -1 && dis2[current.n] < current.w) continue;

        for (int i = g[current.n];~i;i = e[i].nxt) {
            to = e[i].to;
            k = current.w + e[i].w;
            if (dis[to] == -1 || dis[to] > k) {
                swap(dis[to],k);
                q.push({to,dis[to]});
            }
            if ((dis2[to] == -1 || dis2[to] > k) && dis[to] < k) {
                q.push({to,dis2[to] = k});
            }
        }
    }
}

int main()
{
    dscii(n,m);
    init();
    int u,v;
    ll w;
    rep(i,1,m) {
        scii(u,v);
        scl(w);
        add(u,v,w);
        add(v,u,w);
    }
    dij(0);
  
    printf("%lld\n",dis2[n - 1]);
    
    re0;
}
*/

//const int MAXN = 5e5 + 10;
//
//struct Edge {
//    int to;
//    int nxt;
//} e[MAXN * 2];
//int g[MAXN]; // Please call init() to memset it to -1!
//int cnt = 0;
//
//void init(int n)
//{
//    cnt = 0;
//    memn(g,-1,int,n);
//}
//
//void add_edge(int u,int v)
//{
//    e[cnt] = {v,g[u]};
//    g[u] = cnt ++;
//}
//
//struct DPS {
//    int n;
//    ll d;
//};
//
//struct Node {
//    int i;
//    ll d;
//};
//
//ll ans = 0;
//ll dps[MAXN];
//int vis[MAXN];
//int p[MAXN];
//ll ch[MAXN];
//Node ddd[MAXN];
//
////void dfs(int n,ll d) {
////    int to;
////    dps[n] = d;
////    ch[n] = 1;
////    for (int i = g[n];~i;i = e[i].nxt) {
////        to = e[i].to;
////        dfs(to,d + 1);
////        ch[n] += ch[to];
////    }
////}
//
//
//
//int cmp(const Node &a,const Node &b)
//{
//    return a.d > b.d;
//}
//
//void bfs()
//{
//    queue<DPS> q;
//    q.push({1,1});
//    DPS cur;
//    int to;
//    while (!q.empty()) {
//        cur = q.front();
//        dps[cur.n] = cur.d;
//        q.pop();
//        for (int i = g[cur.n];~i;i = e[i].nxt) {
//            to = e[i].to;
//            q.push({to,cur.d + 1});
//        }
//    }
//}
//
//int main()
//{
//    int n;
//    ll mx;
//    int mx_i;
//    __T {
//        sci(n);
//        init(n + 5);
//        rep(i,2,n) {
//            sci(p[i]);
//            add_edge(p[i], i);
//        }
//        p[1] = -1;
//        ans = 0;
////        dfs(1,1);
//        bfs();
//
//        rep(i,1,n) {
//            ddd[i] = {i,dps[i]};
//            ch[i] = 1;
//        }
//        sort(ddd + 1, ddd + 1 + n, cmp);
//
//
//        mx = ddd[1].d;
//        mx_i = ddd[1].i;
//
//        rep(i,1,n) {
//            ch[p[i]] += ch[i];
//        }
//
////        rep(i,1,n) printf("%lld ",ch[i]);
////        puts("");
//
////        cout << mx << endl;
////        cout << mx_i << endl;
//        ans += mx * n;
//        memn(vis,0,int,n + 5);
//        while (mx_i != -1) {
//            vis[mx_i] = 1;
//            mx_i = p[mx_i];
//        }
//        rep(i,1,n) {
//            if (vis[i]) continue;
//            ans += ch[i];
//        }
//        printf("%lld\n",ans);
//    }
//    return 0;
//}


/*
const int MAXN = 5e5 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

ll ans = 0;
int p[MAXN];
ll ch[MAXN];

void dfs(int n) {
    int to;
    ch[n] = 1;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs(to);
        ch[n] += ch[to];
    }
}

int n;

void dfs2(int k,ll x)
{
    if (ch[k] == 1) {
        ans = max(x,ans);
        return;
    }
    int to;
    for (int i = g[k];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs2(to,x + n - ch[to]);
    }
}

int main()
{
    __T {
        sci(n);
        init(n + 5);
        rep(i,2,n) {
            sci(p[i]);
            add_edge(p[i], i);
        }
        p[1] = -1;
        ans = 0;
        dfs(1);
        dfs2(1,0);
        rep(i,1,n) ans += ch[i];
        printf("%lld\n",ans);
        
    }
    return 0;
}
*/

//int main()
//{
//    ll a,b,k;
//    ll x,y;
//    __T {
//        sclll(a,b,k);
//        if (b < a) swap(a,b);
//
//        if (a == 0) {
//            puts("1");
//            continue;
//        }
//
////        a *= 2;
//        ll m = (k + 1) * 2 + 1;
//        ll c = a;
//        cout << ((k + 1) * (m - 2) + (k + 2) * 2) << endl;
//        c -= (a / ((k + 1) * (m - 2) + (k + 2) * 2)) * (m - 1);
//
//        printf(">>%lld\n",(a / (m * ((k + 1) * (m - 2) + (k + 2) * 2))) * (m - 1));
//        printf("%lld %lld\n",m,c);
//    }
//    return 0;
//}


/*
int main()
{
    string str;
    cin >> str;
    itn cnt = 0;
    int o1 = 0;
    int o0 = 0;
    for (int i = 0;str[i];i ++) {
        if (str[i] == '0') o0 = 1;
        if (str[i] == '1') o1 = 1;
        if (o0 && o1) {
            cnt ++;
            o0 = o1 = 0;
        }
    }
    printf("%d\n",cnt);
    return 0;
}
*/

/*
void solve(int s)
{
    char a[30][30];
    int n = s / 8;
    int m = s % 8;
    int r = 0,c = 0;
    
    if (m == 3 || m == 5 || m == 6 || m == 7) n ++;
    
    r = min(n * 2 + 1,25);
    c = n / 12;
    if (n % 12) c ++;
    c = c * 2 + 1;
    printf("%d %d\n",c,r);
    int cnt = 0;
    REP(i,0,c) {
        REP(j,0,r) {
            if (i & 1 && j & 1 && cnt < n) {
                a[i][j] = 'X';
                cnt ++;
            }
            else a[i][j] = '.';
        }
    }
    
    if (m == 1) {
        a[0][0] = 'X';
    } else if (m == 2) {
        a[0][0] = 'X';
        a[0][1] = 'X';
    } else if (m == 3) {
        a[1][1] = '.';
        a[0][0] = 'X';
    } else if (m == 4) {
        a[1][0] = 'X';
        a[0][1] = 'X';
    } else if (m == 5) {
        a[0][0] = 'X';
        a[0][1] = 'X';
        
        a[1][r - 2] = '.';
        a[0][r - 1] = 'X';
    } else if (m == 6) {
        a[1][3] = '.';
        a[1][2] = 'X';
    } else if (m == 7) {
        a[1][1] = '.';
        a[0][0] = 'X';
        a[1][0] = 'X';
        a[0][1] = 'X';
    }
    REP(i,0,c) {
        REP(j,0,r) {
            printf("%c",a[i][j]);
        }
        puts("");
    }
}

int main()
{
    int s;
    __T {
        sci(s);
        if (s == 0) {
            printf("1 1\n");
            printf("X\n");
        } else if (s == 1) {
            printf("1 2\n");
            printf("X.\n");
        } else if (s == 2) {
            printf("1 3\n");
            printf("X.X\n");
        } else if (s == 3) {
            puts("2 2");
            puts("X.\n..");
        } else if (s == 4) {
            printf("2 2\n");
            printf(".X\nX.\n");
        } else if (s == 5) {
            puts("1 6");
            puts("X.X.X.");
        } else if (s == 6) {
            puts("1 7");
            puts(".X.X.X.");
        } else if (s == 7) {
            puts("3 3");
            puts("XX.\nX..\n...");
        } else if (s == 8) {
            puts("3 3");
            puts("...\n.X.\n...");
        } else if (s == 9) {
            puts("3 3");
            puts("X..\n.X.\n...");
        } else if (s == 10) {
            puts("3 3");
            puts("XX.\n.X.\n...");
        } else if (s == 11) {
            puts("3 5");
            puts("X....\n...X.\n.....");
        } else if (s == 12) {
            puts("3 3");
            puts(".X.\nXX.\n...");
        } else if (s == 13) {
            puts("5 3");
            puts("XX.\n.X.\n...\n...\nX..");
        } else if (s == 14) {
            puts("3 4");
            puts("....\n.XX.\n....");
        } else {
            solve(s);
        }
    }
    re0;
}
*/


//const int mod = 1e9 + 7;
//
//int a[5010];
//int vis[5010];
//int n;
//
//ll dfs(int x,int k)
//{
//    if (x == n) return 1;
//    ll sum = 0;
//    if (a[x] == 0) {
//        rep(i,k + 1,n) {
//            if (vis[i]) continue;
//            vis[i] = 1;
//            sum += dfs(x + 1,i);
//            vis[i] = 0;
//        }
//    } else {
//        pre(i,k - 1,1) {
//            if (vis[i]) continue;
//            vis[i] = 1;
//            sum += dfs(x + 1,i);
//            vis[i] = 0;
//        }
//    }
//    return sum;
//}
//
//int main()
//{
////    mem(vis,0);
////    __T {
////        sci(n);
////        rep(i,1,n - 1) sci(a[i]);
////        ll ans = 0;
////        rep(i,1,n) {
////            vis[i] = 1;
////            ans += dfs(1,i);
////            vis[i] = 0;
////        }
////        printf("%lld\n",ans);
////    }
//
//    sci(n);
//    int x = n - 1;
//    int xx = 1 << x;
//    int t;
//    ll ans;
//    REP(i,0,xx) {
//        t = i;
//        for (int j = x;j >= 1;j --) {
//            a[j] = t & 1;
//            t >>= 1;
//        }
//        rep(j,1,x) printf("%d",a[j]);
//        ans = 0;
//        rep(i,1,n) {
//            vis[i] = 1;
//            ans += dfs(1,i);
//            vis[i] = 0;
//        }
//        printf(" = %lld\n",ans);
//    }
//    return 0;
//}

/*
struct Node {
    int n;
    int i;
} a[105];

int cmp(const Node &a,const Node &b)
{
    if (a.n == b.n) return a.i < b.i;
    return a.n > b.n;
}

int main()
{
    int n,m,k;
    __T {
        sciii(n,m,k);
        rep(i,1,n) {
            sci(a[i].n);
            a[i].i = i;
        }
        if (k == 0) {
            rep(i,1,n) {
                if (i != 1) {
                    printf(" ");
                }
                printf("%d",i);
            }
            puts("");
            continue;
        }
        sort(a + 1,a + 1 + n,cmp);
        rep(i,1,n) {
            if (i != 1) {
                printf(" ");
            }
            printf("%d",a[i].i);
        }
        puts("");
    }
    re0;
}
*/

/*
const int MAXN = 1000;

struct Edge {
    int to;
    int nxt;
    ll w;
} e[MAXN * 2];

int cnt = 0;
int g[MAXN];

void init()
{
    mem(g,-1);
    cnt = 0;
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,g[u],w};
    g[u] = cnt ++;
}

ll a[MAXN];
ll dis[MAXN];
ll vis[MAXN];
ll mm[MAXN];

struct Node {
    int n;
    ll w;
    ll a;
    bool operator <(const Node &o) const {
        return w > o.w;
    }
};

void dij(int s)
{
    mem(dis,-1);
    mem(vis,0);
    mem(mm,0);
    priority_queue<Node> q;
    q.push({s,dis[s] = 0,a[s]});
    
    Node cur;
    int to;
    ll cost;
    while (!q.empty()) {
        cur = q.top();
        q.pop();
        
        if (cur.w > dis[cur.n]) continue;
        if (cur.w == dis[cur.n]) {
            vis[cur.n] ++;
            mm[cur.n] = max(mm[cur.n],cur.a);
        }
        
        for (int i = g[cur.n];~i;i = e[i].nxt) {
            to = e[i].to;
            cost = cur.w + e[i].w;
            if (dis[to] == -1 || dis[to] >= cost) {
                q.push({to,dis[to] = cost,cur.a + a[to]});
            }
        }
    }
}

int main()
{
    int n,m,c1,c2;
    scii(n,m);
    scii(c1,c2);
    rep(i,0,n - 1) scl(a[i]);
    init();
    int u,v;
    ll w;
    rep(i,1,m) {
        scii(u,v);
        scl(w);
        add_edge(u,v,w);
        add_edge(v,u,w);
    }
    dij(c1);
    printf("%lld %lld\n",vis[c2],mm[c2]);
    
    return 0;
}
*/

/*
const int MAXN = 110;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];

int cnt;
int g[MAXN];

int dps[MAXN];
int mx_d;

void init()
{
    mem(g,-1);
    cnt = 0;
    
    mem(dps,0);
    mx_d = -1;
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

void dfs(int n,int d)
{
    mx_d = max(mx_d,d);
    int cnt = 0;
    int to;
    
    for (int i = g[n];~i;i = e[i].nxt,cnt ++)
    {
        to = e[i].to;
        dfs(to,d + 1);
    }
    
    if (cnt == 0) dps[d] ++;
}

int main()
{
    int n,m;
    int id,k;
    int v;
    while (~scii(n,m)) {
        if (n == 0) break;
        init();
        while (m --) {
            scii(id,k);
            while (k --) {
                sci(v);
                add(id,v);
            }
        }
        
        dfs(1,0);
        
        rep(i,0,mx_d) {
            if (i) printf(" ");
            printf("%d",dps[i]);
        }
        puts("");
    }
    
    return 0;
}
*/

/*
int main()
{
    string str;
    int h,m,s,hh,mm,ss;
    string min_str,max_str;
    int mi = INT_INF;
    int mx = -1;
    int i,x;
    __T {
        cin >> str;
        scanf("%d:%d:%d",&h,&s,&m);
        scanf("%d:%d:%d",&hh,&mm,&ss);
        i = h * 10000 + m * 100 + s;
        x = hh * 10000 + mm * 100 + ss;
        if (i < mi) {
            mi = i;
            min_str = str;
        }
        if (x > mx) {
            mx = x;
            max_str = str;
        }
    }
    cout << min_str << " " << max_str << endl;
    return 0;
}
*/

/*
int main()
{
    dsci(n);
    deque<int> q;
    char a,b;
    int k;
    int i = 1;
    while (n --) {
        scanf(" %c %c",&a,&b);
        if (a == 'A' && b == 'L') {
            q.push_front(i ++);
        } else if (a == 'A' && b == 'R') {
            q.push_back(i ++);
        } else if (a == 'D' && b == 'L') {
            scanf("%d",&k);
            rep(i,1,k) q.pop_front();
        } else if (a == 'D' && b == 'R') {
            scanf("%d",&k);
            rep(i,1,k) q.pop_back();
        }
    }
    while (!q.empty()) {
        printf("%d\n",q.front());
        q.pop_front();
    }
    return 0;
}
*/

/*
int n,m;
ll a[100010];
ll s[100010];

inline bool check(ll x) {
    int l = 0;
    int cnt = 0;
    rep(i,1,n) {
//        printf(">>%lld\n",s[i] - s[l]);
        if (a[i] > x) return 0;
        if (s[i] - s[l] > x)
        {
            cnt ++;
            l = i - 1;
        }
    }
//    printf(">>%lld\n",s[n] - s[l]);
    cnt ++;
//    cout << cnt << endl;
    return cnt <= m;
}

int main()
{
    scii(n,m);
    s[0] = 0;
    rep(i,1,n) {
        scl(a[i]);
        s[i] = s[i - 1] + a[i];
    }
//    rep(i,1,n) printf("%d ",s[i]);
    ll l,r,mm;
    l = s[1];
    r = s[n];
    while (l < r) {
        mm = (l + r) / 2;
        if (check(mm)) {
            r = mm;
        } else l = mm + 1;
    }
    printf("%lld\n",r);
    return 0;
}
*/

/*
ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n;
    ll a[1000];
    int cnt = 0;
    sci(n);
    string str;
    scanf(" ");
    getline(cin,str);
    
    stringstream ss(str);
    ll t;
    while (ss >> t) {
        a[cnt ++] = t;
    }
    
    map<ll,int> vis;
    ll x;
    rep(i,2,n + 1) {
        REP(j,0,cnt) {
            if (vis[a[j]] && vis[a[j]] != i) continue;
            t = a[j];
            x = 0;
            while (t) {
                x += quickpow(t % 10,i);
                t /= 10;
            }
            vis[x] = i;
        }
    }
    sort(a,a + cnt);
    int f = 1;
    REP(i,0,cnt) {
        if (vis[a[i]]) continue;
        if (f) f = 0;
        else printf(" ");
        printf("%lld",a[i]);
    }
    puts("");
    re0;
}
*/

/*
const int MAXN = 1e6 + 10;

int is_prime[MAXN];
int is_prime_small[MAXN];


void segment_sieve(ll a,ll b)
{
    for (ll i = 0;i * i < b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i < b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i < b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j < b;j += i)
            {
                is_prime_small[j] = 0;
            }
            for (ll j = max(2LL,(a + i - 1) / i) * i; j < b;j += i)
            {
                is_prime[j - a] = 0;
            }
        }
    }
}

int main()
{
    ll a,b;
    scanf("%lld %lld",&a,&b);
    segment_sieve(a,b + 1);
    int ans = 0;
    rep(i,0,b - a) {
        if(is_prime[i]) ans ++;
    }
    if (a == 1) ans --;
    printf("%d\n",ans);
    
    return 0;
}
*/

/*
const int MAXN = 1000000;

struct Edge {
    int to;
    double w;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,double w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

ll x[110];
ll y[110];
int to_u[110];

int pre[MAXN];
//ll dis[MAXN];
double dis[MAXN];
int vis[MAXN];

struct ST {
    int n;
    double w;

    bool operator< (const ST &other) const {
        return w > other.w;
    }
};

ll n,v;

void dij(int s) {
//    mem(dis,-1);
    rep(i,1,n) dis[i] = -1;
//    mem(ans,0);
    mem(vis,0);

    priority_queue<ST> q;
    q.push({s,dis[s] = 0});
//    ans[s] = 0;

    ST current;
    double k;
    int to;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;

        for (int i = g[current.n];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current.n] + e[i].w;
            if (dis[to] == -1 || dis[to] > k) {
                q.push({to,dis[to] = k});
//                ans[to] = ans[current.n] + sqrt(e[i].w / 10.0);
            }
        }
    }
}

int main()
{
    scll(n,v);
    init(MAXN - 5);
    rep(i,1,n) {
        scll(x[i],y[i]);
        sci(to_u[i]);
    }
    ll w;
    rep(i,1,n) {
        if (to_u[i] != 0) {
            w = (x[i] - x[to_u[i]]) * (x[i] - x[to_u[i]]) + (y[i] - y[to_u[i]]) * (y[i] - y[to_u[i]]);
            add_edge(i, to_u[i], sqrt(w) / v);
            add_edge(to_u[i], i, sqrt(w) / v);
        }
        rep(j,1,n) {
            if (i != j && x[i] == x[j] && y[i] > y[j]) {
                add_edge(i, j, sqrt((y[i] - y[j]) * 0.2));
            }
        }
    }
    dij(1);
    printf("%.2f\n",dis[n]);
    
    return 0;
}
*/

/*
const int MAXN = 100;

int ans[MAXN] = {0};
int tmp[MAXN] = {0};
int base[MAXN] = {1};

void print(int *a)
{
    pre(i,MAXN - 1,0) printf("%d",a[i]);
    puts("");
}

void add(int a[],int b)
{
    int p = 0;
    REP(i,0,MAXN) {
        a[i] += b % 10 + p;
        b /= 10;
        p = a[i] / 10;
        a[i] %= 10;
    }
//    print(a);
}

void add(int a[],int b[])
{
    // a = a + b
    int p = 0;
    REP(i,0,MAXN) {
        a[i] += b[i] + p;
        p = a[i] / 10;
        a[i] %= 10;
    }
//    print(a);
}

void cpy(int a[],int des[])
{
    REP(i,0,MAXN) {
        des[i] = a[i];
    }
}

void multy(int a[],int b)
{
    int x[MAXN] = {0};
    int k[MAXN];
    int off = 0;
    int z,t;
    int p;
    while (b) {
        z = b % 10;
        p = 0;
        REP(i,0,MAXN) {
            t = z * a[i];
            k[i] = t + p;
            p = k[i] / 10;
            k[i] %= 10;
        }
//        printf(">>");
//        print(k);
        p = 0;
        REP(i,off,MAXN) {
            x[i] += k[i - off] + p;
            p = x[i] / 10;
            x[i] %= 10;
        }
        off ++;
        b /= 10;
    }
    
//    print(x);
    cpy(x,a);
}

int main()
{
    int x,n;
    scii(x,n);
    int t;
    rep(i,0,n) {
        sci(t);
        if (i == 0) add(ans,t);
        else {
            cpy(base, tmp);
            multy(tmp, t);
            add(ans,tmp);
        }
        multy(base, x);
    }
    print(ans);
    return 0;
}
*/

/*
const int MAXN = 310;

struct Node {
    int to;
    ll w;
    bool operator <(const Node &o) const {
        return w > o.w;
    }
};

vector<Node> g[MAXN];

ll dis[MAXN];
int vis[MAXN];

void prime(int s)
{
    mem(dis,-1);
    mem(vis,0);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0});
    
    Node current;
    ll k;
    
    ll ans = 0;
    
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.to]) continue;
        vis[current.to] = 1;
        
        ans += current.w;
        
        for (auto to : g[current.to]) {
            k = to.w;
            if (dis[to.to] == -1 || dis[to.to] > k) {
                q.push({to.to,dis[to.to] = k});
            }
        }
    }
    
    printf("%lld\n",ans);
}

int main()
{
    dsci(n);
    ll t;
    rep(i,1,n) {
        scl(t);
        g[0].pb({i,t});
        g[i].pb({0,t});
    }
    rep(i,1,n) {
        rep(j,1,n) {
            scl(t);
            if (i != j) {
                g[i].pb({j,t});
            }
        }
    }
    prime(0);
    return 0;
}
*/

//const int MAXN = 510;
//
//vector<int> g[MAXN];
//
//int x,y;
//
//void dfs(int n) {
//
//}
//
//int main()
//{
//    int n,m;
//    scii(n,m);
//    scii(x,y);
//    int u,v;
//    while (m --) {
//        scii(u,v);
//        g[u].pb(v);
//        g[v].pb(u);
//    }
//
//    return 0;
//}

/*
int main()
{
    dsci(nn);
    string str;
    cin >> str;
    int k = 0,i = 0,n = 0,g = 0;
    rep(j,0,nn - 1) {
        if (str[j] == 'k') k ++;
        if (str[j] == 'i') i ++;
        if (str[j] == 'n') n ++;
        if (str[j] == 'g') g ++;
    }
//    _C(k << " " << i << " " << n << " " << g);
    ll cnt = 0;
    while (k >= 1 && i >= 2 && n >= 2 && g >= 2) {
        cnt += 2;
        k --;
        i -= 2;
        n -= 2;
        g -= 2;
    }
    while (k >= 1 && i >= 1 && n >= 1 && g >= 1) {
        cnt ++;
        k --;
        i --;
        n --;
        g --;
    }
    printf("%lld\n",cnt);
    return 0;
}
*/

/*
int main()
{
    dsci(n);
    int a[100010];
    rep(i,1,n) sci(a[i]);
    sort(a + 1,a + 1 + n);
    if (a[n] > n) {
        printf("-1\n");
        return 0;
    }
    int l = a[1];
    int cnt = 0;
    int ans = 0;
    int k[100010];
    rep(i,1,n) {
        if (l == cnt) {
            ans ++;
            cnt = 0;
        }
        l = a[i];
        k[i] = ans;
        cnt ++;
    }
    if (cnt != l) {
        ans = k[n - a[n] + 1];
    }
    printf("%d\n",ans + 1);
    return 0;
}
*/

//const int MAXN = 1000000;
//
//struct Edge {
//    int to;
//    int nxt;
//} e[MAXN * 2];
//int g[MAXN];
//int cnt;
//
//int n,m,x,y;
//
//int vis[510];
//int d[510];
//
//void init() {
//    cnt = 0;
//    mem(g,-1);
//    mem(vis,0);
//}
//
//void add(int u,int v)
//{
//    e[cnt] = {v,g[u]};
//    g[u] = cnt ++;
//}
//
//
//void dfs(int n)
//{
//    if (vis[n]) return;
//    vis[n] = 1;
//    int to;
//    int c = 0;
//    for (int i = g[n];~i;i = e[i].nxt,c ++) {
//        to = e[i].to;
//        dfs(to);
//    }
//    d[n] = c;
//}
//
//int main()
//{
//    scii(n,m);
//    scii(x,y);
//    int u,v;
//    init();
//    while (m --) {
//        scii(u,v);
//        add(u,v);
//        add(v,u);
//    }
//    return 0;
//}

/*
ll A[1010][1010];
ll B[1010][1010];

int main()
{
    int n,q;
    int t,i,j,val;
    ll sum;
    cio
    while (cin >> n >> q)
    {
        sum = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                cin >> A[i][j];
            }
        }
        rep(i,1,n) {
            rep(j,1,n) {
                cin >> B[i][j];
            }
        }
        rep(i,1,n) {
            rep(j,1,n) {
                sum += A[i][j] * B[j][i];
            }
        }
    //    _C(sum);
        while (q --) {
            cin >> t >> i >> j >> val;
            if (t) {
                // B
                sum -= B[i][j] * A[j][i];
                B[i][j] = val;
                sum += B[i][j] * A[j][i];
            } else {
                // A
                sum -= A[i][j] * B[j][i];
                A[i][j] = val;
                sum += A[i][j] * B[j][i];
            }
            _C(sum);
        }
    }
    
    return 0;
}

*/
/*
int main() {
    string a,b;
    cin >> a >> b;
    int this_num = 0;
    ulong lena = a.length() - 1;
    ulong lenb = b.length() - 1;
    int judge = 1;
    for (;lenb >= 0 && lena >= 0;lenb --, lena--, judge++){
        this_num = 0;
        if (judge % 2){
            this_num = (a[lena] - '0' + b[lenb] - '0') % 13;
            if (this_num == 10) {
                a[lena] = 'J';
            } else if (this_num == 11) {
                a[lena] = 'Q';
            } else if (this_num == 12) {
                a[lena] = 'K';
            } else if (this_num < 10) {
                a[lena] = this_num + '0';
            }
        } else {
            this_num = b[lenb] - a[lena];
            if (this_num < 0) this_num += 10;
            a[lena] = this_num + '0';
        }
    }
    if (a.length() < b.length()) {
        for (int i = 0;i < b.length() - a.length();i ++)
            cout << b[i];
    }
    cout << a;
}
*/

/*
double s[10010];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
    }
    sort(s+1,s+n+1);
    double sum1=s[1];
    for(int i=2;i<=n;i++)
    {
        sum1=sum1/2+s[i]/2;
    }
    
    printf("%.0f\n",floor(sum1));
    return 0;
}
*/

/*
// 树状数组：单点修改，区间和查询
const int MAXN = 5e5 + 10;

ll a[MAXN];
ll c[MAXN];

int n,m;

void modify(int idx,ll x)
{
    // 从叶子结点一路向上更新
    for (int i = idx;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

ll sum(int idx)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int main()
{
    scii(n,m);
    rep(i,1,n) scl(a[i]);
    rep(i,1,n) modify(i, a[i]);
    int t,x,y;
    while (m --) {
        sciii(t,x,y);
        if (t == 1) {
            // modify
            modify(x, y);
        } else if (t == 2) {
            // query
            printf("%lld\n",sum(y) - sum(x - 1));
        }
    }
    re0;
}
*/

/*
// 树状数组+差分： 区间修改+单点查询
const int MAXN = 5e5 + 10;

int a[MAXN];
int c[MAXN];

int n,m;

void modify(int idx,ll x)
{
    // 从叶子结点一路向上更新
    for (int i = idx;i <= n;i += lowbit(i))
    {
        c[i] += x;
    }
}

ll sum(int idx)
{
    // 查询：由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

void pls(int l,int r,int k)
{
    modify(l, k);
    modify(r + 1, -k);
}

void init()
{
    rep(i,1,n) {
        pls(i,i,a[i]);
    }
}

int main()
{
    scii(n,m);
    rep(i,1,n) sci(a[i]);
    init();
    
    int t;
    int x,y,k;
    
    while (m --) {
        sci(t);
        if (t == 1) {
            sciii(x,y,k);
            // modify
            pls(x,y,k);
        } else if (t == 2) {
            sci(x);
            // get_ans: sum_up
            printf("%lld\n",sum(x));
        }
    }
    return 0;
}
*/

/*
// 树状数组求逆序数
const int MAXN = 5e4 + 10;

int a[MAXN];
int b[MAXN];
ll c[MAXN];

int n,m;

void modify(int idx,ll x)
{
    // 从叶子结点一路向上更新
    for (int i = idx;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

ll sum(int idx)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int main()
{
    int *x;
    ll ans;
    int idx;
    while (~sci(n)) {
        
        rep(i,1,n) {
            sci(a[i]);
            b[i] = a[i];
            c[i] = 0;
        }
        sort(a + 1, a + 1 + n);
        x = unique(a + 1, a + 1 + n);
//        for (int *i = a + 1;i != x;i ++) printf("%d ",*i);
//        puts("");
        ans = 0;
        pre(i,n,1) {
            idx = (int) (lower_bound(a + 1, x, b[i]) - a);
            
            ans += sum(idx);
            modify(idx, 1);
        }
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    int k1,k2;
    pair<int,double> p1[50],p2[50];
    sci(k1);
    rep(i,1,k1) {
        sci(p1[i].first);
        scd(p1[i].second);
    }
    sci(k2);
    rep(i,1,k2) {
        sci(p2[i].first);
        scd(p2[i].second);
    }
    
    double a[2010];
    rep(i,0,2009) a[i] = 0;
    rep(i,1,k1) {
        rep(j,1,k2) {
            a[p1[i].first + p2[j].first] += p1[i].second * p2[j].second;
        }
    }
    vector<pair<int, double>> ans;
    pre(i,2010,0) {
        if (a[i] != 0) {
            ans.pb(mpair(i,a[i]));
        }
    }
    printf("%lu",ans.size());
    for (auto i : ans) {
        printf(" ");
        printf("%d %.1f",i.first,i.second);
    }
    puts("");
    return 0;
}
*/

/*
ll c[50010];
int n;

ll sum(int idx)
{
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i)) {
        ans += c[i];
    }
    return ans;
}

void modify(int idx,int a) {
    for (int i = idx;i <= n;i += lowbit(i)) {
        c[i] += a;
    }
}

int main()
{
    int T;
    sci(T);
    
    
    char cmd[100];
    int l,r;
    rep(test,1,T) {
        sci(n);
        rep(i,1,n) c[i] = 0;
        rep(i,1,n) {
            sci(l);
            modify(i, l);
        }
        printf("Case %d:\n",test);
        while (1) {
            scanf("%s",cmd);
            if (strcmp("Query", cmd) == 0) {
                scii(l,r);
                printf("%lld\n",sum(r) - sum(l - 1));
            } else if (strcmp("Add", cmd) == 0) {
                scii(l,r);
                modify(l, r);
            } else if (strcmp("Sub", cmd) == 0) {
                scii(l,r);
                modify(l, -r);
            } else if (strcmp("End", cmd) == 0) {
                break;
            }
        }
    }
    return 0;
}
*/

/*
ll cnt[1000010];

inline int is462(int x)
{
    int last = 0;
    int t;
    while (x) {
        t = x % 10;
        if (t == 4) re1;
        else if (t == 6 && last == 2) re1;
        last = t;
        x /= 10;
    }
    re0;
}

int main()
{
    int a,b;
    cnt[0] = 0;
    rep(i,1,1000000) {
        cnt[i] = cnt[i - 1];
        if (is462(i)) {
            cnt[i] ++;
        }
    }
    ll ans;
    while (~scii(a,b)) {
        if (a == 0 && b == 0) break;
        ans = b - a + 1;
        if (a == 0) a ++;
        ans -= cnt[b] - cnt[a - 1];
        printf("%lld\n",ans);
    }
    return 0;
}
*/

//const int mod = 1e9 + 7;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int main()
//{
//    string str = " 123456";
//    int i = 3;
//    rep(j,1,i) {
//        rep(l,j,i) printf("%c",str[l]);
//    }
//
//    int n,k;
////    string str;
//    ll ans;
//    __T {
//        scii(n,k);
//        cin >> str;
//        ans = 0;
//        rep(i,1,n) {
//            ans += quickpow(str[i - 1] - '0',k) * i % mod;
//            ans %= mod;
//            if (i != 1) printf(" ");
//            printf("%lld",ans);
//        }
//        puts("");
//    }
//    re0;
//}

/*
int main()
{
    int a[100010] = {0};
    dscii(n,q);
    int t;
    rep(i,1,n) {
        sci(t);
        a[t] = i;
    }
    int l,r;
    while (q --) {
        scii(l,r);
        rep(i,0,n)
            if (a[i] < l || a[i] > r) {
                printf("%d\n",i);
                break;
            }
    }
    return 0;
}
*/

/*
class Solution {
public:
    
    inline int judge(string x)
    {
        if (x[0] == x[4] && x[1] == x[3] && x[0] != x[1] && x[0] != x[2] && x[1] != x[2]) re1;
        re0;
    }
    
    int Fivecharacterpalindrome(string &s) {
        // write your code here
        ulong l = s.length();
        int cnt = 0;
        for (int i = 4;i < l;i ++) {
            if (judge(s.substr(i - 4,5))) cnt ++;
        }
        return cnt;
    }
};

int main()
{
    string x;
    cin >> x;
    Solution s;
    _C(s.Fivecharacterpalindrome(x));
    re0;
}
*/

/*
class Solution {
public:
    
    const static int MAXN = 50010;
    
    int st[MAXN][20];
    int st2[MAXN][20];
    vector<int> a;
    
    void init_max() {
        // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
        int n = (int) a.size();
        rep(i,1,n) st[i][0] = a[i - 1];

        for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
            rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
                st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); // 套公式
            }
        }
    }

    int query_max(int l, int r)
    {
        int x = log2(r - l + 1);
        return max(st[l][x],st[r - (1 << x) + 1][x]);
    }
    
    void init_min() {
        // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
        int n = (int) a.size();
        rep(i,1,n) st2[i][0] = a[i - 1];

        for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
            rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
                st2[i][j] = min(st2[i][j - 1], st2[i + (1 << (j - 1))][j - 1]); // 套公式
            }
        }
    }

    int query_min(int l, int r)
    {
        int x = log2(r - l + 1);
        return min(st2[l][x],st2[r - (1 << x) + 1][x]);
    }
 
    int Intervalxor(vector<int> &num, vector<vector<int>> &ask) {
        // write your code here
        a = num;
        init_max();
        init_min();
        int f = 1;
        int ans = -1;
        int k;
        for (auto q : ask) {
            k = query_max(q[0], q[1]);
            k += query_min(q[2], q[3]);
//            _C(k);
            if (f) {
                f = 0;
                ans = k;
            } else {
                ans ^= k;
            }
        }
        return ans;
    }
};

int main()
{
    Solution s;
    int n;
    vector<int> num;
    sci(n);
    int t;
    while (n --) {
        sci(t);
        num.pb(t);
    }
    int q;
    sci(q);
    vector<vector<int>> ask;
    while (q --) {
        vector<int> x;
        dscii(l,r);
        x.pb(l);
        x.pb(r);
        scii(l,r);
        x.pb(l);
        x.pb(r);
        ask.pb(x);
    }
    _C(s.Intervalxor(num, ask));
    
    re0;
}
*/

/*
class Solution {
public:
    string castMagic(vector<vector<int>> &triangle, vector<int> &point) {
        // write your code here
        ll ax = triangle[0][0],ay = triangle[0][1],
        bx = triangle[1][0],by = triangle[1][1],
        cx = triangle[2][0],cy = triangle[2][1],
        px = point[0],py = point[1];

        ll pax = ax - px,
            pay = ay - py;
        ll pbx = bx - px,
            pby = by - py;
        ll pcx = cx - px,
            pcy = cy - py;
        
//        _C(">>" << pcx << " " << pcy);
        
        ll a = pax * pby - pay * pbx,
            b = pbx * pcy - pby * pcx,
            c = pcx * pay - pcy * pax;
//        a /= abs(a);
//        b /= abs(b);
//        c /= abs(c);
//        _C(a << " " << b << " " << c);
        
        if ((ay-by)*(ax-cx) == (ay-cy)*(ax-bx)) return "No";
        
        
        if ((a >= 0 && b >= 0 && c >= 0) || (a <= 0 && b <= 0 && c <= 0))
            return "Yes";
        else return "No";
    }
};

int main()
{
    dscll(ax,ay);
    dscll(bx,by);
    dscll(cx,cy);
    dscll(px,py);
    vector<vector<int>> a;
    vector<int> p;
    vector<int> x,y,z;
    x.pb(ax);
    x.pb(ay);
    y.pb(bx);
    y.pb(by);
    z.pb(cx);
    z.pb(cy);
    a.pb(x);
    a.pb(y);
    a.pb(z);
    p.pb(px);
    p.pb(py);

    Solution s;
    _C(s.castMagic(a, p));


    return 0;
}
*/


//int n;
//
//int ans = 0;
//
//void dfs(int i,int j)
//{
////    _C(">>" << i << " " << j);
//
//    if (i == n && j == n) {
//        ans ++;
//        return;
//    }
////    if (vis[i][j]) return;
////    vis[i][j] = 1;
//
//    if (i + 1 <= n) {
//        dfs(i + 1,j);
////        vis[i + 1][j] = 0;
//    }
//    if (j + 1 <= i) {
//        dfs(i,j + 1);
////        vis[i][j + 1] = 0;
//    }
//    if (i + 1 <= n && j + 1 <= i + 1) {
//        dfs(i + 1,j + 1);
////        vis[i + 1][j + 1] = 0;
//    }
//}
//
//int main()
//{
//
//    sci(n);
//    dfs(1,1);
//    _C(ans);
//    return 0;
//}

/*
const int MAXN = 1e7;
ll a[MAXN + 1];

class Solution {
public:
    
    const static int mod = 1e9 + 7;
    
    ll quickpow(ll a, ll b)
    {
        ll ans = 1;
        while (b)
        {
            if (b & 1) ans = a * ans % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return ans;
    }
    
    void init()
    {
        a[0] = 1;
        a[1] = 1;
        rep(i,2,MAXN) {
            a[i] = ((6 * i - 3) * a[i - 1] % mod - (i - 2) * a[i - 2] % mod + mod) % mod
            * quickpow(i + 1,mod - 2) % mod;
        }
    }
    
    int pyramid(int n, vector<int> &k) {
        // write your code here
        int t;
        init();
        ll ans = 0;
        for (auto i : k) {
            t = n - i + 1;
            if (t == 1) {
                ans += 1;
            } else {
                ans += (a[t - 1] * 2) % mod;
            }
            ans %= mod;
        }
        return (int) ans;
    }
};

int main()
{
    int n;
    sci(n);
    dsci(q);
    vector<int> k;
    int t;
    
    while (q --) {
        sci(t);
        k.pb(t);
    }
    
    Solution s;
    _C(s.pyramid(n, k));
    return 0;
}
*/


/*
const int MAXN = 2e7 + 10;

int a[30];
int n,k;
int check[MAXN];
int zhi[MAXN];
ll ans = 0;

void init()
{
    mem(zhi,0);
    mem(check,0);
    check[1] = 1;
    ans = 0;
    for (int i = 2;i <= MAXN;i ++) {
        for (int j = i + i;j <= MAXN;j += i) {
            zhi[j] = 0;
        }
    }
    int pos = 0;
    for (int i = 2 ;i < MAXN;i++)
    {
        if (!check[i]) zhi[pos ++] = i;
        for (int j = 0;j < pos && i * zhi[j] < MAXN;j ++)
        {
            check[i * zhi[j]] = 1;
            if (i % zhi[j] == 0)
                break;
        }
    }
}



void dfs(int x,ll num,int t)
{
    if (t == k) {
        if (!check[num]) ans ++;
        return;
    }
    if (x == n) return;
    
    dfs(x + 1,num + a[x],t + 1);
    dfs(x + 1,num,t);
}

int main()
{
    init();
//    printf("%d %d %d %d %d\n",check[1],check[2],check[3],check[4],check[29]);
    scii(n,k);
    REP(i,0,n) {
        sci(a[i]);
    }
    dfs(0,0,0);
    printf("%lld\n",ans);
    return 0;
}
*/

/*
int main()
{
    double a[5],b[5],c[5];
    double mm;
    char t[5];
    double ans = 1;
    rep(i,1,3) {
        scddd(a[i],b[i],c[i]);
        mm = max(max(a[i],b[i]),c[i]);
        if (mm == a[i]) t[i] = 'W';
        else if (mm == b[i]) t[i] = 'T';
        else if (mm == c[i]) t[i] = 'L';
        ans *= mm;
        if (t[i] == 'W') ans *= 0.65;
    }
    rep(i,1,3) {
        printf("%c ",t[i]);
    }
    printf("%.2f\n",(ans - 1) * 2);
    return 0;
}
*/

/*
struct Stu {
    int id,c,m,e,a;
} s[100000];

int cmp_c(const Stu &a,const Stu &b)
{
    return a.c > b.c;
}

int cmp_m(const Stu &a,const Stu &b)
{
    return a.m > b.m;
}

int cmp_e(const Stu &a,const Stu &b)
{
    return a.e > b.e;
}

int cmp_a(const Stu &a,const Stu &b)
{
    return a.a > b.a;
}

int cmp(const pair<int, char> &a,const pair<int, char> &b)
{
    if (a.first == b.first) {
        char l = a.second,r = b.second;
        if (l == 'A') {
            if (r == 'C') return 1;
            else if (r == 'M') return 1;
            else if (r == 'E') return 1;
        } else if (l == 'C') {
            if (r == 'A') return 0;
            else if (r == 'M') return 1;
            else if (r == 'E') return 1;
        } else if (l == 'M') {
            if (r == 'A') return 0;
            else if (r == 'C') return 0;
            else if (r == 'E') return 1;
        } else if (l == 'E') {
            if (r == 'A') return 0;
            else if (r == 'C') return 0;
            else if (r == 'M') return 0;
        }
    }
    return a.first < b.first;
}

int main()
{
    int n,q;
    scanf("%d%d",&n,&q);
    REP(i,0,n) {
        scanf("%d%d%d%d",&s[i].id,&s[i].c,&s[i].m,&s[i].e);
        s[i].a = s[i].c + s[i].m + s[i].e;
    }
    map<int,int> c,m,e,a;
    sort(s,s + n,cmp_c);
    
    REP(i,0,n) {
        c[s[i].id] = i + 1;
        if (i != 0) {
            if (s[i].c == s[i - 1].c) c[s[i].id] = c[s[i - 1].id];
        }
    }
    
    sort(s,s + n,cmp_m);
    
    REP(i,0,n) {
        m[s[i].id] = i + 1;
        if (i != 0) {
            if (s[i].m == s[i - 1].m) m[s[i].id] = m[s[i - 1].id];
        }
    }
    
    sort(s,s + n,cmp_e);
    
    REP(i,0,n) {
        e[s[i].id] = i + 1;
        if (i != 0) {
            if (s[i].e == s[i - 1].e) e[s[i].id] = e[s[i - 1].id];
        }
    }
    
    sort(s,s + n,cmp_a);
    
    REP(i,0,n) {
        a[s[i].id] = i + 1;
        if (i != 0) {
            if (s[i].a == s[i - 1].a) a[s[i].id] = a[s[i - 1].id];
        }
    }
    int id;
    vector<pair<int, char>> x;
    while (q --) {
        scanf("%d",&id);
        if (a.find(id) == a.end()) {
            printf("N/A\n");
            continue;
        }
        x.clear();
        x.pb(make_pair(c[id], 'C'));
        x.pb(make_pair(m[id], 'M'));
        x.pb(make_pair(e[id], 'E'));
        x.pb(make_pair(a[id], 'A'));
        sort(x.begin(),x.end(),cmp);
        printf("%d %c\n",x[0].first,x[0].second);
    }
    return 0;
}
*/

/*
ll quickpow(ll a,ll b) {
    ll ans = 1;
    while (b) {
        if (b & 1) ans *= a;
        a *= a;
        b >>= 1;
    }
    return ans;
}

int isP(ll n)
{
    if (n == 1) return 0;
    for (ll i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int l,k;
    string str;
    scanf("%d%d",&l,&k);
    cin >> str;
    if (l < k) {
        puts("404");
        return 0;
    }
    ll x = 0;
    for (int i = 0;i < k;i ++) {
        x = x * 10 + str[i] - '0';
    }
    string s = "%0";
    s += (char) (k + '0');
    s += "lld\n";
    if (isP(x)) {
        printf(s.c_str(),x);
        return 0;
    }
    for (int i = k;i < l;i ++) {
        x = x - quickpow(10, k - 1) * (str[i - k] - '0');
        x *= 10;
        x += str[i] - '0';

        if (isP(x)) {
            printf(s.c_str(),x);
            return 0;
        }
    }
    printf("404\n");
    return 0;
}
*/

/*
int cmp(const pair<string,int> &a,const pair<string,int> &b)
{
    if (a.second == b.second) return a.first < b.first;
    return a.second > b.second;
}

int cmp2(const pair<int,int> &a,const pair<int,int> &b)
{
    if (a.second == b.second) return a.first < b.first;
    return a.second > b.second;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int site_n[1000] = {0};
    int site_s[1000] = {0};
    vector<pair<string,int>> tp['Z'];
    map<int,map<int,int>> date;
//    map<string,int> scr;
    string str;
    int s;
    int x,y;
    while (n --) {
        cin >> str >> s;
        tp[str[0]].push_back(make_pair(str,s));
        x = 0;
        for (int i = 1;i <= 3;i ++) {
            x = x * 10 + str[i] - '0';
        }
        site_n[x] ++;
        site_s[x] += s;
        
        y = 0;
        for (int i = 4;i <= 9;i ++) {
            y = y * 10 + str[i] - '0';
        }
        
        date[y][x] ++;
    }
    sort(tp['A'].begin(),tp['A'].end(),cmp);
    sort(tp['B'].begin(),tp['B'].end(),cmp);
    sort(tp['T'].begin(),tp['T'].end(),cmp);
    int t;
    char k;
    vector<pair<int,int>> c;
    rep(ii,1,m) {
        scanf("%d",&t);
        if (t == 1) {
            scanf(" %c",&k);
            printf("Case %d: %d %c\n",ii,t,k);
            if (tp[k].size() == 0) printf("NA\n");
            for (auto i : tp[k]) {
                cout << i.first << " " << i.second << endl;
            }
        } else {
            scanf("%d",&x);
            if (t == 2) {
                printf("Case %d: %d %03d\n",ii,t,x);
                if (site_n[x] == 0) {
                    printf("NA\n");
                } else printf("%d %d\n",site_n[x],site_s[x]);
            } else if (t == 3) {
                printf("Case %d: %d %06d\n",ii,t,x);
                c.clear();
                if (date[x].size() == 0) {
                    printf("NA\n");
                    continue;
                }
                for (auto i : date[x]) {
                    c.push_back(i);
                }
                sort(c.begin(), c.end(), cmp2);
                for (auto i : c) {
                    printf("%d %d\n",i.first,i.second);
                }
            }
        }
    }
    return 0;
}
*/

/*
const int MAXN = 10010;

pair<int,int> e[MAXN];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    
    int u,v;
    rep(i,1,m) {
        scanf("%d%d",&u,&v);
        e[i] = make_pair(u,v);
    }
    int k;
    scanf("%d",&k);
    int a[MAXN];
    int ok;
    int ans;
    rep(ii,1,k) {
        REP(i,0,n) {
            scanf("%d",a + i);
        }
        ok = 1;
        rep(i,1,m) {
            if (a[e[i].first] == a[e[i].second]) {
                ok = 0;
                break;
            }
        }
        if (!ok) {
            puts("No");
            continue;
        }
        sort(a,a + n);
        ans = (int) (unique(a,a + n) - a);
        printf("%d-coloring\n",ans);
    }
    return 0;
}
*/

/*
int a[100010];

int type = 0;
// -1 min
// 1 max
// 0 not sure
// -2 not heap

vector<vector<int>> all;
int n;

void dfs(int i,vector<int> path)
{
    path.pb(a[i]);
    
    if (i * 2 > n && i * 2 + 1 > n) {
        all.pb(path);
        return;
    }
    
    if (i * 2 + 1 <= n) dfs(i * 2 + 1,path);
    if (i * 2 <= n) dfs(i * 2,path);
}

int main()
{
    scanf("%d",&n);
    rep(i,1,n) scanf("%d",a + i);
    if (n == 1) {
        printf("%d\nNot Heap\n",a[1]);
        return 0;
    }
    
    dfs(1,vector<int>());
    int f;
    int l;
    for (auto i : all) {
        f = 1;
        l = a[1];
        for (auto j : i) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",j);
            if (type == 0) {
                if (j > l) type = -1;
                if (j < l) type = 1;
            } else if (type == 1) {
                if (j > l) type = -2;
            } else if (type == -1) {
                if (j < l) type = -2;
            }
            l = j;
        }
        puts("");
    }
    if (type == -2) {
        puts("Not Heap");
    } else if (type == -1) {
        puts("Min Heap");
    } else if (type == 1) {
        puts("Max Heap");
    }
    
    return 0;
}
*/

/*
inline int isLie(int i,int j,int a)
{
    if (abs(a) == i || abs(a) == j) {
        if (a > 0) return 1;
    } else {
        if (a < 0) return 1;
    }
    return 0;
}

int main()
{
    int n;
    int a[110];
    scanf("%d",&n);
    rep(i,1,n) scanf("%d",a + i);
    
    int lie;
    
    rep(i,1,n - 1) {
        rep(j,i + 1,n) {
            lie = 0;
            rep(k,1,n) {
                if (isLie(i, j, a[k])) lie ++;
            }
            if (lie == 2) {
                if ((isLie(i, j, a[i]) || isLie(i, j, a[j])) && !(isLie(i, j, a[i]) && isLie(i, j, a[j]))) {
                    printf("%d %d\n",i,j);
                    return 0;
                }
            }
        }
    }
    puts("No Solution");
    return 0;
}
*/

/*
int n;
int a[100010];

int ok(int x)
{
    REP(i,0,n) {
        if (a[i] > x) {
            return n - i >= x;
        }
    }
    return 0;
}

int main()
{
    scanf("%d",&n);
    REP(i,0,n) scanf("%d",a + i);
    sort(a,a + n);
    int l = 1;
    int r = 100010;
    int m;
    while (l < r) {
        m = (l + r) / 2;
        if (ok(m)) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    printf("%d\n",l - 1);
    re0;
}
*/

/*
int main() {
    int n,q;
    map<int,set<int> > mp;
    int u,v;
    scanf("%d%d",&n,&q);
    while (n --) {
        scanf("%d%d",&u,&v);
        mp[u].insert(v);
        mp[v].insert(u);
    }
    set<int> l;
    int ok;
    while (q --) {
        scanf("%d",&n);
        l.clear();
        ok = 1;
        
        rep(i,1,n) {
            scanf("%d",&u);
            if (mp.find(u) != mp.end()) {
                if (l.find(u) != l.end()) ok = 0;
                else for (auto j : mp[u]) l.insert(j);
            }
        }
        if (ok) puts("Yes");
        else puts("No");
    }
    return 0;
}
*/

/*
int g[210][210];

int main()
{
    mem(g,-1);
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v,w;
    while (m --) {
        scanf("%d%d%d",&u,&v,&w);
        g[u][v] = w;
        g[v][u] = w;
    }
    int q;
    scanf("%d",&q);
    if (q == 0) {
        return 0;
    }
    int t;
    int f;
    int nn;
    set<int> a;
    int ok;
    ll dis;
    ll dis_m = -1;
    int dis_i = 1;
    rep(ii,1,q)
    {
        a.clear();
        scanf("%d",&nn);
        if (nn == 0) continue;
        scanf("%d",&t);
        f = t;
        a.insert(f);
        ok = 1;
        dis = 0;
        rep(i,2,nn) {
            scanf("%d",&m);
            a.insert(m);
            if (g[t][m] == -1) ok = 0;
            else {
                dis += g[t][m];
            }
            t = m;
        }
        printf("Path %d: ",ii);
        if (ok) {
            printf("%lld ",dis);
            if (a.size() == n && t == f) {
                if (nn == n + 1) puts("(TS simple cycle)");
                else puts("(TS cycle)");
                if (dis < dis_m || dis_m == -1) {
                    dis_m = dis;
                    dis_i = ii;
                }
            } else puts("(Not a TS cycle)");
        } else {
            puts("NA (Not a TS cycle)");
        }
    }
    printf("Shortest Dist(%d) = %lld\n",dis_i,dis_m);
    
    return 0;
}
*/

/*
struct Node {
    Node *l;
    Node *r;
    Node *fa;
    int n;
    
    Node(Node *l,Node *r,Node *fa,int n):l(l),r(r),fa(fa),n(n)
    {}
};


map<int,Node*> mp;

int a[10010];
int b[10010];

Node *root;

void build(int la,int ra,int lb,int rb,Node *f)
{
    if (la >= ra) return;
    int s = a[la];
    int m = lb;
    rep(i,lb,rb) {
        if (b[i] == s) {
            m = i;
            break;
        }
    }
    
    if (lb < m) {
        Node *l = new Node(NULL,NULL,f,a[la + 1]);
        f -> l = l;
        mp[a[la + 1]] = l;
        build(la + 1, la + m - lb, lb, m - 1,f -> l);
    }
    if (m < rb) {
        Node *r = new Node(NULL,NULL,f,a[la + m - lb + 1]);
        f -> r = r;
        mp[a[la + m - lb + 1]] = r;
        build(la + m - lb + 1, ra, m + 1, rb,f -> r);
    }
}

int main()
{
    int m,n;
    scanf("%d%d",&m,&n);
    rep(i,1,n) scanf("%d",b + i);
    rep(i,1,n) scanf("%d",a + i);
    
    root = new Node(NULL,NULL,NULL,a[1]);
    mp[a[1]] = root;
    build(1,n,1,n,root);
//    rep(i,1,n * 2 + 1) printf("%d ",tree[i]);
    int u,v;
    set<int> as;
    while (m --) {
        scanf("%d%d",&u,&v);
        if (mp[u] == NULL && mp[v] == NULL) printf("ERROR: %d and %d are not found.\n",u,v);
        else if (mp[u] == NULL) printf("ERROR: %d is not found.\n",u);
        else if (mp[v] == NULL) printf("ERROR: %d is not found.\n",v);
        else {
            as.clear();
            for (Node *i = mp[u];i != NULL;i = i -> fa) {
                as.insert(i -> n);
                if (i -> n == v) {
                    printf("%d is an ancestor of %d.\n",v,u);
                    goto nxt;
                }
            }
            for (Node *i = mp[v];i != NULL;i = i -> fa) {
                if (i -> n == u) {
                    printf("%d is an ancestor of %d.\n",u,v);
                    goto nxt;
                }
                if (as.find(i -> n) != as.end()) {
                    printf("LCA of %d and %d is %d.\n",u,v,i -> n);
                    goto nxt;
                }
            }
        }
    nxt:;
    }
    re0;
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[100010];
    REP(i,0,n) {
        scanf("%d",a + i);
    }
    sort(a,a + n);
    int i = 1;
    for (;i <= n;i ++) {
        if (!binary_search(a, a + n, i)) break;
    }
    printf("%d\n",i);
    
    return 0;
}
*/

/*
int isP(int n)
{
    if (n <= 1) return 0;
    for (int i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int _hash[20010];
int has[20010];
int s_u,n,m;
int mod;

int _search(int num)
{
    int ans = 0;
    int p;
    int ok = 1;
    REP(i,0,mod) {
        ans ++;
        if (_hash[p = (i * i + num) % mod] == num || !has[p]) {
            ok = 0;
            break;
        }
    }
    return ans + ok; // 不是很理解为什么没找到最后还要加一个1
}

int main()
{
    
    scanf("%d%d%d",&s_u,&n,&m);
    while (!isP(s_u)) s_u ++;
    
    mod = s_u;
    
    int t;
    int p;
    int ok;
    rep(ii,1,n) {
        scanf("%d",&t);
        ok = 0;
        REP(i,0,mod) {
            if (!has[p = (t + i * i) % mod]) {
                has[p] = 1;
                _hash[p] = t;
                ok = 1;
                break;
            }
        }
        if (!ok) printf("%d cannot be inserted.\n",t);
    }
    
    ll tm = 0;
    rep(i,1,m) {
        scanf("%d",&t);
        tm += _search(t);
    }
    printf("%.1f\n",tm / (double) m);
    return 0;
}
*/

/*
const int MAXN = 1e4 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];

int g[MAXN];
int cnt;

void init()
{
    mem(g,-1);
    cnt = 0;
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    init();
    int u,v;
    int in[MAXN] = {0};
    while (m --) {
        scanf("%d%d",&u,&v);
        in[v] ++;
        add(u,v);
    }
    
    int q;
    scanf("%d",&q);
    int t;
    int f = 1;
    int inn[MAXN];
    int ok;
    REP(ii,0,q)
    {
        memcpy(inn, in, sizeof(in));
        ok = 1;
        rep(iii,1,n) {
            scanf("%d",&t);
            if (inn[t] == 0) {
                for (int i = g[t];~i;i = e[i].nxt) inn[e[i].to] --;
            } else {
                ok = 0;
            }
        }
        
        if (!ok) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",ii);
        }
    }
    re0;
}
*/

/*
int a[1010];
int m,n;

int cmp1(int a,int b) {
    return a <= b;
}

int cmp2(int a,int b) {
    return a >= b;
}


int dfs(int i,int (*func)(int,int)) {
    int ok = 1;
    if (i * 2 <= n) {
        if (!func(a[i],a[i * 2])) return 0;
        ok &= dfs(i * 2,func);
    }
    if (i * 2 + 1 <= n) {
        if (!func(a[i],a[i * 2 + 1])) return 0;
        ok &= dfs(i * 2 + 1,func);
    }
    return ok;
}

int f;

void prt(int i)
{
    if (i * 2 <= n) prt(i * 2);
    if (i * 2 + 1 <= n) prt(i * 2 + 1);
    if (f) f = 0;
    else printf(" ");
    printf("%d",a[i]);
}

int main()
{
    scanf("%d%d",&m,&n);
    int ok1,ok2;
    while (m --) {
        rep(i,1,n) scanf("%d",a + i);
        ok1 = dfs(1,cmp1);
        ok2 = dfs(1,cmp2);
        if (!ok1 && !ok2) puts("Not Heap");
        else if (ok1 && ok2) puts("Min Heap");
        else if (ok1 && !ok2) puts("Min Heap");
        else if (!ok1 && ok2) puts("Max Heap");
        f = 1;
        prt(1);
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    string d;
    int n;
    cin >> d >> n;
    string a;
    char l;
    int cnt;
    rep(ii,1,n - 1) {
        a = "";
        l = -1;
        cnt = 0;
        for (int i = 0;d[i];i ++) {
            if (l != -1 && l != d[i]) {
                a += l;
                a += cnt + '0';
                cnt = 1;
            } else cnt ++;
            l = d[i];
        }
        
        a += l;
        a += cnt + '0';
        
        d = a;
    }
    cout << d << endl;
    return 0;
}
*/

/*
void toLow(string &str) {
    for (int i = 0;str[i];i ++) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            str[i] = str[i] - 'A' + 'a';
        }
    }
}

unordered_map<string,int> mpn;

int cmp(const pair<string,int> &a,const pair<string,int> &b) {
    if (a.second == b.second) {
        if (mpn[a.first] == mpn[b.first]) return a.first < b.first;
        return mpn[a.first] < mpn[b.first];
    }
    return a.second > b.second;
}

int main()
{
    cio
    int n;
    cin >> n;
    string id;
    int scr;
    string sch;
    unordered_map<string,double> mps;
    
    rep(i,1,n) {
        cin >> id >> scr >> sch;
        toLow(sch);
        if (id[0] == 'A') mps[sch] += scr;
        else if (id[0] == 'B') mps[sch] += scr / 1.5;
        else if (id[0] == 'T') mps[sch] += scr * 1.5;
        mpn[sch] ++;
    }
    int cnt = 0;
    pair<string,int> p[100010];
    for (auto i : mps) {
        p[cnt ++] = mpair(i.first,(int) i.second);
    }
    sort(p, p + cnt, cmp);
    int r = 1;
    cout << cnt << endl;
    REP(i,0,cnt) {
        if (i != 0) {
            if (p[i].second != p[i - 1].second) r = i + 1;
        }
        cout << r << " " << p[i].first << " " << p[i].second << " " << mpn[p[i].first] << endl;
    }
    return 0;
}
*/

/*
const int MAXN = 40010;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];
int cnt;
int g[MAXN];

void init() {
    mem(g,-1);
    cnt = 0;
}

void add(int u,int v) {
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    init();
    while (m --) {
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
    }
    int q;
    scanf("%d",&q);
    int k;
    map<int,int> mp;
    vector<int> vec;
    int t,ok;
    while (q --) {
        scanf("%d",&k);
        mp.clear();
        vec.clear();
        rep(i,1,k) {
            scanf("%d",&t);
            vec.push_back(t);
            
            for (int j = g[t];~j;j = e[j].nxt) {
                mp[e[j].to] ++;
            }
        }
        ok = 1;
        for (auto i : vec) {
            if (mp[i] < k - 1) {
                ok = 0;
                break;
            }
            mp.erase(mp.find(i));
        }
        if (!ok) {
            puts("Not a Clique");
            continue;
        }
        for (auto i : mp) {
            if (i.second >= k) {
                ok = 0;
                break;
            }
        }
        if (ok) puts("Yes");
        else puts("Not Maximal");
    }
    return 0;
}
*/

/*
map<int,int> mp;
int main()
{
    int q,n;
    scanf("%d%d",&q,&n);
    int a[10010];
    rep(i,1,n) {
        scanf("%d",a + i);
        mp[a[i]] = 1;
    }
    int u,v;
    while (q --) {
        scanf("%d%d",&u,&v);
        if (!mp[u] && !mp[v]) printf("ERROR: %d and %d are not found.\n",u,v);
        else if (!mp[u]) printf("ERROR: %d is not found.\n",u);
        else if (!mp[v]) printf("ERROR: %d is not found.\n",v);
        else rep(i,1,n) {
            if (a[i] == u) {
                printf("%d is an ancestor of %d.\n",u,v);
                break;
            } else if (a[i] == v) {
                printf("%d is an ancestor of %d.\n",v,u);
                break;
            } else if ((u > a[i] && v < a[i]) || (v > a[i] && u < a[i])) {
                printf("LCA of %d and %d is %d.\n",u,v,a[i]);
                break;
            }
        }
    }
    return 0;
}
*/

/*
struct Node {
    string name;
    int p = -1,m = -1,f = -1,g = -1;
};

int cmp(const Node &a,const Node &b) {
    if (a.g == b.g) return a.name < b.name;
    return a.g > b.g;
}

int main()
{
    unordered_map<string,int> mp1;
    unordered_map<string,int> mp2;
    unordered_map<string,int> mp3;
    int p,m,n;
    scanf("%d%d%d",&p,&m,&n);
    string id;
    int scr;
    for (int i = 0;i < p;i ++) {
        cin >> id >> scr;
        mp1[id] = scr;
    }
    for (int i = 0;i < m;i ++) {
        cin >> id >> scr;
        mp2[id] = scr;
    }
    for (int i = 0;i < n;i ++) {
        cin >> id >> scr;
        mp3[id] = scr;
    }
    unordered_map<string, Node> mp;
    for (auto i : mp1) {
        mp[i.first].p = i.second;
    }
    for (auto i : mp2) {
        mp[i.first].m = i.second;
    }
    for (auto i : mp3) {
        mp[i.first].f = i.second;
    }
    vector<Node> ans;
    for (auto i : mp) {
        if (i.second.p < 200) continue;
        if (i.second.m > i.second.f) i.second.g = i.second.m * 0.4 + i.second.f * 0.6 + 0.5;
        else i.second.g = i.second.f;
        if (i.second.g < 60) continue;
        i.second.name = i.first;
        ans.pb(i.second);
    }
    sort(ans.begin(),ans.end(),cmp);
    for (auto i : ans) {
        cout << i.name;
        printf(" %d %d %d %d\n",i.p,i.m,i.f,i.g);
    }
    return 0;
}
*/

/*
const int MAXN = 5e4 + 10;

int a[MAXN];
int b[MAXN];


struct Node {
    Node *l;
    Node *r;
    int n;
    
    Node(Node *l,Node *r,int n):l(l),r(r),n(n)
    {}
};

void build(int la,int ra,int lb,int rb,Node *f)
{
    if (la >= ra) return;
    int s = a[la];
    int m = lb;
    rep(i,lb,rb) {
        if (b[i] == s) {
            m = i;
            break;
        }
    }
    
    if (lb < m) {
        Node *l = new Node(NULL,NULL,a[la + 1]);
        f -> l = l;
        build(la + 1, la + m - lb, lb, m - 1,f -> l);
    }
    if (m < rb) {
        Node *r = new Node(NULL,NULL,a[la + m - lb + 1]);
        f -> r = r;
        build(la + m - lb + 1, ra, m + 1, rb,f -> r);
    }
}

int ok = 0;

void dfs(Node *root) {
    if (root -> l != NULL && !ok) dfs(root -> l);
    if (root -> r != NULL && !ok) dfs(root -> r);
    if (!ok) {
        printf("%d\n",root -> n);
        ok = 1;
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) scanf("%d",a + i);
    rep(i,1,n) scanf("%d",b + i);
    Node *root = new Node(NULL,NULL,a[1]);
    build(1,n,1,n,root);
    dfs(root);
    return 0;
}
*/

//const int MAXN = 1e5 + 10;
//
//struct Edge {
//    int to;
//    int nxt;
//    Edge(){}
//    Edge(int to,int nxt):to(to),nxt(nxt){}
//} e[MAXN * 2];
//int cnt;
//int g[MAXN];
//
//int vis[MAXN];
//int type[MAXN];
//
//void init() {
//    memset(g,-1,sizeof(g));
//    cnt = 0;
//}
//
//void add(int u,int v)
//{
//    e[cnt] = Edge(v,g[u]);
//    g[u] = cnt ++;
//}
//
//int to;
//vector<vector<int>> ans;
//vector<int> tmp;
//
//void dfs(int n,int d)
//{
//    if (d == 3) {
//        if (n == to) {
//            ans.push_back(tmp);
//        }
//        return;
//    }
//
//    if (n == to) return;
//
//    int t;
//    for (int i = g[n];~i;i = e[i].nxt) {
//        t = e[i].to;
//        if (d == 0 || d == 2) {
//            if (type[t] == type[n]) {
//                if (vis[t]) continue;
//                tmp.push_back(abs(t));
//                vis[t] = 1;
//                dfs(t,d + 1);
//                vis[t] = 0;
//                tmp.erase(tmp.end() - 1);
//            }
//        } else if (d == 1) {
//            if (type[t] != type[n]) {
//                if (vis[t]) continue;
//                tmp.push_back(abs(t));
//                vis[t] = 1;
//                dfs(t,d + 1);
//                vis[t] = 0;
//                tmp.erase(tmp.end() - 1);
//            }
//        }
//    }
//}
//
//int cmp(const vector<int> &a,const vector<int> &b)
//{
//    if (a[0] == b[0]) return a[1] < b[1];
//    return a[0] < b[0];
//}
//
//void dfs2(int n,int d)
//{
//    if (d == 3) {
//        if (n == to) {
//            ans.push_back(tmp);
//        }
//        return;
//    }
//
//    if (n == to) return;
//
//    int t;
//    for (int i = g[n];~i;i = e[i].nxt) {
//        t = e[i].to;
//        if (type[t] == type[n]) {
//            if (vis[t]) continue;
//            tmp.push_back(abs(t));
//            vis[t] = 1;
//            dfs2(t,d + 1);
//            vis[t] = 0;
//            tmp.erase(tmp.end() - 1);
//        }
//    }
//}
//
//int main()
//{
//    int n,m;
//    scanf("%d%d",&n,&m);
//    int u,v;
//    set<int> s;
//    init();
//    rep(i,1,m) {
//        scanf("%d%d",&u,&v);
//
//        type[abs(u)] = u / abs(u);
//        type[abs(v)] = v / abs(v);
//        u = abs(u);
//        v = abs(v);
//        add(u,v);
//        add(v,u);
//    }
//    int q;
//    scanf("%d",&q);
//    while (q --) {
//        scanf("%d%d",&u,&v);
//        tmp.clear();
//        ans.clear();
//        u = abs(u);
//        v = abs(v);
//        to = v;
//
//        if (type[u] == type[v]) {
//            vis[u] = 1;
//            dfs2(u,0);
//            vis[u] = 0;
//        } else {
//            vis[u] = 1;
//            dfs(u,0);
//            vis[u] = 0;
//        }
//
//        sort(ans.begin(),ans.end(),cmp);
//        printf("%lu\n",ans.size());
//        for (auto i : ans) {
//            printf("%d %d\n",i[0],i[1]);
//        }
//    }
//    return 0;
//}

/*
int ok(int a,int b,int c,int d) {
    return abs(a - b) == abs(c - d);
}

int main()
{
    int a,b,c,d;
    __T {
        scii(a,b);
        scii(c,d);
        if (ok(a,b,c,d) || ok(a,c,b,d) || ok(a,d,b,c) || ok(b,c,a,d) || ok(b,d,a,c) || ok(c,d,a,b)) puts("YES");
        else puts("NO");
    }
    return 0;
}
*/

/*
int main()
{
    
    dscll(n,m);
    if (n > m) swap(n,m);
    if (n <= 1) puts("1");
    else if (n <= 2) printf("%lld\n",(ll) ceil(m / 2.0));
    else if (n == 3 && m == 3) puts("8");
    else if (n >= 3 && m > 3) printf("%lld\n",n * m);
    return 0;
}
*/

/*
int main()
{
    int a[500010];
    dsci(n);
    rep(i,1,n) {
        sci(a[i]);
    }
    sort(a + 1,a + 1 + n);
    int cnt = 0;
    
    for (int i = n,j = n / 2;j >= 1 && i >= n / 2 + 1;j --) {
        if (a[j] * 2 <= a[i]) {
            i --;
            cnt ++;
        }
    }
    
    printf("%d\n",n - cnt);
    return 0;
}
*/

/*
int main()
{
    ll a,b;
    __T {
        scll(a,b);
        if (!(a & b)) puts("1");
        else printf("%lld\n",a & b);
    }
    return 0;
}
*/

/*
int main()
{
    dscii(n,m);
    int a[300010];
    rep(i,1,n) sci(a[n - i + 1]);
    int t;
    int i = n;
    while (m --) {
        sci(t);
        a[++ i] = t;
    }
    int vis[100010] = {0};
    pre(ii,i,1) {
        if (vis[a[ii]]) continue;
        printf("%d ",a[ii]);
        vis[a[ii]] = 1;
    }
    return 0;
}
*/

/*
char a[1030][1030];
char b[1030][1030];
string str[10];

void init()
{
    int w;
    a[1][1] = 'C';
    a[1][2] = 'C';
    a[2][1] = 'P';
    a[2][2] = 'C';
    str[1] = "CC\nPC\n";
    w = 2;
    rep(i,1,9) {
        str[i + 1] = "";
        rep(j,1,w) {
            rep(k,1,w) {
                if (i & 1) {
                    b[j][k] = a[j][k];
                } else {
                    a[j][k] = b[j][k];
                }
            }
        }

        rep(j,1,w) {
            rep(k,1,w) {
                if (i & 1) {
                    b[j][k + w] = a[j][k];
                } else {
                    a[j][k + w] = b[j][k];
                }
            }
        }

        rep(j,1,w) {
            rep(k,1,w) {
                if (i & 1) {
                    if (a[j][k] == 'C') b[j + w][k] = 'P';
                    else if (a[j][k] == 'P') b[j + w][k] = 'C';
                } else {
                    if (b[j][k] == 'C') a[j + w][k] = 'P';
                    else if (b[j][k] == 'P') a[j + w][k] = 'C';
                }
            }
        }

        rep(j,1,w) {
            rep(k,1,w) {
                if (i & 1) {
                    b[j + w][k + w] = a[j][k];
                } else {
                    a[j + w][k + w] = b[j][k];
                }
            }
        }


        w <<= 1;
        rep(ii,1,w) {
            rep(jj,1,w) {
                if (i & 1) str[i + 1] += b[ii][jj];
                else str[i + 1] += a[ii][jj];
            }
            str[i + 1] += '\n';
        }
    }
}

int main()
{
    init();
    int n;
    __T {
        sci(n);
        cout << str[n];
    }
    return 0;
}
*/

/*
int a[100010];

int main()
{
    int n,k;
    ll ans;
    int cnt;
    int t;
    __T {
        scii(n,k);
        cnt = n;
        ans = k;
        cnt --;
        rep(i,1,n) {
            sci(t);
            ans += t / k * k;
            a[i] = t % k;
            cnt -= t / k;
        }
        
        sort(a + 1,a + 1 + n,greater<int>());
        
        rep(i,1,n) {
            if (cnt > 0) {
                cnt --;
                ans += k;
            } else ans += a[i];
        }
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
const int MAXN = 5e4 + 10;

struct Node {
    int end;
    ll w;
    bool operator<(const Node &o) const {
        return w < o.w;
    }
};

multiset<Node> que;
vector<Node> g[MAXN];

void init(int x)
{
    rep(i,1,x) g[i].clear();
    que.clear();
}

void add(int u,int v,ll w)
{
    g[u].pb({v,w});
}

int n,m,q;

ll ans[250010];

void bfs(int mm)
{
    Node cur;
    while (que.size() > mm) que.erase(-- que.end());
    multiset<Node>::iterator it;
    rep(ii,1,mm) {
        cur = *que.begin();
        que.erase(que.begin());
        ans[ii] = cur.w;
        for (auto i : g[cur.end]) {
            if (que.size() < mm - ii) que.insert({i.end,cur.w + i.w});
            else if (que.size()) {
                it = -- que.end();
                if (cur.w + i.w < it -> w) {
                    que.erase(it);
                    que.insert({i.end,cur.w + i.w});
                } else break;
            }
        }
    }
}

int main()
{
    int u,v,w;
    int mm,t;
    vector<int> qq;
    __T {
        sciii(n,m,q);
        init(n + 5);
        while (m --) {
            sciii(u,v,w);
            add(u,v,w);
            que.insert({v,w});
        }
        
        rep(i,1,n) sort(g[i].begin(),g[i].end());
        
        mm = -1;
        qq.clear();
        while (q --) {
            sci(t);
            qq.pb(t);
            mm = max(mm,t);
        }
        bfs(mm);
        for (auto i : qq) {
            printf("%lld\n",ans[i]);
        }
    }
    return 0;
}
*/

/*
const int mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n,m;
    ll x;
    __T {
        scii(n,m);
        x = quickpow(n, m) % mod;
        printf("%lld\n",((x + mod - 1) % mod) * quickpow(x, mod - 2) % mod);
    }
    return 0;
}
*/

/*
int main()
{
    int x,y;
    __T {
        scii(x,y);
        if (abs(x - y) % 3) puts("yyds");
        else puts("awsl");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100];
    __T {
        sci(n);
        rep(i,1,n) {
            sci(a[i]);
        }
        int ok = 1;
        rep(i,2,n) {
            if (a[i - 1] == a[i]) {
                ok = 0;
                break;
            }
        }
        if (ok) puts("YES");
        else puts("NO");
    }
    return 0;
}
*/

/*
int a[1000010];

int main()
{
    int n,m,k;
    ll ans = 0;
    int mm,t;
    __T {
        sciii(n,m,k);
        mm = INT_INF;
        ans = (k - 1) * 2;
        rep(i,1,m) {
            sci(t);
            if (i == 1) mm = t;
            else mm = min(t,mm);
            ans += abs(t - k) * 2;
        }
        if (mm < k) {
            ans -= abs(mm - k);
            ans -= k - 1;
            ans += mm - 1;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

//int n;
//int A[55][55];
//int k[5][5];
//
//int main()
//{
//    int sum;
//    __T {
//        sci(n);
//        rep(i,1,n)
//            rep(j,1,n) sci(A[i][j]);
//        sum = 0;
//        rep(i,1,3)
//        {
//            rep(j,1,3) {
//                sci(k[i][j]);
//                sum += k[i][j];
//            }
//        }
//
//    }
//    return 0;
//}

/*
const int MAXN = 1e7 + 10;

//int mod = 1e9 + 7;

int is_prime[MAXN];
int is_prime_small[MAXN];

ll segment_sieve(ll a,ll b)
{
    ll ans = 0;
    for (ll i = 0;i * i < b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i < b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i < b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j < b;j += i)
            {
                is_prime_small[j] = 0;
            }
            for (ll j = max(2LL,(a + i - 1) / i) * i; j < b;j += i)
            {
                is_prime[j - a] = 0;
            }
        }
    }
    for (ll i = 0;i < b - a;i ++) {
        if (is_prime[i]) {
//            _C(">>" << i + a);
            ans = ans + i + a;
        }
    }
    return ans;
}

ll a[1010];

int main()
{
    
    
        for (ll i = 0;i <= 999;i ++) {
            _C(i * 10000000 + 1 << " -> " << (i + 1) * 10000000);
            _C((a[i] = segment_sieve(i * 10000000 + 1, (i + 1) * 10000000 + 1)));
        }
        for (ll i = 0;i <= 999;i ++) {
            printf("%lld,",a[i]);
        }
    
    return 0;
}

*/

/*
const int MAXN = 1000010;

namespace Min25 {
    int prime[MAXN], id1[MAXN], id2[MAXN], flag[MAXN], ncnt, m;

    ll g[MAXN], sum[MAXN], a[MAXN], T, n;

    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }

    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }

    inline ll f(ll x) {
        return x;
    }

    inline void init() {
        
        rep(i,0,MAXN - 1) {
            prime[i] = id1[i] = id2[i] = flag[i] = 0;
            g[i] = sum[i] = a[i] = 0;
        }
        
        ncnt = 0;
        m = 0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) {
                prime[++ncnt] = i;
                sum[ncnt] = sum[ncnt - 1] + i;
            }
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++)
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }

    inline ll solve(ll x) {
        if (x <= 1) return x;
        n = x;
        init();
        return g[ID(n)];
    }

}

ll mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}


int main() {
    ll n,k;
    ll ans;
    __T {
        scll(n,k);
        if (n == 1) puts("0");
        else {
            n ++;
            mod = k;
            ans = (((3 + n) % mod) * ((n - 2) % mod) % mod) * quickpow(2, mod - 2) % mod;
            ans += (Min25::solve(n) - 2) % mod;
            printf("%lld\n",ans % mod);
        }
    }
    
}
*/

/*
int main()
{
    int n;
    int a[1000010];
    int t = 0;
    int ii;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        t = 0;
        
        for (ii = 2;ii <= n;ii ++) {
            if (a[ii] <= a[ii - 1]) {
                t = 1;
                break;
            }
        }
        if (ii == 2) t = -1;
        
        for (;ii <= n;ii ++) {
            if (a[ii] >= a[ii - 1]) {
                t = -1;
                break;
            }
        }
        if (t == 1) puts("Yes");
        else puts("No");
    }
    re0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    int b[100010];
    map<int,int> mp;
    int ans;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        rep(i,1,n) sci(b[i]);
        mp.clear();
        rep(i,1,n) {
            mp[a[i] - b[i]] ++;
        }
        ans = 0;
        for (auto i : mp) {
            ans = max(ans,i.second);
        }
        printf("%d\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    int n,b;
    int t;
    int ok;
    __T {
        scii(n,b);
        ok = 0;
        rep(i,1,n) {
            sci(t);
            if ((t + b) % 7 == 0) ok = 1;
        }
        puts(ok ? "Yes" : "No");
    }
    re0;
}
*/

/*
int cmp(const pair<string,ll> &a,const pair<string,ll> &b)
{
    if (a.second == b.second) return a.first < b.first;
    return a.second > b.second;
}

int main()
{
    int n,m;
    pair<string,ll> a[110];
    ll ans;
    __T {
        scii(n,m);
        rep(i,1,n) cin >> a[i].first >> a[i].second;
        sort(a + 1, a + 1 + n, cmp);
        ans = 0;
        rep(i,1,m) {
            ans += (m - i + 1) * a[i].second;
        }
        printf("%lld",ans);
        rep(i,1,m) cout << " " << a[i].first;
        puts("");
    }
    re0;
}
*/

/*
int main()
{
    ll n;
    string str;
    int ans[100010];
    ll x;
    __T {
        scl(n);
        cin >> str;
        if ((x = (1 + n) * n / 2) % 2) puts("-1");
        else {
            x /= 2;
            pre(i,(int) n,1) {
                if (x - i >= 0) {
                    if (str[i - 1] == '1') ans[i] = 3;
                    else ans[i] = 1;
                    x -= i;
                } else {
                    if (str[i - 1] == '1') ans[i] = 4;
                    else ans[i] = 2;
                }
            }
            rep(i,1,n) printf("%d",ans[i]);
            puts("");
        }
    }
    re0;
}
*/

/*
int m;

struct Tile {
    char type;
    int rank;
    
    bool operator<=(const Tile &o) const {
        if (type == o.type) return rank <= o.rank;
        else if (type == 'C' && o.type == 'B') return 1;
        else if (type == 'C' && o.type == 'D') return 1;
        else if (type == 'B' && o.type == 'D') return 1;
        return 0;
    }
    
    Tile operator++(int) {
        if (rank < m) rank ++;
        else {
            rank = 1;
            if (type == 'C') type = 'B';
            else if (type == 'B') type = 'D';
            else if (type == 'D') rank = m + 1;
        }
        return *this;
    }
    
    Tile operator--(int) {
        if (rank > 1) rank --;
        else {
            if (type == 'D') {
                type = 'B';
                rank = m;
            }
            else if (type == 'B') {
                type = 'C';
                rank = m;
            }
            
        }
        return *this;
    }
};

int main()
{
    int n;
    int w;
    Tile t[100010];
    Tile begin,end;
    int ans;
    __T {
        scii(n,m);
        w = -1;
        
        rep(i,1,n) {
            scanf(" %c",&t[i].type);
            if (t[i].type == 'W') w = i;
            else scanf(" %d",&t[i].rank);
        }
        
        if (n >= 2 && (w > 2 || w == -1) && !(t[1] <= t[2])) {
            puts("1");
        } else if (w != -1) {
            begin.type = t[w - 1].type;
            begin.rank = t[w - 1].rank;
            if (w != 2) {
                begin ++;
            }
            
            end.type = t[w + 1].type;
            end.rank = t[w + 1].rank;
            
            if (w == 1) {
                begin.type = 'C';
                begin.rank = 1;
                
                if (w != n) {
                    end.type = t[w + 1].type;
                    end.rank = t[w + 1].rank;
                }
            }
            end --;
            
            if (w == n) {
                end.type = 'D';
                end.rank = m;
            }
            
            ans = 0;
            for (;begin <= end;begin ++,ans ++);
            printf("%d\n",ans);
        } else {
            printf("%d\n",m * 3 - n + 1);
        }
        
    }
    re0;
}
*/

//ll pls(int l,int r)
//{
//
//}
//
//int main()
//{
//    int n;
//    int b[100010];
//    int a[100010];
//    ll ans;
//    int l;
//    __T {
//        sci(n);
//        rep(i,1,n) sci(a[i]);
//        rep(i,1,n) sci(b[i]);
//        rep(i,1,n) a[i] -= b[i];
//        ans = 0;
//        l = -1;
//        rep(r,1,n) {
//            if (a[r] != 0) {
//                if (l == -1) l = r;
//            } else {
//                pls(l,r - 1);
//                l = -1;
//            }
//        }
//
//        printf("%lld\n",ans);
//    }
//    re0;
//}

//char a[10];
//char to[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
//int v['z'];
//
//void init()
//{
//    v['0'] = 6;
//    v['1'] = 2;
//    v['2'] = 5;
//    v['3'] = 5;
//    v['4'] = 4;
//    v['5'] = 5;
//    v['6'] = 6;
//    v['7'] = 3;
//    v['8'] = 7;
//    v['9'] = 6;
//    v['A'] = 6;
//    v['B'] = 5;
//    v['C'] = 4;
//    v['D'] = 5;
//    v['E'] = 5;
//    v['F'] = 4;
//}
//
//void conv(uint x)
//{
//    mem(a,'0');
//    int i = 0;
//    int ans = 0;
//    while (x != 0) {
//        a[++ i] = to[x % 16];
//        x /= 16;
//    }
//    pre(i,8,1) {
//        printf("%c",a[i]);
//        ans += a[i];
//    }
//    printf(" %d\n",ans);
//}
//
//
//int main()
//{
//    init();
//    for (int i = 0;i <= 100;i ++) {
//        conv(i);
//    }
//
//    return 0;
//}


/*
struct Node {
    int l,r;
};

int cmp(const Node &a,const Node &b) {
    return a.l < b.l;
}

int main()
{
    int n,m,x,y;
    Node a[110];
    Node b[110];
    Node k[1000010];
    int cnt;
    int aa,bb;
    ll ans = 0;
    __T {
        cnt = 0;
        scanf("%d %d %d %d",&n,&m,&x,&y);
        rep(i,1,x) scii(a[i].l,a[i].r);
        rep(i,1,y) scii(b[i].l,b[i].r);
        rep(j,1,y) {
            rep(i,1,x) {
                aa = max(a[i].l,b[j].l);
                bb = min(a[i].r,b[j].r);
                if (aa <= bb) {
                    k[cnt].l = aa;
                    k[cnt ++].r = bb;
                }
            }
        }
        sort(k, k + cnt, cmp);
        ans = 0;
        REP(i,0,cnt) {
//            printf("%d %d\n",k[i].l,k[i].r);
            ans += max(0,k[i].r - k[i].l - m + 2);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
ll sum[20];

ll nn[20] = {6,2,5,5,4,5,6,3,7,6,6,5,4,5,5,4};

void init()
{
    sum[0] = 6;
    sum[1] = 8;
    sum[2] = 13;
    sum[3] = 18;
    sum[4] = 22;
    sum[5] = 27;
    sum[6] = 33;
    sum[7] = 36;
    sum[8] = 43;
    sum[9] = 49;
    sum[10] = 55;
    sum[11] = 60;
    sum[12] = 64;
    sum[13] = 69;
    sum[14] = 74;
    sum[15] = 78;
}

void to(char num[])
{
    rep(i,0,7) {
        if (num[i] >= '0' && num[i] <= '9') num[i] ^= 48;
        else num[i] = num[i] - 'A' + 10;
    }
}

uint conv(char num[],int l)
{
    uint ans = 0;
    for (int i = 0;i < l;i ++) {
        ans += (1ULL << (i * 4ULL)) * num[i];
    }
    return ans;
}

ull get(ull num)
{
    ull ans = 0;
    ull f = num / 16,t = 0;
    ull x = 1;
    int k;
    rep(i,0,7) {
        k = num % 16;
        
        // group
        ans += f * sum[15] * (1ULL << (4 * i));
        
        // middle
        if (k) ans += sum[k - 1] * (1ULL << (4 * i));
        
        
        // tail
        ans += (t + 1) * nn[k];
        
        t += (num % 16) * x;
        x <<= 4;
        f /= 16;
        num /= 16;
    }
    return ans;
}

ull single_conv(ull a)
{
    ull ans = 0;
    rep(i,0,7) {
        ans += nn[a % 16];
        a /= 16;
    }
    return ans;
}

void add(uint a,uint b)
{
    ull x = (ull) a + (ull)(b - 1);
    uint k = 0;
    uint t = a + (b - 1);
    if (x > k - 1) {
        printf("%llu\n",single_conv(a) + get(k - 1) - get(a) + get(t));
    } else {
        printf("%llu\n",single_conv(a) + get(x) - get(a));
    }
}

int main()
{
    init();

    int s;
    char num[10];
    char str[10];
    uint x;
    __T {
        scanf("%d",&s);
        scanf("%s",str);
        rep(i,0,7) num[7 - i] = str[i];
        to(num);
        x = conv(num,8);
        add(x,s);
    }
    return 0;
}
*/

/*
int main()
{
    ll x[100];
    x[1] = 1;
    rep(i,2,63) {
        x[i] = x[i - 1] * 2 + 1;
//        printf("%lld\n",x[i]);
    }
    ll y[100];
    rep(i,1,31) {
        y[i] = (1 + x[i]) * x[i]/ 2;
//        printf("%lld\n",y[i]);
    }
    
    
    ll n;
    int i;
    ll k = 0;
    __T {
        scl(n);
        k = 0;
        for (i = 1;i <= 31;i ++) {
            k += y[i];
            if (k <= 0 || k > n) {
                printf("%d\n",i - 1);
                break;
            }
        }
    }
    re0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    int a[100010];
    rep(i,1,n) sci(a[i]);
    sort(a + 1,a + 1 + n);
    int ans = 0;
    
    vector<int> aa;
    aa.pb(a[(n + 1) / 2]);
    if (!(n % 2)) aa.pb(a[(n + 1) / 2 + 1]);
    for (int i = (n + 1) / 2 + 1 + !(n % 2),j = 1;i <= n;i ++,j ++) {
        if (a[j] < a[i] && a[j] < a[i - 1]) ans ++;
        aa.pb(a[j]);
        aa.pb(a[i]);
    }
    printf("%d\n",ans);
    int f = 1;
    for (auto i : aa) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    re0;
}
*/

/*
int main()
{
    int n,m;
    int a[1010];
    int ok;
    int ok2;
    ll sum;
    __T {
        scii(n,m);
        ok = 1;
        ok2 = 0;
        sum = 0;
        rep(i,1,n) {
            sci(a[i]);
            sum += a[i];
            if (a[i] == m) ok2 = 1;
            if (i != 1) {
                if (a[i] != a[i - 1]) ok = 0;
            }
        }
        if (ok && a[1] == m) puts("0");
        else {
            if (m * (ll) n == sum || ok2) puts("1");
            else puts("2");
        }
        
    }
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int n;
    priority_queue<ll,vector<ll>,greater<ll>> que;
    set<ll> vis;
    ll last;
    list<ll> ans;
    list<ll>::iterator j;
    ll g;
    int ok;
    __T {
        sci(n);
        vis.clear();
        ans.clear();
        while (!que.empty()) que.pop();
        for (int i = 2;i * i <= n;i ++) {
            if (n % i == 0) {
                if (isZhi(i)) ans.pb(i);
                else que.push(i);
                if (i != n / i) {
                    if (isZhi(n / i)) ans.pb(n / i);
                    else que.push(n / i);
                }
            }
        }
        
        if (ans.size() == 1) {
            printf("%lld",*ans.begin());
            while (!que.empty()) {
                printf(" %lld",que.top());
                que.pop();
            }
            printf(" %d\n0\n",n);
        } else if (ans.size() == 2 && (*ans.begin()) * (*(++ ans.begin())) == n) {
            printf("%lld %lld %d\n1\n",*ans.begin(),*(++ ans.begin()),n);
        } else {
            for (auto i = ++ ans.begin();i != ans.end();i ++) {
                j = i;
                j --;
                ans.insert(i, g = (*i) * (*j) * gcd(*i,*j));
                vis.insert(g);
            }
            while (!que.empty()) {
                last = que.top();
                que.pop();
                
                if (vis.find(last) != vis.end()) continue;
                
                ok = 0;
                for (auto i = ++ ans.begin();i != ans.end();i ++) {
                    j = i;
                    j --;
                    if (gcd(last,*j) != 1 && gcd(last,*i) != 1) {
                        ans.insert(i, last);
                        ok = 1;
                        break;
                    }
                }
                if (!ok) ans.pb(last);
            }
            ans.pb(n);
            ok = 1;
            for (auto i : ans) {
                if (ok) ok = 0;
                else printf(" ");
                printf("%lld",i);
            }
            printf("\n0\n");
        }
    }
    re0;
}
*/

/*
int n;

const int MAXN = 1e5 + 10;

int a[MAXN];
ll c[MAXN];

void modify(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int mx[MAXN];

void modify_m(int i,int x)
{
    int low;
    a[i] = x; // 会直接修改数组的值
    for (;i <= n;i += lowbit(i)) {
        mx[i] = a[i];
        low = lowbit(i);
        for (int j = 1;j < low;j <<= 1) {
            mx[i] = max(mx[i], mx[i - j]);
        }
    }
}

int query_max(int l,int r)
{
    int ans = max(a[l],a[r]);
    while(true)
    {
        ans = max(ans, a[r]);
        if (l == r) break;
        r --;
        for (;r - l > lowbit(r);r -= lowbit(r))
        {
            ans = max(ans,mx[r]);
        }
    }
    return ans;
}

int main()
{
    int m;
    scii(n,m);
    rep(i,1,n) {
        sci(a[i]);
        modify_m(i, a[i]); // 修改最大值
        modify(i, a[i]);
    }
    int t,x,y;
    while (m --) {
        sciii(t,x,y);
        if (t == 1) {
            modify(x, y - a[x]);
            modify_m(x, y);
        } else if (t == 2) {
            printf("%lld\n",sum(y) - sum(x - 1));
        } else printf("%d\n",query_max(x, y));
    }
    re0;
}
*/


/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n >= 7) {
            if (n % 2) {
                printf("%d %d\n",3,n - 3);
            } else {
                printf("%d %d\n",2,n - 2);
            }
        } else {
            switch (n) {
                case 1:
                    puts("-1");
                    break;
                case 2:
                    puts("-1");
                    break;
                case 3:
                    puts("-1");
                    break;
                case 4:
                    puts("-1");
                    break;
                case 5:
                    puts("-1");
                    break;
                case 6:
                    puts("2 4");
                    break;
                default:
                    break;
            }
        }
        
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    int w[100010];
    double sum = 0;
    __T {
        sum = 0;
        scii(n,k);
        rep(i,1,n) {
            sci(w[i]);
            sum += w[i];
        }
        rep(i,1,n) {
            if (i != 1) printf(" ");
            printf("%.8f",w[i] * (sum + k) / sum);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int a[10]['z'];
    int k[] = {1,2,3,4,5,6};
    int ok = 0;
    __T {
        k[0] = 1;
        k[1] = 2;
        k[2] = 3;
        k[3] = 4;
        k[4] = 5;
        k[5] = 6;
        mem(a,0);
        rep(ii,1,6) {
            cin >> str;
            for (int i = 0;str[i];i ++) {
                a[ii][str[i]] ++;
            }
        }
        ok = 0;
        do {
            if (a[k[0]]['h'] && a[k[1]]['a'] && a[k[2]]['r'] && a[k[3]]['b'] && a[k[4]]['i'] && a[k[5]]['n']) {
                ok = 1;
                break;
            }
        } while (next_permutation(k, k + 6));
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    vector<int> a(n);
    rep(i,0,n-1) a[i] = i + 1;
    vector<int> b(n);
    int m,M;
    map<vector<int>,vector<vector<int>>> all;
    do {
        m = a[0];
        M = a[0];
        rep(i,0,n-1) {
            m = min(m,a[i]);
            M = max(M,a[i]);
            b[i] = M - m;
        }
        all[b].pb(a);
    } while (next_permutation(a.begin(), a.end()));
    
    for (auto i : all) {
        for (auto j : i.first) printf(" %d",j);
        puts(":");
        for (auto j : i.second) {
            for (auto k : j) printf(" %d",k);
            puts("");
        }
        printf("cnt = %lu\n",i.second.size());
        puts("");
    }
    
    return 0;
}
*/



/*
const int mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll AA[100010];

ll A(int a,int b)
{
    return (AA[a] * quickpow(AA[a - b], mod - 2)) % mod;
}

int main()
{
    int n;
    int a[100010];
    int vis[100010];
    int cnt = 0;
    int ok,has;
    
    AA[0] = 1;
    AA[1] = 1;
    rep(i,2,100005) {
        AA[i] = i * AA[i - 1];
        AA[i] %= mod;
    }
    
    int last;
    int length;
    int cc;
    ll ans;
    
    __T {
        cc = cnt = 0;
        ans = 1;
        sci(n);
        vis[0] = 0;
        rep(i,1,n) {
            sci(a[i]);
            vis[i] = 0;
        }

        ok = 1;
        has = 0;
        rep(i,2,n) {
            if (a[i] >= n) {
                ok = 0;
                break;
            }
            if (a[i] == n - 1) has = 1;
            if (a[i] < a[i - 1]) {
                ok = 0;
                break;
            }
            if (has && a[i] < n - 1) {
                ok = 0;
                break;
            }
        }
        if (a[1] != 0) ok = 0;
        
        
        if (ok) {
            length = 0;
            last = 0;
            
            rep(i,2,n) {
                if (a[i] > last) {
                    if (cc < length) {
                        puts("0");
                        goto nxt;
                    }
                    
                    ans *= A(cc,length);
                    ans %= mod;
                    
                    cc -= length;
                    cc += a[i] - last - 1;
                    
                    length = 0;
                    cnt ++;
                    
                } else length ++;
                last = a[i];
            }
            
            if (cc < length) {
                puts("0");
                goto nxt;
            }
            
            ans *= A(cc,length);
            ans %= mod;
            
            ans *= quickpow(2, cnt);
            ans %= mod;
            printf("%lld\n",ans);
        } else puts("0");
    nxt:;
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    int a[50010];
    int ok = 1;
    __T {
        scl(n);
        rep(i,1,n) {
            sci(a[i]);
            
        }
        ok = 1;
       
        rep(i,2,n) {
            if (a[i] >= a[i - 1]) {
                ok = 0;
                break;
            }
        }
        
        puts(ok ? "NO" : "YES");
        
    }
    return 0;
}
*/


/*
int main()
{
    int n;
    ll x[50][5];
    ll k[50];
    ll t;
    ll cnt = 0;

    __T {
        sci(n);
        mem(x,0);
        cnt = 0;
        rep(i,1,n) {
            scl(t);
            REP(i,0,32) {
                k[i] = t & 1;
                t >>= 1;
            }
            pre(i,31,0) {
                if (k[i]) {
                    cnt += x[i][1];
                    x[i][1] ++;
                    break;
                }
            }
        }
        printf("%lld\n",cnt);
    }
    return 0;
}
*/

/*
int main()
{
    int n,q;
    ll a[300010];
    ll dp[2];
    __T {
        scii(n,q);
        dp[0] = dp[1] = 0;
        rep(i,1,n) scl(a[i]);
        dp[1] = a[1];
        rep(i,2,n) {
            dp[0] = max(dp[0],dp[1] - a[i]);
            dp[1] = max(dp[1],dp[0] + a[i]);
        }
        printf("%lld\n",max(dp[0],dp[1]));
    }
    return 0;
}
*/

/*
int main()
{
    freopen("data.txt","w",stdout);
    int a[500];
    rep(i,1,480) a[i] = i;
    srand((uint)time(NULL));
    rep(i,1,480) swap(a[rand() % 480 + 1],a[rand() % 480 + 1]);
    rep(i,1,160) printf("%d ",a[i]);
    puts("\r\n");
    rep(i,161,320) printf("%d ",a[i]);
    puts("\r\n");
    rep(i,321,480) printf("%d ",a[i]);
    puts("\r\n");
    return 0;
}
*/

//
//int main()
//{
//    int n,m;
//    scii(n,m);
//    int a[20010];
//    rep(i,1,n) sci(a[i]);
//    int u,v,x;
//    while (m --) {
//        sciii(u,v,x);
//
//    }
//    re0;
//}

/*
int main()
{
    int n;
    char x;
    sci(n);
    scanf(" %c",&x);
    int nn = n - 1;
    nn /= 2;
    int v = sqrt(4 * nn + 4) - 1;
    if (v % 2 == 0) v --;
    rep(i,1,(v - 1) / 2 + 1) {
        REP(ii,1,i) printf(" ");
        rep(ii,1,v - (i - 1) * 2) printf("%c",x);
        puts("");
    }
    
    pre(i,(v - 1) / 2,1) {
        REP(ii,1,i) printf(" ");
        rep(ii,1,v - (i - 1) * 2) printf("%c",x);
        puts("");
    }
    printf("%d\n",n - (v + 3) * (v - 1) / 2 - 1);
    return 0;
}
*/

/*
int main()
{
    char p[100010];
    mem(p,1);
    p[1] = 0;
    p[2] = 1;
    int n;
    sci(n);
    rep(i,2,n) {
        for (int j = i + i;j <= n;j += i) {
            p[j] = 0;
        }
    }
    int cnt = 0;
    int pp[100010];
    rep(i,1,n) {
        if (p[i]) pp[++ cnt] = i;
    }
    int ans = 0;
    rep(i,2,n) {
        if (pp[i] - pp[i - 1] == 2) ans ++;
    }
    printf("%d\n",ans);
    re0;
}
*/

/*
int main()
{
    int n,m;
    scii(n,m);
    int a[110];
    REP(i,0,n) sci(a[i]);
    REP(i,0,n) {
        if (i != 0) printf(" ");
        printf("%d",a[(i - m + n * m) % n]);
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    int x,y,z,k;
    __T {
        sciii(x,y,z);
        k = x + y - z;
        if (x + y < z) puts("-1");
        else if (x + y == z) printf("%d\n",z + 1);
        else if (k <= x || k <= z) puts("-1");
        else printf("%d\n",x + y - z);
    }
    return 0;
}
*/

/*ll to(int a) {
    ll ans = 1;
    while (a) {
        
        ans *= a % 10;
        
        if (ans == 0) return ans;
        a /= 10;
    }
    return ans;
}

int main()
{
    int l,r;
    ll ans;
    __T {
        scii(l,r);
        ans = 1;
        rep(i,l,r) {
            ans *= to(i);
            if (ans == 0) break;
            ans %= 1000000007;
        }
        _C(ans);
    }
    re0;
}
*/

/*
string str;
int n,k;

int chk(int l) {
    int ans = 0;
    for (int i = 0;i < n;) {
        if (str[i] == '1') {
            ans ++;
            i += l;
        } else i ++;
    }
    return ans <= k;
}

int main()
{
    int l,r,m;
    __T {
        scii(n,k);
        cin >> str;
        l = 1;
        r = n;
        while (l < r) {
            m = (l + r) / 2;
            if (chk(m)) r = m;
            else l = m + 1;
        }
        printf("%d\n",r);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    ll n;
    ll a6,a9,a0,a8;
    ll ans = 0;
    int o;
    
    __T {
        cin >> str;
        n = str.size();
        ans = (1 + n) * n / 2;
        o = 0;
        a0 = a8 = a6 = a9 = 0;
        REP(i,0,n) {
            if (str[i] == '6') a6 ++;
            else if (str[i] == '9') a9 ++;
            else if (str[i] == '0') a0 ++;
            else if (str[i] == '8') a8 ++;
            if (str[i] == '0' || str[i] == '8') o = 1;
        }
        ans -= (a0 + 1) * a0 / 2;
        ans -= (a8 + 1) * a8 / 2;
        o = o || (a6 && a9);
        if (o) ans ++;
        ans -= a6 * a9;
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
const int MAXN = 1e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int vis[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}


void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
        vis[i] = 0;
    }
}

int n,m;

int conv(int i,int j) {
    return i * m + j;
}

int main()
{
    char a[MAXN];
    
    int t;
    int ii,jj;
    int ok;
    int last;
    int times;
    __T {
        scii(n,m);
        init(n * m + 5);
        REP(i,0,n) {
            scanf(" ");
            REP(j,0,m) {
                scanf("%c",&a[conv(i,j)]);
            }
        }
        REP(i,0,n) {
            REP(j,0,m) {
                scanf("%d",&t);
                ii = i;
                jj = j;
                switch (a[conv(i,j)]) {
                    case 'u':
                        ii -= t;
                        break;
                    case 'd':
                        ii += t;
                        break;
                    case 'l':
                        jj -= t;
                        break;
                    case 'r':
                        jj += t;
                        break;
                    default:
                        break;
                }
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    bind(conv(i,j),conv(ii,jj));
                    vis[conv(ii,jj)] ++;
                }
            }
        }
        ok = 1;
        last = find(0);
        REP(i,1,n * m) {
            if (last != (t = find(i))) {
                ok = 0;
                break;
            }
            last = t;
        }
        times = 0;
        REP(i,0,n * m) if (vis[i] == 0) times ++;
        if (times >= 2) ok = 0;
        
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main()
{
    int n;
    char p[MAXN],vis[MAXN];
    int cnt;
    int t;
    vector<pair<int,int>> ans;
    __T {
        ans.clear();
        sci(n);
        rep(i,0,n) {
            p[i] = 1;
            vis[i] = 0;
        }
        rep(i,3,n) {
            if (!p[i] || i % 2 == 0) continue;
            cnt = 1;
            for (int j = i + i;j <= n;j += i) {
                p[j] = 0;
                if (!vis[j]) cnt ++;
            }
            
            t = i;
            for (int j = i * (2 + cnt % 2);j <= n;j += i) {
                if (vis[j]) continue;
                if (t == -1) {
                    t = j;
                } else {
                    vis[j] = vis[t] = 1;
                    ans.pb(mpair(t,j));
                    t = -1;
                }
            }
        }
        
        t = -1;
        rep(i,2,n) {
            if (!(i & 1) && !vis[i]) {
                if (t == -1) {
                    t = i;
                } else {
                    ans.pb(mpair(t,i));
                    t = -1;
                }
            }
        }
        printf("%lu",ans.size());
        for (auto i : ans) {
            printf(" %d %d",i.first,i.second);
        }
        puts("");
    }
    re0;
}
*/

/*
int main()
{
    int n,x;
    __T {
        scii(n,x);
        if (n == 1 || n == 2) printf("1\n");
        else {
            n -= 2;
            printf("%.0f\n",ceil(n / (double)x) + 1);
        }
    }
    re0;
}
*/

/*
int main() {
    int n;
    sci(n);
    ll s = 0;
    ll ans = 0;
    ll a[200010];
    set<ll> vis;
    vis.insert(0);
    REP(i,0,n) scanf("%lld",&a[i]);
    REP(i,0,n) {
        if (vis.find(s + a[i]) != vis.end()){
            vis.clear();
            vis.insert(s = 0);
            ans ++;
        }
        s += a[i];
        vis.insert(s);
    }
    printf("%lld\n",ans);
    
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int a,b,c,d;
    int ok;
    __T {
        scii(n,m);
        ok = 0;
        while (n --) {
            scii(a,b);
            scii(c,d);
            if (b == c) ok = 1;
        }
        if (m % 2) puts("NO");
        else {
            puts(ok ? "YES" : "NO");
        }
    }
    re0;
}
*/
/*
int main()
{
    int n;
    sci(n);
    ll a1,a2,a3;
    ll b1,b2,b3;
    sclll(a1,a2,a3);
    sclll(b1,b2,b3);
    ll w = min(a1,b2) + min(a2,b3) + min(a3,b1);
    ll l;
    ll t;
    
    ll aa1,aa2,aa3;
    ll bb1,bb2,bb3;
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    l = min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1);
    
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    
    printf("%lld %lld\n",l,w);
    
    return 0;
}
*/

/*
const int MAXN = 2e4 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 1];
int g[MAXN];

int cnt;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int bg[MAXN],ed[MAXN];
int dfn = 0;

void dfs(int n) {
    bg[n] = ++ dfn;
    // iterate graph
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs(to);
    }
    ed[n] = dfn;
}

int n,m;

struct node{
    int l,r;
    ll add;
    ll sum;
} tree[MAXN << 2];
void pushup(int index){
    tree[index].sum = tree[index<<1].sum+tree[index<<1|1].sum;
}
void pushdown(int index){    //下推标记
    if(tree[index].add){
         tree[index<<1].sum += (tree[index<<1].r-tree[index<<1].l+1)*tree[index].add;
        tree[index<<1|1].sum +=(tree[index<<1|1].r-tree[index<<1|1].l+1)*tree[index].add;
        
        tree[index<<1].add += tree[index].add;
        tree[index<<1|1].add += tree[index].add;
        
        tree[index].add = 0;
    }
}
void build(int l, int r, int index){        //建树    数组a的l,r区间建树
    tree[index].l = l;
    tree[index].r = r;
    tree[index].add = 0;
    if(l == r){
//        scanf("%lld",&tree[index].sum);
        
         tree[index].sum = 0;
        return;
    }
    int mid = (l+r)>>1;
    build(l,mid,index<<1);
    build(mid+1,r,index<<1|1);
    pushup(index);
}
void update(int l,int r,int index, ll w){    //修改a[L]的值 更新sum
    if(l <= tree[index].l && r >= tree[index].r){
        tree[index].sum += (tree[index].r-tree[index].l+1)*w;
        tree[index].add += w;
        return;
    }
    pushdown(index);
    int mid = (tree[index].l + tree[index].r)>>1;
    if(l <= mid) update(l,r,index<<1,w);
    if(r > mid) update(l,r,index<<1|1,w);
    pushup(index);
}
ll query(int l,int r,int index){    //查询
    if(l <= tree[index].l && r >= tree[index].r){
        return tree[index].sum;
    }
    pushdown(index);
    int mid = (tree[index].l + tree[index].r)>>1;
    ll sum = 0;
     if(l <= mid){
         sum += query(l,r,index<<1);
     }
    if(r > mid){
        sum += query(l,r,index<<1|1);
    }
    return sum;
}

int main()
{
    init();
    scii(n,m);
    build(1,n,1);
    int t;
    int root = 1;
    rep(i,1,n) {
        sci(t);
        if (t) add(t,i);
        else root = i;
    }
    dfs(root);

    int u,x,v;
    while (m --) {
        sciii(u,x,v);
        printf("%lld\n",query(bg[v],bg[v],1));
        update(bg[u], ed[u], 1, x);
    }
    return 0;
}
*/

/*
const int MAXN = 2e4 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 1];
int g[MAXN];

int cnt;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int bg[MAXN],ed[MAXN];
int dfn = 0;

void dfs(int n) {
    bg[n] = ++ dfn;
    // iterate graph
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs(to);
    }
    ed[n] = dfn;
}

int n,m;
ll c[MAXN] = {0};

void modify(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i))
    {
        c[i] += x;
    }
}

ll sum(int i)
{
    // 查询：由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

void pls(int l,int r,int k)
{
    modify(l, k);
    modify(r + 1, -k);
}


int main()
{
    init();
    
    scii(n,m);
    int t;
    int root = 1;
    rep(i,1,n) {
        sci(t);
        if (t) add(t,i);
        else root = i;
    }
    dfs(root);

    int u,x,v;
    while (m --) {
        sciii(u,x,v);
        printf("%lld\n",sum(bg[v]));
        pls(bg[u],ed[u],x);
    }
    return 0;
}
*/

/*
int n;

const int MAXN = 1e5 + 10;

struct Edge {
    Edge(){}
    Edge(int to,int nxt):to(to),nxt(nxt){}
    int to;
    int nxt;
} e[MAXN << 1];

int g[MAXN];
int cnt;

int dfn = 0;

void init()
{
    mem(g,-1);
    cnt = 0;
    dfn = 0;
}

void add(int u,int v) {
    e[cnt] = Edge(v,g[u]);
    g[u] = cnt ++;
}

int in[MAXN],out[MAXN];

void dfs(int k,int f)
{
    in[k] = ++ dfn;
    for (int i = g[k];~i;i = e[i].nxt)
    {
        if (e[i].to != f) {
            dfs(e[i].to,k);
        }
    }
    out[k] = dfn;
}

int c[MAXN] = {0};
int a[MAXN];

void modify(int idx,ll x)
{
    a[idx] += x;
    // 从叶子结点一路向上更新
    for (int i = idx;i <= n;i += lowbit(i))
    {
        c[i] += x;
    }
}

ll sum(int idx)
{
    // 查询：由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int main()
{
    sci(n);
    init();
    int u,v;
    rep(i,1,n - 1) {
        scii(u,v);
        add(u,v);
        add(v,u);
    }
    dsci(m);
    char c;
    int x;
    dfs(1,-1);
    
    rep(i,1,n) {
        modify(i, 1);
    }
    
    while (m --) {
        scanf(" %c",&c);
        sci(x);
        if (c == 'C') {
            if (a[in[x]]) modify(in[x], -1);
            else modify(in[x], 1);
        }
        else if (c == 'Q') printf("%lld\n",sum(out[x]) - sum(in[x] - 1));
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int ans;
    int cnt;
    __T {
        sci(n);
        ans = n;
        cnt = n;
        for (int i = 1;cnt <= ans;i ++,ans = min(ans,cnt)) {
            cnt = (i - 1) + n / i + min(n % i,1) - 1;
        }
        printf("%d\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    ll k;
    ll n,ans;
    while (~scl(k)) {
        k = abs(k);
        for (ans = 1,n = 1;n < k || n % 2 != k % 2;n += ++ ans);
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    int n,k;
    __T {
        scii(n,k);
        rep(i,1,k) {
            n = (n >> 1) + (n & 1);
            if (n == 1 | n == 0) break;
        }
        printf("%d\n",n);
    }
    re0;
}
*/

/*
int main()
{
    ll year1,mon1,day1;
    ll year,mon,day;
    string s;
    string str[] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday"};
    map<string,int> conv;
    rep(i,0,4) conv[str[i]] = i;
    __T {
        scanf("%lld %lld %lld", &year, &mon, &day);
        cin >> s;
        scanf("%lld %lld %lld", &year1, &mon1, &day1);
        day %= 5;
        day1 %= 5;
        
        _C(str[(conv[s] + day1 + 5 - day) % 5]);
        
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    ll x = 0,y;
    ll p;
    __T {
        sci(n);
        p = 0;
        rep(i,1,n) {
            sci(a[i]);
            p += a[i];
        }
        p /= n;
        x = y = 0;
        rep(i,1,n) {
            x += a[i] - p;
            y += abs(a[i] - p);
        }
        printf("%lld\n",x + (y - x) / 2);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    string str;
    ll x,y;
    ll ans;
    ll ans2;
    __T {
        scii(n,k);
        cin >> str;
        x = y = 0;
        ans = ans2 = 0;
        REP(i,0,n) {
            switch (str[i]) {
                case 'U':
                    y ++;
                    break;
                case 'D':
                    y --;
                    break;
                case 'L':
                    x --;
                    break;
                case 'R':
                    x ++;
                    break;
                default:
                    break;
            }
            ans2 = max(abs(x) + abs(y),ans2);
        }
        x *= (k - 1);
        y *= (k - 1);
        REP(i,0,n) {
            switch (str[i]) {
                case 'U':
                    y ++;
                    break;
                case 'D':
                    y --;
                    break;
                case 'L':
                    x --;
                    break;
                case 'R':
                    x ++;
                    break;
                default:
                    break;
            }
            ans = max(abs(x) + abs(y),ans);
        }
        printf("%lld\n",max(ans,ans2));
    }
    re0;
}
*/

/*
int main()
{
    ll k;
    string str;
    ll n,m;
    int u,v;
    ll i;
    __T {
        scl(k);
        cin >> str;
        scll(n,m);
        rep(i,1,m) scii(u,v);
        
        i = (m - n + 1 + k) % k;
        if (str[i] == '1') puts("2");
        else if (str[i] == '2') puts("1");
    }
    return 0;
}
*/

/*
int cmp(const pair<int,int> &a,const pair<int,int> &b)
{
    if (a.second == b.second) return a.first < b.first;
    return a.second < b.second;
}

int main() {
    int n;
    int l,r;
    ll ans;
    pair<int, int> a[100010];
    map<int,int> vis;
    __T {
        sci(n);
        vis.clear();
        rep(i,1,n) {
            scii(l,r);
            a[i] = mpair(l,r);
        }
        sort(a + 1,a + 1 + n,cmp);
        ans = 0;
        rep(i,1,n) {
            rep(j,a[i].first,a[i].second) {
                if (!vis[j]) {
                    vis[j] = 1;
                    ans ++;
                    break;
                }
            }
        }
        printf("%lld\n",ans);
    }
}
*/

/*
int n,m;
const int MAXN = 110;

vector<int> g1[MAXN],g2[MAXN];

int in[MAXN],out[MAXN];

int ch[MAXN],fa[MAXN];

int nonvis[MAXN];
int vis[MAXN];

int tuopu()
{
    queue<int> q;
    rep(i,1,n) {
        if (nonvis[i]) {
            if (in[i] == 0) q.push(i);
        }
        vis[i] = 0;
    }
    int t;
    while (!q.empty()) {
        t = q.front();
        q.pop();
        
        if (vis[t]) continue;
        vis[t] = 1;
        
        for (auto i : g1[t]) {
            ch[i] += 1 + ch[t];
            in[i] --;
            if (in[i] == 0) {
                q.push(i);
            }
        }
        
    }
    int ok = 1;
    rep(i,1,n) {
        if (!vis[i] && nonvis[i]) {
            ok = 0;
            break;
        }
    }
    
    if (!ok) re0;
    re1;
}


void bfs()
{
    queue<int> q1;
    queue<int> q2;
    
    rep(i,1,n) {
        ch[i] = fa[i] = vis[i] = 0;
    }
    int t;
    rep(i,1,n) {
        rep(j,1,n) vis[j] = 0;
        ch[i] = -1;
        
        q1.push(i);
        while (!q1.empty()) {
            t = q1.front();
            q1.pop();
            
            if (vis[t]) continue;
            vis[t] = 1;
            
            ch[i] ++;
            
            for (auto i : g1[t]) {
                q1.push(i);
            }
        }
        
        rep(j,1,n) vis[j] = 0;
        fa[i] = -1;
        
        q2.push(i);
        while (!q2.empty()) {
            t = q2.front();
            q2.pop();
            
            if (vis[t]) continue;
            vis[t] = 1;
            
            fa[i] ++;
            
            for (auto i : g2[t]) {
                q2.push(i);
            }
        }
    }
}

int main()
{
    int u,v;
    
    __T {
        scii(n,m);
        rep(i,1,n) {
            g1[i].clear();
            g2[i].clear();
            in[i] = out[i] = nonvis[i] = 0;
        }
        
        while (m --) {
            scii(u,v);
            in[v] ++;
            out[u] ++;
            g1[u].pb(v);
            g2[v].pb(u);
            nonvis[u] = 1;
            nonvis[v] = 1;
        }
        
        if (tuopu())
        {
            bfs();
            rep(i,1,n) {
                if (!nonvis[i] || (ch[i] <= n / 2 && fa[i] <= n / 2)) printf("1");
                else printf("0");
            }
        } else rep(i,1,n) printf("0");
        puts("");
    }
    return 0;
}
*/

/*
int a,p,pp;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % pp;
        a = a * a % pp;
        b >>= 1;
    }
    return ans;
}


int main()
{
    vector<int> ans;
    int d;
    int e;
    vector<int>::iterator it;
    __T {
        scii(a,p);
        pp = 1 << p;
        ans.clear();
        if (a & 1) {
            printf("1\n");
            continue;
        }
        rep(x,1,pp) {
            if (quickpow(a, x) == quickpow(x, a)) {
                ans.pb(x);
            }
            if (ans.size() == 5) break;
        }
        
        it = ans.end();
        d = (e = *(-- it)) - *(-- it);
        printf("%lu\n",ans.size() + (pp - e) / d);
    }
    return 0;
}
*/


/*
int main()
{
    int n;
    sci(n);
    int ans = 0;
    int u,v;
    int de[100010] = {0};
    
    rep(i,1,n - 1) {
        scii(u,v);
        de[u] ++;
        de[v] ++;
    }
    rep(i,1,n) {
        if (de[i] == 1) ans ++;
    }
    printf("%d\n",ans);
    re0;
}
*/

/*
int main()
{
    dsci(n);
    set<int> s;
    int a[100010];
    rep(i,1,n) sci(a[i]);
    int b[100010];
    b[1] = 0;
    s.insert(a[1]);
    set<int>::iterator it;
    rep(i,2,n) {
        it = s.upper_bound(a[i]);
        if (it != s.end()) b[i] = *it;
        else b[i] = 0;
        s.insert(a[i]);
    }
    ll sum = 0;
    rep(i,1,n) sum += b[i];
    printf("%lld\n",sum);
    re0;
}
*/

/*
int a[100010];
int b[100010] = {0};

int max(int a,int b) {
    return a > b ? a : b;
}

int main()
{
    int n,m,q,maxn = -1;
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
        maxn = max(a[i],maxn);
        b[a[i]] ++;
    }
    for (int i = maxn - 1;i >= 1;i --) b[i] += b[i + 1];
    scanf("%d",&m);
    while (m --) {
        scanf("%d",&q);
        printf("%d\n",b[a[q] + 1]);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int u,v;
    __T {
        sci(n);
        rep(i,1,n - 1) {
            scii(u,v);
        }
        if (!(n & 1)) puts("Bob");
        else puts("Alice");
    }
    re0;
}
*/

/*
int main()
{
    int n,k;
    vector<int> pos;
    char x[] = {'0','1','2','3','4','5','6','7','8','9'};
    __T {
        scii(k,n);
        pos.clear();
        while (n) {
            n --;
            pos.pb(n % k);
            n /= k;
        }
        
        for (auto i = pos.rbegin();i != pos.rend();i ++)
        {
            printf("%c",x[10 - k + *i]);
        }
        puts("");
    }
    re0;
}
*/

/*
int main()
{
    int k;
    sci(k);
    k --;
    
    int l = 1,r = k;
    int le = k - l * r;
    int cnt = l + r + le;
    
    int low = cnt;
    
    for (int i = 1,x;i * i <= k;i ++) {
        x = k / i;
        le = k - i * x;
        cnt = i + x + le;
        if (cnt <= low) {
            low = cnt;
            l = i;
            r = x;
        }
    }
    le = k - l * r + 1;
    
    cnt = low;
    cnt ++;
    printf("%d\n",cnt);
    
    int i;
    int f = 1;
    for (i = 2;i <= le;i ++) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i - 1);
    }
    rep(j,1,l) {
        if (j == 1) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",le);
        } else {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i - 1);
        }
        i ++;
    }
    rep(j,1,r) {
        if (j == 1) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",le);
        } else {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i - 1);
        }
        i ++;
    }
    puts("");
    for (i = 1;i <= le;i ++) {
        if (i != 1) printf(" ");
        printf("2");
    }
    for (i = le + 1;i <= cnt;i ++) {
        printf(" 1");
    }
    puts("");
    return 0;
}
*/

/*
int ucmp(const pair<string,int> &a,const pair<string,int> &b) {
    return a.first == b.first;
}

int cmp(const pair<string,int> &a,const pair<string,int> &b) {
    return a.second < b.second;
}

int main()
{
    int n;
    scanf("%d ",&n);
    pair<string,int> str[1010];
    for (int i = 0;i < n;i ++) {
        getline(cin,str[i].first);
        str[i].second = i;
    }
    sort(str,str + n);
    pair<string, int> *end;
    end = unique(str, str + n, ucmp);
    int m = (int) (end - str);
    printf("%d\n",m);
    sort(str,str + m,cmp);
    for (int i = 0;i < m;i ++) cout << str[i].first << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d ",&n);
    vector<string> ans;
    string str;
    map<string,int> vis;
    for (int i = 0;i < n;i ++) {
        getline(cin,str);
        if (vis[str]) continue;
        vis[str] = 1;
        ans.push_back(str);
    }
    printf("%lu\n",ans.size());
    for (auto i : ans) cout << i << endl;
    return 0;
}
*/

/*
int main()
{
    string m;
    cin >> m;
    string str;
    vector<string> ans;
    int ok;
    __T {
        cin >> str;
        ok = 1;
        if (m.size() != str.size()) continue;
        for (int i = 0;str[i];i ++) {
            if (m[i] == '*') continue;
            if (m[i] != str[i]) {
                ok = 0;
                break;
            }
        }
        if (ok) ans.pb(str);
    }
    printf("%lu\n",ans.size());
    for (auto i : ans) {
        _C(i);
    }
    return 0;
}
*/

/*
int n,m;
int main()
{
    scii(n,m);
    int a[1010];
    int b[1010];
    rep(i,1,n) scii(a[i],b[i]);
    int x,y,t;
    int cnt;
    int mod,k;
    int idx;
    rep(j,1,m) {
        sciii(x,y,t);
        cnt = 0;
        rep(i,1,n) {
            mod = b[i] - a[i];
            mod *= 2;
            k = t % mod;
            if (k < b[i] - a[i] + 1) idx = a[i] + k;
            else idx = a[i] + (mod - k);
            if (idx >= x && idx <= y) cnt ++;
        }
        printf("%d\n",cnt);
    }
    
    re0;
}
*/

/*
pair<int,int> a[100010];

int cmp(const pair<int,int> &a,const pair<int,int> &b)
{
    return a.second < b.second;
}

int main()
{
    int n,k;
    scii(n,k);
    int t[100010] = {0};
    rep(i,1,n) {
        sci(a[i].first);
        t[a[i].first] ++;
    }
    rep(i,1,n) sci(a[i].second);
    
    sort(a + 1,a + 1 + n,cmp);
    int cnt = 0;
    rep(i,1,k) if (t[i]) cnt ++;
    ll ans = 0;
    rep(i,1,n) {
        if (cnt >= k) break;
        if (t[a[i].first] <= 1) continue;
        t[a[i].first] --;
        cnt ++;
        ans += a[i].second;
    }
    printf("%lld\n",ans);
    re0;
}
*/

/*
int a[10];
int b[10];
int n;
ll k,cnt,mod;
ll nn;

ll get(int i) {
    ll ans = 0;
    int x = 0;
    rep(j,i,7) {
        ans ++;
        if (a[j]) x ++;
        if (x == n) return ans;
    }
    nn = n - x;
    k = nn / cnt;
    mod = nn % cnt;
    if (mod) k ++;
//    _C(">>" << k)
    ans += k * 7;
    ans -= 7 - b[mod];
    return ans;
}

int main()
{
    
    int s,e;
    
    ll ans;
    ll x;
    __T {
        sci(n);
        cnt = 0;
        s = 0;
        e = 0;
        rep(i,1,7) {
            sci(a[i]);
            if (a[i]) {
                b[++ cnt] = i;
                if (!s) s = i;
                e = i;
            }
        }
        b[0] = e;
        ans = -1;
        rep(i,1,7) {
            x = get(i);
//            _C(x);
            if (ans == -1 || x < ans) ans = x;
        }
        
        printf("%lld\n",ans);
        
    }
    re0;
}
*/

/*
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll r = exgcd(b, a % b, x, y);
    ll t = y;
    y = x - (a / b) * y;
    x = t;
    return r;
}

int main()
{
    ll n,nn;
    scl(n);
    nn = n;
    vector<ll> y;
    for (ll i = 2;i * i <= nn;i ++) {
        if (n % i == 0) {
            y.pb(i);
            y.pb(n / i);
        }
    }
    
    ll a,b;
    ll p;
    for (auto i : y) {
        for (auto j : y) {
            if (i > 1 && i < nn && j > 1 && j < nn && exgcd(i,j,a,b) == 1) {
                a *= (nn - 1);
                b *= (nn - 1);
                
                if (a <= 0) {
                    p = abs(a) / j;
                    p ++;
                    a += p * j;
                    b -= p * i;
                }
                if (b <= 0) {
                    p = abs(b) / i;
                    p ++;
                    b += p * i;
                    a -= p * j;
                }
                
                if (b >= nn) {
                    p = (b - nn) / i;
                    p ++;
                    a += p * j;
                    b -= p * i;
                }
                
                if (a >= nn) {
                    p = (a - nn) / j;
                    p ++;
                    b += p * i;
                    a -= p * j;
                }
                
                if (a < 1 || a >= j || b < 1 || b >= i) continue;
                
                printf("YES\n2\n");
                printf("%lld %lld\n",a,j);
                printf("%lld %lld\n",b,i);
                re0;
            }
        }
    }
    puts("NO");
    
    re0;
}
*/

/*
int n,m;

int check(int a,int b,int c)
{
    int ok = 0;
    
    int h = b + c,
    w = 3 * a + b + c;
    
    if (h <= n && w <= m) ok = 1;
    if (h <= m && w <= n) ok = 1;
    
    h = 2 * a + 2 * c;
    w = b + 2 * c;
    
    if (h <= n && w <= m) ok = 1;
    if (h <= m && w <= n) ok = 1;
    
    return ok;
}

int main()
{
    int a,b,c;
    sciii(a,b,c);
    scii(n,m);
    int ok = check(a,b,c) | check(a,c,b) | check(b,a,c) | check(b,c,a) | check(c,a,b) | check(c,b,a);
    puts(ok ? "Yes" : "No");
    re0;
}
*/

/*
int a[110],b[110],c[110];
int p[110];
int n;

int main()
{
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        rep(i,1,n) sci(b[i]);
        rep(i,1,n) sci(c[i]);
        p[1] = a[1];
        rep(i,2,n - 1) {
            if (a[i] != p[i - 1]) p[i] = a[i];
            else if (b[i] != p[i - 1]) p[i] = b[i];
            else p[i] = c[i];
        }
        if (a[n] != p[1] && a[n] != p[n - 1]) p[n] = a[n];
        else if (b[n] != p[1] && b[n] != p[n - 1]) p[n] = b[n];
        else p[n] = c[n];
        rep(i,1,n) {
            if (i != 1) printf(" ");
            printf("%d",p[i]);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    int n,l;
    int f[100010];
    double ta[100010];
    double tb[100010];
    double v;
    int t;
    double ext;
    double va,vb;
    double a,b;
    __T {
        scii(n,l);
        rep(i,1,n) sci(f[i]);
        f[0] = 0;
        f[n + 1] = l;
        v = 1;
        
        ta[0] = 0;
        rep(i,1,n + 1) {
            ta[i] = (f[i] - f[i - 1]) / v + ta[i - 1];
            v ++;
        }
        
        v = 1;
        
        tb[n + 1] = 0;
        pre(i,n,0) {
            tb[i] = (f[i + 1] - f[i]) / v + tb[i + 1];
            v ++;
        }
        
        
//        rep(i,0,n + 1) {
//            printf("%f ",ta[i]);
//        }
//        puts("");
//        rep(i,0,n + 1) {
//            printf("%f ",tb[i]);
//        }
//        puts("");
        
        for (t = 0;t <= n + 1;t ++) {
            if (ta[t] >= tb[t]) break;
        }
        
        va = t;
        vb = n + 2 - t;
//        _C(va << " " << vb);
        
        ext = max(ta[t - 1],tb[t]);
        a = f[t - 1];
        b = f[t];
        
//        _C(">>" << t)
        
        if (fabs(ta[t - 1] - tb[t]) <= 1e-6){}
        else if (ta[t - 1] > tb[t]) {
            b -= vb * fabs(ext - tb[t]);
        } else if (ta[t - 1] < tb[t]) {
            a += va * fabs(ext - ta[t - 1]);
        }
//        _C("s> " << a << " " << b)
        printf("%.15f\n",ext + (b - a) / (va + vb));
        
        
        
    }
    re0;
}
*/

//
//itn h[1000010];
//pair<int,int> r[20010];
//pair<int,int> w[20010];
//
//int main()
//{
//    itn n,m;
//    scii(n,m);
//    mem(h,-1);
//    rep(i,1,n) {
//        scii(r[i].first,r[i].second);
//    }
//    rep(i,1,m) {
//        scii(w[i].first,w[i].second);
//    }
//
//
//
//    rep(i,1,n) {
//        rep(j,1,m) {
//            if (r[i].second <= w[j].second && r[i].first <= w[j].first)
//            h[w[j].second - r[i].second] = max(h[w[j].second - r[i].second],w[j].first - r[i].first + 1);
//        }
//    }
//    _C(h[0])
//    ll mx = -INT_INF;
//    ll ans = INT_INF;
//    pre(i,1000005,0) {
//        mx = max((ll)h[i],mx);
//        ans = min(ans,mx + i);
//    }
//    _C(ans);
//
////    int mn_x,mn_y,mn;
////    int ans_x = 0,ans_y = 0,ans = 0;
////    int t;
////    rep(i,1,n) {
////        mn_y = h[r[i].second] - r[i].first + 1;
////        mn_x = 0;
////        mn = mn_x + mn_y;
////
////        _C(">>" << mn);
////        rep(j,1,m) {
////            if (w[j].second < r[i].second) continue;
////            t = w[j].second - r[i].second + 1 + h[w[j].second + 1] - r[i].first + 1;
////            if (t < mn) {
////                mn = t;
////                mn_x = h[w[j].second + 1] - r[i].first + 1;
////                mn_y = w[j].second - r[i].second + 1;
////            }
////        }
////        _C(">>" << mn << " " << mn_x << " " << mn_y);
////        ans_x = max(ans_x,mn_x);
////        ans_y = max(ans_y,mn_y);
////    }
////    printf("%d\n",ans_x + ans_y);
//    re0;
//}

/*
int main()
{
    ll n;
    int q;
    scl(n);
    sci(q);
    char cc;
    ll k;
    ll r = (1 + n) * n / 2,c = r;
    ll tr = n,tc = n;
    int visr[1000010] = {0};
    int visc[1000010] = {0};
    while (q --) {
        scanf(" %c %lld",&cc,&k);
        if (cc == 'R') {
            if (visr[k]) puts("0");
            else {
                visr[k] = 1;
                printf("%lld\n",k * tc + c);
                r -= k;
                tr --;
            }
        } else if (cc == 'C') {
            if (visc[k]) puts("0");
            else {
                visc[k] = 1;
                printf("%lld\n",k * tr + r);
                c -= k;
                tc --;
            }
        }
    }
    
}
*/

/*
pair<string,int> st[200010];
int cnt = 0;
int s = -1;
int s_idx;
string str = "";

int last_index = 0;

string ans = "";
string word = "";

int ok() {
    if (word.size() <= 1) re0;
    int up_num = 0;
    for (int i = 0;word[i];i ++) {
        if (isupper(word[i])) up_num ++;
    }
    return isupper(word[0]) && up_num == 1;
}

void ended(int i)
{
//    _C(s);
//    REP(i,0,cnt) {
//        _C(st[i].first)
//    }
    if (s == -1 || cnt - s <= 1) {
        rep(j,last_index,i) {
            printf("%c",str[j]);
        }
    } else {
        rep(j,last_index,s_idx - 1) {
            printf("%c",str[j]);
        }
        string x = " (";
        REP(j,s,cnt) {
            if (j != s) x += ' ';
            x += st[j].first;
            printf("%c",st[j].first[0]);
        }
        x += ')';
        cout << x;
//        _C(cnt << " " << st[cnt].first << " " << st[cnt].second)
        rep(j,st[cnt - 1].second,i) {
            printf("%c",str[j]);
        }
    }
    cnt = 0;
    s = -1;
    last_index = i + 1;
}

void add(int i)
{
//    _C(">>" << word)
    if (ok()) {
        if (s == -1) {
            s = cnt;
            s_idx = i - (int) word.size();
        }
    } else {
        if (s != -1) {
            ended(i - (int) word.size() - 1);
            s = -1;
        }
    }
    st[cnt].first = word;
    st[cnt ++].second = i;
//    _C(st[cnt - 1].first << " " << st[cnt - 1].second)
    word = "";
}



int main()
{
    string line;
    while (getline(cin,line)) str += line + '\n';
//    _C(str)
    for (int i = 0;str[i];i ++) {
        if (str[i] == ' ') {
            add(i);
        } else if (str[i] == ',' || str[i] == '.' || str[i] == '\n') {
//            _C("\\")
            add(i);
//            _C(",")
            ended(i);
        } else word += str[i];
    }
    ended((int) str.size() - 1);
    re0;
}
*/

/*
int main() {
    int n,m;
    string str;
    int ans,ans1;
    __T {
        scii(n,m);
        cin >> str;
        ans = 0; // L
        ans1 = 0; // R
        if (str[m - 1] == 'R') ans ++;
        else ans1 ++;
        REP(i,m + 1,n) {
            if (str[i - 1] == 'L') ans1 ++;
        }
        pre(i,m - 1,2) {
            if (str[i - 1] == 'R') ans ++;
        }
//        _C(ans << " " << ans1)
        printf("%d\n",min(ans,ans1));
    }
    
}
*/

/*
int n;

int ok(int a,int b,int c)
{
    return a >= 0 && b >= 0 && c >= 0 && a < n && b < n && c < n;
}

int ok(int a,int b,int c,int d)
{
    return a >= 0 && b >= 0 && c >= 0 && a < n && b < n && c < n && d >= 0 && d < n;
}

int ccpc(char a,char b,char c,char d)
{
    return a == 'C' && b == 'C' && c == 'P' && d == 'C';
}

int main()
{
    string str;
    int ans;
    int a,b,c,d;
    int k1,k2;
    int okk = 0;
    __T {
        sci(n);
        cin >> str;
        ans = 0;
        REP(i,0,n - 3) {
            if (ccpc(str[i],str[i + 1],str[i + 2],str[i + 3])) ans ++;
        }
//        _C(ans)
        okk = 0;
        
        // C
        rep(i,0,n) {
            a = i - 3;
            b = i - 2;
            c = i - 1;
            k1 = 0;
            k2 = 0;
            if (ok(a,b,c) && ccpc(str[a],str[b],str[c],'C')) k1 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            if (ok(a,b,c) && ccpc(str[a],str[b],'C',str[c])) k1 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            if (ok(a,b,c) && ccpc(str[a],'C',str[b],str[c])) k1 ++;
            a = i;
            b = i + 1;
            c = i + 2;
            if (ok(a,b,c) && ccpc('C',str[a],str[b],str[c])) k1 ++;
            
            
            a = i - 3;
            b = i - 2;
            c = i - 1;
            d = i;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            d = i + 1;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            d = i + 2;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            
            if (k1 > k2) {
                okk = 1;
                break;
            }
        }
        
        if (okk) {
            printf("%d\n",ans + 1);
            continue;
        }
        
        rep(i,0,n) {
            a = i - 3;
            b = i - 2;
            c = i - 1;
            k1 = 0;
            k2 = 0;
            if (ok(a,b,c) && ccpc(str[a],str[b],str[c],'P')) k1 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            if (ok(a,b,c) && ccpc(str[a],str[b],'P',str[c])) k1 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            if (ok(a,b,c) && ccpc(str[a],'P',str[b],str[c])) k1 ++;
            a = i;
            b = i + 1;
            c = i + 2;
            if (ok(a,b,c) && ccpc('P',str[a],str[b],str[c])) k1 ++;
            
            
            a = i - 3;
            b = i - 2;
            c = i - 1;
            d = i;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            d = i + 1;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            d = i + 2;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            
            if (k1 > k2) {
                okk = 1;
                break;
            }
        }
        
        printf("%d\n",ans + okk);
        
    }
    return 0;
}
*/

/*
ll dis(ll x,ll y) {return x * x + y * y;}

int main()
{
    int n;
    ll R;
    ll r;
    pair<ll,int> a[110];
    ll x,y;
    int cnt;
    ll k;
    ll m;
    int f;
    vector<int> ans;
    __T {
        sci(n);
        scll(R,r);
        rep(i,1,n) {
            scll(x,y);
            a[i] = mpair(dis(x,y),i);
        }
        ans.clear();
        sort(a + 1,a + 1 + n);
        if (r == R) {
            rep(i,1,n) {
                ans.pb(i);
            }
        } else if (r * 2 >= R) {
            cnt = 0;
            k = 2 * r - R;
            k *= k;
            rep(i,1,n) {
                if (a[i].first <= k) cnt ++;
                else break;
            }
            if (cnt != 0) {
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            } else {
                m = a[1].first;
                cnt = 0;
                rep(i,1,n) {
                    if (m == a[i].first) cnt ++;
                    else break;
                }
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            }
        } else {
            cnt = 0;
            k = R - 2 * r;
            k *= k;
            rep(i,1,n) {
                if (a[i].first <= k) cnt ++;
                else break;
            }
            if (cnt != 0) {
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            } else {
                m = a[1].first;
                cnt = 0;
                rep(i,1,n) {
                    if (m == a[i].first) cnt ++;
                    else break;
                }
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            }
        }
        printf("%lu\n",ans.size());
        sort(ans.begin(), ans.end());
        f = 1;
        for (auto i : ans) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i);
        }
        puts("");
    }
    return 0;
}
*/

/*
const int MAXN = 1e7 + 10;

ll p[MAXN];
int n;

int num[MAXN], prim[MAXN];
int pn = 0;
void table(){
    memset(num, -1, sizeof(num));
    for(int i = 2;i <= n;i++){
        if(num[i]) prim[pn++] = i;
        for(int j = 0;j < pn && 1LL*i*prim[j] <= n;j++){
            num[i*prim[j]] = 0;
            if(i % prim[j] == 0) break;
        }
    }
}

void pls(int l,int r,ll k)
{
    p[l] += k;
    p[r + 1] -= k;
}

ll s[10000010];

int main()
{
    sci(n);
    ll ans;
    table();
    REP(i,0,pn) {
        pls(1,n / prim[i],1);
    }
    s[0] = p[0];
    rep(i,1,n) s[i] = s[i - 1] + p[i];
    
    ans = 0;
    rep(i,1,n) {
        ans += (s[i] - 1) * s[i];
    }
    
    printf("%lld\n",ans);
    re0;
}
*/

/*
int main()
{
    int a[15][20];
    mem(a,-1);
    
    dscii(n,k);
    
    ll ans = 0;
    int x;
    rep(i,1,n) {
        sci(x);
        rep(j,1,x) sci(a[i][j]);
    }
    x = 0;
    rep(j,1,19) {
        rep(i,1,n) {
            if (a[i][j] == -1) a[i][j] = 50;
            if (a[i][j] >= ans) {
                ans += a[i][j];
                x ++;
            }
            if (x == k) goto end;
        }
    }
    end:
    ans += (k - x) * 50LL;
    printf("%lld\n",ans);
    re0;
}
*/

/*
int aa,bb,cc,dd;
int n;

struct Node {
    int a,b,c,d;
    int cnt;
    int i;
    
} node[40],nn[40];

int mx = 0;
vector<int> ans;
vector<int> k;

ll sub[40];

void dfs(int i,int a,int b,int c,int d,int x)
{
    if (i == n) {
        if (x > mx) {
            mx = x;
            ans = k;
        }
        return;
    }
    if (x + sub[i] <= mx) return; // 剪枝
    if (a >= node[i].a && b >= node[i].b && c >= node[i].c && d >= node[i].d) {
        k.pb(node[i].i);
        dfs(i + 1,a - node[i].a,b - node[i].b,c - node[i].c,d - node[i].d,x + node[i].cnt);
        k.erase(k.end() - 1);
    }
    dfs(i + 1,a,b,c,d,x);
}

int main()
{
    sci(n);
    int a,b,c,d,cnt;
    REP(i,0,n) {
        scii(a,b);
        sciii(c,d,cnt);
        nn[i] = {a,b,c,d,cnt,i};
    }

    sub[n - 1] = nn[n - 1].cnt;
    pre(i,n - 2,0) sub[i] = sub[i + 1] + nn[i].cnt;

    scii(aa,bb);
    scii(cc,dd);
    int ct = 0;
    REP(i,0,n) {
        if (nn[i].a <= aa && nn[i].b <= bb && nn[i].c <= cc && nn[i].d <= dd) node[ct ++] = nn[i];
    }
    n = ct;
    
    dfs(0,aa,bb,cc,dd,0);

    printf("%lu\n",ans.size());
    sort(ans.begin(), ans.end());
    int f = 1;
    for (auto i : ans) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    if (ans.size() != 0) puts("");
    re0;
}
*/

//
//const int maxw = 100010;
//ll hight[maxw],l[maxw],r[maxw];
//ll w;
//ll n;
//
//ll num(int pos,ll h){
//    ll sum = 0;
//    if(h<=hight[pos]||pos==w-1||pos==0)return -1;
//    else sum+=h-hight[pos];
//    ll temp = h;
//    for(int i=pos+1;i<w;i++){
//        temp--;
//        if(temp<=hight[i])break;
//        else{
//            if(i==w-1)return -1;
//            sum+=temp-hight[i];
//        }
//    }
//    temp = h;
//    for(int i=pos-1;i>=0;i--){
//        temp--;
//        if(temp<=hight[i])break;
//        else{
//            if(i==0)return -1;
//            sum+=temp-hight[i];
//        }
//    }
//    return sum;
//}
//ll mx = -1;
//
//int check(ll m)
//{
//    if (m <= mx) return 1;
//    int ok = 0;
//    ll k;
//    REP(i,1,w - 1) {
//        if ((k = num(i, m)) != -1 && k <= n) {
//            ok = 1;
//            break;
//        }
//    }
//    return ok;
//}
//
//int main(){
//    scanf("%lld%lld",&w,&n);
//    for(int i=0;i<w;i++){
//        scanf("%lld",&hight[i]);
//        mx = max(mx,hight[i]);
//    }
//
//    ll r = 1e9;
//    ll l = 1;
//    ll m;
//    while (l < r) {
//        m = (l + r) >> 1;
////        _C(l << " " << r)
//        if (check(m)) l = m + 1;
//        else r = m;
//    }
//    printf("%lld\n",l - 1);
//
//    return 0;
//}

/*
int main()
{
    int n;
    __T {
        sci(n);
        while (1) {
            if (n % 7 == 0 && n % 4 != 0) {
                printf("%d\n",n);
                break;
            }
            n ++;
        }
    }
}
*/


/*
int main()
{
    string str;
    string ans;
    __T {
        cin >> str;
        ans = "";
        for (int i = 0;str[i];i ++) {
            if (i == 0) ans += str[i];
            else if (str[i] != 'a' && str[i] != 'e' && str[i] != 'i' && str[i] != 'o' && str[i] != 'u' && str[i] != 'y') ans += str[i];
        }
        _C(ans);
    }
    return 0;
}
*/


/*
int n;
int a[100010];

int ok(int i) {
    if (i - 1 < 1 || i + 1 > n) return 0;
    return a[i - 1] < a[i] && a[i] > a[i + 1];
}

int main()
{
    int m;
    int cnt,cnt2;
    int s;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        m = 0;
        
        rep(i,1,n) {
            if (ok(i)) m ++;
        }
//        _C(m)
        s = 0;
        rep(i,1,n) {
            cnt = 0;
            cnt2 = 0;
            if (ok(i - 1)) cnt ++;
            if (ok(i)) cnt ++;
            if (ok(i + 1)) cnt ++;
            if (i - 2 >= 1 && i + 1 <= n && a[i - 1] > a[i - 2] && a[i - 1] > a[i + 1]) cnt2 ++;
            if (i - 1 >= 1 && i + 2 <= n && a[i + 1] > a[i - 1] && a[i + 1] > a[i + 2]) cnt2 ++;
            s = max(s,cnt - cnt2);
        }
        printf("%d\n",m - s);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    int b[100010];
    int m;
    int ans = 0;
    __T {
        sci(n);
        ans = 0;
        rep(i,1,n) {
            sci(a[i]);
            b[i] = a[i];
        }
        sort(b + 1,b + 1 + n);
        m = n;
        pre(i,n,1) {
            if (a[i] == b[m]) {
                m --;
                ans ++;
            }
        }
        printf("%d\n",n - ans);
    }
    re0;
}
*/

/*
const int MAXN = 1e6 + 10; ///////////
int n,m;
vector<int> g[MAXN];
int vis[MAXN];
int dis[MAXN];

int cc = 0;
vector<int> a[MAXN];

priority_queue<int,vector<int>,greater<int>> q;

void dij(int s)
{
    a[cc].clear();
    q.push(s);
    int top;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        if (vis[top]) continue;
        vis[top] = 1;
        a[cc].pb(top);
        for (auto i : g[top]) {
            q.push(i);
        }
    }
    cc ++;
}

struct Node {
    int n;
    int which;
    int i;
    int operator <(const Node &o) const {
        return n > o.n;
    }
};

int main()
{
    int u,v;
    priority_queue<Node> k;
    int f,x,ff,ii;
    int cnt;
    __T {
        scii(n,m);
        cc = 0;
        rep(i,1,n) {
            g[i].clear();
            vis[i] = 0;
            dis[i] = -1;
        }
        while (m --) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        cnt = 0;
        rep(i,1,n) {
            if (vis[i]) continue;
            dij(i);
            cnt ++;
        }
        
        REP(i,0,cc) {
            k.push({a[i][0],i,0});
        }
        
        printf("%d\n",cnt);
        
        ff = 1;
        while (!k.empty()) {
            f = k.top().n;
            x = k.top().which;
            ii = k.top().i;
            k.pop();
//            _C(f << " " << x)
            if (ff) ff = 0;
            else printf(" ");
            printf("%d",f);
            if (ii + 1 < a[x].size()) {
//                _C(">>" << a[x].front());
                k.push({a[x][ii + 1],x,ii + 1});
            }
        }
        puts("");
    }
}
*/

/*
int main()
{
    int n;
    ll x,y;
    ll a[100010];
    ll xx,yy;
    ll sub;
    ll ans;
    map<ll,ll> mp;
    ll a1;
    ll k;
    __T {
        sci(n);
        scll(x,y);
        ans = 0;
        xx = 0;
        yy = 0;
        rep(i,1,n) {
            scl(a[i]);
            xx += i * a[i];
            yy += i * (a[i] * a[i]);
        }
        
//        _C(xx)
//        _C(yy)
        if (xx == x && yy == y) {
            mp.clear();
            rep(i,1,n) {
                mp[a[i]] ++;
            }
            for (auto i : mp) {
                ans += i.second * (i.second - 1) / 2;
            }
            printf("%lld\n",ans);
        } else if (xx == x || yy == y) {
            printf("0\n");
        }else {
            sub = (yy - y) / (xx - x);
            if ((yy - y) % (xx - x)) {
                puts("0");
                continue;
            }
            rep(i,1,n) {
                a1 = sub - a[i];
                if (a[i] != a1) {
                    k = (xx - x) / (a1 - a[i]) + i;
                    if (k > i && k <= n && a1 == a[k]) ans ++;
                }
            }
            
            printf("%lld\n",ans);
        }
    }
    re0;
}
*/

/*
int main()
{
    string a,b;
    int x['z' + 1];
    int y['z' + 1];
    int ok;
    while (cin >> a >> b) {
        mem(x,0);
        mem(y,0);
        if (a == b) printf("Equal\n");
        else if (a[0] == b[0] && a[a.size() - 1] == b[b.size() - 1]) {
            ok = 1;
            for (int i = 0;a[i];i ++) {
                x[a[i]] ++;
            }
            for (int i = 0;b[i];i ++) {
                y[b[i]] ++;
            }
            rep(i,0,'z') {
                if (x[i] != y[i]) {
                    ok = 0;
                    break;
                }
            }
            puts(ok ? "Yes" : "No");
        } else {
            puts("No");
        }
    }
    re0;
}
*/

/*
int main()
{
    int n;
    
    string str;
    int t['z' + 1] = {0};
    int ans = 0;
    char c;
    while (~sci(n))
    {
        cin >> str;
        mem(t,0);
        ans = 0;
        for (int i = 0;str[i];i ++) {
            c = str[i];
            if (c == 'x') t[c] ++;
            else if (c == 't') {
                if (t['x'] > 0) {
                    t['x'] --;
                    t[c] ++;
                }
            } else if (c == 'C') {
                if (t['t'] > 0) {
                    t['t'] --;
                    t[c] ++;
                }
            } else if (c == 'p') {
                if (t['C'] > 0) {
                    t['C'] --;
                    t[c] ++;
                }
            } else if (c == 'c') {
                if (t['p'] > 0) {
                    t['p'] --;
                    ans ++;
                }
            }
        }
        printf("%d\n",ans);
    }
}
*/

/*
int main()
{
    string str[14];
    int s['z'][10] = {0};
    map<string,int> k;
    REP(i,0,14) cin >> str[i];
    REP(i,0,14) {
        if (isdigit(str[i][0])) {
            s[str[i][1]][str[i][0] - '0'] ++;
        } else {
            k[str[i]] ++;
        }
    }
    set<char> n1;
    set<char> n9;
    if (s['s'][1]) n9.insert('s');
    if (s['s'][9]) n9.insert('s');
    if (s['p'][1]) n9.insert('p');
    if (s['p'][9]) n9.insert('p');
    if (s['w'][1]) n9.insert('w');
    if (s['w'][9]) n9.insert('w');
    
    
    re0;
}
*/

/*
string Manacher(string &s)
{
    //改造字符串
    int n = (int) s.size();
    string res = "$#";
    for (int i = 0;i < n;i ++)
    {
        res += s[i];
        res += "#";
    }

    //数组
    n = (int) res.size();
    vector<int> P(n,0);
    int mi = 0,right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值
    int maxLen = 0,maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点
    for (int i = 1;i < n;i ++)
    {
        P[i] = right > i ? min(P[2 * mi - i],right - i) : 1; //关键句，文中对这句以详细讲解
        while (res[i + P[i]] == res[i - P[i]]) {
            P[i] ++;
        }
        if (right < i + P[i]) //超过之前的最右端，则改变中心点和对应的最右端
        {
            right = i + P[i];
            mi = i;
        }
        if (maxLen < P[i]) //更新最大回文串的长度，并记下此时的点
        {
            maxLen = P[i];
            maxPoint = i;
        }
    }
    return s.substr((maxPoint - maxLen) / 2,maxLen - 1);
}

ll Manacher_n(string &s)
{
    //改造字符串
    int n = (int) s.size();
    string res = "$#";
    for (int i = 0;i < n;i ++)
    {
        res += s[i];
        res += "#";
    }

    //数组
    n = (int) res.size();
    vector<ll> P(n,0);
    ll mi = 0,right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值
    ll maxLen = 0,maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点
    
    ll ans = 0;
    for (ll i = 1;i < n;i ++)
    {
        P[i] = right > i ? min(P[2 * mi - i],right - i) : 1; //关键句，文中对这句以详细讲解
        while (res[i + P[i]] == res[i - P[i]]) {
            P[i] ++;
        }
        if (right < i + P[i]) //超过之前的最右端，则改变中心点和对应的最右端
        {
            right = i + P[i];
            mi = i;
        }
        if (maxLen < P[i]) //更新最大回文串的长度，并记下此时的点
        {
            maxLen = P[i];
            maxPoint = i;
        }
        ans += P[i] / 2;
    }
    return ans;
}



int main()
{
    string mod,str;
    cio
    int n;
    int l,r;
    int ok;
    int T;
    cin >> T;
    while (T --) {
        cin >> mod >> str;
        n = (int) mod.size();
        if (mod == str) {
            _C(Manacher_n(str));
        } else {
            for (l = 0;l < n;l ++) {
                if (str[l] != mod[l]) break;
            }
            for (r = n - 1;r >= 0;r --) {
                if (str[r] != mod[r]) break;
            }
            ok = 1;
            rep(i,l,r) {
                if (mod[i] != str[r - i + l]) {
                    ok = 0;
                    break;
                }
            }
            if (!ok) _C(0)
            else {
                for (int i = l - 1,j = r + 1;i >= 0 && j < n;j ++,i --,ok ++) {
                    if (mod[i] != mod[j]) break;
                }
                _C(ok);
            }
        }
    }

}
*/

/*
const int MAXN = 1e6 + 10;
unordered_map<int,ll> mp;
vector<int> vec[MAXN];
vector<int> g[MAXN];
ll cnt[MAXN];
int vis[MAXN];
int in[MAXN];
int vv[MAXN];

void bfs(int n) {
    queue<int> q;
    q.push(n);
    int t;
    while (!q.empty()) {
        t = q.front();
        q.pop();
        for (auto i : g[t]) {
            in[i] --;
            cnt[i] += cnt[t];
            if (!in[i]) q.push(i);
        }
    }
}

void dfs(int n)
{
    if (vv[n]) return;
    vv[n] = 1;
    for (auto i : g[n]) {
        in[i] ++;
        dfs(i);
    }
}

int main()
{
    int n;
    int t,k,tt;
    int x,y;
    ll v;
    ll mx;
    ll sum;
    __T {
        read(n);
        rep(i,1,n) {
            g[i].clear();
            vv[i] = vis[i] = in[i] = cnt[i] = 0;
            vec[i].clear();
        }
        mp.clear();
        rep(i,1,n) {
            read(t);
            if (t == 1) {
                if (i == n) {
                    sci(k);
                    rep(ii,1,k) {
                        read(tt);
                        mp[tt] ++;
                    }
                    vis[i] = 1;
                } else {
                    sci(k);
                    rep(ii,1,k) {
                        read(tt);
                        vec[i].push_back(tt);
                    }
                    vis[i] = 1;
                }
            } else {
                read(x);
                read(y);
                g[i].push_back(x);
                g[i].push_back(y);
            }
        }

        mx = 0;
        sum = 0;
        if (mp.size()) {
            for (auto j : mp) {
                mx = max(mx,j.second);
                sum += j.second;
            }
        } else {
            cnt[n] = 1;
            dfs(n);
            bfs(n);
            rep(i,1,n-1) {
                if (!cnt[i] || !vis[i]) continue;

                for (auto j : vec[i]) {
                    v = mp[j] += cnt[i];
                    mx = max(mx,v);
                    sum += cnt[i];
                }
            }
        }
        printf("%lld\n", mx * 2 <= sum ? sum : (sum - mx) * 2);

    }
    return 0;
}
*/

/*
8
1 1 1
1 2 2 2
2 1 2
1 3 3 3 3
2 3 4
1 4 4 4 4 4
2 3 6
2 5 7
*/

/*
// 线段树 - 二叉树，节点存的是一个 l，r，区间的内容n
const int MAXN = 1e5 + 10;

struct Node {
    int l,r;
    ll mx;
    ll mn;
    ll sum;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
ll a[MAXN];

void push_up(int i)
{
    tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;
    tree[i].mn = min(tree[i << 1].mn,tree[i << 1 | 1].mn);
    tree[i].mx = max(tree[i << 1].mx,tree[i << 1 | 1].mx);
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy == 1) {
        tree[i << 1].sum += (tree[i << 1].r - tree[i << 1].l + 1) * tree[i].lzn;
        tree[i << 1 | 1].sum += (tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1) * tree[i].lzn;
        
        tree[i << 1].mx += tree[i].lzn;
        tree[i << 1 | 1].mx += tree[i].lzn;
        
        tree[i << 1].mn += tree[i].lzn;
        tree[i << 1 | 1].mn += tree[i].lzn;
        
        tree[i << 1].lzn += tree[i].lzn;
        tree[i << 1 | 1].lzn += tree[i].lzn;
        
        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;
        
        tree[i].lazy = 0;
        tree[i].lzn = 0;
    } else if (tree[i].lazy == 2) {
        tree[i << 1].sum = (tree[i << 1].r - tree[i << 1].l + 1) * tree[i].lzn;
        tree[i << 1 | 1].sum = (tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1) * tree[i].lzn;
        
        tree[i << 1].mx = tree[i].lzn;
        tree[i << 1 | 1].mx = tree[i].lzn;
        
        tree[i << 1].mn = tree[i].lzn;
        tree[i << 1 | 1].mn = tree[i].lzn;
        
        tree[i << 1].lzn = tree[i].lzn;
        tree[i << 1 | 1].lzn = tree[i].lzn;
        
        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;
        
        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].sum = a[l]; // a原数组，把原来的数值给叶子结点
        tree[i].mx = a[l];
        tree[i].mn = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void add(int l,int r,ll x,int i) // 将区间[l,r]整个加上x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum += (tree[i].r - tree[i].l + 1) * x;
        tree[i].mx += x;
        tree[i].mn += x;
        tree[i].lzn += x;
        
        tree[i].lazy = 1;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) add(l,r,x,i << 1);
    if (r > m) add(l,r,x,i << 1 | 1);
    push_up(i);
}

void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum = (tree[i].r - tree[i].l + 1) * x;
        tree[i].mx = x;
        tree[i].mn = x;
        tree[i].lzn = x;
        
        tree[i].lazy = 2;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].sum;
//        return tree[i].mx;
//        return tree[i].mn;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll sum = 0;
//    ll mx = 0;
//    ll mn = INT_INF;
    if (l <= m) {
         sum += query(l,r,i << 1);
//         mx = max(mx,query(l,r,i << 1));
//         mn = min(mn,query(l,r,i << 1));
    }
    if (r > m) {
        sum += query(l,r,i << 1 | 1);
//        mx = max(mx,query(l,r,i << 1 | 1));
//        mn = min(mn,query(l,r,i << 1 | 1));
    }
    return sum;
//    return mx;
//    return mn;
}

int main()
{
    dscii(n,m);
    rep(i,1,n) scl(a[i]);
    build(1, n, 1);
    int k,a,b;
    ll c;
    while (m --) {
        sciii(k,a,b);
        if (k == 1) {
            printf("%lld\n",query(a, b, 1));
        } else if (k == 2) {
            scl(c);
            modify(a, b, c, 1);
            rep(i,1,n) printf("a[%d]=%lld\n",i,query(i, i, 1));
        }
    }
    re0;
}
*/

/*
int n,m;
char mp[110][110];

struct AZ
{
    int x,y;
    char c;
};

AZ A['z'][3];

struct Node {
    int x,y;
    int dis;
    int t;
    bool operator<(const Node &o) const {
        return dis > o.dis;
    }
};

int dis[110][110][3];
int vis[110][110][3];
int dx[] = {0,-1,0,1};
int dy[] = {1,0,-1,0};

void dij(int x,int y)
{
    priority_queue<Node> q;
    mem(dis,-1);
    mem(vis,0);

    int k = 1;
    if (mp[x][y] >= 'A' && mp[x][y] <= 'Z') k = 2;


    Node t;
    int xx,yy;
    q.push({x,y,dis[x][y][1] = dis[x][y][2] = 0,k}); // t=1跑周围，t=2跳跃


    AZ a1,a2;
    while (!q.empty()) {
        t = q.top();
        q.pop();
        if (vis[t.x][t.y][t.t]) continue;
        vis[t.x][t.y][t.t] = 1;

        if (t.t == 2) {
            a1 = A[mp[t.x][t.y]][1];
            a2 = A[mp[t.x][t.y]][2];
            if (t.x == a1.x && t.y == a1.y) {
                // goto 2
                xx = a2.x;
                yy = a2.y;
                if (dis[xx][yy][1] == -1 || dis[t.x][t.y][2] <= dis[xx][yy][1]) {
                    q.push({xx,yy,dis[xx][yy][1] = dis[t.x][t.y][2],1});
                }
            } else {
                // goto 1
                xx = a1.x;
                yy = a1.y;
                if (dis[xx][yy][1] == -1 || dis[t.x][t.y][2] <= dis[xx][yy][1]) {
                    q.push({xx,yy,dis[xx][yy][1] = dis[t.x][t.y][2],1});
                }
            }
        } else {
            rep(i,0,3) {
                xx = t.x + dx[i];
                yy = t.y + dy[i];
                if (xx >= 1 && yy >= 1 && xx <= n && yy <= m) {
                    if (mp[xx][yy] != '1') {
                        k = 1;
                        if (mp[xx][yy] >= 'A' && mp[xx][yy] <= 'Z') k = 2;
                        
                        if (dis[xx][yy][k] == -1 || dis[t.x][t.y][1] + 1 < dis[xx][yy][k]) {
                            q.push({xx,yy,dis[xx][yy][k] = dis[t.x][t.y][1] + 1,k});
                        }
                        
                    }
                }
            }
        }
    }
}

int main()
{
    int v['z'] = {0};
    int k;
    scii(n,m);
    rep(i,1,n) {
        scanf(" ");
        rep(j,1,m) {
            scanf("%c",&mp[i][j]);
            if (mp[i][j] >= 'A' && mp[i][j] <= 'Z') {
                k = 1;
                if (v[mp[i][j]]) k ++;
                v[mp[i][j]] = 1;
                A[mp[i][j]][k] = {i,j,mp[i][j]};
            }
        }
    }
    dij(1,1);

    // rep(i,1,n) {
    //     rep(j,1,m) printf("%d ",dis[i][j]);
    //     puts("");
    // }

    int ans = -1;
    if (dis[n][m][1] != -1) ans = dis[n][m][1];
    if (dis[n][m][2] != -1) {
        if (ans == -1) ans = dis[n][m][2];
        else ans = min(ans,dis[n][m][2]);
    }

    if (ans == -1) puts("No Solution.");
    else printf("%d\n",ans);
    return 0;
}
*/

/*
int main()
{
    int n;
    int s;
    while (~sci(n)) {
        s = 1;
        while (n > 1) {
            if (s) n = n / 9 + (n % 9 ? 1 : 0);
            else n = n / 2 + n % 2;
            s = 1 - s;
        }
        puts(!s ? "Stan wins." : "Ollie wins.");
    }
    
    return 0;
}
*/
/*
int main()
{
    int n;
    int a[1010];
    int t;
    int mx = -1;
    int ans;
    __T {
        sci(n);
        mem(a,0);
        rep(i,1,n) {
            sci(t);
            a[t] ++;
        }
        mx = -1;
        ans = -1;
        rep(i,1,1000) {
            if (mx == -1) {
                mx = a[i];
                ans = i;
            } else if (mx == a[i]) {
                ans = -1;
            } else if (a[i] > mx) {
                mx = a[i];
                ans = i;
            }
        }
        if (ans != -1) printf("%d\n",ans);
        else puts("Nobody");
        
    }
    
}
*/

/*
int main()
{
    int s,m,d;
    pair<int,string> k1[110];
    pair<int,string> k2[110];
    pair<int,string> k3[110];
    int m1,m2,m3;
    int ans;
    __T {
        sciii(s,m,d);
        rep(i,1,s) {
            cin >> k1[i].second >> k1[i].first;
        }
        sort(k1 + 1, k1 + 1 + s);
        
        rep(i,1,m) {
            cin >> k2[i].second >> k2[i].first;
        }
        sort(k2 + 1, k2 + 1 + m);
        
        rep(i,1,d) {
            cin >> k3[i].second >> k3[i].first;
        }
        sort(k3 + 1, k3 + 1 + d);
        
        m1 = s / 2 + 1;
        m2 = m / 2 + 1;
        m3 = d / 2 + 1;
        
        ans = k1[m1].first + k2[m2].first + k3[m3].first;
        printf("%d ",ans);
        cout << k1[m1].second << " " << k2[m2].second << " " << k3[m3].second << endl;
    }
    re0;
}
*/

/*
ll a[100000];
ll t[100000];
ll p[1000010];

int main()
{
    int n;
    ll k;
    ll m;
    ll ans = 0;
    __T {
        sci(n);
        rep(i,1,n) {
            scl(a[i]);
            p[a[i]] = 0;
            t[i] = 0;
        }
        
        for (ll i = 1;i <= n;i ++) {
            if (p[a[i]] != 0) {
                t[i] -= p[a[i]] * (n - i + 1);
            }
            p[a[i]] = i;
//            printf("%lld ",t[i]);
        }
        
//        puts("");
        
        ans = 0;
        k = n - 2;
        m = n;
        rep(i,1,n) {
//            _C(m)
            t[i] += m;
            ans += a[i] * t[i];
            m += k;
            k -= 2;
        }
        printf("%lld\n",ans);
    }
}
*/

/*
struct Node {
    double s;
    int id,pid;
};

int cmp1(const Node &a,const Node &b) {
    return a.s > b.s;
}

int cmp2(const Node &a,const Node &b) {
    return a.id < b.id;
}


int main()
{
    int n,q,s,c;
    // n 队伍
    // q 服务器
    // s score
    // c chk points
    int a;
    Node rs[110];
    
    
    int ss[110][15];
    set<pair<int,int>> ato[110];
    int atk,dfd,svs;
    
    
    int rp[110][15];
    
    
    int u,tt,cnt;
    double all;
    
    
    
    __T {
        scii(n,q);
        scii(s,c);
        rep(i,1,n) {
            rs[i].s = s;
            rs[i].id = i;
        }
        
        rep(ii,1,c) {
            mem(ss,0);
            rep(i,1,n) ato[i].clear();
            
            // attack
            
            sci(a);
            rep(i,1,a) {
                sciii(atk,dfd,svs);
                if (ato[atk].find(mpair(dfd,svs)) == ato[atk].end()) ss[dfd][svs] ++;
                ato[atk].insert(mpair(dfd,svs));
            }
            
            rep(i,1,n) {
                rep(j,1,q) {
                    if (ss[i][j]) rs[i].s -= n - 1;
                }
                for (auto j : ato[i]) {
                    rs[i].s += (n - 1) / (double) ss[j.first][j.second];
                }
            }
            
            // repair
            rep(i,1,q) {
                all = 0;
                cnt = 0;
                rep(j,1,n) {
                    sci(rp[i][j]);
                    if (!rp[i][j]) {
                        rs[j].s -= n - 1;
                        all += n - 1;
                    } else cnt ++;
                }
                rep(j,1,n) {
                    if (rp[i][j]) {
                        rs[j].s += all / (double) cnt;
                    }
                }
            }
//
//            rep(i,1,n) {
//                ok = 1;
//                rep(j,1,q) {
//                    if (!rp[j][i]) ok = 0;
//                }
//                if (ok) cnt ++;
//            }
//
//            rep(i,1,n) {
//                ok = 1;
//                rep(j,1,q) {
//                    if (!rp[j][i]) ok = 0;
//                }
//                if (ok) rs[i].s += all / (double) cnt;
//            }
            
            
            
            // query
            sort(rs + 1, rs + 1 + n, cmp1);
            rs[1].pid = 1;
            rep(i,2,n) {
                if (abs(rs[i].s - rs[i - 1].s) <= 1e-6) rs[i].pid = rs[i - 1].pid;
                else rs[i].pid = i;
            }
            
            sort(rs + 1, rs + 1 + n, cmp2);
            
            sci(u);
            rep(i,1,u) {
                sci(tt);
                printf("%.8f %d\n",rs[tt].s,rs[tt].pid);
            }
        }
        
        
    }
    re0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main() {
    int n,m;
    int a[MAXN];
    int cnt;
    int mn = -1;
    ll ans;
    __T {
        scii(n,m);
        cnt = 0;
        rep(i,1,n) {
            sci(a[i]);
            if (!a[i]) cnt ++;
        }
        if (n == m) {
            puts("Richman");
            continue;
        }
        if (cnt > m) {
            puts("Impossible");
            continue;
        }
        m -= cnt;
        mn = -1;
        ans = 0;
        rep(i,1,n) {
            if (!a[i]) continue;
            if (m > 0) {
                ans += a[i];
                m --;
            } else {
                if (mn == -1) mn = a[i];
                else mn = min(mn,a[i]);
            }
        }
        printf("%lld\n",ans + mn - 1);
        
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    string a,b;
    int aa[1000010];
    int cnt = 0;
    int c1;
    int idx;
    __T {
        sci(n);
        cin >> a >> b;
        c1 = cnt = 0;
        idx = -1;
        rep(i,0,n-1) {
            aa[i + 1] = (a[i] != b[i]);
//            printf("%d",aa[i + 1]);
            if (aa[i + 1]) {
                c1 ++;
                if (idx == -1) idx = i + 1;
            }
        }
//        puts("");
        if (aa[n]) cnt ++;
        rep(i,1,n) {
            if (aa[i] != aa[i - 1] && aa[i - 1]) cnt ++;
        }
//        _C(cnt)
        if (cnt == 2) printf("6\n");
        else if (cnt == 0) {
            printf("%lld\n",(n + 1LL) * n / 2);
        } else if (cnt == 1) {
            printf("%d\n",(n - 1) * 2);
        } else printf("0\n");
    }
    re0;
}
*/

/*
inline double func(double x) {
    return 1 - x - sin(x);
}

int main()
{
    double l = 0,r = 1;
    const double exp = 5e-5;
    double m;
    int cnt = 0;
    while (r - l > exp) {
        m = (l + r) / 2;
        if (func(m) * func(l) < 0) r = m;
        else l = m;
        cnt ++;
    }
    printf("%d %f\n",cnt,l);
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

ll t[55];
ll a[MAXN];

int main()
{
    int n;
    ll x;
    ll ans;
    __T {
        sci(n);
        mem(t,0);
        rep(i,1,n) {
            scl(a[i]);
            for (ll j = 1,k = 1;j <= 1e9;j <<= 1,k ++) {
                if (a[i] >= (j << 1) && a[i] % (j << 1) < j) t[k] ++;
            }
        }
        ans = 0;
        rep(i,1,n) {
            x = log2(a[i]);
            x ++;
            ans += t[x];
        }
        printf("%lld\n",ans);
    }
    
    re0;
}
*/

/*
int main()
{
    map<double,ll> ka;
    ll kb;
    
    ll x1,x2,y1,y2;
    int n;
    ull cnt;
    map<pair<double,double>,ll> sameA;
    map<ll,ll> sameB;
    pair<double,double> l;
    double k;
    ll ans;
    __T {
        kb = cnt = 0;
        sci(n);
        ka.clear();
        sameB.clear();
        sameA.clear();
        rep(ii,1,n) {
            scll(x1,y1);
            scll(x2,y2);
            if (x1 - x2 == 0) {
                kb ++;
                cnt += sameB[x1] ++;
            }
            else {
                ka[k = (y1 - y2) / (double) (x1 - x2)] ++;
                
                l = make_pair(k, (x1 * y2 - x2 * y1) / (double) (x1 - x2));
                cnt += sameA[l] ++;
            }
        }

        ans = 0;
        ans += (n - kb) * kb;
        for (auto i : ka) {
            ans += (n - i.second) * i.second;
        }
        printf("%lld\n",ans / 2 + cnt);
    }
    return 0;
}
*/

/*
struct Node {
    ll l,r;
};

int cmp(const Node &a,const Node &b) {
    return a.r < b.r;
}

int cmp1(const Node &a,const Node &b) {
    return a.l < b.l;
}

int n;

ll get(Node *lx,Node *rx)
{
    ll sumx,subx[100010];
    ll ok;
    ll m1,m2;
    
    sort(rx + 1,rx + 1 + n,cmp);
    sort(lx + 1,lx + 1 + n,cmp1);
    
    subx[n] = lx[n].l;
    pre(i,n - 1,1) subx[i] = subx[i + 1] + lx[i].l;
    
    sumx = 0;
    m1 = -1;
    for (int i = 1,j = 1;i <= n ;i ++) {
        ok = 0;
        while (j <= n) {
            if (lx[j].l > rx[i].r) {
                ok = subx[j];
                break;
            }
            j ++;
        }
        ok -= (n - j + 1) * rx[i].r;
        
        ok += rx[i].r * (i - 1);
        ok -= sumx;
        
        if (m1 == -1) m1 = ok;
        else m1 = min(m1,ok);
        
        sumx += rx[i].r;
    }
            
            
    subx[1] = rx[1].r;
    rep(i,2,n) subx[i] = subx[i - 1] + rx[i].r;
    
    sumx = 0;
    m2 = -1;
    for (int i = n,j = n;i >= 1;i --) {
        ok = 0;
        while (j >= 1) {
            if (rx[j].r < lx[i].l) {
                ok = subx[j];
                break;
            }
            j --;
        }
        ok = j * lx[i].l - ok;
        
        ok -= lx[i].l * (n - i);
        ok += sumx;
        
        if (m2 == -1) m2 = ok;
        else m2 = min(m2,ok);
                
        sumx += lx[i].l;
    }
    return min(m1,m2);
}

int main()
{
    Node lx[100010];
    Node rx[100010];
    
    Node ly[100010];
    Node ry[100010];
    int x1,x2,y1,y2;
    
    __T {
        sci(n);
        rep(i,1,n) {
            scii(x1,y1);
            scii(x2,y2);
            lx[i] = {x1,x2};
            rx[i] = {x1,x2};
            ly[i] = {y1,y2};
            ry[i] = {y1,y2};
        }
        printf("%lld\n",get(lx,rx) + get(ly,ry));
    }
    return 0;
}
*/

/*
ll quickpow(ll a, ll b, ll n)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) {
            if (a == -1) return -1;
            ans = a * ans;
            if (ans >= n) return -1;
        }
        if (a != -1) a = a * a;
        if (a >= n) a = -1;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n,k;
    ll m,l;
    ll ans;
    int i;
    int T = 1;
    __T  {
        scii(n,k);
        if (k == 1) {
            printf("Case #%d: %d\n",T ++,n);
            continue;
        }
        l = 1;
        ans = 0;
        for (i = 2;i <= n;i ++) {
            m = quickpow(i, k, n);
            if (m == -1) break;
            ans += ((m - 1) - l) / (i - 1) + 1;
            l = m;
        }
        ans += (n - l) / (i - 1) + 1;
        printf("Case #%d: %lld\n",T ++,ans);
    }
}
*/

/*
struct Node {
    int n;
    int i;
};

int cmp(const Node &a,const Node &b) {
    return a.n < b.n;
}

int main()
{
    int n,max1;
    ll p;
    Node a[400010];
    int vis[200010];
    Node l,r;
    int li,ri;
    int start;
    int ans;
    int m;
    int T = 1;
    __T {
        max1 = 0;
        sci(n);
        scl(p);
        for (int i = 1,j = 1;i <= n;i ++) {
            sci(a[j ++].n);
            a[j - 1].i = i;
            sci(a[j ++].n);
            a[j - 1].i = i;
            max1 = max(max1,a[j-1].n);
            vis[i] = 0;
        }
        
        
        sort(a + 1,a + 1 + n * 2,cmp);
        
        
        m = ans = 0;
        start = n * 2;
        pre(i,n*2,1) {
            if (a[i].n >= max1) {
                l = {(int) ceil(a[i].n * p / 100.0)};
                r = {a[i].n};
//                _C(">>" << a[i].n)
//                _C(l.n << " " << r.n)
                li = (int) (lower_bound(a + 1, a + 1 + n * 2, l, cmp) - a);
                ri = i;
//                _C("lr> " << li << " " << ri)
                
                pre(j,start,li) {
                    if (!vis[a[j].i]) m ++;
                    vis[a[j].i] ++;
                }
                start = li - 1;
//                _C("m1=" << m)
                if (i + 1 <= n * 2) {
                    vis[a[i + 1].i] --;
//                    _C(vis[a[i + 1].i])
                    if (!vis[a[i + 1].i]) m --;
                }
//                _C("m2=" << m)
                ans = max(ans,m);
            } else break;
        }
        printf("Case #%d: %d\n",T ++, ans);
    }
}
*/

/*
int main()
{
    string str;
    int s;
    int ans;
    __T {
        cin >> str;
        s = str[0] ^ 48;
        ans = 10 * (s - 1);
        for (int i = 0;str[i];i ++) ans += (i + 1);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[5010];
    int vis[5010];
    int ok;
    __T {
        sci(n);
        ok = 1;
        rep(i,1,n) {
            sci(a[i]);
            vis[i] = 0;
            if (i != 1) {
                if (a[i] != a[i - 1]) ok = 0;
            }
        }
        if (ok) {
            puts("NO");
            continue;
        }
        puts("YES");
        rep(i,2,n) {
            if (a[i] != a[1]) {
                printf("1 %d\n",i);
                vis[i] = 1;
            }
        }
        rep(i,2,n) {
            if (vis[i]) {
                rep(j,2,n) {
                    if (!vis[j]) {
                        printf("%d %d\n",i,j);
                    }
                }
                break;
            }
        }
    }
    return 0;
}
*/

/*
int cmp(const pair<int,int> &a,const pair<int,int> &b) {
    if (a.second == b.second) return a.first < b.first;
    return a.second < b.second;
}

int main()
{
    
    int n,q;
    scii(n,q);
    pair<int,int> px[2010];
    pair<int,int> py[2010];
    rep(i,1,n) {
        scii(px[i].first,px[i].second);
        py[i] = px[i];
    }
    sort(px + 1,px + 1 + n);
    sort(py + 1,py + 1 + n,cmp);
    int u,v;
    int cnt;
    while (q --) {
        scii(u,v);
        cnt = 0;
        rep(i,1,n) {
            
        }
    }
    return 0;
}
*/


/*
int n,m;

const int MAXN = 500010;

struct Edge {
    Edge(){}
    Edge(int to,int nxt,int v):to(to),nxt(nxt),v(v){}
    int to;
    int nxt;
    int v;
} e[MAXN * 2];
int g[MAXN];

int cnt = 0;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = Edge(v,g[u],-1);
    g[u] = cnt ++;
}

int vis[MAXN];
int dps[MAXN];
vector<ll> cc;

void dfs(int k,int f,int d)
{
    if (vis[k]) {
        cc.pb(d - dps[k]);
        return;
    }
    vis[k] = 1;
    dps[k] = d;
    for (int i = g[k];~i;i = e[i].nxt) {
        if (e[i].to == f || dps[e[i].to] > d) continue;
        dfs(e[i].to,k,d + 1);
    }
}

const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    scii(n,m);
    init();
    int u,v;
    rep(i,1,m) {
        scii(u,v);
        add(u,v);
        add(v,u);
    }
    rep(i,1,n) {
        if (vis[i]) continue;
        dfs(i,-1,0);
    }
    ll ans = 1;
    ll s = 0;
    for (auto i : cc) {
        s += i;
        ans *= (quickpow(2, i) + mod - 1) % mod;
        ans %= mod;
    }
    
    ans *= quickpow(2, m - s);
    printf("%lld\n",ans % mod);
    re0;
}
*/

/*
char str[100010];

int get(char a[],char b[]) {
    if (a[0] == b[0] && a[1] == b[1] && a[2] == b[2]) return 0;
    if(a[1] == b[0] && a[2] == b[1]) return 1;
    if(a[2] == b[0]) return 2;
    return 3;
}

ll dp[100010][7];

struct Node {
    int n;
    char str[7][3];
} x['Z' + 1];

int main()
{
    x['Y'] = {1,{
        {'Q','Q','Q'}
    }};
    x['V'] = {3,{
        {'Q','Q','W'},
        {'Q','W','Q'},
        {'W','Q','Q'},
    }};
    x['G'] = {3,{
        {'Q','Q','E'},
        {'Q','E','Q'},
        {'E','Q','Q'},
    }};
    x['C'] = {1,{
        {'W','W','W'},
    }};
    x['X'] = {3,{
        {'Q','W','W'},
        {'W','W','Q'},
        {'W','Q','W'},
    }};
    x['Z'] = {3,{
        {'W','E','W'},
        {'W','W','E'},
        {'E','W','W'},
    }};
    x['T'] = {1,{
        {'E','E','E'},
    }};
    x['F'] = {3,{
        {'Q','E','E'},
        {'E','E','Q'},
        {'E','Q','E'},
    }};
    x['D'] = {3,{
        {'W','E','E'},
        {'E','W','E'},
        {'E','E','W'},
    }};
    x['B'] = {6,{
        {'Q','E','W'},
        {'Q','W','E'},
        {'W','Q','E'},
        {'W','E','Q'},
        {'E','Q','W'},
        {'E','W','Q'},
    }};
    char ch;
    int n = 0;
    while ((ch = getchar()) != '\n') {
        str[n ++] = ch;
    }
    str[n] = '\0';
//    puts(str);
    mem(dp,-1);
    REP(i,0,6) {
        dp[0][i] = 3;
    }
//    REP(j,0,6) {
//        printf("%lld ",dp[0][j]);
//    }
//    puts("");
    
//    _C(n)
    
    REP(i,1,n) {
        REP(j,0,x[str[i - 1]].n) {
            REP(k,0,x[str[i]].n) {
                if (dp[i][k] == -1) dp[i][k] = dp[i - 1][j] + get(x[str[i - 1]].str[j],x[str[i]].str[k]);
                else dp[i][k] = min(dp[i - 1][j] + get(x[str[i - 1]].str[j],x[str[i]].str[k]),dp[i][k]);
            }
        }
//        REP(j,0,6) {
//            printf("%lld ",dp[i][j]);
//        }
//        puts("");
    }
    ll ans = -1;
    REP(i,0,6) {
        if (dp[n - 1][i] != -1) {
            if (ans == -1) ans = dp[n - 1][i];
            else ans = min(ans,dp[n - 1][i]);
        }
    }
    printf("%lld\n",ans + n);
}
*/

/////kmp
/*
const int MAXN = 1e6 + 10;
string str;
string p;
int n;
int m;

int nxt[MAXN];

void make()
{
    // nxt(标号从[1,m]，m是匹配串长度)数组意义：nxt[i]是取出从1到i的前缀，对于这个前缀s，存在一个它的子串t，并且t != s，同时t既是s的前缀又是s的后缀，nxt[i] = max(|t|)。
    nxt[0] = -1;
    nxt[1] = 0;
    for (int i = 0,k = -1;i < m;)
    {
        if (k == -1 || p[i] == p[k]) nxt[++ i] = ++ k;
        else k = nxt[k];
    }
}

int kmp()
{
    int ok = 0;
    make();
    
    //int f = 0;
    for (int i = 0,j = 0;i < n;)
    {
        if (str[i] == p[j]) {
            j ++;
            i ++;
            if (j == m) {
                //printf("Found: %lu\n",i - m); // 找到一个p串在str串中的下标
                ok ++;
                //f = 1;
                j = nxt[j];
            }
        }
        else {
            if (j == 0) i ++;
            j = nxt[j];
        }
        
    }
    //if (!f) printf("Not Found!\n");
    return ok;
}

int main()
{
    cin >> str >> p;
    n = (int) str.size();
    m = (int) p.size();
    printf("%d\n",kmp());
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main()
{
    int f,n;
    scii(f,n);
    int nxt[MAXN];
    int a[MAXN];
    
    int addr,num,next;
    
    mem(nxt,-1);
    rep(i,1,n) {
        sciii(addr,num,next);
        a[addr] = num;
        nxt[addr] = next;
    }
    
    int vis[10010] = {0};
    int ff = -1;
    int cc = ff;
    
    int c = f;
    int l = -1;
    while (c != -1) {
        if (vis[abs(a[c])]) {
            nxt[l] = nxt[c];
            if (ff == -1) {
                ff = c;
                cc = c;
            } else {
                nxt[cc] = c;
                cc = c;
            }
        } else l = c;
        vis[abs(a[c])] = 1;
        c = nxt[c];
        nxt[cc] = -1;
    }
    c = f;
    while (c != -1) {
        printf("%05d %d ",c,a[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    c = ff;
    while (c != -1) {
        printf("%05d %d ",c,a[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    return 0;
}
*/

/*
int main()
{
    int na,nb;
    
    vector<pair<int,int>> a;
    vector<pair<int,int>> b;
    int x,y;
    
    sci(na);
    rep(i,1,na) {
        scii(x,y);
        a.pb(mpair(x,y));
    }
    
    sci(nb);
    rep(i,1,nb) {
        scii(x,y);
        b.pb(mpair(x,y));
    }
    
    int multy[10010];
    int add[10010];
    
    mem(multy,0);
    for (auto i : a) {
        for (auto j : b) {
            multy[i.second + j.second + 3000] += i.first * j.first;
        }
    }
    int f = 1;
    pre(i,10000,0) {
        if (multy[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d %d",multy[i],i - 3000);
        }
    }
    if (f) printf("0 0");
    puts("");
    
    mem(add,0);
    for (auto i : a) {
        add[i.second + 3000] += i.first;
    }
    for (auto i : b) {
        add[i.second + 3000] += i.first;
    }
    
    f = 1;
    pre(i,10000,0) {
        if (add[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d %d",add[i],i - 3000);
        }
    }
    if (f) printf("0 0");
    puts("");
    return 0;
}
*/

/*
const int MAXN = 100010;

int main()
{
    int f,n,k;
    sciii(f,n,k);
    int num[MAXN];
    int nxt[MAXN];
    int pre[MAXN];
    
    int addr,nn,nt;
    
    int last = -1;
    rep(i,1,n) {
        sciii(addr,nn,nt);
        num[addr] = nn;
        nxt[addr] = nt;
    }
    
    int c = f;
    int cc = 0;
    while (c != -1) {
        pre[c] = last;
        last = c;
        c = nxt[c];
        cc ++;
    }
    n = cc;
    
    int cnt = 0;
    int ff = f;
    int sf = 0;
    c = f;
//    int cc;
    
    int x = 0;
    int mx = n / k;
    last = -1;
    while (c != -1) {
        cnt ++;
        nt = nxt[c];
        
        if (x < mx) swap(nxt[c],pre[c]);
        
        if (cnt == k) {
            swap(pre[c],nxt[f]);
            if (nt != -1) pre[nt] = c;
            if (last != -1) nxt[last] = c;
            last = f;
            f = nt;
            if (!sf) {
                sf = 1;
                ff = c;
            }
            cnt = 0;
            x ++;
            
        }
        c = nt;
    }
    
    c = ff;
    while (c != -1) {
        printf("%05d %d ",c,num[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    
    re0;
}
*/


// AC自动机
// 给定n个模式串s_i和一个文本串t，求有多少个不同的模式串在文本串里出现过。两个模式串不同当且仅当他们编号不同。

/*
const int MAXN = 5e5 + 10;

struct AC_Auto {
    int next[MAXN][26],fail[MAXN],end[MAXN];
    int root,cnt;

    inline int newNode() {
        for (int i = 0;i < 26;i ++) next[cnt][i] = -1;
        end[cnt ++] = 0;
        return cnt - 1;
    }
    void init() {
        cnt = 0;
        root = newNode();
    }

    void insert(char str[]) {
        int len = (int) strlen(str);
        int now = root;
        for (int i = 0;i < len;i++) {
            if (next[now][str[i] - 'a'] == -1) next[now][str[i] - 'a'] = newNode();
            now = next[now][str[i] - 'a'];
        }
        end[now] ++;
    }

    void build() {
        queue<int> q;
        fail[root] = root;
        for(int i = 0;i < 26;i++)
        {
            if (next[root][i] == -1) next[root][i] = root;
            else
            {
                fail[next[root][i]] = root;
                q.push(next[root][i]);
            }
        }
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            for (int i = 0;i < 26;i++)
            {
                if (next[now][i] == -1) next[now][i] = next[fail[now]][i];
                else
                {
                    fail[next[now][i]] = next[fail[now]][i];
                    q.push(next[now][i]);
                }
            }
        }
    }

    int query(char *s) {
        int len = (int) strlen(s);
        int now = 0,ans = 0;
        for (int i = 0;i < len;i ++){
            now = next[now][s[i] - 'a'];
            for (int t = now;t && ~end[t];t = fail[t]) {
                ans += end[t];
                end[t] = -1;
            }
        }
        return ans;
    }

    void debug() {
        for (int i = 0;i < cnt;i ++) {
            printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]);
            for (int j = 0;j < 26;j ++) printf("%2d",next[i][j]);
            printf("]\n");
        }
    }
};

AC_Auto ac;
char str[MAXN << 1];

int main()
{
    int n;
    __T {
        scanf("%d",&n);
        ac.init();
        rep(i,1,n) {
            scanf("%s",str);
            ac.insert(str);
        }
        ac.build();
        scanf("%s",str);
        printf("%d\n",ac.query(str));
    }
    return 0;
}
*/

//
//int n = 2,m = 2;
//
//// 0 u
//// 1 d
//// 2 l
//// 3 r
//
//int vis[110][110] = {0};
//int ans = 0;
//
//void dfs(int i,int j,int dir,int cnt)
//{
//    _C(i << " " << j)
//    if (vis[i][j]) return;
//    vis[i][j] = 1;
//    if (cnt == n * m) {
//        ans ++;
//        return;
//    }
//    int ii,jj;
//    switch (dir) {
//        case 0:
//            ii = i;
//            jj = j + 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,cnt + 1);
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,cnt + 1);
//            break;
//        case 1:
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,cnt + 1);
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,cnt + 1);
//            break;
//        case 2:
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,cnt + 1);
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,cnt + 1);
//            break;
//        case 3:
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,cnt + 1);
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,cnt + 1);
//            break;
//        default:
//            break;
//    }
//    vis[i][j] = 0;
//}
//
//int main()
//{
//    int ii,jj;
//    rep(i,1,n) {
//        rep(j,1,m) {
//            vis[i][j] = 1;
//
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,2);
//            puts("");
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,2);
//            puts("");
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,2);
//            puts("");
//            ii = i;
//            jj = j + 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,2);
//            puts("");
//            puts("");
//
//            vis[i][j] = 0;
//        }
//    }
//    _C(ans)
//    return 0;
//}
//
//

/*
int main()
{
    int n,m;
    int ans;
    int T = 1;
    __T {
        scii(n,m);
        if (m < n) swap(m, n);
        
        if (n == 1) {
            if (m == 1) ans = 1;
            else ans = 2;
        }
        else if (n == 2) {
            ans = 2 * m;
        } else {
            ans = (n - 2) * 2 + (m - 2) * 2 + 4;
        }
        printf("Case #%d: %d\n",T++,ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int T = 1;
    __T {
        sci(n);
        printf("Case #%d:\n",T ++);
        puts("YES");
        rep(i,1,n) {
            rep(j,i,n) {
                printf("%d %d %d %d %d %d %d %d\n",i,j, 0,j,i , 1,j,i);
            }
        }
    }
    re0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    int a[100010];
    int x;
    ll pre[100010],sub[100010];
    ll ans = 1;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        pre[1] = a[1];
        sub[n] = a[n];
        rep(i,2,n) pre[i] = gcd(a[i],pre[i - 1]);
        pre(i,n - 1,1) sub[i] = gcd(a[i],sub[i + 1]);
        ans = 1;
        rep(i,1,n) {
            if (i == 1) ans = max(ans,sub[i+1]);
            else if (i == n) ans = max(ans,pre[i-1]);
            else ans = max(ans,gcd(pre[i-1],sub[i+1]));
        }
        printf("%d\n",ans);
    }
}*/

/*
struct Node {
    ll pos,c;
    bool operator<(const Node &o) const {
        return pos < o.pos;
    }
};

ll dp[3010][3010];
ll m[3010];
ll jj[3010];

int main()
{
    int n;
    Node a[3010];
    ll pos,c;
    ll ans;
    int t1,t2;
    int last;
    while (~sci(n)) {
        rep(i,1,n) {
            scll(pos,c);
            a[i].pos = pos;
            a[i].c = c;
        }
        sort(a + 1,a + 1 + n);
        jj[1] = m[1] = dp[1][1] = a[1].c;
        

        rep(i,2,n) {
            m[i] = (dp[i][i-1] = jj[i-1] + a[i].pos - a[i-1].pos);
            rep(j,1,i-2) {
                dp[i][j] = dp[i-1][j] + a[i].pos - a[j].pos;
                m[i] = min(m[i],dp[i][j]);
            }
            jj[i] = m[i - 1] + a[i].c;
            m[i] = min(m[i],jj[i]);
        }
        printf("%lld\n",m[n]);
    }
    re0;
}
*/


//
//int main() {
//    string c[10];
//    int a[10];
//    int b[10];
//    const int x = 1 << 5;
//    int niu,niu_cnt,no;
//    int ok1 = 0;
//    int t;
//    __T {
//        rep(i,1,5) cin >> c[i];
//        rep(i,1,5) {
//            if (c[i] == "A") a[i] = 1;
//            else if (c[i] == "10" || c[i] == "J" || c[i] == "K" || c[i] == "Q") a[i] = 10;
//            else a[i] = c[i][0] ^ 48;
//            _C(a[i])
//        }
//
//        rep(i,1,5) cin >> c[i];
//        rep(i,1,5) {
//            if (c[i] == "A") b[i] = 1;
//            else if (c[i] == "10" || c[i] == "J" || c[i] == "K" || c[i] == "Q") b[i] = 10;
//            else b[i] = c[i][0] ^ 48;
//            _C(b[i])
//        }
//
//        ok1 = -1;
//
//        REP(i,0,x) {
//            niu = 0;
//            niu_cnt = 0;
//            no = 0;
//            for (int j = i,k = 1;k <= 5;k ++,j >>= 1) {
//                if (j & 1) {
//                    niu_cnt ++;
//                    niu += a[k];
//                } else no += a[k];
//            }
//            if (niu_cnt == 3) {
//                if (niu % 10 == 0) {
//                    t = no % 10;
//                    if (ok1 == -1 || t == 0) ok1 = t;
//                    else if (ok1 != 0) ok1 = max(ok1,t);
//                }
//            }
//        }
//    }
//    re0;
//}

/*
const double esp = 5e-5;

inline double f(double x) {
    return x * x * x - 2 * x - 5;
}

int main()
{
    double l = 2,r = 3;
    double m;
    while (r - l > esp) {
        m = (l + r) / 2;
        if (f(m) * f(l) < 0) r = m;
        else l = m;
    }
    printf("%f\n",l);
    return 0;
}
*/

/*
const double esp = 1e-4;

inline double f(double x) {
    return x * x * x + 10 * x - 20;
}

int main()
{
    double l = 1,r = 2;
    double m;
    while (r - l > esp) {
        m = (l + r) / 2;
        if (f(m) * f(l) < 0) r = m;
        else l = m;
    }
    printf("%f\n",l);
    return 0;
}
*/

/*
const int MAXN = 1e7 + 10;

int is_prime[MAXN];
int is_prime_small[MAXN];

void segment_sieve(ll a,ll b)
{
    for (ll i = 0;i * i <= b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i <= b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i <= b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j <= b;j += i) is_prime_small[j] = 0;
            for (ll j = max(2LL,(a + i - 1) / i) * i; j <= b;j += i) is_prime[j - a] = 0;
        }
    }
}

ll primes[MAXN];

int main()
{
    ll l,r;
    int cnt;
    ll ln,lx,lnl,lnr,lxl,lxr;
    ll t;
    int cc;
    while (~scll(l,r)) {
        cnt = 0;
        segment_sieve(l, r);
        for (ll i = 0;i <= r - l;i ++) {
            if (is_prime[i]) {
                primes[cnt ++] = i + l;
            }
        }
        ln = -1;
        lx = -1;
        
        cc = 0;
        if (primes[0] != 1) cc ++;
        
        REP(i,1,cnt) {
            if (primes[i] != 1) cc ++;
            if (primes[i] == 1 || primes[i - 1] == 1) continue;
            
            t = primes[i] - primes[i - 1];
            if (ln == -1 || t < ln) {
                ln = t;
                lnl = primes[i-1];
                lnr = primes[i];
            }
            if (t > lx) {
                lx = t;
                lxl = primes[i-1];
                lxr = primes[i];
            }
        }
        if (cc < 2) {
            printf("There are no adjacent primes.\n");
            continue;
        }
        printf("%lld,%lld are closest, %lld,%lld are most distant.\n",lnl,lnr,lxl,lxr);
    }
}
*/

/*
const int S = 9; //随机算法判定次数，一般8~10就够了

// 计算ret = (a*b)%c a,b,c < 2^63
long long mult_mod(ll a,ll b,ll c)
{
    a %= c;
    b %= c;
    ll ret = 0;
    ll tmp = a;
    while (b) {
        if (b & 1) {
            ret += tmp;
            if (ret > c)ret -= c;//直接取模慢很多
        }
        tmp <<= 1;
        if (tmp > c) tmp -= c;
        b >>= 1;
    }
    return ret;
}

// 计算 ret = (a^n)%mod
long long pow_mod(ll a,ll n,ll mod)
{
    ll ret = 1;
    ll temp = a % mod;
    
    while (n)
    {
        if (n & 1) ret = mult_mod(ret,temp,mod);
        temp = mult_mod(temp,temp,mod);
        n >>= 1;
    }
    return ret;
}
    
// 通过 a^(n-1)=1(mod n)来判断n是不是素数
// n-1 = x*2^t 中间使用二次判断
// 是合数返回true, 不一定是合数返回false
bool check(ll a,ll n,ll x,ll t)
{
    ll ret = pow_mod(a,x,n);
    ll last = ret;
    for (int i = 1;i <= t;i ++)
    {
        ret = mult_mod(ret,ret,n);
        if (ret == 1 && last != 1 && last != n-1) return true; //合数
        last = ret;
    }
    if (ret != 1) return true;
    else return false;
}

bool Miller_Rabin(ll n)
{
    if (n < 2) return false;
    if (n == 2) return true;
    if ((n & 1) == 0) return false; //偶数
    ll x = n - 1;
    ll t = 0;
    while ((x & 1) ==0) {
        x >>= 1;
        t ++;
    }
    srand((uint) time(NULL));
    ll a;
    for (int i = 0;i < S;i ++)
    {
        a = rand() % (n - 1) + 1;
        if (check(a,n,x,t)) return false;
    }
    return true;
}

ll factor[100]; //质因素分解结果(刚返回时时无序的)
int tol; //质因素的个数，编号0~tol-1

ll gcd(ll a,ll b) {
    ll t;
    while (b)
    {
        t = a;
        a = b;
        b = t % b;
    }
    if (a >= 0) return a;
    else return -a;
}

// 找出一个因子
ll pollard_rho(ll x,ll c) {
    ll i = 1, k = 2;
    srand((uint) time(NULL));
    ll x0 = rand() % (x - 1) + 1;
    ll y = x0;
    ll d;
    while (1)
    {
        i ++;
        x0 = (mult_mod(x0,x0,x) + c) % x;
        d = gcd(y - x0,x);
        if (d != 1 && d != x) return d;
        if (y == x0) return x;
        if (i == k) {
            y = x0;
            k += k;
        }
    }
}

// 对n进行素因子分解，存入factor. k设置为107左右即可
void findfac(ll n,int k)
{
    if (n == 1) return;
    if (Miller_Rabin(n)) {
        factor[tol ++] = n;
        return;
    }
    ll p = n;
    int c = k;
    while (p >= n) p = pollard_rho(p,c --); // 值变化，防止死循环k
    findfac(p,k);
    findfac(n / p,k);
}



// 找出一个数字所有的质因子，若有重复的质因子，则输出yes CCPC2020威海
int main()
{
    ll n;
    int ok = 0;
    __T {
        scl(n); // 读取一个ll数
        tol = 0; // 质数的个数=0
        findfac(n, 107); // 找出所有的因子
        sort(factor, factor + tol); // 排序
        
        ok = 0;
        REP(i,1,tol) {
            if (factor[i - 1] == factor[i]) { // 找出了一样的了
                ok = 1;
                break;
            }
        }
        puts(ok ? "yes" : "no");
    }
}
*/

/*
int main()
{
    int m,n,k;
    sciii(m,n,k);
    stack<int> s;
    int a[1010];
    int ok;
    int j;
    while (k --) {
        rep(i,1,n) sci(a[i]);
        ok = 0;
        j = 1;
        rep(i,1,n+1) {
            while (s.size() != 0 && s.top() == a[j]) {
                j ++;
                s.pop();
                ok ++;
            }
            if (i <= n && s.size() < m) s.push(i);
        }
        while (!s.empty()) s.pop();
        puts(ok == n ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    int a[1010];
    int b[1010];
    int an = 0,bn = 0;
    int t;
    rep(i,1,n) {
        sci(t);
        if (t & 1) a[++ an] = t;
        else b[++ bn] = t;
    }
    int i = 1,j = 1;
    int cnt = 0;
    int f = 1;
    while (i <= an || j <= bn) {
        cnt ++;
        if (i <= an) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",a[i]);
            i ++;
        }
        if (!(cnt & 1)) {
            if (j <= bn) {
                if (f) f = 0;
                else printf(" ");
                printf("%d",b[j]);
                j ++;
            }
        }
    }
    puts("");
    return 0;
}
*/

/*
int mp[1010][1010];
int mm[1010][1010];
int dx[] = {0,1,-1,0};
int dy[] = {1,0,0,-1};

const int MAXN = 1e6 + 10;
const int mod = 1e9 + 7;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 3];
int g[MAXN];

int cnt;

void add(int u,int v) {
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int in[MAXN];
int out[MAXN];
int id;

ll step[MAXN][5];



ll Tuopu()
{
    queue<int> q;
    rep(i,1,id) {
//        _C(i << " " << in[i])
        if (in[i] == 0) {
            q.push(i);
            step[i][1] = 1;
        }
    }
    int top;
    int to;
    int cnt;
    while (!q.empty()) {
        top = q.front();
        q.pop();
        for (int i = g[top];~i;i = e[i].nxt) {
            to = e[i].to;
            
            rep(i,1,4) {
                cnt = i + 1;
                if (cnt > 4) cnt = 4;
                step[to][cnt] += step[top][i];
                step[to][cnt] %= mod;
            }
            
            in[to] --;
            if (in[to] == 0) q.push(to);
        }
    }
    
    ll ans = 0;
    
    rep(i,1,id) {
        if (out[i] == 0) {
            ans += step[i][4];
            ans %= mod;
        }
    }
    return ans;
}

int main()
{
    mem(g,-1);
    cnt = 0;
    id = 0;
    int n,m;
    scii(n,m);
    rep(i,1,n) {
        rep(j,1,m) {
            sci(mp[i][j]);
            mm[i][j] = ++ id;
        }
    }
    int ii,jj;
    rep(i,1,n) {
        rep(j,1,m) {
            REP(k,0,4) {
                ii = i + dy[k];
                jj = j + dx[k];
                if (ii >= 1 && ii <= n && jj <= m && jj >= 1) {
                    if (mp[i][j] + 1 == mp[ii][jj]) {
                        add(mm[i][j],mm[ii][jj]);
                        in[mm[ii][jj]] ++;
                        out[mm[i][j]] ++;
                    }
                }
            }
        }
    }
    printf("%lld\n",Tuopu());
    re0;
}
*/


/*
const int MAXN = 100010;

vector<int> g[MAXN];

int n;
int color[MAXN];

int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}

int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
//    _C(x << " " << type)
    int t = 0;
    if (!vis[color[x]]) t ++;
    vis[color[x]] += type;
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy)
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留
{
    
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子
        heavy = weight[x];
    }
    
//    _C(">>" << x << " " << keep)
    t += count(x, f, 1);
    heavy = 0;
    ans[x] = t;

    if (!keep) count(x, f, -1);
    return t;
}

int main()
{
    sci(n);

    int u,v;
    rep(i,1,n-1) {
        scii(u,v);
        g[u].pb(v);
        g[v].pb(u);
    }
    rep(i,1,n) sci(color[i]);

    getMaxSon(1, -1);
    dfs(1, -1, 1);

    int t;
    __T {
        sci(t);
        printf("%d\n",ans[t]);
    }
    return 0;
}
*/

/*
const int MAXN = 200010;

vector<int> g[MAXN];

int n;

// -----统计重儿子（节点数最多的儿子）-----
int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}
// ----------------------------------


int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
    int t = 0;
    
    // ---------------在此修改计数方式---------------
    if (vis[x - 1] && vis[x + 1]) t --;
    else if (!vis[x - 1] && !vis[x + 1]) t ++;
    // -------------------------------------------
    
    vis[x] += type;
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy) // 跳过重儿子
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留，调用直接(root,-1,1)
{
    
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子，不保留
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子，保留
        heavy = weight[x]; // 记录当前重儿子
    }
    
    t += count(x, f, 1); // 计算答案
    heavy = -1; // 清空重儿子记录
    ans[x] = t; // 记录答案

    if (!keep) count(x, f, -1); // 不保留直接清除vis
    return t;
}

int main()
{
    int u,v;
    int T = 1;
    __T {
        sci(n);
        rep(i,1,n + 5) {
            g[i].clear();
            ans[i] = vis[i] = 0; // 注意清空
        }
        heavy = -1; // 注意清空
        rep(i,1,n - 1) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        getMaxSon(1, -1);
        dfs(1, -1, 1);
        printf("Case #%d:",T ++);
        rep(i,1,n) printf(" %d",ans[i]);
        puts("");
    }
    return 0;
}
*/


/*
// ***************************************************
// *                                                 *
// *     启发式树上合并：用于统计树上子树中特定节点的个数     *
// *                                                 *
// ***************************************************
const int MAXN = 200010;

vector<int> g[MAXN];

int n;

// -----统计重儿子（节点数最多的儿子）-----
int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}
// ----------------------------------


int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
    int t = 0;
    
    // ---------------在此修改计数方式---------------
    if (vis[x - 1] && vis[x + 1]) t --;
    else if (!vis[x - 1] && !vis[x + 1]) t ++;
    // -------------------------------------------
    
    // -----根据题意改变vis什么，若是统计颜色的则vis[color[x]] += type-----
    vis[x] += type;
    // -------------------------------------------------------------
    
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy) // 跳过重儿子
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留，调用直接(root,-1,1)
{
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子，不保留
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子，保留
        heavy = weight[x]; // 记录当前重儿子
    }
    
    t += count(x, f, 1); // 计算答案
    heavy = -1; // 清空重儿子记录
    ans[x] = t; // 记录答案

    if (!keep) count(x, f, -1); // 不保留直接清除vis
    return t;
}

int main()
{
    int u,v;
    int T = 1;
    __T {
        sci(n);
        rep(i,1,n + 5) {
            g[i].clear();
            ans[i] = vis[i] = 0; // 注意清空
        }
        heavy = -1; // 注意清空
        rep(i,1,n - 1) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        getMaxSon(1, -1);
        dfs(1, -1, 1);
        printf("Case #%d:",T ++);
        rep(i,1,n) printf(" %d",ans[i]);
        puts("");
    }
    return 0;
}
*/

/*
const int MAXN = 500010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN << 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memset(g, -1, sizeof(int) * n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memset(dis, -1, sizeof(int) * (n + 5));

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

// ***********************************************
// *             二分图匹配 - 网络流算法             *
// *   思路：建立超级源点到各个左部点的联系（权重为1），  *
// * 建立右部点到超级汇点的联系，以及左右部分点之间的联系，*
// *               最后直接最大流板子。              *
// ***********************************************

int main()
{
    // **注意：MAXN尽量开大点，不然很容易RE**
    int nn,mm,e;
    scanf("%d%d%d",&nn,&mm,&e);
    init(nn + mm + 10);
    int u,v;
    // nn + mm + 1 源点
    // nn + mm + 2 汇点
    while (e --) {
        scanf("%d%d",&u,&v);
        add_edge(u, v + nn, 1); // 建立 左部点 到 右部点 的联系
        add_edge(v + nn, u, 0);
    }
    rep(i,1,nn) {
        add_edge(nn + mm + 1, i, 1); // 建立超级源点到各个左部点的联系
        add_edge(i, nn + mm + 1, 0);
    }
    
    rep(i,nn + 1,nn + mm) {
        add_edge(i, nn + mm + 2, 1); // 建立 右部点 到超级汇点的联系
        add_edge(nn + mm + 2, i, 0);
    }
    
    n = nn + mm + 2; // 设置总点量
    s = nn + mm + 1; // 设置起点
    t = nn + mm + 2; // 设置终点
    printf("%lld\n",dinic());
    return 0;
}
*/

/*
const int MAXN = 500010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN << 1];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memset(g, -1, sizeof(int) * n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memset(dis, -1, sizeof(int) * (n + 5));

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

int main()
{
    int nn,m,k;
    sciii(nn,m,k);
    int tmp;
    
    s = 1;
    t = 3;
    int v;
    init(nn + m + 10);
    n = nn + m + 3;
    rep(i,1,nn) {
        sci(tmp);
        while (tmp --) {
            sci(v);
            add_edge(i + 3, v + nn + 3, 1);
            add_edge(v + nn + 3, i + 3, 0);
        }
        add_edge(1, i + 3, 1);
        add_edge(i + 3, 1, 0);
        
        add_edge(2, i + 3, 1);
        add_edge(i + 3, 2, 0);
    }
    
    rep(i,1,m) {
        add_edge(nn + i + 3, 3, 1);
        add_edge(3, nn + i + 3, 0);
    }
    
    add_edge(1, 2, k);
    add_edge(2, 1, 0);
    
    
    printf("%lld\n",dinic());
    
    return 0;
}
*/

/*
const int MAXN = 1e6 + 10;

int a[MAXN];

int isP[MAXN];
vector<int> p[MAXN];

void sheive()
{
    isP[1] = 1;
    rep(i,2,1000000) {
        if (isP[i]) continue;
        p[i].pb(i);
        for (int j = i + i;j <= 1000000;j += i) {
            p[j].pb(i);
            isP[j] = 1;
        }
    }
}

ll last[MAXN];

int main()
{
    sheive();
    int n;
    scanf("%d",&n);
    rep(i,1,n) scanf("%d",a + i);
    ll ans = 0;
    rep(i,1,n) {
        for (auto j : p[a[i]]) {
            ans += (i - last[j]) * (n - i + 1);
            last[j] = i;
        }
    }
    printf("%lld\n",ans);
    
    return 0;
}
*/

/*
struct Node {
    ll i,j,k;
} ans[500];

int main()
{
    ll k,m,n,s;
    int ok;
    int a[500] = {0};
    printf("%lu\n",time(NULL));
    rep(x,0,200) {
        ok = 0;
        for (ll i = -5000;i <= 5000;i ++) {
            for (ll j = -5000;j <= 5000;j ++) {
                k = i*i*i + j*j*j;
                m = x - k;
                n = pow(m,1/3.0);
                s = 0;
                if (n * n * n == m) {
                    s = n;
                    ok = 1;
                } else if ((n+1) * (n+1) * (n+1) == m) {
                    s = n + 1;
                    ok = 1;
                } else if ((n-1) * (n-1) * (n-1) == m) {
                    s = n - 1;
                    ok = 1;
                }
                if (abs(s) > 5000) ok = 0;
                if (ok) {
                    ans[x] = {i,j,s};
                    goto end;
                }
            }
        }
        end:
        a[x] = ok;
        printf("%d\n",x);
    }
    printf("int ok[] = {");
    rep(i,0,200) printf("%d,",a[i]);
    printf("};\n");
    printf("int ans[][3]={");
    rep(i,0,200) printf("{%lld,%lld,%lld},",ans[i].i,ans[i].j,ans[i].k);
    printf("};\n");
    printf("%lu\n",time(NULL));
    return 0;
}
*/

/*
int ok[] = {1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,};
int ans[][3]={{-5000,0,5000},{-5000,1,5000},{-4373,-486,4375},{-5,4,4},{0,0,0},{0,0,0},{-637,-205,644},{-169,44,168},{-5000,2,5000},{-216,-52,217},{-650,-353,683},{-695,-641,843},{-11,7,10},{0,0,0},{0,0,0},{-265,-262,332},{-4114,-588,4118},{-3331,2195,2977},{-1373,-1276,1671},{-95,47,91},{-2816,-741,2833},{-401,-287,445},{0,0,0},{0,0,0},{-10,8,8},{-2683,1839,2357},{-2107,237,2106},{-5000,3,5000},{-2268,-249,2269},{-233,-69,235},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-1555,-244,1557},{-1120,-509,1154},{-3223,2358,2731},{-444,-84,445},{-27,16,25},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-823,-307,837},{-7,-5,8},{-2369,1709,2025},{-758,-473,815},{-141,49,139},{-3950,-1247,3991},{0,0,0},{0,0,0},{-796,602,659},{0,0,0},{-2370,1518,2141},{-3885,-648,3891},{-3329,1837,3131},{-672,505,559},{-998,361,982},{0,0,0},{0,0,0},{-1201,-163,1202},{-966,668,845},{-2744,-1561,2903},{-161,102,146},{-5000,4,5000},{-929,403,903},{1,1,4},{0,0,0},{0,0,0},{-403,134,398},{-2359,824,2325},{-533,401,443},{-432,-104,434},{-335,-146,344},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-2080,-829,2123},{-706,-196,711},{-1300,-706,1366},{-2368,-1719,2638},{-1317,847,1188},{-3707,1315,3651},{0,0,0},{0,0,0},{0,0,0},{-4126,-1972,4271},{-1390,-1282,1686},{-2514,1953,2036},{-1803,365,1798},{-3389,-2912,3992},{-4052,861,4039},{-248,-98,253},{0,0,0},{0,0,0},{-22,14,20},{-3168,-991,3200},{-2101,-1638,2391},{-893,-622,984},{-1797,-903,1870},{-2327,319,2325},{-239,118,229},{0,0,0},{0,0,0},{-7,-4,8},{-2689,-1165,2760},{-1309,947,1117},{-1165,-948,1345},{-2948,853,2924},{0,0,0},{-4793,-2312,4966},{0,0,0},{0,0,0},{0,0,0},{-12,8,11},{-1906,-757,1945},{-896,-555,962},{-4328,383,4327},{-3677,-1673,3789},{-2804,1219,2725},{0,0,0},{0,0,0},{-37,-16,38},{-1,0,5},{-5000,5,5000},{-2212,-419,2217},{-4034,-3881,4988},{-3989,-726,3997},{-1580,-1238,1801},{0,0,0},{0,0,0},{-1,2,5},{-399,167,389},{-3013,-1766,3203},{-1351,-629,1395},{-1116,816,946},{-758,-428,801},{-86,-77,103},{0,0,0},{0,0,0},{-139,104,116},{-7,-3,8},{0,0,0},{-2746,-2552,3342},{-8,-7,10},{-327,-263,376},{-2366,1528,2131},{0,0,0},{0,0,0},{-367,260,317},{-463,215,447},{-805,486,741},{-3736,-695,3744},{-2135,-516,2145},{-3693,-1049,3721},{0,0,0},{0,0,0},{0,0,0},{-1534,383,1526},{-3874,-1654,3972},{-4767,-2476,4980},{-4125,-1417,4180},{-3423,-2943,4033},{-66,-59,79},{0,0,0},{0,0,0},{0,0,0},{-802,-574,890},{-1354,-1012,1521},{-3834,-2149,4047},{-1328,891,1178},{0,0,0},{0,0,0},{-335,-170,349},{0,0,0},{0,0,0},{-1168,-160,1169},{-13,-10,15},{-2839,1503,2691},{0,0,0},{-4874,974,4861},{-90,-29,91},{-4889,976,4876},{0,0,0},{0,0,0},{-4,5,5},{-1885,-1092,2000},{-1639,318,1635},{-1702,-1403,1974},{-4812,-593,4815},{-377,-215,399},{-20,16,16},{0,0,0},{0,0,0},{0,0,0},{-1057,-579,1112},{-2867,-1606,3026},{-3752,-1347,3809},{-2208,508,2199},{-2318,-638,2334},};

int main()
{
    int x;
    __T {
        scanf("%d",&x);
        if (ok[x]) printf("%d %d %d\n",ans[x][0],ans[x][1],ans[x][2]);
        else puts("impossible");
    }
}
*/

/*
int dp[1010][1010];

int main()
{
    int n,v;
    int val[1010];
    int vol[1010];
    __T {
        scanf("%d%d",&n,&v);
        rep(i,1,n) scanf("%d",val + i);
        rep(i,1,n) scanf("%d",vol + i);
        rep(j,0,v) dp[0][j] = 0;
        rep(i,1,n) {
            rep(j,0,v) {
                if (vol[i] <= j) dp[i][j] = max(dp[i - 1][j - vol[i]] + val[i],dp[i - 1][j]);
                else dp[i][j] = dp[i - 1][j];
            }
        }
        printf("%d\n",dp[n][v]);
    }
}
*/

/*
const int MAXN = 1e5 + 10;

ll a[MAXN];

int n;

int check(ll t) {
    ll x = 0;
    t --;
    rep(i,1,n) {
        if (a[i] < t) x += t - a[i];
    }
    return x <= t;
}


int main()
{
    
    ll l,r,m;
    int T = 1;
    __T {
        scanf("%d",&n);
        rep(i,1,n) {
            scanf("%lld",a + i);
        }
        l = 1;
        r = 1e10;
        while (l < r) {
            m = (l + r) >> 1;
            if (check(m)) l = m + 1;
            else r = m;
        }
        printf("Case #%d: %lld\n",T ++,l - 1);
    }
    return 0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    ll x;
    int T = 1;
    ll n;
    ll ans;
    __T {
        scanf("%lld",&x);
        printf("Case #%d: ",T ++);
        if (x == 6 || x < 5) printf("-1\n");
        else {
            if (x & 1) puts("1");
            else {
                if (x % 4 == 0) printf("2\n");
                else {
                    n = x / 3;
                    ans = 4;
                    repl(i,n-2,n+2) {
                        repl(j,n-2,n+2) {
                            repl(k,n-2,n+2) {
                                if (i + j + k == x && i > 1 && j > 1 && k > 1 && gcd(i,j) == 1 && gcd(i,k) == 1 && gcd(j,k) == 1) {
                                    ans = min(ans,max(i,max(j,k)) - min(i,min(j,k)));
                                }
                            }
                        }
                    }
                    printf("%lld\n",ans);
                }
            }
        }
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

struct Node {
    int l,r;
    ll mx;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
ll a[MAXN];

void push_up(int i)
{
    tree[i].mx = max(tree[i << 1].mx,tree[i << 1 | 1].mx);
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy) {
        tree[i << 1].mx = max(tree[i].lzn,tree[i << 1].mx);
        tree[i << 1 | 1].mx = max(tree[i].lzn,tree[i << 1 | 1].mx);

        tree[i << 1].lzn = max(tree[i].lzn,tree[i << 1].lzn);
        tree[i << 1 | 1].lzn = max(tree[i].lzn,tree[i << 1 | 1].lzn);

        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;

        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].mx = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}


void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].mx = max(x,tree[i].mx);
        
        tree[i].lzn = max(tree[i].lzn,x);
        tree[i].lazy = 1;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].mx;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll mx = 0;
    if (l <= m) {
         mx = max(mx,query(l,r,i << 1));
    }
    if (r > m) {
        mx = max(mx,query(l,r,i << 1 | 1));
    }
    return mx;
}

struct pr {
    pr(int x,int t):x(x),t(t){}
    pr(){}
    int x,t;
    bool operator<(const pr &o) const {
        if (t == o.t) return x > o.x;
        return t < o.t;
    }
    bool operator!=(const pr &o) const {
        return t != o.t;
    }
} p[MAXN],pp[MAXN];

int main()
{
    int n,m;
    int u,v;
    int T = 1;
    int cnt;
    __T {
        read(n);
        read(m);
        build(1, m, 1);
        rep(i,1,n) {
            read(v);
            read(u);
            p[i] = pr(u,v);
        }
        cnt = 0;
        sort(p + 1,p + 1 + n);
        pp[++ cnt] = p[1];
        rep(i,2,n) {
            if (p[i] != p[i - 1]) pp[++ cnt] = p[i];
        }
        
        rep(i,1,cnt) {
            u = pp[i].x;
            v = pp[i].t;
            for (int j = 1;j <= m;j += 2 * v) {
                modify(j, min(m,j + v - 1), u, 1);
            }
        }
        
        
        printf("Case #%d:",T ++);
        rep(i,1,m) {
            printf(" %lld",query(i, i, 1));
        }
        printf("\n");
    }
    
    re0;
}
*/


/*
const int MAXN = 1e6 + 10;

int is_prime[MAXN];
int is_prime_small[MAXN];

void segment_sieve(ll a,ll b)
{
    for (ll i = 0;i * i <= b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i <= b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i <= b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j <= b;j += i) is_prime_small[j] = 0;
            for (ll j = max(2LL,(a + i - 1) / i) * i; j <= b;j += i) is_prime[j - a] = 0;
        }
    }
}


int main()
{
    int l,r;
    int cnt;
    __T {
        scanf("%d%d",&l,&r);
        if (r - l >= 100) puts("Yes");
        else {
            segment_sieve(l, r);
            cnt = 0;
            rep(i,0,r - l) if (is_prime[i]) cnt ++;
            if (cnt * 3 < r - l + 1) puts("Yes");
            else puts("No");
        }
    }
}
*/

/*
int main()
{
    ll l,r;
    ll s;
    ll kl,kr;
    ll ans;
    ll m;
    ll sub[100],pre[100];
    ll sub_cnt,pre_cnt;
    __T {
        scanf("%lld%lld%lld",&l,&r,&s);
        kl = l;
        kr = r;
        for (ll i = l;;i ++) {
            kl = i;
            if ((i & 1) == 0 && ((i >> 1) & 1) == 0) break;
        }
        for (ll i = r;;i --) {
            kr = i;
            if ((i & 1) == 1 && ((i >> 1) & 1) == 1) break;
        }
//        _C(kl << " " << kr)
        if (kr > kl) {
            ans = 0;
            pre_cnt = sub_cnt = 0;
            pre[0] = sub[0] = 0;
            prel(i,kl-1,l) {
                sub[sub_cnt + 1] = i ^ sub[sub_cnt];
                sub_cnt ++;
            }
            
            repl(i,kr+1,r) {
                pre[pre_cnt + 1] = i ^ pre[pre_cnt];
                pre_cnt ++;
            }
            
            rep(i,0,sub_cnt) {
                rep(j,0,pre_cnt) {
                    if ((sub[i] ^ pre[j]) <= s) {
                        ans = max(ans,(ll)j + i);
                    }
                }
            }
            
//            _C(">>" << ans)
            
            ans += kr - kl + 1;
        } else {
            ans = -1;
            repl(i,l,r) {
                repl(j,i,r) {
                    m = 0;
                    repl(k,i,j) {
                        m ^= k;
                    }
                    if (m <= s) ans = max(ans,j-i+1);
                }
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
struct Node {
    ll first;
    ll second;
    int num;
} x[110];

int cmp(const Node &a,const Node &b)
{
    if (a.first == b.first) return a.second > b.second;
    return a.first > b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    ll s[110][110];
    rep(i,1,n) {
        rep(j,1,n) scanf("%lld",&s[i][j]);
        x[i] = {0ll,0ll,i};
    }
    
    rep(i,1,n) {
        rep(j,1,n) {
            if (i == j) continue;
            if (s[i][j] > s[j][i]) x[i].first += 3;
            else if (s[i][j] == s[j][i]) x[i].first += 1;
            x[i].second += s[i][j] - s[j][i];
        }
    }
    sort(x+1,x+1+n,cmp);
    
//    rep(i,1,n) {
//        printf("%d ",x[i].num);
//    }
//    puts("");
//    rep(i,1,n) {
//        printf("%lld ",x[i].first);
//    }
//    puts("");
//    rep(i,1,n) {
//        printf("%lld ",x[i].second);
//    }
    
    if (n == 1) printf("1\n");
    else {
        if (x[1].first != x[2].first) printf("%d\n",x[1].num);
        else {
            if (x[1].second != x[2].second) printf("%d\n",x[1].num);
            else puts("play-offs");
        }
    }
    
    return 0;
}
*/

/*
const ll t = 998857459;
ll kk[100010];
ll x[100010];
ll num[100010];

ll ans[100010];

int main()
{
    kk[1] = 1;
    int n,m;
    scanf("%d%d",&n,&m);
    rep(i,2,2802) {
        kk[i] = kk[i-1] * i;
        kk[i] %= t;
    }
    
    int a;
    int cnt = 0;
    x[0] = num[0] = 0;
    int k = -1;
    rep(i,1,n) {
        scanf("%d",&a);
        if (a >= 2803) {
            if (k != -1) k ++;
        } else {
            if (k == -1) k = 1;
            cnt ++;
            x[cnt] = kk[a] + x[cnt - 1];
            num[cnt] = k + num[cnt - 1];
            k = 1;
        }
    }
//    rep(i,1,cnt) {
//        printf("%lld ",x[i]);
//    }
//    puts("");
//
//    rep(i,1,cnt) {
//        printf("%lld ",num[i]);
//    }
//    puts("");
    
    rep(i,1,cnt) {
        rep(j,i,cnt) {
            ans[num[j]-num[i]+1] = max(ans[num[j]-num[i]+1],(x[j] - x[i-1])%t);
        }
    }
    rep(i,2,n) ans[i] = max(ans[i-1],ans[i]);
    
//    rep(i,1,n) printf("%lld ",ans[i]);
//    puts("");
    
    int idx;
    while (m --) {
        sci(a);
        idx = (int) (lower_bound(ans + 1, ans + 1 + n, a) - ans);
        if (idx == n + 1) puts("-1");
        else printf("%d\n",idx);
    }
    return 0;
}
*/

/*
const int MAXN = 5e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

int vis[500010];

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

struct Node {
    int u,v;
    ll w;
    bool operator<(const Node &o) const {
        return w > o.w;
    }
} e[500010];

int main()
{
    int n,m,k;
    int u,v,w,c;
    ll ans;
    int cnt;
    int ok;
    int last;
    int t;
    __T {
        scanf("%d %d %d",&n,&m,&k);
        init(n + 10);
        cnt = ans = 0;
        rep(i,1,m) {
            vis[i] = 0;
            scii(u,v);
            scii(w,c);
            if (c == 0) {
                ans += w;
                bind(u,v);
            } else {
                e[++ cnt] = {u,v,w};
            }
        }
        sort(e + 1, e + 1 + cnt);
        rep(i,1,cnt) {
            if (find(e[i].u) == find(e[i].v)) continue;
            vis[i] = 1;
            bind(e[i].u,e[i].v);
            ans += e[i].w;
            k --;
            if (k <= 0) break;
        }
        ok = 1;
        last = find(1);
        rep(i,2,n) {
            t = find(i);
            if (t != last) {
                ok = 0;
                break;
            }
            last = t;
        }
        if (!ok) puts("-1");
        else {
            rep(i,1,cnt) {
                if (vis[i]) continue;
                ans += e[i].w;
                k --;
                if (k <= 0) break;
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}
*/

/*
const int mod = 1e9+7;

int main()
{
    string str;
    ll a[100010];
    int s[100010];
    int cnt;
    ll ans;
    int k;
    __T {
        cin >> str;
        cnt = 0;
        for (int i = (int) str.size()-1;i >= 0;i --) {
            s[++ cnt] = str[i] ^ 48;
            a[cnt] = 1;
        }
        a[0] = 1;
        ans = 0;
        
        rep(i,1,cnt) {
            if (s[i]) {
                ans += a[i - 1];
                ans %= mod;
                k = 3;
            } else {
                k = 2;
            }
            a[i] = a[i - 1] * k;
            a[i] %= mod;
        }
        ans ++;
        ans %= mod;
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
char str[10000010];

int main()
{
    const int m1 = 137;
    const int m2 = 73;
    int a1,a2;
    int T = 1;
    while (~scanf("%s",str)) {
        a1 = a2 = 0;
        for (int i = 0;str[i];i ++) {
            a1 *= 10;
            a1 %= m1;
            
            a2 *= 10;
            a2 %= m2;
            
            a1 += str[i] ^ 48;
            a2 += str[i] ^ 48;
            
            a1 %= m1;
            a2 %= m2;
        }
        printf("Case #%d: ",T++);
        if (a1 == 0 || a2 == 0) puts("YES");
        else puts("NO");
    }
    return 0;
}
*/

/*
int main()
{
    cio
    string str;
    int T;
    cin >> T;
    int n;
    rep(i,1,T) {
        int c['z' + 1] = {0};
        cin >> str;
        for (int i = 0;str[i];i ++) {
            c[str[i]] ++;
        }
        n = 0;
        rep(i,0,'z') if (c[i]) n ++;
        printf("Case #%d: %d\n",i,n);
    }
    reutrn 0;
}
*/

/*
const int MAXN = 1e5+10;

int p[MAXN];
int h[MAXN];
int s[MAXN];
int n;

void pls(int l,int r,int k)
{
    p[l] += k;
    p[r + 1] -= k;
}

void init(int n)
{
    rep(i,0,n) {
        p[i]=0;
    }
}


int main()
{
    int n,m,k;
    
    int a,b;
    int last;
    int idx;
    int ans;
    int T = 1;
    while (~scanf("%d%d%d",&n,&m,&k)) {
        rep(i,1,n) {
            scanf("%d",h + i);
        }
        init(n + 5);
        sort(h + 1,h + 1 + n);
        last = 0;
        rep(i,1,n) if (h[i] <= 1) last = i;
        ans = 0;
        while (m --) {
            scanf("%d%d",&a,&b);
            idx = lower_bound(h+1,h+1+n,a) - h;
            if (idx == n + 1 || h[idx] > a) idx --;
            pls(last+1,idx,1);
            idx = lower_bound(h+1,h+1+n,b) - h;
            if (idx == n + 1 || h[idx] > b) idx --;
            last = idx;
        }
        s[0] = 0;
        rep(i,1,n) {
            s[i] = s[i - 1] + p[i];
            if (s[i] >= k) ans ++;
        }
        printf("Case %d: %d\n",T ++,ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n,w,s;
    int vis[100];
    int cnt;
    int i,j;
    while (~scanf("%d%d%d",&n,&w,&s)) {
        memset(vis,0,sizeof vis);
        i = (w-2+n) % n;
        j = 0;
        cnt = 0;
        while (cnt < n) {
            i ++;
            i %= n;
            if (vis[i]) continue;
            j ++;

            if (j == s) {
                vis[i] = 1;
                printf("%d\n",i + 1);
                cnt ++;
                j = 0;
            }

        }
    }
    return 0;
}
*/

/*
struct Node {
    Node(){}
    Node(const char a[],int b):x(b){
        strcpy(str, a);
    }
    char str[20];
    int x;
};

int main()
{
    int n;
    char k[20];
    int x,y;
    int m;
    sci(n);
    map<int,Node> mp;
    while (n --) {
        scanf("%s %d %d",k,&x,&y);
        mp[x] = Node(k,y);
    }
    scanf("%d",&m);
    while (m --) {
        sci(x);
        printf("%s %d\n",mp[x].str,mp[x].x);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int j,k = 0;
    while (cin >> str)
    {
        j = 0;
        for (int i = 0;str[i];i ++)
        {
            if (str[i] != str[j])
            {
                j = 0;
                k = i + 1;
            } else {
                if (j < k - 1) j ++;
                else j = 0;
            }
        }
        if (j != 0) k = (int) str.size();
        printf("%d\n",k);
    }
     
    return 0;
}
*/

/*
struct Node {
    int type; // 0 - num,1 - op
    char c;
    ll num;
};

int priority[130];

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

void getPost(string &str,vector<Node> &post) {
    post.clear();
    stack<char> op_stk;
    ll num = 0;
    int has_num = 0;
    
    for (int i = 0;str[i];i ++) {
        if (str[i] >= '0' && str[i] <= '9') {
            num = num * 10 + (str[i] ^ 48);
            has_num = 1;
        } else {
            if (has_num) post.push_back({0,0,num});
            has_num = num = 0;
            if (str[i] != ')') {
                if (str[i] != '(') while (!op_stk.empty() && priority[op_stk.top()] >= priority[str[i]]) {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.push(str[i]);
            } else {
                while (op_stk.top() != '(') {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.pop();
            }
        }
    }
    if (has_num) post.push_back({0,0,num});
    while (!op_stk.empty()) {
        post.push_back({1,op_stk.top(),0});
        op_stk.pop();
    }
}

ll getAns(vector<Node> &post) {
    ll ans = 0;
    stack<ll> num_stk;
    
    for (auto i : post) {
        if (!i.type) num_stk.push(i.num);
        else {
            switch (i.c) {
                case '+':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans += num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '-':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() - ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '*':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans *= num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '/':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() / ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '^':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = quickpow(num_stk.top(),ans);
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                default:
                    break;
            }
        }
    }
    return num_stk.top();
}

int main() {
    
    
    priority['('] = 1;
    priority['^'] = 4;
    priority['*'] = priority['/'] = 3;
    priority['+'] = priority['-'] = 2;
    
    string str;
    cin >> str;
    vector<Node> post;
    
    getPost(str,post);
    printf("%lld ",getAns(post));
    
    priority['*'] = priority['/'] = 2;
    priority['+'] = priority['-'] = 3;
    
    getPost(str,post);
    printf("%lld\n",getAns(post));
}
*/


/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll s = -1;
    ll l = 0;
    ll lm = 0,sm =-1;
    ll nn = n;
    ll ii;
    for (ll i = 2;i * i <= n;i ++) {
        nn = n;
        if (nn % i == 0) {
            ii = i;
            s = i;
            l = 0;
            while (nn % ii == 0) {
                l ++;
                nn /= ii;
                ii ++;
            }
            if (l > lm) {
                lm = l;
                sm = s;
            }
        }
        
    }
    
    if (lm == 0) printf("1\n%lld\n",n);
    else {
        printf("%lld\n",lm);
        rep(i,1,lm) {
            if (i != 1) printf("*");
            printf("%lld",sm ++);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    string x[10] = {"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};
    string all[150];
    all['-'] = "fu";
    rep(i,0,9) all[i + '0'] = x[i];
    string str;
    cin >> str;
    for (int i = 0;str[i];i ++) {
        if (i != 0) printf(" ");
        cout << all[str[i]];
    }
    puts("");
}
*/

/*
int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    int j = 0;
    ll ans = 0;
    rep(i,a,b) {
        ans += i;
        if (j == 5) {
            printf("\n");
            j = 0;
        }
        printf("%5d",i);
        j ++;
    }
    printf("\nSum = %lld\n",ans);
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    scanf("%d",&n);
    ll son[110],mot[110];
    ll lcm = 1;
    rep(i,1,n) {
        scanf("%lld/%lld",son + i,mot + i);
        lcm = lcm / gcd(lcm,mot[i]) * mot[i];
    }
    ll sum = 0;
    rep(i,1,n) {
        sum += son[i] * (lcm / mot[i]);
    }
    int f = sum < 0;
    sum = abs(sum);
    ll z = sum / lcm;
    sum -= z * lcm;
    ll g = gcd(sum,lcm);
    sum /= g;
    lcm /= g;
    int p = 0;
    int k = 1;
    if (f) printf("-");
    if (z != 0) {
        printf("%lld",z);
        p = 1;
        k = 0;
    }
    if (sum != 0) {
        if (!k) printf(" ");
        printf("%lld/%lld",sum,lcm);
        p = 1;
    }
    if (!p) printf("0");
    puts("");
    return 0;
}
*/

/*
int main()
{
    set<char> bb;
    string a,b;
    getline(cin, a);
    getline(cin, b);
    for (int i = 0;b[i];i ++) bb.insert(b[i]);
    for (int i = 0;a[i];i ++) {
        if (bb.find(a[i]) != bb.end()) continue;
        printf("%c",a[i]);
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    ll a[20];
    a[1] = 1;
    rep(i,2,10) a[i] = a[i - 1] * i;
    int n;
    scanf("%d",&n);
    ll ans = 0;
    rep(i,1,n) ans += a[i];
    printf("%lld\n",ans);
}
*/

/*
int mp[20][20];
int mmp[20][20];
int op[20];
int ans[20][20];
int times = -1;

int n,m;

int dx[] = {1,-1,0,0,0};
int dy[] = {0,0,-1,1,0};

int tmp[20][20];

void go() {
    int t = 0;
    
    rep(i,1,n) {
        rep(j,1,m) {
            mmp[i][j] = mp[i][j];
        }
    }
    
    int ii,jj;
    rep(i,1,n) {
        rep(j,1,m) {
            tmp[i][j] = op[j];
            if (op[j]) {
                t ++;
                rep(k,0,4) {
                    ii = i + dx[k];
                    jj = j + dy[k];
                    if (ii >= 1 && ii <= n && jj >= 1 && jj <= m) {
                        mmp[ii][jj] = !mmp[ii][jj];
                    }
                }
            }
        }
        rep(j,1,m) op[j] = mmp[i][j];
    }
    
    rep(i,1,m) if (mmp[n][i]) return;
    
    if (times == -1 || t < times) {
        times = t;
        rep(i,1,n) {
            rep(j,1,m) {
                ans[i][j] = tmp[i][j];
            }
        }
    }
}


int main()
{
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        rep(j,1,m) {
            scanf("%d",&mp[i][j]);
        }
    }
    int x = 1 << m;
    int xx;
    REP(i,0,x) {
        xx = i;
        rep(i,1,m) {
            op[i] = xx & 1;
            xx >>= 1;
        }
        go();
    }
    
    if (times == -1) puts("IMPOSSIBLE");
    else {
        rep(i,1,n) {
            rep(j,1,m) {
                if (j != 1) printf(" ");
                printf("%d",ans[i][j]);
            }
            puts("");
        }
    }
    return 0;
}
*/

///????????
/// https://vjudge.net/problem/POJ-1426
/*
int mod;
ull ans;
void dfs(ull n,int dps) {
    if (ans != 0) return;
    if (n % mod == 0) {
        ans = n;
        return;
    }
    if (dps == 19) reutrn;
    dfs(n * 10,dps + 1);
    dfs(n * 10 + 1,dps + 1);
}

int main() {
    while (~scanf("%d",&mod) && mod) {
        ans = 0;
        dfs(1,0);
        printf("%llu\n",ans);
    }
}
*/

/*
int main()
{
    string a,b,str;
    getline(cin,str);
    int ok = 0;
    for (int i = 0;str[i];i ++) {
        if (!ok && str[i] == ' ') {
            ok = 1;
            continue;
        }
        if (!ok) a += str[i];
        else b += str[i];
    }
    int num1 = 0,num2 = 0;
    int has1 = 1,has2 = 1;
    for (int i = 0;a[i];i ++) {
        if (!isdigit(a[i])) {
            has1 = 0;
            break;
        }
        num1 = num1 * 10 + (a[i] ^ 48);
    }
    
    for (int i = 0;b[i];i ++) {
        if (!isdigit(b[i])) {
            has2 = 0;
            break;
        }
        num2 = num2 * 10 + (b[i] ^ 48);
    }
    
    if (num1 < 1 || num1 > 1000) has1 = 0;
    if (num2 < 1 || num2 > 1000) has2 = 0;
    
    if (has1) printf("%d",num1);
    else printf("?");
    printf(" + ");
    if (has2) printf("%d",num2);
    else printf("?");
    printf(" = ");
    if (has1 && has2) printf("%d\n",num1 + num2);
    else printf("?\n");
    return 0;
}
*/

/*
int main()
{
    int aa,bb;
    int n;
    scanf("%d%d%d",&aa,&bb,&n);
    int a,b,c,d;
    int a1,a2;
    int ok = 1;
    while (n --) {
        scii(a,b);
        scii(c,d);
        a1 = 0;
        a2 = 0;
        if (b == a + c) a1 = 1;
        if (d == a + c) a2 = 1;
        if (a1 && a2) continue;
        if (!a1 && !a2) continue;
        if (a1) aa --;
        if (a2) bb --;
        if (aa == 0 || bb == 0) {
            if (ok) {
                if (aa == 0) {
                    puts("A");
                    printf("%d\n",bb);
                } else {
                    puts("B");
                    printf("%d\n",aa);
                }
                ok = 0;
            }
        }
    }
    
    
    return 0;
}
*/

/*
struct Node1 {
    int cur;
    int to;
    int len;
    int time;
    bool operator<(const Node1 &o) const {
        return time > o.time;
    }
};

struct Node2 {
    int cur;
    int to;
    int len;
    int time;
    bool operator<(const Node2 &o) const {
        return len > o.len;
    }
};

vector<Node1> g1[510];
vector<Node2> g2[510];

int dis[510];
int num[510];
int p[510];

void dij1(int s) {
    mem(dis,-1);
    mem(num,-1);
    priority_queue<Node1> q;
    q.push({-1,s,0,dis[s] = 0});
    int cost;
    Node1 top;
    int n,to;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        n = top.to;

        if (dis[n] != -1 && dis[n] < top.time) continue;
        if (dis[n] == top.time) {
            if (num[n] == -1 || top.len < num[n]) {
                num[n] = top.len;
                p[n] = top.cur;
            }
            
        }

        for (auto i : g1[n]) {
            to = i.to;
            cost = dis[n] + i.time;
            if (dis[to] == -1 || dis[to] >= cost) {
                q.push({n,i.to,top.len + i.len,dis[to] = cost});
            }
        }
    }
}

void dij2(int s) {
    mem(dis,-1);
    mem(num,-1);
    priority_queue<Node2> q;
    q.push({-1,s,dis[s] = 0,0});
    int cost;
    Node2 top;
    int n,to;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        n = top.to;

        if (dis[n] != -1 && dis[n] < top.len) continue;
        if (dis[n] == top.len) {
            if (num[n] == -1 || top.time < num[n]) {
                num[n] = top.time;
                p[n] = top.cur;
            }
            
        }

        for (auto i : g1[n]) {
            to = i.to;
            cost = dis[n] + i.len;
            if (dis[to] == -1 || dis[to] >= cost) {
                q.push({n,i.to,dis[to] = cost,top.time + 1});
            }
        }
    }
}

int main()
{
    int n,m;
    scii(n,m);
    int u,v,type,l,t;
    while (m --) {
        scii(u,v);
        sci(type);
        scii(l,t);
        g1[u].push_back({0,v,l,t});
        g2[u].push_back({0,v,l,t});
        if (!type) {
            g1[v].push_back({0,u,l,t});
            g2[v].push_back({0,u,l,t});
        }
    }

    int s;
    scii(s,t);
    dij1(s);
    printf("Time = %d",dis[t]);
    vector<int> a1,a2;

    a1.push_back(t);
    int x = p[t];
    while (x != s) {
        a1.push_back(x);
        x = p[x];
    }
    a1.push_back(s);

    dij2(s);
    a2.push_back(t);
    x = p[t];
    while (x != s) {
        a2.push_back(x);
        x = p[x];
    }
    a2.push_back(s);
    int f = 1;
    if (a1 == a2) {
        printf("; Distance = %d: ",dis[t]);
    } else {
        printf(": ");
        for (vector<int>::reverse_iterator it = a1.rbegin();it != a1.rend();it ++) {
            if (f) f = 0;
            else printf(" => ");
            printf("%d",*it);
        }
        printf("\nDistance = %d: ",dis[t]);
    }
    f = 1;
    for (vector<int>::reverse_iterator it = a2.rbegin();it != a2.rend();it ++) {
        if (f) f = 0;
        else printf(" => ");
        printf("%d",*it);
    }
    return 0;
}
*/

/*
vector<int> g[510];
int vis[510];
int vv[510];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    int k;
    sci(k);
    queue<int> q;
    int top;
    int ok;
    int nn = n;
    int has;
    while (k --) {
        scanf("%d",&u);
        q.push(u);
        while (!q.empty()) {
            top = q.front();
            q.pop();
            if (vis[top] || vv[top]) continue;
            vis[top] = 1;
            for (auto i : g[top]) {
                q.push(i);
            }
        }
        ok = 0;
        has = 0;
        for (auto i : g[u]) {
            if (!vv[i]) {
                has = 1;
                q.push(i);
                break;
            }
        }
        if (has) {
            vis[u] = 2;
            while (!q.empty()) {
                top = q.front();
                q.pop();
                if (vis[top] == 2 || vv[top]) continue;
                vis[top] = 2;
                for (auto i : g[top]) q.push(i);
            }
            rep(i,0,n-1) if (vis[i] == 1) {
                ok = 1;
                break;
            }
        }
        vv[u] = 1;
        if (ok) printf("Red Alert: ");
        printf("City %d is lost",u);
        if (ok) puts("!");
        else puts(".");
        nn --;
        mem(vis,0);
    }
    if (!nn) printf("Game Over.\n");
}
*/

/*
int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int get(int k)
{
    int ans = 0;
    int x = k;
    map<int,int> mp;
    int kk;
    do {
        mp[k] = 1;
        kk = 0;
        while (k) {
            kk += (k % 10) * (k % 10);
            k /= 10;
        }
        k = kk;
        ans ++;
        if (k == 1) {
            break;
        }
    } while (!mp[k]);
    return ans * (isZhi(x) ? 2 : 1);
}

int main()
{
    int a,b;
    scii(a,b);
    map<int,int> mp;
    map<int,int> vis;
    int ok;
    int k,kk;
    rep(i,a,b) {
        mp.clear();
        k = i;
        ok = 0;
        if (vis[k] == -1) continue;
        
        do {
            mp[k] = 1;
            kk = 0;
            while (k) {
                kk += (k % 10) * (k % 10);
                k /= 10;
            }
            k = kk;
            if (k == 1) {
                ok = 1;
                break;
            }
        } while (!mp[k]);
        mp.clear();
        
        k = i;
        do {
            if (ok) vis[k] ++;
            else vis[k] = -1;
            mp[k] = 1;
            kk = 0;
            while (k) {
                kk += (k % 10) * (k % 10);
                k /= 10;
            }
            k = kk;
        } while (!mp[k]);
        
    }
    ok = 0;
    for (auto i : vis) {
        if (i.first < a) continue;
        if (i.first > b) break;
        if (i.second == 1) {
            ok = 1;
            printf("%d %d\n",i.first,get(i.first));
        }
    }
    if (!ok) puts("SAD");
    return 0;
}
*/

/*
int main()
{
    int n,m,k;
    sciii(n,m,k);
    stack<int> st;
    int a[1010];
    int mnt;
    while (k --) {
        rep(i,1,n) sci(a[i]);
        mnt = 0;
        rep(i,1,n) {
            if (a[i] == mnt + 1) {
                mnt ++;
                while (!st.empty() && st.top() == mnt + 1) {st.pop();mnt ++;}
            } else {
                if (st.size() >= m) {
                    break;
                }
                st.push(a[i]);
            }
        }
        if (st.empty()) puts("YES");
        else {
            while (!st.empty()) st.pop();
            puts("NO");
        }
    }
}
*/

/*int startWith(string a,string b) {
    if (a.size() < b.size()) return 0;
    return a.substr(0,b.size()) == b;
}

int endsWith(string a,string b) {
    if (a.size() < b.size()) return 0;
    return a.substr(a.size() - b.size(),b.size()) == b;
}

map<string,int> mp;

int g[100010];
int sex[100010];

map<int,int> s1,s2;
int ok;

int main()
{
    int n;
    sci(n);
    string uu[100010],vv[100010];
    string t;
    rep(i,1,n) {
        cin >> uu[i] >> vv[i];
        mp[uu[i]] = i;
        if (endsWith(vv[i], "sson") || endsWith(vv[i], "m")) {
            sex[i] = 1;
        } else if (endsWith(vv[i], "sdottir") || endsWith(vv[i], "f")) {
            sex[i] = 0;
        }
    }
    string u,v;
    rep(i,1,n) {
        u = uu[i];
        v = vv[i];
        t = "";
        if (endsWith(v, "sson")) t = v.substr(0,v.size()-4);
//        if (endsWith(v, "m")) t = v.substr(0,v.size()-1);
        if (endsWith(v, "sdottir")) t = v.substr(0,v.size()-7);
//        if (endsWith(v, "f")) t = v.substr(0,v.size()-1);
        g[i] = mp[t];
    }
    int q;
    sci(q);
    string name;
    string u1,v1,u2,v2;
    int k,dps;
    while (q --) {
        cin >> u1 >> v1 >> u2 >> v2;
        if (mp[u1] == 0 || mp[u2] == 0) puts("NA");
        else if (sex[mp[u1]] == sex[mp[u2]]) puts("Whatever");
        else {
            ok = 1;
            s1.clear();
            s2.clear();
            
            k = mp[u1];
            dps = 1;
            while (k != 0) {
                s1[k] = dps ++;
                k = g[k];
            }
            
            k = mp[u2];
            dps = 1;
            while (k != 0) {
                s2[k] = dps ++;
                k = g[k];
            }
            
            for (auto i : s1) {
                if (s2[i.first]) {
                    if (i.second < 5 || s2[i.first] < 5) {
                        ok = 0;
                        break;
                    }
                    
                }
            }
            
            
            if (ok) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}*/

/*
int isLetter(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

int isDot(char c) {
    return !isLetter(c) && !isdigit(c);
}

int main()
{
    int n;
    sci(n);
    scanf(" ");
    string str;
    vector<string> tmp,words;
    vector<char> dots;
    string x;
    int f;
    rep(i,1,n) {
        getline(cin,str);
        _C(str);
        printf("AI: ");
        stringstream ss(str);
        tmp.clear();
        words.clear();
        dots.clear();
        while (ss >> x) {
            tmp.pb(x);
        }
        f = 1;
        for (auto i : tmp) {
            if (f) f = 0;
            else if (!isDot(i[0])) dots.pb(' ');
            str = "";
            for (int j = 0;i[j];j ++) {
                if (isDot(i[j])) {
                    words.pb(str);
                    str = "";
                    dots.pb(i[j]);
                } else str += i[j];
            }
            if (str != "") words.pb(str);
        }
        _C(words.size());
        _C(dots.size());
        _C("")
    }
    return 0;
}
*/

/*
ll ans[1000010][12];

int main()
{
    int n,b;
    int ii;
    rep(i,1,1000000) {
        rep(j,2,10) {
            ii = i;
            while (ii) {
                ans[i][j] += (ii % j);
                ii /= j;
            }
            ans[i][j] += ans[i - 1][j];
        }
    }
    int T = 1;
    __T {
        scii(n,b);
        printf("Case #%d: %lld\n",T++,ans[n][b]);
    }
}
*/

/*
int main()
{
    int n,m;
    int l,r;
    map<int,pair<int,int>> num; // 1,-1
    ll ans,t;
    int f;
    int T = 1;
    __T {
        scii(n,m);
        num.clear();
        ans = 0;
        while (m --) {
            scii(l,r);
            num[l].first ++;
            num[r+1].second ++;
        }
        t = 0;
        f = -1;
        for (auto i : num) {
            if (f != -1 && (t & 1)) ans += i.first - f;
            t += i.second.first;
            t -= i.second.second;
            f = i.first;
        }
        printf("Case #%d: %lld\n",T++,ans);
    }
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[1010] = {0};
    rep(i,1,n) sci(a[i]);
    int u,v;
    scanf("%d%d",&u,&v);
    int cur = u;
    set<int> x;
    if (!a[u]) {
        printf("ERROR: T[%d] is NULL\n",u);
        return 0;
    }
    if (!a[v]) {
        printf("ERROR: T[%d] is NULL\n",v);
        return 0;
    }
    while (a[cur]) {
        x.insert(cur);
        cur >>= 1;
    }
    cur = v;
    while (a[cur]) {
        if (x.find(cur) != x.end()) {
            printf("%d %d\n",cur,a[cur]);
            break;
        }
        cur >>= 1;
    }
    re0;
}
*/

/*
struct Node {
    Node(){}
    Node(ll c,Node *l,Node *r):n(c),l(l),r(r){}
    ll n;
    Node *l;
    Node *r;
};

void build(Node* &node)
{
    ll ch;
    scanf("%lld",&ch);
    if (ch == 0) return;
    node = new Node(ch,NULL,NULL);
    build(node -> l);
    build(node -> r);
}

ll tg;

ll a[110];

vector<vector<ll>> ans;

void dfs(Node *node,int num,int dps)
{
    num += node -> n;
    a[dps] = node -> n;
    if (num == tg && node -> l == NULL && node -> r == NULL) {
        vector<ll> k;
        rep(i,1,dps) k.pb(a[i]);
        ans.pb(k);
    }
    if (node -> l != NULL) dfs(node -> l,num,dps + 1);
    if (node -> r != NULL) dfs(node -> r,num,dps + 1);
}

int main()
{
    Node *root;
    build(root);
    scanf("%lld",&tg);
    dfs(root,0,1);
    printf("%lu\n",ans.size());
    for (auto i : ans) {
        for (auto j : i) {
            printf("%lld ",j);
        }
        puts("");
    }
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n & 1) {
            pre(i,n,n/2+2) printf("%d ",i);
            pre(i,n/2,1) printf("%d ",i);
            printf("%d",n/2+1);
        } else {
            pre(i,n,1) {
                if (i != n) printf(" ");
                printf("%d",i);
            }
        }
        puts("");
    }
}
*/

/*
map<int,int> a;
map<int,int> b;

int main()
{
    int n,t;
    int ans;
    __T {
        a.clear();
        sci(n);
        rep(i,1,n) {
            sci(t);
            a[t] ++;
            b[t] = i;
        }
        ans = -1;
        for (auto i : a) {
            if (i.second == 1) {
                ans = b[i.first];
                break;
            }
        }
        printf("%d\n",ans);
    }
    
    return 0;
}
*/

/*
int a[200010];
map<int,int> pos;
map<int,int> ans;

int main()
{
    int n;
    int t,l=0;
    int cnt;
    int m;
    __T {
        sci(n);
        cnt = 0;
        pos.clear();
        ans.clear();
        rep(i,1,n) {
            sci(t);
            if (i != 1) {
                if (l != t) a[++cnt] = t;
            } else a[++cnt] = t;
            l = t;
        }
//        rep(i,1,cnt) printf("%d ",a[i]);
//        puts("");
        rep(i,1,cnt) {
            if (pos[a[i]] != i) ans[a[i]] ++;
            pos[a[i]] = i;
        }
        ans[a[cnt]] --;
        ans[a[1]] --;
//        _C("----");
        m = INT_INF;
        for (auto i : ans) {
            m = min(m,i.second);
//            printf("%d %d\n",i.first,i.second);
        }
        printf("%d\n",m+1);;
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    map<ll,int> a;
    ll nn;
    int ans;
    ll all[100];
    __T {
        scl(n);
        a.clear();
        nn = n;
        for (ll i = 2;i * i <= n;i ++) {
            while (nn % i == 0) {
                a[i] ++;
                nn /= i;
            }
        }
        if (nn != 1) a[nn] ++;
        ans = 1;
        for (auto i : a) {
            ans = max(ans,i.second);
        }
        rep(i,1,ans) all[i] = 1;
        for (auto i : a) {
            for (int j = 1,k = ans;j <= i.second;j ++,k --) {
                all[k] *= i.first;
            }
        }
        printf("%d\n",ans);
        rep(i,1,ans) {
            if (i != 1) printf(" ");
            printf("%lld",all[i]);
        }
        puts("");
    }
    return 0;
}
*/

/*
vector<int> g[200010];
int d[100010];
int vis[100010];
int c[100010];

int s;
int mnt;

void find_cir(int u,int dps,int f)
{
    if (vis[u]) {
        if (!c[u]) {
            s = u;
            mnt = dps - vis[u];
        }
        return;
    }
    vis[u] = dps;
    for (auto i : g[u]) {
        if (f == i) continue;
        find_cir(i,dps + 1,u);
        if (s != -1) {
            if (s == u) s = -1;
            c[u] = 1;
            break;
        }
    }
}

int get(int u,int f) {
    int cnt = 0;
    for (auto i : g[u]) {
        if (f == i) continue;
        get(i,u);
    }
    return cnt + 1;
}

int main()
{
    int n;
    int u,v;
    __T {
        sci(n);
        rep(i,1,n) {
            g[i].clear();
            vis[i] = c[i] = d[i] = 0;
        }
        rep(i,1,n) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        rep(i,1,n) d[i] /= 2;
        s = -1;
        find_cir(1,1,-1);
//        rep(i,1,n) printf("%d ",c[i]);
//        puts("");
//        printf("%d\n",mnt);
        
    }
    return 0;
}
*/

//const int MAXN = 200010;
//
//int ST[MAXN][40];
//int st[MAXN][40];
//int a[MAXN];
//
//int n;
//
//void init() {
//    // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
//    rep(i,1,n) ST[i][0] = a[i];
//
//    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
//        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
//            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]); // 套公式
//        }
//    }
//
//    rep(i,1,n) st[i][0] = a[i];
//
//    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
//        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
//            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); // 套公式
//        }
//    }
//}
//
//inline int qmax(int l, int r)
//{
//    int x = log2(r - l + 1);
//    return max(ST[l][x],ST[r - (1 << x) + 1][x]);
//}
//
//inline int qmin(int l, int r)
//{
//    int x = log2(r - l + 1);
//    return min(st[l][x],st[r - (1 << x) + 1][x]);
//}
//
//int prefix[MAXN];
//int sufix[MAXN];
//
//int main()
//{
//    int l,r;
//    itn aa,bb,cc;
//    __T
//    {
//        sci(n);
//        rep(i,1,n) sci(a[i]);
//        init();
//        prefix[1] = a[1];
//        rep(i,2,n) prefix[i] = max(a[i],prefix[i - 1]);
//        sufix[n] = a[n];
//        pre(i,n-1,1) sufix[i] = max(a[i], sufix[i + 1]);
////        rep(i,1,n) printf("%d ",prefix[i]);
////        puts("");
////        rep(i,1,n) printf("%d ",sufix[i]);
////        puts("");
//        rep(i,1,n) {
//            l = (int) (lower_bound(sufix + 1, sufix + 1 + n, prefix[i], greater<int>()) - sufix);
//            r = (int) (upper_bound(sufix + 1, sufix + 1 + n, prefix[i], greater<int>()) - sufix);
////            _C(l << " " << r)
//            l = max(l,i+1);
//            pre(j,r-1,l) {
//                if (i+1>j-1) break;
////                _C("[1," << i << "] [" << i + 1 << "," << j - 1 << "] [" << j << "," << n << "]")
////                _C(prefix[i] << " " << qmin(i+1, j-1) << " " << sufix[j])
//                if (prefix[i] == sufix[j] && qmin(i+1, j-1) == prefix[i]) {
//                    aa = i;
//                    bb = j - i - 1;
//                    cc = n - j + 1;
//                    goto end;
//                }
//            }
//        }
//        puts("NO");
//        continue;
//        end:
//        puts("YES");
//        printf("%d %d %d\n",aa,bb,cc);
//    }
//
//    return 0;
//}

/*
int main()
{
    int n;
    int k;
    int tg;
    char x;
    __T {
        sci(n);
        x = 'a';
        while (n > 0) {
            k = sqrt(n * 2 + 0.25) - 0.5;
            tg = (1+k)*k/2;
            rep(i,1,k) printf("%c",x);
            n = n - tg;
            x ++;
        }
        puts("");
    }
}
*/

/*
const int MAXN = 50;

struct Node {
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}

    int n;
    Node *l;
    Node *r;
} *root;

int gin[MAXN];
int gpost[MAXN];

void build(int *in,int *post,int len,Node **node)
{
    if (len <= 0) return;
    int mid = post[len-1];
    int x = 0;
    REP(i,0,len) {
        if (in[i] == mid) {
            x = i;
            break;
        }
    }
    *node = new Node(mid,NULL,NULL);
    build(in,post,x,&((*node) -> l));
    build(in + x + 1, post + x, len - x - 1, &((*node) -> r));
}

void dfs(Node *node) {
    printf(" %d",node -> n);
    if (node -> l != NULL) dfs(node -> l);
    if (node -> r != NULL) dfs(node -> r);
}

int main()
{
    int n;
    sci(n);
    REP(i,0,n) sci(gpost[i]);
    REP(i,0,n) sci(gin[i]);
    build(gin, gpost, n, &root);
    printf("Preorder:");
    dfs(root);
    puts("");
}
*/

/*
vector<int> g[100010];
vector<int> c[100010];

int m = 0;

void dfs(int n,int dps)
{
    m = max(m,dps);
    c[dps].pb(n);
    for (auto i : g[n]) {
        dfs(i,dps + 1);
    }
}

int main()
{
    int n;
    sci(n);
    int t;
    rep(i,1,n) {
        sci(t);
        if (t == -1) t = 0;
        g[t].pb(i);
    }
    dfs(0,0);
    printf("%d\n",m);
    sort(c[m].begin(),c[m].end());
    int f = 1;
    for (auto i : c[m]) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
}
*/

/*
struct Node {
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}
    int n;
    Node *l;
    Node *r;
} *root;

int n,m;

void build()
{
    int t;
    read(t);
    root = new Node(t,NULL,NULL);
    Node *node;
    rep(i,2,n) {
        read(t);
        node = root;
        while (1) {
            if (t <= node -> n) {
                if (node -> l == NULL) {
                    node -> l = new Node(t,NULL,NULL);
                    break;
                }
                else node = node -> l;
            } else {
                if (node -> r == NULL) {
                    node -> r = new Node(t,NULL,NULL);
                    break;
                }
                else node = node -> r;
            }
        }
    }
}

int find(int n)
{
    Node *node = root;
    while (node != NULL) {
        if (node -> n == n) return 1;
        if (n < node -> n) node = node -> l;
        else node = node -> r;
    }
    return 0;
}

int main()
{
    read(m);
    read(n);
    build();
    int u,v;
    set<int> f;
    Node *node;
    int hasU,hasV;
    rep(i,1,m) {
        read(u);
        read(v);
        hasU = find(u);
        hasV = find(v);
        if (!hasU && !hasV) printf("ERROR: %d and %d are not found.\n",u,v);
        else if (!hasU) printf("ERROR: %d is not found.\n",u);
        else if (!hasV) printf("ERROR: %d is not found.\n",v);
        else {
            node = root;
            while (node != NULL) {
                if (u == node -> n) {
                    printf("%d is an ancestor of %d.\n",u,v);
                    break;
                } else if (v == node -> n) {
                    printf("%d is an ancestor of %d.\n",v,u);
                    break;
                } else if ((u < node -> n && v > node -> n) || (v < node -> n && u > node -> n)) {
                    printf("LCA of %d and %d is %d.\n",u,v,node -> n);
                    break;
                } else {
                    if (u < node -> n) node = node -> l;
                    if (u > node -> n) node = node -> r;
                }
            }
        }
    }
}
*/

/*
int main()
{
    int ans = 0;
    rep(a,1,9) {
        rep(b,1,9) {
            rep(c,1,9) {
                rep(d,1,9) {
                    rep(e,1,9) {
                        if (a == b || a == c || a == d || a == e ||
                            b == c || b == d || b == e ||
                            c == d || c == e ||
                            d == e) continue;
                        if ((a * 10 + b) * (c * 100 + d * 10 + e) == (a * 100 + d * 10 + b) * (c * 10 + e)) ans ++;
                    }
                }
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
*/

/*
int get(int x) {
    int ans = 0;
    while (x) {
        ans += x /= 5;
    }
    return ans;
}

int main()
{
    int n;
    int l,r;
    int m,k;
    int f;
    int x = 0;
    __T {
        sci(n);
        l = 1;
        f = 0;
        r = 1000000000;
        
        while (l <= r) {
            m = (l + r) / 2;
            k = get(m);
            if (k < n) l = m + 1;
            else if (k > n) r = m - 1;
            else {
                r = m - 1;
                x = m;
                f = 1;
            }
        }
        if (f) printf("%d\n",x);
        else puts("QAQ");
    }
    
}
*/

/*
int dp[3010][5010];
int main()
{
    int n;
    int a[3010];
    int sum;
    int ans;
    __T {
        sci(n);
        sum = 0;
        rep(i,1,n) {
            sci(a[i]);
            sum += a[i];
        }
        ans = 0;
        rep(i,1,n) {
            for (int j = 0;j <= sum;j ++) {
                if (j >= a[i]) dp[i][j] = max(dp[i-1][j],min(dp[i - 1][j - a[i]] + a[i],sum - dp[i - 1][j - a[i]] - a[i]));
                else dp[i][j] = dp[i-1][j];
                ans = max(dp[i][j],ans);
            }
        }
        printf("%d\n",ans);
        
    }
}
*/

/*
struct Node {
    Node *nxt[10];
    Node() {
        rep(i,0,9) nxt[i] = NULL;
    }
};

Node *root;

void add(ll num) {
    vector<int> k;
    Node *node = root;
    while (num) {
        k.pb(num % 10);
        num /= 10;
    }
    while (k.size() < 10) k.pb(0);
    for (vector<int>::reverse_iterator i = k.rbegin();i != k.rend();i ++) {
        if (node -> nxt[*i] == NULL) {
            node -> nxt[*i] = new Node();
        }
        node = node -> nxt[*i];
    }
}

void dfs(Node *node,int num)
{
    printf("%d ",num);
    rep(i,0,9) {
        if (node -> nxt[i] != NULL) dfs(node -> nxt[i],i);
    }
}

int main()
{
    int n,r;
    scii(n,r);
    root = new Node();
    ll t;
    rep(i,1,n) {
        scl(t);
        add(t);
    }
    
    int q;
    sci(q);
    vector<int> k;
    Node *node;
    int mx,mj;
    Node *pm = NULL;
    ll num;
    ll ans;
    while (q --) {
        k.clear();
        scl(t);
        node = root;
        ans = 0;
        while (t) {
            k.pb(t % 10);
            t /= 10;
        }
        while (k.size() < 10) k.pb(0);
        num = 0;
        for (vector<int>::reverse_iterator i = k.rbegin();i != k.rend();i ++) {
            mx = -1;
            mj = -1;
            rep(j,0,9) {
                if (node -> nxt[j] != NULL) {
                    if (((j + *i) % r) > mx) {
                        mx = (j + *i) % r;
                        pm = node -> nxt[j];
                        mj = j;
                    }
                }
            }
            num *= 10;
            num += mj;
            node = pm;
            ans *= 10;
            ans += mx;
        }
        _C(ans)
    }
}
*/

/*
const int MAXN = 2e5 + 10;

struct Node {
    int l,r;
    ll sum;
    ll lazy;
} tree[MAXN << 2];
void push_up(int i)
{
    tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy) {
        tree[i << 1].sum = tree[i << 1].r - tree[i << 1].l + 1 - tree[i << 1].sum;
        tree[i << 1 | 1].sum = tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1 - tree[i << 1 | 1].sum;

        tree[i << 1].lazy = !tree[i << 1].lazy;
        tree[i << 1 | 1].lazy = !tree[i << 1 | 1].lazy;

        tree[i].lazy = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    if (l == r) {
        tree[i].sum = 0;
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void add(int l,int r,int i) // 将区间[l,r]整个加上x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum = tree[i].r - tree[i].l + 1 - tree[i].sum;
        tree[i].lazy = !tree[i].lazy;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) add(l,r,i << 1);
    if (r > m) add(l,r,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].sum;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll sum = 0;
    if (l <= m) {
         sum += query(l,r,i << 1);
    }
    if (r > m) {
        sum += query(l,r,i << 1 | 1);
    }
    return sum;
}

vector<int> g[MAXN];

int dfn = 0;
int in[MAXN],out[MAXN];

void dfs(int k,int f)
{
    in[k] = ++ dfn;
    for (vector<int>::iterator i = g[k].begin();i != g[k].end();i ++)
    {
        if (*i != f) {
            dfs(*i,k);
        }
    }
    out[k] = dfn;
}

int main() {
    int n,q;
    scii(n,q);
    int u,v;
    rep(i,1,n-1) {
        scii(u,v);
        g[u].pb(v);
    }
    dfs(1,-1);
    build(1, n, 1);
    while (q --) {
        scii(u,v);
        if (u == 1) {
            add(in[v], out[v], 1);
        } else {
            printf("%lld\n",query(in[v], out[v], 1));
        }
    }
}
*/

/*
int main()
{
    const int mod = 1e9 + 7;
    ll n,m,na,ma,nb,mb,a,b;
    __T {
        scll(n,m);
        na = n + 1;
        nb = n;
        ma = m + 1;
        mb = m;
        if (na % 2 == 0) na /= 2;
        if (nb % 2 == 0) nb /= 2;
        if (ma % 2 == 0) ma /= 2;
        if (mb % 2 == 0) mb /= 2;
        na %= mod;
        nb %= mod;
        ma %= mod;
        mb %= mod;
        a = na * nb % mod;
        b = ma * mb % mod;
        printf("%lld\n",a * b % mod);
    }
}*/

/*
struct Node {
    int n;
    Node *l;
    Node *r;
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}
} *root;

Node* RR(Node *node)
{
    Node *l = node -> l;
    node -> l = l -> r;
    l -> r = node;
    return l;
}

Node* LL(Node *node)
{
    Node *r = node -> r;
    node -> r = r -> l;
    r -> l = node;
    return r;
}

Node* LR(Node *node)
{
    node -> l = LL(node -> l);
    return RR(node);
}

Node* RL(Node *node)
{
    node -> r = RR(node -> r);
    return LL(node);
}

int getHeight(Node *n) {
    if (n == NULL) return 0;
    int x = 0;
    x = max(x,getHeight(n -> l));
    x = max(x,getHeight(n -> r));
    return x + 1;
}

int getF(Node *node)
{
    return getHeight(node -> l) - getHeight(node -> r);
}

Node* insert(Node *node,int n)
{
    if (node == NULL) {
        node = new Node(n,NULL,NULL);
    } else if (n < node -> n) {
        node -> l = insert(node -> l, n);
        if (getF(node) == 2) {
            if (n < node -> l -> n) node = RR(node);
            else node = LR(node);
        }
    } else if (n > node -> n) {
        node -> r = insert(node -> r, n);
        if (getF(node) == -2) {
            if (n > node -> r -> n) node = LL(node);
            else node = RL(node);
        }
    }
    return node;
}

void dfs(Node *node)
{
    if (node == NULL) return;
    printf("%d ",node -> n);
    dfs(node -> l);
    dfs(node -> r);
}

int main()
{
    int n;
    sci(n);
    int t;
    rep(i,1,n) {
        sci(t);
        root = insert(root,t);
    }
    printf("%d\n",root -> n);
}
*/

/*
int a[100010]; // 从1开始
int n = 0;

void up(int i)
{
    int p = i / 2;
    while (p != 0 && a[i] > a[p])
    {
        swap(a[i], a[p]);
        i = p;
        p /= 2;
    }
}

void down(int i)
{
    int k = i * 2;
    if (k + 1 <= n && a[k + 1] > a[k]) k ++;
    while (k <= n && a[i] < a[k])
    {
        swap(a[i], a[k]);
        i = k;
        k *= 2;
        if (k + 1 <= n && a[k + 1] > a[k]) k ++;
    }
}

void push(int num)
{
    a[++ n] = num;
    up(n);
}

void pop()
{
    if (n > 0)
    {
        swap(a[1], a[n --]);
        down(1);
    }
}

void heapify()
{
    for (int i = n / 2;i >= 1;i --)
    {
        down(i);
    }
}

int main() {
    int m;
    scanf("%d%d",&n,&m);
    rep(i,1,n) sci(a[i]);
    heapify();
    int t,x;
    while (m --) {
        sci(t);
        if (t == 0) {
            pop();
        } else if (t == 1) {
            sci(x);
            push(x);
        } else if (t == 2) {
            sci(x);
            printf("%d\n",a[x]);
        }
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

int main()
{
    int n,m;
    int a[MAXN];
    scii(n,m);
    rep(i,1,m) {
        sci(a[i]);
    }
    int k;
    sci(k);
    int u,v;
    init(n + 5);
    rep(i,1,k) {
        scii(u,v);
        bind(u,v);
    }
    int ok = 0;
    int x = find(1);
    rep(i,1,m) {
        if (x == find(a[i])) {
            ok = 1;
            break;
        }
    }
    puts(ok ? "YES" : "NO");
    return 0;
}
*/

/*
int a[100010]; // 从1开始
int n = 0;

void up(int i)
{
    int p = i / 2;
    while (p != 0 && a[i] < a[p])
    {
        swap(a[i], a[p]);
        i = p;
        p /= 2;
    }
}

void down(int i)
{
    int k = i * 2;
    if (k + 1 <= n && a[k + 1] < a[k]) k ++;
    while (k <= n && a[i] > a[k])
    {
        swap(a[i], a[k]);
        i = k;
        k *= 2;
        if (k + 1 <= n && a[k + 1] < a[k]) k ++;
    }
}

void push(int num)
{
    a[++ n] = num;
    up(n);
}

void pop()
{
    if (n > 0)
    {
        swap(a[1], a[n --]);
        down(1);
    }
}

void heapify()
{
    for (int i = n / 2;i >= 1;i --)
    {
        down(i);
    }
}

int main() {
    int n,m;
    scii(n,m);
    int t;
    rep(i,1,n) {
        sci(t);
        push(t);
    }
    int f;
    rep(i,1,m) {
        sci(t);
        f = 1;
        while (t > 0) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",a[t]);
            t >>= 1;
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    ll t;
    priority_queue<ll,vector<ll>,greater<ll>> q;
    rep(i,1,n) {
        scl(t);
        q.push(t);
    }
    ll sum;
    ll ans = 0;
    while (q.size() >= 2) {
        sum = q.top();
        q.pop();
        sum += q.top();
        q.pop();
        q.push(sum);
        ans += sum;
    }
//    ans += q.top();
    printf("%lld\n",ans);
}
*/

//int a[1000010];
//
//int main()
//{
//    int m,n;
//    while (~scii(m,n)) {
//        rep(i,1,n) sci(a[i]);
//
//    }
//
//    return 0;
//}

/*
struct Node {
    int type; // 0 - num,1 - op
    char c;
    ll num;
};

int priority[130];

void getPost(string &str,vector<Node> &post) {
    post.clear();
    stack<char> op_stk;
    ll num = 0;
    int has_num = 0;
    
    for (int i = 0;str[i];i ++) {
        if (str[i] >= '0' && str[i] <= '9') {
            num = num * 10 + (str[i] ^ 48);
            has_num = 1;
        } else {
            if (has_num) post.push_back({0,0,num});
            has_num = num = 0;
            if (str[i] != ')') {
                if (str[i] != '(') while (!op_stk.empty() && priority[op_stk.top()] >= priority[str[i]]) {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.push(str[i]);
            } else {
                while (op_stk.top() != '(') {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.pop();
            }
        }
    }
    if (has_num) post.push_back({0,0,num});
    while (!op_stk.empty()) {
        post.push_back({1,op_stk.top(),0});
        op_stk.pop();
    }
}

ll getAns(vector<Node> &post) {
    ll ans = 0;
    stack<ll> num_stk;
    
    for (auto i : post) {
        if (!i.type) num_stk.push(i.num);
        else {
            switch (i.c) {
                case '+':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans += num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '-':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() - ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '*':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans *= num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                default:
                    break;
            }
        }
    }
    return num_stk.top();
}

vector<Node> post;
set<ll> ans;
ll t;
void dfs(int i,string str)
{
    if (i == str.size()) {
        if (str.size() == 4) return;
        post.clear();
        getPost(str,post);
        t = getAns(post);
        if (t >= 0) ans.insert(t);
        return;
    }
    dfs(i + 1,str);
    dfs(i + 2,str.substr(0,i) + '+' + str.substr(i));
    dfs(i + 2,str.substr(0,i) + '-' + str.substr(i));
    dfs(i + 2,str.substr(0,i) + '*' + str.substr(i));
}

inline void getStr(string &str,int a)
{
    str += (char)(a + '0');
}

int main()
{
    int a[4];
    scii(a[0],a[1]);
    scii(a[2],a[3]);
    // 4
    int p[] = {0,1,2,3};
    
    priority['('] = 1;
    priority['*'] = 3;
    priority['+'] = priority['-'] = 2;
    string str;
    do {
        str = "";
        getStr(str,a[p[0]]);
        getStr(str,a[p[1]]);
        getStr(str,a[p[2]]);
        getStr(str,a[p[3]]);
        dfs(1,str);
    } while (next_permutation(p, p + 4));
    printf("%lu\n",ans.size());
}
*/

/*
int main()
{
    int n,m;
    int t;
    __T {
        scii(n,m);
        rep(i,1,n) {
            sci(t);
        }
        rep(i,1,m) {
            sci(t);
        }
        if (n == 1 && m == 1) puts("1");
        else if (n == 1 && m == 2) puts("1");
        else if (n == 2 && m == 1) puts("1");
        else puts("7");
    }
    return 0;
}
*/

/*
const int MAXN = 1e4 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

struct Edge {
    int u,v;
    ll w;
};

bool cmp(const Edge &a,const Edge &b) {
    return a.w > b.w;
}

bool cmp1(const Edge &a,const Edge &b) {
    return a.w < b.w;
}

Edge ed[500010];

struct Eg {
    int to;
    ll w;
    int nxt;
} e[500010 * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init_g(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

ll ans = 0;

void dfs(int u,int f,ll m)
{
    ll k;
    if (m != -1) ans += m;
    for (int i = g[u];~i;i = e[i].nxt) {
        if (e[i].to == f) continue;
        k = m;
        if (m == -1 || e[i].w < m) k = e[i].w;
        dfs(e[i].to,u,k);
    }
}

int main()
{
    int n,m;
    scii(n,m);
    int u,v;
    ll w;
    init(n + 5);
    
    rep(i,1,m) {
        scii(u,v);
        scl(w);
        ed[i] = {u,v,w};
    }
    sort(ed + 1,ed + 1 + m,cmp);
    ll k = 0;
    for (auto i : ed) {
        u = find(i.u);
        v = find(i.v);
        if (u != v) {
            bind(u,v);
            k = i.w;
        }
    }
    sort(ed + 1,ed + 1 + m,cmp1);
    init(n + 5);
    init_g(n + 5);
    rep(i,1,m) {
        if (ed[i].w == k) k = -1;
        if (k != -1) continue;
        u = find(ed[i].u);
        v = find(ed[i].v);
        if (u != v) {
            bind(ed[i].u,ed[i].v);
            add_edge(ed[i].u, ed[i].v, ed[i].w);
            add_edge(ed[i].v, ed[i].u, ed[i].w);
        }
    }
    rep(i,1,n) dfs(i,-1,-1);
    printf("%lld\n",ans / 2);
    return 0;
}
*/

/*
int a[10010][10010];

int main()
{
    int n,k,x,y;
    __T {
        scii(n,k);
        if (n == 1) {
            printf("%d\n",0);
            continue;
        }
        a[0][0] = k - 1;
        REP(i,0,n - 1) {
            rep(j,0,i) {
                a[i + 1][j] = 0;
                a[i + 1][j + 1] = 0;
            }
            rep(j,0,i) {
                a[i + 1][j] += a[i][j] / 2;
                a[i + 1][j + 1] += a[i][j] / 2;
                if (a[i][j] & 1) a[i + 1][j] ++;
            }
        }
        x = y = 0;
        do {
            if (a[x][y] & 1) y ++;
            x ++;
        } while (x < n - 1);
        printf("%d\n",y);
    }
}
*/

/*
int main()
{
    double n;
    double ans;
    int i,j;
    __T {
        scd(n);
        ans = 0;
        i = 1;
        j = 1;
        while (1.0 / i >= n) {
            ans += pow(-1,j + 1) * 1 / i;
            i += 2;
            j ++;
        }
        printf("%.6f\n",ans);
    }
    
    return 0;
}
*/

/*
int main()
{
    string str;
    int num,ans;
    char type;
    __T {
        cin >> str;
        num = 0;
        ans = 0;
        type = '+';
        for (int i = 0;str[i];i ++) {
            if (isdigit(str[i])) {
                num *= 10;
                num += str[i] ^ 48;
            } else {
                switch (type) {
                    case '+':
                        ans += num;
                        break;
                    case '-':
                        ans -= num;
                        break;
                    case '*':
                        ans *= num;
                        break;
                    case '/':
                        ans /= num;
                        break;
                }
                num = 0;
                type = str[i];
            }
        }
        printf("%d\n",ans);
    }
}
*/

/*
int check(int n)
{
    int k = 0;
    int nn = n;
    while (n) {
        k += (n % 10) * (n % 10) * (n % 10);
        n /= 10;
    }
    return k == nn;
}

int main()
{
    int u,v;
    __T {
        scii(u,v);
        rep(i,u,v) {
            if (check(i)) printf("%d\n",i);
        }
    }
    return 0;
}
*/

/*int main()
{
    int n,m;
    string str;
    int k;
    __T {
        scii(n,m);
        cin >> str;
        k = 0;
        rep(i,1,n) {
            rep(j,1,m) {
                printf("%c",str[k ++]);
            }
            puts("");
        }
        
    }
}
*/

/*
int a[35][35];
int b[35][35];

int main()
{
    int n,mx;
    int cnt;
    while (~scanf("%d",&n)) {
        if (n == 0) break;
        rep(i,1,n) {
            rep(j,1,n) sci(a[i][j]);
        }
        cnt = mx = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                sci(b[i][j]);
                if (a[i][j] == b[i][j]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[j][n-i+1]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[n-i+1][n-j+1]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[n-j+1][i]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        printf("%d\n",mx);
    }
    return 0;
}
*/

/*
struct Node {
    Node(const string &name,int type):name(name),type(type){}
    Node(){}
    string name;
    map<string,Node*> pNxt;
    int type;
};

Node *root;

void insert(string &str,vector<string> &pv,int t)
{
    string x;
    pv.clear();
    x = "";
    for (int i = 0;str[i];i ++) {
        if (str[i] == '/') {
            pv.pb(x);
            x = "";
        } else x += str[i];
    }
    pv.pb(x);
    Node *node = root;
    Node *p;
    int tt;
    for (auto i = pv.begin();i != pv.end();i ++) {
        p = node -> pNxt[*i];
        if (p != NULL) {
            node = p;
        } else {
            if (i == pv.end() - 1) tt = t;
            else tt = 0;
            p = new Node(*i,tt);
            node -> pNxt[*i] = p;
            node = p;
        }
    }
}

int dfs(Node *node)
{
    if (node == NULL) return 0;
    int size = (int) node -> pNxt.size();
    int sum = 0;
    for (auto i : node -> pNxt) {
        sum += dfs(i.second);
    }
//    _C(node -> name << "=" << node -> type << " " << sum << "/" << size);
    if (node -> type == 0 && sum == size && node -> pNxt.size() != 0 && node -> name != "/") {
        node -> type = 1;
    }
    return node -> type;
}

int ans;

void pre_dfs(Node *node)
{
    if (node == NULL) return;
//    _C(node -> name << " " << node -> type)
    if (node -> type) {
        ans ++;
        return;
    }
    for (auto i : node -> pNxt) {
        pre_dfs(i.second);
    }
}

int main()
{
    int n,m;
    string str;
    vector<string> p;
    string x;
    __T {
        scii(n,m);
        root = new Node("/",0);
        rep(i,1,n) {
            cin >> str;
            insert(str,p,1);
        }
        rep(i,1,m) {
            cin >> str;
            insert(str,p,0);
        }
        dfs(root);
//        _C("=========")
        ans = 0;
        pre_dfs(root);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll k = n / 3;
    printf("%lld\n",(k - 1) * k + k * (n % 3) + (1 + k * 3) * k / 2);
}
*/

/*
char a[1010][1010];
char b[1010][1010];

int main()
{
    int n,m;
    scii(n,m);
    REP(i,0,n) {
        scanf("%s",a[i]);
    }
    REP(i,0,n) {
        scanf("%s",b[i]);
    }
    int sum = 0;
    REP(i,0,n) {
        REP(j,0,m) {
            if (a[i][j] != b[i][j]) sum ++;
        }
    }
    if (sum <= m * n / 2) REP(i,0,n) puts(a[i]);
    else REP(i,0,n) {
        REP(j,0,m) {
            if (a[i][j] == '.') printf("X");
            else printf(".");
        }
        puts("");
    }

    return 0;
}
*/


/*
ll sum[20];

ll nn[20] = {6,2,5,5,4,5,6,3,7,6,6,5,4,5,5,4};

void init()
{
    sum[0] = 6;
    sum[1] = 8;
    sum[2] = 13;
    sum[3] = 18;
    sum[4] = 22;
    sum[5] = 27;
    sum[6] = 33;
    sum[7] = 36;
    sum[8] = 43;
    sum[9] = 49;
    sum[10] = 55;
    sum[11] = 60;
    sum[12] = 64;
    sum[13] = 69;
    sum[14] = 74;
    sum[15] = 78;
}

void to(char num[])
{
    rep(i,0,7) {
        if (num[i] >= '0' && num[i] <= '9') num[i] ^= 48;
        else num[i] = num[i] - 'A' + 10;
    }
}

uint conv(char num[],int l)
{
    uint ans = 0;
    for (int i = 0;i < l;i ++) {
        ans += (1ULL << (i * 4ULL)) * num[i];
    }
    return ans;
}

ull get(ull num)
{
    ull ans = 0;
    ull f = num / 16,t = 0;
    ull x = 1;
    int k;
    rep(i,0,7) {
        k = num % 16;
        
        // group
        ans += f * sum[15] * (1ULL << (4 * i));
        
        // middle
        if (k) ans += sum[k - 1] * (1ULL << (4 * i));
        
        
        // tail
        ans += (t + 1) * nn[k];
        
        t += (num % 16) * x;
        x <<= 4;
        f /= 16;
        num /= 16;
    }
    return ans;
}

ull single_conv(ull a)
{
    ull ans = 0;
    rep(i,0,7) {
        ans += nn[a % 16];
        a /= 16;
    }
    return ans;
}

void add(uint a,uint b)
{
    ull x = (ull) a + (ull)(b - 1);
    uint k = 0;
    uint t = a + (b - 1);
    if (x > k - 1) {
        printf("%llu\n",single_conv(a) + get(k - 1) - get(a) + get(t));
    } else {
        printf("%llu\n",single_conv(a) + get(x) - get(a));
    }
}

int main()
{
    init();

    int s;
    char num[10];
    char str[10];
    uint x;
    __T {
        scanf("%d",&s);
        scanf("%s",str);
        rep(i,0,7) num[7 - i] = str[i];
        to(num);
        x = conv(num,8);
        add(x,s);
    }
    return 0;
}
*/

/*
int main()
{
    ll x[100];
    x[1] = 1;
    rep(i,2,63) {
        x[i] = x[i - 1] * 2 + 1;
//        printf("%lld\n",x[i]);
    }
    ll y[100];
    rep(i,1,31) {
        y[i] = (1 + x[i]) * x[i]/ 2;
//        printf("%lld\n",y[i]);
    }
    
    
    ll n;
    int i;
    ll k = 0;
    __T {
        scl(n);
        k = 0;
        for (i = 1;i <= 31;i ++) {
            k += y[i];
            if (k <= 0 || k > n) {
                printf("%d\n",i - 1);
                break;
            }
        }
    }
    re0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    int a[100010];
    rep(i,1,n) sci(a[i]);
    sort(a + 1,a + 1 + n);
    int ans = 0;
    
    vector<int> aa;
    aa.pb(a[(n + 1) / 2]);
    if (!(n % 2)) aa.pb(a[(n + 1) / 2 + 1]);
    for (int i = (n + 1) / 2 + 1 + !(n % 2),j = 1;i <= n;i ++,j ++) {
        if (a[j] < a[i] && a[j] < a[i - 1]) ans ++;
        aa.pb(a[j]);
        aa.pb(a[i]);
    }
    printf("%d\n",ans);
    int f = 1;
    for (auto i : aa) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    re0;
}
*/

/*
int main()
{
    int n,m;
    int a[1010];
    int ok;
    int ok2;
    ll sum;
    __T {
        scii(n,m);
        ok = 1;
        ok2 = 0;
        sum = 0;
        rep(i,1,n) {
            sci(a[i]);
            sum += a[i];
            if (a[i] == m) ok2 = 1;
            if (i != 1) {
                if (a[i] != a[i - 1]) ok = 0;
            }
        }
        if (ok && a[1] == m) puts("0");
        else {
            if (m * (ll) n == sum || ok2) puts("1");
            else puts("2");
        }
        
    }
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int main()
{
    int n;
    priority_queue<ll,vector<ll>,greater<ll>> que;
    set<ll> vis;
    ll last;
    list<ll> ans;
    list<ll>::iterator j;
    ll g;
    int ok;
    __T {
        sci(n);
        vis.clear();
        ans.clear();
        while (!que.empty()) que.pop();
        for (int i = 2;i * i <= n;i ++) {
            if (n % i == 0) {
                if (isZhi(i)) ans.pb(i);
                else que.push(i);
                if (i != n / i) {
                    if (isZhi(n / i)) ans.pb(n / i);
                    else que.push(n / i);
                }
            }
        }
        
        if (ans.size() == 1) {
            printf("%lld",*ans.begin());
            while (!que.empty()) {
                printf(" %lld",que.top());
                que.pop();
            }
            printf(" %d\n0\n",n);
        } else if (ans.size() == 2 && (*ans.begin()) * (*(++ ans.begin())) == n) {
            printf("%lld %lld %d\n1\n",*ans.begin(),*(++ ans.begin()),n);
        } else {
            for (auto i = ++ ans.begin();i != ans.end();i ++) {
                j = i;
                j --;
                ans.insert(i, g = (*i) * (*j) * gcd(*i,*j));
                vis.insert(g);
            }
            while (!que.empty()) {
                last = que.top();
                que.pop();
                
                if (vis.find(last) != vis.end()) continue;
                
                ok = 0;
                for (auto i = ++ ans.begin();i != ans.end();i ++) {
                    j = i;
                    j --;
                    if (gcd(last,*j) != 1 && gcd(last,*i) != 1) {
                        ans.insert(i, last);
                        ok = 1;
                        break;
                    }
                }
                if (!ok) ans.pb(last);
            }
            ans.pb(n);
            ok = 1;
            for (auto i : ans) {
                if (ok) ok = 0;
                else printf(" ");
                printf("%lld",i);
            }
            printf("\n0\n");
        }
    }
    re0;
}
*/

/*
int n;

const int MAXN = 1e5 + 10;

int a[MAXN];
ll c[MAXN];

void modify(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int mx[MAXN];

void modify_m(int i,int x)
{
    int low;
    a[i] = x; // 会直接修改数组的值
    for (;i <= n;i += lowbit(i)) {
        mx[i] = a[i];
        low = lowbit(i);
        for (int j = 1;j < low;j <<= 1) {
            mx[i] = max(mx[i], mx[i - j]);
        }
    }
}

int query_max(int l,int r)
{
    int ans = max(a[l],a[r]);
    while(true)
    {
        ans = max(ans, a[r]);
        if (l == r) break;
        r --;
        for (;r - l > lowbit(r);r -= lowbit(r))
        {
            ans = max(ans,mx[r]);
        }
    }
    return ans;
}

int main()
{
    int m;
    scii(n,m);
    rep(i,1,n) {
        sci(a[i]);
        modify_m(i, a[i]); // 修改最大值
        modify(i, a[i]);
    }
    int t,x,y;
    while (m --) {
        sciii(t,x,y);
        if (t == 1) {
            modify(x, y - a[x]);
            modify_m(x, y);
        } else if (t == 2) {
            printf("%lld\n",sum(y) - sum(x - 1));
        } else printf("%d\n",query_max(x, y));
    }
    re0;
}
*/


/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n >= 7) {
            if (n % 2) {
                printf("%d %d\n",3,n - 3);
            } else {
                printf("%d %d\n",2,n - 2);
            }
        } else {
            switch (n) {
                case 1:
                    puts("-1");
                    break;
                case 2:
                    puts("-1");
                    break;
                case 3:
                    puts("-1");
                    break;
                case 4:
                    puts("-1");
                    break;
                case 5:
                    puts("-1");
                    break;
                case 6:
                    puts("2 4");
                    break;
                default:
                    break;
            }
        }
        
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    int w[100010];
    double sum = 0;
    __T {
        sum = 0;
        scii(n,k);
        rep(i,1,n) {
            sci(w[i]);
            sum += w[i];
        }
        rep(i,1,n) {
            if (i != 1) printf(" ");
            printf("%.8f",w[i] * (sum + k) / sum);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int a[10]['z'];
    int k[] = {1,2,3,4,5,6};
    int ok = 0;
    __T {
        k[0] = 1;
        k[1] = 2;
        k[2] = 3;
        k[3] = 4;
        k[4] = 5;
        k[5] = 6;
        mem(a,0);
        rep(ii,1,6) {
            cin >> str;
            for (int i = 0;str[i];i ++) {
                a[ii][str[i]] ++;
            }
        }
        ok = 0;
        do {
            if (a[k[0]]['h'] && a[k[1]]['a'] && a[k[2]]['r'] && a[k[3]]['b'] && a[k[4]]['i'] && a[k[5]]['n']) {
                ok = 1;
                break;
            }
        } while (next_permutation(k, k + 6));
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    vector<int> a(n);
    rep(i,0,n-1) a[i] = i + 1;
    vector<int> b(n);
    int m,M;
    map<vector<int>,vector<vector<int>>> all;
    do {
        m = a[0];
        M = a[0];
        rep(i,0,n-1) {
            m = min(m,a[i]);
            M = max(M,a[i]);
            b[i] = M - m;
        }
        all[b].pb(a);
    } while (next_permutation(a.begin(), a.end()));
    
    for (auto i : all) {
        for (auto j : i.first) printf(" %d",j);
        puts(":");
        for (auto j : i.second) {
            for (auto k : j) printf(" %d",k);
            puts("");
        }
        printf("cnt = %lu\n",i.second.size());
        puts("");
    }
    
    return 0;
}
*/



/*
const int mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll AA[100010];

ll A(int a,int b)
{
    return (AA[a] * quickpow(AA[a - b], mod - 2)) % mod;
}

int main()
{
    int n;
    int a[100010];
    int vis[100010];
    int cnt = 0;
    int ok,has;
    
    AA[0] = 1;
    AA[1] = 1;
    rep(i,2,100005) {
        AA[i] = i * AA[i - 1];
        AA[i] %= mod;
    }
    
    int last;
    int length;
    int cc;
    ll ans;
    
    __T {
        cc = cnt = 0;
        ans = 1;
        sci(n);
        vis[0] = 0;
        rep(i,1,n) {
            sci(a[i]);
            vis[i] = 0;
        }

        ok = 1;
        has = 0;
        rep(i,2,n) {
            if (a[i] >= n) {
                ok = 0;
                break;
            }
            if (a[i] == n - 1) has = 1;
            if (a[i] < a[i - 1]) {
                ok = 0;
                break;
            }
            if (has && a[i] < n - 1) {
                ok = 0;
                break;
            }
        }
        if (a[1] != 0) ok = 0;
        
        
        if (ok) {
            length = 0;
            last = 0;
            
            rep(i,2,n) {
                if (a[i] > last) {
                    if (cc < length) {
                        puts("0");
                        goto nxt;
                    }
                    
                    ans *= A(cc,length);
                    ans %= mod;
                    
                    cc -= length;
                    cc += a[i] - last - 1;
                    
                    length = 0;
                    cnt ++;
                    
                } else length ++;
                last = a[i];
            }
            
            if (cc < length) {
                puts("0");
                goto nxt;
            }
            
            ans *= A(cc,length);
            ans %= mod;
            
            ans *= quickpow(2, cnt);
            ans %= mod;
            printf("%lld\n",ans);
        } else puts("0");
    nxt:;
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    int a[50010];
    int ok = 1;
    __T {
        scl(n);
        rep(i,1,n) {
            sci(a[i]);
            
        }
        ok = 1;
       
        rep(i,2,n) {
            if (a[i] >= a[i - 1]) {
                ok = 0;
                break;
            }
        }
        
        puts(ok ? "NO" : "YES");
        
    }
    return 0;
}
*/


/*
int main()
{
    int n;
    ll x[50][5];
    ll k[50];
    ll t;
    ll cnt = 0;

    __T {
        sci(n);
        mem(x,0);
        cnt = 0;
        rep(i,1,n) {
            scl(t);
            REP(i,0,32) {
                k[i] = t & 1;
                t >>= 1;
            }
            pre(i,31,0) {
                if (k[i]) {
                    cnt += x[i][1];
                    x[i][1] ++;
                    break;
                }
            }
        }
        printf("%lld\n",cnt);
    }
    return 0;
}
*/

/*
int main()
{
    int n,q;
    ll a[300010];
    ll dp[2];
    __T {
        scii(n,q);
        dp[0] = dp[1] = 0;
        rep(i,1,n) scl(a[i]);
        dp[1] = a[1];
        rep(i,2,n) {
            dp[0] = max(dp[0],dp[1] - a[i]);
            dp[1] = max(dp[1],dp[0] + a[i]);
        }
        printf("%lld\n",max(dp[0],dp[1]));
    }
    return 0;
}
*/

/*
int main()
{
    freopen("data.txt","w",stdout);
    int a[500];
    rep(i,1,480) a[i] = i;
    srand((uint)time(NULL));
    rep(i,1,480) swap(a[rand() % 480 + 1],a[rand() % 480 + 1]);
    rep(i,1,160) printf("%d ",a[i]);
    puts("\r\n");
    rep(i,161,320) printf("%d ",a[i]);
    puts("\r\n");
    rep(i,321,480) printf("%d ",a[i]);
    puts("\r\n");
    return 0;
}
*/

//
//int main()
//{
//    int n,m;
//    scii(n,m);
//    int a[20010];
//    rep(i,1,n) sci(a[i]);
//    int u,v,x;
//    while (m --) {
//        sciii(u,v,x);
//
//    }
//    re0;
//}

/*
int main()
{
    int n;
    char x;
    sci(n);
    scanf(" %c",&x);
    int nn = n - 1;
    nn /= 2;
    int v = sqrt(4 * nn + 4) - 1;
    if (v % 2 == 0) v --;
    rep(i,1,(v - 1) / 2 + 1) {
        REP(ii,1,i) printf(" ");
        rep(ii,1,v - (i - 1) * 2) printf("%c",x);
        puts("");
    }
    
    pre(i,(v - 1) / 2,1) {
        REP(ii,1,i) printf(" ");
        rep(ii,1,v - (i - 1) * 2) printf("%c",x);
        puts("");
    }
    printf("%d\n",n - (v + 3) * (v - 1) / 2 - 1);
    return 0;
}
*/

/*
int main()
{
    char p[100010];
    mem(p,1);
    p[1] = 0;
    p[2] = 1;
    int n;
    sci(n);
    rep(i,2,n) {
        for (int j = i + i;j <= n;j += i) {
            p[j] = 0;
        }
    }
    int cnt = 0;
    int pp[100010];
    rep(i,1,n) {
        if (p[i]) pp[++ cnt] = i;
    }
    int ans = 0;
    rep(i,2,n) {
        if (pp[i] - pp[i - 1] == 2) ans ++;
    }
    printf("%d\n",ans);
    re0;
}
*/

/*
int main()
{
    int n,m;
    scii(n,m);
    int a[110];
    REP(i,0,n) sci(a[i]);
    REP(i,0,n) {
        if (i != 0) printf(" ");
        printf("%d",a[(i - m + n * m) % n]);
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    int x,y,z,k;
    __T {
        sciii(x,y,z);
        k = x + y - z;
        if (x + y < z) puts("-1");
        else if (x + y == z) printf("%d\n",z + 1);
        else if (k <= x || k <= z) puts("-1");
        else printf("%d\n",x + y - z);
    }
    return 0;
}
*/

/*ll to(int a) {
    ll ans = 1;
    while (a) {
        
        ans *= a % 10;
        
        if (ans == 0) return ans;
        a /= 10;
    }
    return ans;
}

int main()
{
    int l,r;
    ll ans;
    __T {
        scii(l,r);
        ans = 1;
        rep(i,l,r) {
            ans *= to(i);
            if (ans == 0) break;
            ans %= 1000000007;
        }
        _C(ans);
    }
    re0;
}
*/

/*
string str;
int n,k;

int chk(int l) {
    int ans = 0;
    for (int i = 0;i < n;) {
        if (str[i] == '1') {
            ans ++;
            i += l;
        } else i ++;
    }
    return ans <= k;
}

int main()
{
    int l,r,m;
    __T {
        scii(n,k);
        cin >> str;
        l = 1;
        r = n;
        while (l < r) {
            m = (l + r) / 2;
            if (chk(m)) r = m;
            else l = m + 1;
        }
        printf("%d\n",r);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    ll n;
    ll a6,a9,a0,a8;
    ll ans = 0;
    int o;
    
    __T {
        cin >> str;
        n = str.size();
        ans = (1 + n) * n / 2;
        o = 0;
        a0 = a8 = a6 = a9 = 0;
        REP(i,0,n) {
            if (str[i] == '6') a6 ++;
            else if (str[i] == '9') a9 ++;
            else if (str[i] == '0') a0 ++;
            else if (str[i] == '8') a8 ++;
            if (str[i] == '0' || str[i] == '8') o = 1;
        }
        ans -= (a0 + 1) * a0 / 2;
        ans -= (a8 + 1) * a8 / 2;
        o = o || (a6 && a9);
        if (o) ans ++;
        ans -= a6 * a9;
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
const int MAXN = 1e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int vis[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}


void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
        vis[i] = 0;
    }
}

int n,m;

int conv(int i,int j) {
    return i * m + j;
}

int main()
{
    char a[MAXN];
    
    int t;
    int ii,jj;
    int ok;
    int last;
    int times;
    __T {
        scii(n,m);
        init(n * m + 5);
        REP(i,0,n) {
            scanf(" ");
            REP(j,0,m) {
                scanf("%c",&a[conv(i,j)]);
            }
        }
        REP(i,0,n) {
            REP(j,0,m) {
                scanf("%d",&t);
                ii = i;
                jj = j;
                switch (a[conv(i,j)]) {
                    case 'u':
                        ii -= t;
                        break;
                    case 'd':
                        ii += t;
                        break;
                    case 'l':
                        jj -= t;
                        break;
                    case 'r':
                        jj += t;
                        break;
                    default:
                        break;
                }
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    bind(conv(i,j),conv(ii,jj));
                    vis[conv(ii,jj)] ++;
                }
            }
        }
        ok = 1;
        last = find(0);
        REP(i,1,n * m) {
            if (last != (t = find(i))) {
                ok = 0;
                break;
            }
            last = t;
        }
        times = 0;
        REP(i,0,n * m) if (vis[i] == 0) times ++;
        if (times >= 2) ok = 0;
        
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main()
{
    int n;
    char p[MAXN],vis[MAXN];
    int cnt;
    int t;
    vector<pair<int,int>> ans;
    __T {
        ans.clear();
        sci(n);
        rep(i,0,n) {
            p[i] = 1;
            vis[i] = 0;
        }
        rep(i,3,n) {
            if (!p[i] || i % 2 == 0) continue;
            cnt = 1;
            for (int j = i + i;j <= n;j += i) {
                p[j] = 0;
                if (!vis[j]) cnt ++;
            }
            
            t = i;
            for (int j = i * (2 + cnt % 2);j <= n;j += i) {
                if (vis[j]) continue;
                if (t == -1) {
                    t = j;
                } else {
                    vis[j] = vis[t] = 1;
                    ans.pb(mpair(t,j));
                    t = -1;
                }
            }
        }
        
        t = -1;
        rep(i,2,n) {
            if (!(i & 1) && !vis[i]) {
                if (t == -1) {
                    t = i;
                } else {
                    ans.pb(mpair(t,i));
                    t = -1;
                }
            }
        }
        printf("%lu",ans.size());
        for (auto i : ans) {
            printf(" %d %d",i.first,i.second);
        }
        puts("");
    }
    re0;
}
*/

/*
int main()
{
    int n,x;
    __T {
        scii(n,x);
        if (n == 1 || n == 2) printf("1\n");
        else {
            n -= 2;
            printf("%.0f\n",ceil(n / (double)x) + 1);
        }
    }
    re0;
}
*/

/*
int main() {
    int n;
    sci(n);
    ll s = 0;
    ll ans = 0;
    ll a[200010];
    set<ll> vis;
    vis.insert(0);
    REP(i,0,n) scanf("%lld",&a[i]);
    REP(i,0,n) {
        if (vis.find(s + a[i]) != vis.end()){
            vis.clear();
            vis.insert(s = 0);
            ans ++;
        }
        s += a[i];
        vis.insert(s);
    }
    printf("%lld\n",ans);
    
    return 0;
}
*/

/*
int main()
{
    int n,m;
    int a,b,c,d;
    int ok;
    __T {
        scii(n,m);
        ok = 0;
        while (n --) {
            scii(a,b);
            scii(c,d);
            if (b == c) ok = 1;
        }
        if (m % 2) puts("NO");
        else {
            puts(ok ? "YES" : "NO");
        }
    }
    re0;
}
*/
/*
int main()
{
    int n;
    sci(n);
    ll a1,a2,a3;
    ll b1,b2,b3;
    sclll(a1,a2,a3);
    sclll(b1,b2,b3);
    ll w = min(a1,b2) + min(a2,b3) + min(a3,b1);
    ll l;
    ll t;
    
    ll aa1,aa2,aa3;
    ll bb1,bb2,bb3;
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    l = min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1);
    
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    aa1 = a1;aa2 = a2;aa3 = a3;
    bb1 = b1;bb2 = b2;bb3 = b3;
    
    // 3--------------------
    bb3 -= t = min(aa3,bb3);
    aa3 -= t;
    
    bb3 -= t = min(aa1,bb3);
    aa1 -= t;
    
    // 2--------------------
    bb2 -= t = min(aa2,bb2);
    aa2 -= t;
    
    bb2 -= t = min(aa3,bb2);
    aa3 -= t;
    
    // 1--------------------
    bb1 -= t = min(aa1,bb1);
    aa1 -= t;
    
    bb1 -= t = min(aa2,bb1);
    aa2 -= t;
    
    l = min(l,min(aa1,bb2) + min(aa2,bb3) + min(aa3,bb1));
//    _C(aa1 << " " << aa2 << " " << aa3);
//    _C(bb1 << " " << bb2 << " " << bb3);
    
    
    printf("%lld %lld\n",l,w);
    
    return 0;
}
*/

/*
const int MAXN = 2e4 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 1];
int g[MAXN];

int cnt;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int bg[MAXN],ed[MAXN];
int dfn = 0;

void dfs(int n) {
    bg[n] = ++ dfn;
    // iterate graph
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs(to);
    }
    ed[n] = dfn;
}

int n,m;

struct node{
    int l,r;
    ll add;
    ll sum;
} tree[MAXN << 2];
void pushup(int index){
    tree[index].sum = tree[index<<1].sum+tree[index<<1|1].sum;
}
void pushdown(int index){    //下推标记
    if(tree[index].add){
         tree[index<<1].sum += (tree[index<<1].r-tree[index<<1].l+1)*tree[index].add;
        tree[index<<1|1].sum +=(tree[index<<1|1].r-tree[index<<1|1].l+1)*tree[index].add;
        
        tree[index<<1].add += tree[index].add;
        tree[index<<1|1].add += tree[index].add;
        
        tree[index].add = 0;
    }
}
void build(int l, int r, int index){        //建树    数组a的l,r区间建树
    tree[index].l = l;
    tree[index].r = r;
    tree[index].add = 0;
    if(l == r){
//        scanf("%lld",&tree[index].sum);
        
         tree[index].sum = 0;
        return;
    }
    int mid = (l+r)>>1;
    build(l,mid,index<<1);
    build(mid+1,r,index<<1|1);
    pushup(index);
}
void update(int l,int r,int index, ll w){    //修改a[L]的值 更新sum
    if(l <= tree[index].l && r >= tree[index].r){
        tree[index].sum += (tree[index].r-tree[index].l+1)*w;
        tree[index].add += w;
        return;
    }
    pushdown(index);
    int mid = (tree[index].l + tree[index].r)>>1;
    if(l <= mid) update(l,r,index<<1,w);
    if(r > mid) update(l,r,index<<1|1,w);
    pushup(index);
}
ll query(int l,int r,int index){    //查询
    if(l <= tree[index].l && r >= tree[index].r){
        return tree[index].sum;
    }
    pushdown(index);
    int mid = (tree[index].l + tree[index].r)>>1;
    ll sum = 0;
     if(l <= mid){
         sum += query(l,r,index<<1);
     }
    if(r > mid){
        sum += query(l,r,index<<1|1);
    }
    return sum;
}

int main()
{
    init();
    scii(n,m);
    build(1,n,1);
    int t;
    int root = 1;
    rep(i,1,n) {
        sci(t);
        if (t) add(t,i);
        else root = i;
    }
    dfs(root);

    int u,x,v;
    while (m --) {
        sciii(u,x,v);
        printf("%lld\n",query(bg[v],bg[v],1));
        update(bg[u], ed[u], 1, x);
    }
    return 0;
}
*/

/*
const int MAXN = 2e4 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 1];
int g[MAXN];

int cnt;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int bg[MAXN],ed[MAXN];
int dfn = 0;

void dfs(int n) {
    bg[n] = ++ dfn;
    // iterate graph
    int to;
    for (int i = g[n];~i;i = e[i].nxt) {
        to = e[i].to;
        dfs(to);
    }
    ed[n] = dfn;
}

int n,m;
ll c[MAXN] = {0};

void modify(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i))
    {
        c[i] += x;
    }
}

ll sum(int i)
{
    // 查询：由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

void pls(int l,int r,int k)
{
    modify(l, k);
    modify(r + 1, -k);
}


int main()
{
    init();
    
    scii(n,m);
    int t;
    int root = 1;
    rep(i,1,n) {
        sci(t);
        if (t) add(t,i);
        else root = i;
    }
    dfs(root);

    int u,x,v;
    while (m --) {
        sciii(u,x,v);
        printf("%lld\n",sum(bg[v]));
        pls(bg[u],ed[u],x);
    }
    return 0;
}
*/

/*
int n;

const int MAXN = 1e5 + 10;

struct Edge {
    Edge(){}
    Edge(int to,int nxt):to(to),nxt(nxt){}
    int to;
    int nxt;
} e[MAXN << 1];

int g[MAXN];
int cnt;

int dfn = 0;

void init()
{
    mem(g,-1);
    cnt = 0;
    dfn = 0;
}

void add(int u,int v) {
    e[cnt] = Edge(v,g[u]);
    g[u] = cnt ++;
}

int in[MAXN],out[MAXN];

void dfs(int k,int f)
{
    in[k] = ++ dfn;
    for (int i = g[k];~i;i = e[i].nxt)
    {
        if (e[i].to != f) {
            dfs(e[i].to,k);
        }
    }
    out[k] = dfn;
}

int c[MAXN] = {0};
int a[MAXN];

void modify(int idx,ll x)
{
    a[idx] += x;
    // 从叶子结点一路向上更新
    for (int i = idx;i <= n;i += lowbit(i))
    {
        c[i] += x;
    }
}

ll sum(int idx)
{
    // 查询：由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (int i = idx;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int main()
{
    sci(n);
    init();
    int u,v;
    rep(i,1,n - 1) {
        scii(u,v);
        add(u,v);
        add(v,u);
    }
    dsci(m);
    char c;
    int x;
    dfs(1,-1);
    
    rep(i,1,n) {
        modify(i, 1);
    }
    
    while (m --) {
        scanf(" %c",&c);
        sci(x);
        if (c == 'C') {
            if (a[in[x]]) modify(in[x], -1);
            else modify(in[x], 1);
        }
        else if (c == 'Q') printf("%lld\n",sum(out[x]) - sum(in[x] - 1));
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int ans;
    int cnt;
    __T {
        sci(n);
        ans = n;
        cnt = n;
        for (int i = 1;cnt <= ans;i ++,ans = min(ans,cnt)) {
            cnt = (i - 1) + n / i + min(n % i,1) - 1;
        }
        printf("%d\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    ll k;
    ll n,ans;
    while (~scl(k)) {
        k = abs(k);
        for (ans = 1,n = 1;n < k || n % 2 != k % 2;n += ++ ans);
        printf("%lld\n",ans);
    }
    re0;
}
*/

/*
int main()
{
    int n,k;
    __T {
        scii(n,k);
        rep(i,1,k) {
            n = (n >> 1) + (n & 1);
            if (n == 1 | n == 0) break;
        }
        printf("%d\n",n);
    }
    re0;
}
*/

/*
int main()
{
    ll year1,mon1,day1;
    ll year,mon,day;
    string s;
    string str[] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday"};
    map<string,int> conv;
    rep(i,0,4) conv[str[i]] = i;
    __T {
        scanf("%lld %lld %lld", &year, &mon, &day);
        cin >> s;
        scanf("%lld %lld %lld", &year1, &mon1, &day1);
        day %= 5;
        day1 %= 5;
        
        _C(str[(conv[s] + day1 + 5 - day) % 5]);
        
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    ll x = 0,y;
    ll p;
    __T {
        sci(n);
        p = 0;
        rep(i,1,n) {
            sci(a[i]);
            p += a[i];
        }
        p /= n;
        x = y = 0;
        rep(i,1,n) {
            x += a[i] - p;
            y += abs(a[i] - p);
        }
        printf("%lld\n",x + (y - x) / 2);
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    string str;
    ll x,y;
    ll ans;
    ll ans2;
    __T {
        scii(n,k);
        cin >> str;
        x = y = 0;
        ans = ans2 = 0;
        REP(i,0,n) {
            switch (str[i]) {
                case 'U':
                    y ++;
                    break;
                case 'D':
                    y --;
                    break;
                case 'L':
                    x --;
                    break;
                case 'R':
                    x ++;
                    break;
                default:
                    break;
            }
            ans2 = max(abs(x) + abs(y),ans2);
        }
        x *= (k - 1);
        y *= (k - 1);
        REP(i,0,n) {
            switch (str[i]) {
                case 'U':
                    y ++;
                    break;
                case 'D':
                    y --;
                    break;
                case 'L':
                    x --;
                    break;
                case 'R':
                    x ++;
                    break;
                default:
                    break;
            }
            ans = max(abs(x) + abs(y),ans);
        }
        printf("%lld\n",max(ans,ans2));
    }
    re0;
}
*/

/*
int main()
{
    ll k;
    string str;
    ll n,m;
    int u,v;
    ll i;
    __T {
        scl(k);
        cin >> str;
        scll(n,m);
        rep(i,1,m) scii(u,v);
        
        i = (m - n + 1 + k) % k;
        if (str[i] == '1') puts("2");
        else if (str[i] == '2') puts("1");
    }
    return 0;
}
*/

/*
int cmp(const pair<int,int> &a,const pair<int,int> &b)
{
    if (a.second == b.second) return a.first < b.first;
    return a.second < b.second;
}

int main() {
    int n;
    int l,r;
    ll ans;
    pair<int, int> a[100010];
    map<int,int> vis;
    __T {
        sci(n);
        vis.clear();
        rep(i,1,n) {
            scii(l,r);
            a[i] = mpair(l,r);
        }
        sort(a + 1,a + 1 + n,cmp);
        ans = 0;
        rep(i,1,n) {
            rep(j,a[i].first,a[i].second) {
                if (!vis[j]) {
                    vis[j] = 1;
                    ans ++;
                    break;
                }
            }
        }
        printf("%lld\n",ans);
    }
}
*/

/*
int n,m;
const int MAXN = 110;

vector<int> g1[MAXN],g2[MAXN];

int in[MAXN],out[MAXN];

int ch[MAXN],fa[MAXN];

int nonvis[MAXN];
int vis[MAXN];

int tuopu()
{
    queue<int> q;
    rep(i,1,n) {
        if (nonvis[i]) {
            if (in[i] == 0) q.push(i);
        }
        vis[i] = 0;
    }
    int t;
    while (!q.empty()) {
        t = q.front();
        q.pop();
        
        if (vis[t]) continue;
        vis[t] = 1;
        
        for (auto i : g1[t]) {
            ch[i] += 1 + ch[t];
            in[i] --;
            if (in[i] == 0) {
                q.push(i);
            }
        }
        
    }
    int ok = 1;
    rep(i,1,n) {
        if (!vis[i] && nonvis[i]) {
            ok = 0;
            break;
        }
    }
    
    if (!ok) re0;
    re1;
}


void bfs()
{
    queue<int> q1;
    queue<int> q2;
    
    rep(i,1,n) {
        ch[i] = fa[i] = vis[i] = 0;
    }
    int t;
    rep(i,1,n) {
        rep(j,1,n) vis[j] = 0;
        ch[i] = -1;
        
        q1.push(i);
        while (!q1.empty()) {
            t = q1.front();
            q1.pop();
            
            if (vis[t]) continue;
            vis[t] = 1;
            
            ch[i] ++;
            
            for (auto i : g1[t]) {
                q1.push(i);
            }
        }
        
        rep(j,1,n) vis[j] = 0;
        fa[i] = -1;
        
        q2.push(i);
        while (!q2.empty()) {
            t = q2.front();
            q2.pop();
            
            if (vis[t]) continue;
            vis[t] = 1;
            
            fa[i] ++;
            
            for (auto i : g2[t]) {
                q2.push(i);
            }
        }
    }
}

int main()
{
    int u,v;
    
    __T {
        scii(n,m);
        rep(i,1,n) {
            g1[i].clear();
            g2[i].clear();
            in[i] = out[i] = nonvis[i] = 0;
        }
        
        while (m --) {
            scii(u,v);
            in[v] ++;
            out[u] ++;
            g1[u].pb(v);
            g2[v].pb(u);
            nonvis[u] = 1;
            nonvis[v] = 1;
        }
        
        if (tuopu())
        {
            bfs();
            rep(i,1,n) {
                if (!nonvis[i] || (ch[i] <= n / 2 && fa[i] <= n / 2)) printf("1");
                else printf("0");
            }
        } else rep(i,1,n) printf("0");
        puts("");
    }
    return 0;
}
*/

/*
int a,p,pp;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % pp;
        a = a * a % pp;
        b >>= 1;
    }
    return ans;
}


int main()
{
    vector<int> ans;
    int d;
    int e;
    vector<int>::iterator it;
    __T {
        scii(a,p);
        pp = 1 << p;
        ans.clear();
        if (a & 1) {
            printf("1\n");
            continue;
        }
        rep(x,1,pp) {
            if (quickpow(a, x) == quickpow(x, a)) {
                ans.pb(x);
            }
            if (ans.size() == 5) break;
        }
        
        it = ans.end();
        d = (e = *(-- it)) - *(-- it);
        printf("%lu\n",ans.size() + (pp - e) / d);
    }
    return 0;
}
*/


/*
int main()
{
    int n;
    sci(n);
    int ans = 0;
    int u,v;
    int de[100010] = {0};
    
    rep(i,1,n - 1) {
        scii(u,v);
        de[u] ++;
        de[v] ++;
    }
    rep(i,1,n) {
        if (de[i] == 1) ans ++;
    }
    printf("%d\n",ans);
    re0;
}
*/

/*
int main()
{
    dsci(n);
    set<int> s;
    int a[100010];
    rep(i,1,n) sci(a[i]);
    int b[100010];
    b[1] = 0;
    s.insert(a[1]);
    set<int>::iterator it;
    rep(i,2,n) {
        it = s.upper_bound(a[i]);
        if (it != s.end()) b[i] = *it;
        else b[i] = 0;
        s.insert(a[i]);
    }
    ll sum = 0;
    rep(i,1,n) sum += b[i];
    printf("%lld\n",sum);
    re0;
}
*/

/*
int a[100010];
int b[100010] = {0};

int max(int a,int b) {
    return a > b ? a : b;
}

int main()
{
    int n,m,q,maxn = -1;
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) {
        scanf("%d",a + i);
        maxn = max(a[i],maxn);
        b[a[i]] ++;
    }
    for (int i = maxn - 1;i >= 1;i --) b[i] += b[i + 1];
    scanf("%d",&m);
    while (m --) {
        scanf("%d",&q);
        printf("%d\n",b[a[q] + 1]);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int u,v;
    __T {
        sci(n);
        rep(i,1,n - 1) {
            scii(u,v);
        }
        if (!(n & 1)) puts("Bob");
        else puts("Alice");
    }
    re0;
}
*/

/*
int main()
{
    int n,k;
    vector<int> pos;
    char x[] = {'0','1','2','3','4','5','6','7','8','9'};
    __T {
        scii(k,n);
        pos.clear();
        while (n) {
            n --;
            pos.pb(n % k);
            n /= k;
        }
        
        for (auto i = pos.rbegin();i != pos.rend();i ++)
        {
            printf("%c",x[10 - k + *i]);
        }
        puts("");
    }
    re0;
}
*/

/*
int main()
{
    int k;
    sci(k);
    k --;
    
    int l = 1,r = k;
    int le = k - l * r;
    int cnt = l + r + le;
    
    int low = cnt;
    
    for (int i = 1,x;i * i <= k;i ++) {
        x = k / i;
        le = k - i * x;
        cnt = i + x + le;
        if (cnt <= low) {
            low = cnt;
            l = i;
            r = x;
        }
    }
    le = k - l * r + 1;
    
    cnt = low;
    cnt ++;
    printf("%d\n",cnt);
    
    int i;
    int f = 1;
    for (i = 2;i <= le;i ++) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i - 1);
    }
    rep(j,1,l) {
        if (j == 1) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",le);
        } else {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i - 1);
        }
        i ++;
    }
    rep(j,1,r) {
        if (j == 1) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",le);
        } else {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i - 1);
        }
        i ++;
    }
    puts("");
    for (i = 1;i <= le;i ++) {
        if (i != 1) printf(" ");
        printf("2");
    }
    for (i = le + 1;i <= cnt;i ++) {
        printf(" 1");
    }
    puts("");
    return 0;
}
*/

/*
int ucmp(const pair<string,int> &a,const pair<string,int> &b) {
    return a.first == b.first;
}

int cmp(const pair<string,int> &a,const pair<string,int> &b) {
    return a.second < b.second;
}

int main()
{
    int n;
    scanf("%d ",&n);
    pair<string,int> str[1010];
    for (int i = 0;i < n;i ++) {
        getline(cin,str[i].first);
        str[i].second = i;
    }
    sort(str,str + n);
    pair<string, int> *end;
    end = unique(str, str + n, ucmp);
    int m = (int) (end - str);
    printf("%d\n",m);
    sort(str,str + m,cmp);
    for (int i = 0;i < m;i ++) cout << str[i].first << endl;
    return 0;
}
*/

/*
int main()
{
    int n;
    scanf("%d ",&n);
    vector<string> ans;
    string str;
    map<string,int> vis;
    for (int i = 0;i < n;i ++) {
        getline(cin,str);
        if (vis[str]) continue;
        vis[str] = 1;
        ans.push_back(str);
    }
    printf("%lu\n",ans.size());
    for (auto i : ans) cout << i << endl;
    return 0;
}
*/

/*
int main()
{
    string m;
    cin >> m;
    string str;
    vector<string> ans;
    int ok;
    __T {
        cin >> str;
        ok = 1;
        if (m.size() != str.size()) continue;
        for (int i = 0;str[i];i ++) {
            if (m[i] == '*') continue;
            if (m[i] != str[i]) {
                ok = 0;
                break;
            }
        }
        if (ok) ans.pb(str);
    }
    printf("%lu\n",ans.size());
    for (auto i : ans) {
        _C(i);
    }
    return 0;
}
*/

/*
int n,m;
int main()
{
    scii(n,m);
    int a[1010];
    int b[1010];
    rep(i,1,n) scii(a[i],b[i]);
    int x,y,t;
    int cnt;
    int mod,k;
    int idx;
    rep(j,1,m) {
        sciii(x,y,t);
        cnt = 0;
        rep(i,1,n) {
            mod = b[i] - a[i];
            mod *= 2;
            k = t % mod;
            if (k < b[i] - a[i] + 1) idx = a[i] + k;
            else idx = a[i] + (mod - k);
            if (idx >= x && idx <= y) cnt ++;
        }
        printf("%d\n",cnt);
    }
    
    re0;
}
*/

/*
pair<int,int> a[100010];

int cmp(const pair<int,int> &a,const pair<int,int> &b)
{
    return a.second < b.second;
}

int main()
{
    int n,k;
    scii(n,k);
    int t[100010] = {0};
    rep(i,1,n) {
        sci(a[i].first);
        t[a[i].first] ++;
    }
    rep(i,1,n) sci(a[i].second);
    
    sort(a + 1,a + 1 + n,cmp);
    int cnt = 0;
    rep(i,1,k) if (t[i]) cnt ++;
    ll ans = 0;
    rep(i,1,n) {
        if (cnt >= k) break;
        if (t[a[i].first] <= 1) continue;
        t[a[i].first] --;
        cnt ++;
        ans += a[i].second;
    }
    printf("%lld\n",ans);
    re0;
}
*/

/*
int a[10];
int b[10];
int n;
ll k,cnt,mod;
ll nn;

ll get(int i) {
    ll ans = 0;
    int x = 0;
    rep(j,i,7) {
        ans ++;
        if (a[j]) x ++;
        if (x == n) return ans;
    }
    nn = n - x;
    k = nn / cnt;
    mod = nn % cnt;
    if (mod) k ++;
//    _C(">>" << k)
    ans += k * 7;
    ans -= 7 - b[mod];
    return ans;
}

int main()
{
    
    int s,e;
    
    ll ans;
    ll x;
    __T {
        sci(n);
        cnt = 0;
        s = 0;
        e = 0;
        rep(i,1,7) {
            sci(a[i]);
            if (a[i]) {
                b[++ cnt] = i;
                if (!s) s = i;
                e = i;
            }
        }
        b[0] = e;
        ans = -1;
        rep(i,1,7) {
            x = get(i);
//            _C(x);
            if (ans == -1 || x < ans) ans = x;
        }
        
        printf("%lld\n",ans);
        
    }
    re0;
}
*/

/*
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll r = exgcd(b, a % b, x, y);
    ll t = y;
    y = x - (a / b) * y;
    x = t;
    return r;
}

int main()
{
    ll n,nn;
    scl(n);
    nn = n;
    vector<ll> y;
    for (ll i = 2;i * i <= nn;i ++) {
        if (n % i == 0) {
            y.pb(i);
            y.pb(n / i);
        }
    }
    
    ll a,b;
    ll p;
    for (auto i : y) {
        for (auto j : y) {
            if (i > 1 && i < nn && j > 1 && j < nn && exgcd(i,j,a,b) == 1) {
                a *= (nn - 1);
                b *= (nn - 1);
                
                if (a <= 0) {
                    p = abs(a) / j;
                    p ++;
                    a += p * j;
                    b -= p * i;
                }
                if (b <= 0) {
                    p = abs(b) / i;
                    p ++;
                    b += p * i;
                    a -= p * j;
                }
                
                if (b >= nn) {
                    p = (b - nn) / i;
                    p ++;
                    a += p * j;
                    b -= p * i;
                }
                
                if (a >= nn) {
                    p = (a - nn) / j;
                    p ++;
                    b += p * i;
                    a -= p * j;
                }
                
                if (a < 1 || a >= j || b < 1 || b >= i) continue;
                
                printf("YES\n2\n");
                printf("%lld %lld\n",a,j);
                printf("%lld %lld\n",b,i);
                re0;
            }
        }
    }
    puts("NO");
    
    re0;
}
*/

/*
int n,m;

int check(int a,int b,int c)
{
    int ok = 0;
    
    int h = b + c,
    w = 3 * a + b + c;
    
    if (h <= n && w <= m) ok = 1;
    if (h <= m && w <= n) ok = 1;
    
    h = 2 * a + 2 * c;
    w = b + 2 * c;
    
    if (h <= n && w <= m) ok = 1;
    if (h <= m && w <= n) ok = 1;
    
    return ok;
}

int main()
{
    int a,b,c;
    sciii(a,b,c);
    scii(n,m);
    int ok = check(a,b,c) | check(a,c,b) | check(b,a,c) | check(b,c,a) | check(c,a,b) | check(c,b,a);
    puts(ok ? "Yes" : "No");
    re0;
}
*/

/*
int a[110],b[110],c[110];
int p[110];
int n;

int main()
{
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        rep(i,1,n) sci(b[i]);
        rep(i,1,n) sci(c[i]);
        p[1] = a[1];
        rep(i,2,n - 1) {
            if (a[i] != p[i - 1]) p[i] = a[i];
            else if (b[i] != p[i - 1]) p[i] = b[i];
            else p[i] = c[i];
        }
        if (a[n] != p[1] && a[n] != p[n - 1]) p[n] = a[n];
        else if (b[n] != p[1] && b[n] != p[n - 1]) p[n] = b[n];
        else p[n] = c[n];
        rep(i,1,n) {
            if (i != 1) printf(" ");
            printf("%d",p[i]);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    int n,l;
    int f[100010];
    double ta[100010];
    double tb[100010];
    double v;
    int t;
    double ext;
    double va,vb;
    double a,b;
    __T {
        scii(n,l);
        rep(i,1,n) sci(f[i]);
        f[0] = 0;
        f[n + 1] = l;
        v = 1;
        
        ta[0] = 0;
        rep(i,1,n + 1) {
            ta[i] = (f[i] - f[i - 1]) / v + ta[i - 1];
            v ++;
        }
        
        v = 1;
        
        tb[n + 1] = 0;
        pre(i,n,0) {
            tb[i] = (f[i + 1] - f[i]) / v + tb[i + 1];
            v ++;
        }
        
        
//        rep(i,0,n + 1) {
//            printf("%f ",ta[i]);
//        }
//        puts("");
//        rep(i,0,n + 1) {
//            printf("%f ",tb[i]);
//        }
//        puts("");
        
        for (t = 0;t <= n + 1;t ++) {
            if (ta[t] >= tb[t]) break;
        }
        
        va = t;
        vb = n + 2 - t;
//        _C(va << " " << vb);
        
        ext = max(ta[t - 1],tb[t]);
        a = f[t - 1];
        b = f[t];
        
//        _C(">>" << t)
        
        if (fabs(ta[t - 1] - tb[t]) <= 1e-6){}
        else if (ta[t - 1] > tb[t]) {
            b -= vb * fabs(ext - tb[t]);
        } else if (ta[t - 1] < tb[t]) {
            a += va * fabs(ext - ta[t - 1]);
        }
//        _C("s> " << a << " " << b)
        printf("%.15f\n",ext + (b - a) / (va + vb));
        
        
        
    }
    re0;
}
*/

//
//itn h[1000010];
//pair<int,int> r[20010];
//pair<int,int> w[20010];
//
//int main()
//{
//    itn n,m;
//    scii(n,m);
//    mem(h,-1);
//    rep(i,1,n) {
//        scii(r[i].first,r[i].second);
//    }
//    rep(i,1,m) {
//        scii(w[i].first,w[i].second);
//    }
//
//
//
//    rep(i,1,n) {
//        rep(j,1,m) {
//            if (r[i].second <= w[j].second && r[i].first <= w[j].first)
//            h[w[j].second - r[i].second] = max(h[w[j].second - r[i].second],w[j].first - r[i].first + 1);
//        }
//    }
//    _C(h[0])
//    ll mx = -INT_INF;
//    ll ans = INT_INF;
//    pre(i,1000005,0) {
//        mx = max((ll)h[i],mx);
//        ans = min(ans,mx + i);
//    }
//    _C(ans);
//
////    int mn_x,mn_y,mn;
////    int ans_x = 0,ans_y = 0,ans = 0;
////    int t;
////    rep(i,1,n) {
////        mn_y = h[r[i].second] - r[i].first + 1;
////        mn_x = 0;
////        mn = mn_x + mn_y;
////
////        _C(">>" << mn);
////        rep(j,1,m) {
////            if (w[j].second < r[i].second) continue;
////            t = w[j].second - r[i].second + 1 + h[w[j].second + 1] - r[i].first + 1;
////            if (t < mn) {
////                mn = t;
////                mn_x = h[w[j].second + 1] - r[i].first + 1;
////                mn_y = w[j].second - r[i].second + 1;
////            }
////        }
////        _C(">>" << mn << " " << mn_x << " " << mn_y);
////        ans_x = max(ans_x,mn_x);
////        ans_y = max(ans_y,mn_y);
////    }
////    printf("%d\n",ans_x + ans_y);
//    re0;
//}

/*
int main()
{
    ll n;
    int q;
    scl(n);
    sci(q);
    char cc;
    ll k;
    ll r = (1 + n) * n / 2,c = r;
    ll tr = n,tc = n;
    int visr[1000010] = {0};
    int visc[1000010] = {0};
    while (q --) {
        scanf(" %c %lld",&cc,&k);
        if (cc == 'R') {
            if (visr[k]) puts("0");
            else {
                visr[k] = 1;
                printf("%lld\n",k * tc + c);
                r -= k;
                tr --;
            }
        } else if (cc == 'C') {
            if (visc[k]) puts("0");
            else {
                visc[k] = 1;
                printf("%lld\n",k * tr + r);
                c -= k;
                tc --;
            }
        }
    }
    
}
*/

/*
pair<string,int> st[200010];
int cnt = 0;
int s = -1;
int s_idx;
string str = "";

int last_index = 0;

string ans = "";
string word = "";

int ok() {
    if (word.size() <= 1) re0;
    int up_num = 0;
    for (int i = 0;word[i];i ++) {
        if (isupper(word[i])) up_num ++;
    }
    return isupper(word[0]) && up_num == 1;
}

void ended(int i)
{
//    _C(s);
//    REP(i,0,cnt) {
//        _C(st[i].first)
//    }
    if (s == -1 || cnt - s <= 1) {
        rep(j,last_index,i) {
            printf("%c",str[j]);
        }
    } else {
        rep(j,last_index,s_idx - 1) {
            printf("%c",str[j]);
        }
        string x = " (";
        REP(j,s,cnt) {
            if (j != s) x += ' ';
            x += st[j].first;
            printf("%c",st[j].first[0]);
        }
        x += ')';
        cout << x;
//        _C(cnt << " " << st[cnt].first << " " << st[cnt].second)
        rep(j,st[cnt - 1].second,i) {
            printf("%c",str[j]);
        }
    }
    cnt = 0;
    s = -1;
    last_index = i + 1;
}

void add(int i)
{
//    _C(">>" << word)
    if (ok()) {
        if (s == -1) {
            s = cnt;
            s_idx = i - (int) word.size();
        }
    } else {
        if (s != -1) {
            ended(i - (int) word.size() - 1);
            s = -1;
        }
    }
    st[cnt].first = word;
    st[cnt ++].second = i;
//    _C(st[cnt - 1].first << " " << st[cnt - 1].second)
    word = "";
}



int main()
{
    string line;
    while (getline(cin,line)) str += line + '\n';
//    _C(str)
    for (int i = 0;str[i];i ++) {
        if (str[i] == ' ') {
            add(i);
        } else if (str[i] == ',' || str[i] == '.' || str[i] == '\n') {
//            _C("\\")
            add(i);
//            _C(",")
            ended(i);
        } else word += str[i];
    }
    ended((int) str.size() - 1);
    re0;
}
*/

/*
int main() {
    int n,m;
    string str;
    int ans,ans1;
    __T {
        scii(n,m);
        cin >> str;
        ans = 0; // L
        ans1 = 0; // R
        if (str[m - 1] == 'R') ans ++;
        else ans1 ++;
        REP(i,m + 1,n) {
            if (str[i - 1] == 'L') ans1 ++;
        }
        pre(i,m - 1,2) {
            if (str[i - 1] == 'R') ans ++;
        }
//        _C(ans << " " << ans1)
        printf("%d\n",min(ans,ans1));
    }
    
}
*/

/*
int n;

int ok(int a,int b,int c)
{
    return a >= 0 && b >= 0 && c >= 0 && a < n && b < n && c < n;
}

int ok(int a,int b,int c,int d)
{
    return a >= 0 && b >= 0 && c >= 0 && a < n && b < n && c < n && d >= 0 && d < n;
}

int ccpc(char a,char b,char c,char d)
{
    return a == 'C' && b == 'C' && c == 'P' && d == 'C';
}

int main()
{
    string str;
    int ans;
    int a,b,c,d;
    int k1,k2;
    int okk = 0;
    __T {
        sci(n);
        cin >> str;
        ans = 0;
        REP(i,0,n - 3) {
            if (ccpc(str[i],str[i + 1],str[i + 2],str[i + 3])) ans ++;
        }
//        _C(ans)
        okk = 0;
        
        // C
        rep(i,0,n) {
            a = i - 3;
            b = i - 2;
            c = i - 1;
            k1 = 0;
            k2 = 0;
            if (ok(a,b,c) && ccpc(str[a],str[b],str[c],'C')) k1 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            if (ok(a,b,c) && ccpc(str[a],str[b],'C',str[c])) k1 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            if (ok(a,b,c) && ccpc(str[a],'C',str[b],str[c])) k1 ++;
            a = i;
            b = i + 1;
            c = i + 2;
            if (ok(a,b,c) && ccpc('C',str[a],str[b],str[c])) k1 ++;
            
            
            a = i - 3;
            b = i - 2;
            c = i - 1;
            d = i;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            d = i + 1;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            d = i + 2;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            
            if (k1 > k2) {
                okk = 1;
                break;
            }
        }
        
        if (okk) {
            printf("%d\n",ans + 1);
            continue;
        }
        
        rep(i,0,n) {
            a = i - 3;
            b = i - 2;
            c = i - 1;
            k1 = 0;
            k2 = 0;
            if (ok(a,b,c) && ccpc(str[a],str[b],str[c],'P')) k1 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            if (ok(a,b,c) && ccpc(str[a],str[b],'P',str[c])) k1 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            if (ok(a,b,c) && ccpc(str[a],'P',str[b],str[c])) k1 ++;
            a = i;
            b = i + 1;
            c = i + 2;
            if (ok(a,b,c) && ccpc('P',str[a],str[b],str[c])) k1 ++;
            
            
            a = i - 3;
            b = i - 2;
            c = i - 1;
            d = i;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 2;
            b = i - 1;
            c = i;
            d = i + 1;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            a = i - 1;
            b = i;
            c = i + 1;
            d = i + 2;
            if (ok(a,b,c,d) && ccpc(str[a],str[b],str[c],str[d])) k2 ++;
            
            if (k1 > k2) {
                okk = 1;
                break;
            }
        }
        
        printf("%d\n",ans + okk);
        
    }
    return 0;
}
*/

/*
ll dis(ll x,ll y) {return x * x + y * y;}

int main()
{
    int n;
    ll R;
    ll r;
    pair<ll,int> a[110];
    ll x,y;
    int cnt;
    ll k;
    ll m;
    int f;
    vector<int> ans;
    __T {
        sci(n);
        scll(R,r);
        rep(i,1,n) {
            scll(x,y);
            a[i] = mpair(dis(x,y),i);
        }
        ans.clear();
        sort(a + 1,a + 1 + n);
        if (r == R) {
            rep(i,1,n) {
                ans.pb(i);
            }
        } else if (r * 2 >= R) {
            cnt = 0;
            k = 2 * r - R;
            k *= k;
            rep(i,1,n) {
                if (a[i].first <= k) cnt ++;
                else break;
            }
            if (cnt != 0) {
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            } else {
                m = a[1].first;
                cnt = 0;
                rep(i,1,n) {
                    if (m == a[i].first) cnt ++;
                    else break;
                }
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            }
        } else {
            cnt = 0;
            k = R - 2 * r;
            k *= k;
            rep(i,1,n) {
                if (a[i].first <= k) cnt ++;
                else break;
            }
            if (cnt != 0) {
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            } else {
                m = a[1].first;
                cnt = 0;
                rep(i,1,n) {
                    if (m == a[i].first) cnt ++;
                    else break;
                }
                rep(i,1,cnt) {
                    ans.pb(a[i].second);
                }
            }
        }
        printf("%lu\n",ans.size());
        sort(ans.begin(), ans.end());
        f = 1;
        for (auto i : ans) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i);
        }
        puts("");
    }
    return 0;
}
*/

/*
const int MAXN = 1e7 + 10;

ll p[MAXN];
int n;

int num[MAXN], prim[MAXN];
int pn = 0;
void table(){
    memset(num, -1, sizeof(num));
    for(int i = 2;i <= n;i++){
        if(num[i]) prim[pn++] = i;
        for(int j = 0;j < pn && 1LL*i*prim[j] <= n;j++){
            num[i*prim[j]] = 0;
            if(i % prim[j] == 0) break;
        }
    }
}

void pls(int l,int r,ll k)
{
    p[l] += k;
    p[r + 1] -= k;
}

ll s[10000010];

int main()
{
    sci(n);
    ll ans;
    table();
    REP(i,0,pn) {
        pls(1,n / prim[i],1);
    }
    s[0] = p[0];
    rep(i,1,n) s[i] = s[i - 1] + p[i];
    
    ans = 0;
    rep(i,1,n) {
        ans += (s[i] - 1) * s[i];
    }
    
    printf("%lld\n",ans);
    re0;
}
*/

/*
int main()
{
    int a[15][20];
    mem(a,-1);
    
    dscii(n,k);
    
    ll ans = 0;
    int x;
    rep(i,1,n) {
        sci(x);
        rep(j,1,x) sci(a[i][j]);
    }
    x = 0;
    rep(j,1,19) {
        rep(i,1,n) {
            if (a[i][j] == -1) a[i][j] = 50;
            if (a[i][j] >= ans) {
                ans += a[i][j];
                x ++;
            }
            if (x == k) goto end;
        }
    }
    end:
    ans += (k - x) * 50LL;
    printf("%lld\n",ans);
    re0;
}
*/

/*
int aa,bb,cc,dd;
int n;

struct Node {
    int a,b,c,d;
    int cnt;
    int i;
    
} node[40],nn[40];

int mx = 0;
vector<int> ans;
vector<int> k;

ll sub[40];

void dfs(int i,int a,int b,int c,int d,int x)
{
    if (i == n) {
        if (x > mx) {
            mx = x;
            ans = k;
        }
        return;
    }
    if (x + sub[i] <= mx) return; // 剪枝
    if (a >= node[i].a && b >= node[i].b && c >= node[i].c && d >= node[i].d) {
        k.pb(node[i].i);
        dfs(i + 1,a - node[i].a,b - node[i].b,c - node[i].c,d - node[i].d,x + node[i].cnt);
        k.erase(k.end() - 1);
    }
    dfs(i + 1,a,b,c,d,x);
}

int main()
{
    sci(n);
    int a,b,c,d,cnt;
    REP(i,0,n) {
        scii(a,b);
        sciii(c,d,cnt);
        nn[i] = {a,b,c,d,cnt,i};
    }

    sub[n - 1] = nn[n - 1].cnt;
    pre(i,n - 2,0) sub[i] = sub[i + 1] + nn[i].cnt;

    scii(aa,bb);
    scii(cc,dd);
    int ct = 0;
    REP(i,0,n) {
        if (nn[i].a <= aa && nn[i].b <= bb && nn[i].c <= cc && nn[i].d <= dd) node[ct ++] = nn[i];
    }
    n = ct;
    
    dfs(0,aa,bb,cc,dd,0);

    printf("%lu\n",ans.size());
    sort(ans.begin(), ans.end());
    int f = 1;
    for (auto i : ans) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    if (ans.size() != 0) puts("");
    re0;
}
*/

//
//const int maxw = 100010;
//ll hight[maxw],l[maxw],r[maxw];
//ll w;
//ll n;
//
//ll num(int pos,ll h){
//    ll sum = 0;
//    if(h<=hight[pos]||pos==w-1||pos==0)return -1;
//    else sum+=h-hight[pos];
//    ll temp = h;
//    for(int i=pos+1;i<w;i++){
//        temp--;
//        if(temp<=hight[i])break;
//        else{
//            if(i==w-1)return -1;
//            sum+=temp-hight[i];
//        }
//    }
//    temp = h;
//    for(int i=pos-1;i>=0;i--){
//        temp--;
//        if(temp<=hight[i])break;
//        else{
//            if(i==0)return -1;
//            sum+=temp-hight[i];
//        }
//    }
//    return sum;
//}
//ll mx = -1;
//
//int check(ll m)
//{
//    if (m <= mx) return 1;
//    int ok = 0;
//    ll k;
//    REP(i,1,w - 1) {
//        if ((k = num(i, m)) != -1 && k <= n) {
//            ok = 1;
//            break;
//        }
//    }
//    return ok;
//}
//
//int main(){
//    scanf("%lld%lld",&w,&n);
//    for(int i=0;i<w;i++){
//        scanf("%lld",&hight[i]);
//        mx = max(mx,hight[i]);
//    }
//
//    ll r = 1e9;
//    ll l = 1;
//    ll m;
//    while (l < r) {
//        m = (l + r) >> 1;
////        _C(l << " " << r)
//        if (check(m)) l = m + 1;
//        else r = m;
//    }
//    printf("%lld\n",l - 1);
//
//    return 0;
//}

/*
int main()
{
    int n;
    __T {
        sci(n);
        while (1) {
            if (n % 7 == 0 && n % 4 != 0) {
                printf("%d\n",n);
                break;
            }
            n ++;
        }
    }
}
*/


/*
int main()
{
    string str;
    string ans;
    __T {
        cin >> str;
        ans = "";
        for (int i = 0;str[i];i ++) {
            if (i == 0) ans += str[i];
            else if (str[i] != 'a' && str[i] != 'e' && str[i] != 'i' && str[i] != 'o' && str[i] != 'u' && str[i] != 'y') ans += str[i];
        }
        _C(ans);
    }
    return 0;
}
*/


/*
int n;
int a[100010];

int ok(int i) {
    if (i - 1 < 1 || i + 1 > n) return 0;
    return a[i - 1] < a[i] && a[i] > a[i + 1];
}

int main()
{
    int m;
    int cnt,cnt2;
    int s;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        m = 0;
        
        rep(i,1,n) {
            if (ok(i)) m ++;
        }
//        _C(m)
        s = 0;
        rep(i,1,n) {
            cnt = 0;
            cnt2 = 0;
            if (ok(i - 1)) cnt ++;
            if (ok(i)) cnt ++;
            if (ok(i + 1)) cnt ++;
            if (i - 2 >= 1 && i + 1 <= n && a[i - 1] > a[i - 2] && a[i - 1] > a[i + 1]) cnt2 ++;
            if (i - 1 >= 1 && i + 2 <= n && a[i + 1] > a[i - 1] && a[i + 1] > a[i + 2]) cnt2 ++;
            s = max(s,cnt - cnt2);
        }
        printf("%d\n",m - s);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[100010];
    int b[100010];
    int m;
    int ans = 0;
    __T {
        sci(n);
        ans = 0;
        rep(i,1,n) {
            sci(a[i]);
            b[i] = a[i];
        }
        sort(b + 1,b + 1 + n);
        m = n;
        pre(i,n,1) {
            if (a[i] == b[m]) {
                m --;
                ans ++;
            }
        }
        printf("%d\n",n - ans);
    }
    re0;
}
*/

/*
const int MAXN = 1e6 + 10; ///////////
int n,m;
vector<int> g[MAXN];
int vis[MAXN];
int dis[MAXN];

int cc = 0;
vector<int> a[MAXN];

priority_queue<int,vector<int>,greater<int>> q;

void dij(int s)
{
    a[cc].clear();
    q.push(s);
    int top;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        if (vis[top]) continue;
        vis[top] = 1;
        a[cc].pb(top);
        for (auto i : g[top]) {
            q.push(i);
        }
    }
    cc ++;
}

struct Node {
    int n;
    int which;
    int i;
    int operator <(const Node &o) const {
        return n > o.n;
    }
};

int main()
{
    int u,v;
    priority_queue<Node> k;
    int f,x,ff,ii;
    int cnt;
    __T {
        scii(n,m);
        cc = 0;
        rep(i,1,n) {
            g[i].clear();
            vis[i] = 0;
            dis[i] = -1;
        }
        while (m --) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        cnt = 0;
        rep(i,1,n) {
            if (vis[i]) continue;
            dij(i);
            cnt ++;
        }
        
        REP(i,0,cc) {
            k.push({a[i][0],i,0});
        }
        
        printf("%d\n",cnt);
        
        ff = 1;
        while (!k.empty()) {
            f = k.top().n;
            x = k.top().which;
            ii = k.top().i;
            k.pop();
//            _C(f << " " << x)
            if (ff) ff = 0;
            else printf(" ");
            printf("%d",f);
            if (ii + 1 < a[x].size()) {
//                _C(">>" << a[x].front());
                k.push({a[x][ii + 1],x,ii + 1});
            }
        }
        puts("");
    }
}
*/

/*
int main()
{
    int n;
    ll x,y;
    ll a[100010];
    ll xx,yy;
    ll sub;
    ll ans;
    map<ll,ll> mp;
    ll a1;
    ll k;
    __T {
        sci(n);
        scll(x,y);
        ans = 0;
        xx = 0;
        yy = 0;
        rep(i,1,n) {
            scl(a[i]);
            xx += i * a[i];
            yy += i * (a[i] * a[i]);
        }
        
//        _C(xx)
//        _C(yy)
        if (xx == x && yy == y) {
            mp.clear();
            rep(i,1,n) {
                mp[a[i]] ++;
            }
            for (auto i : mp) {
                ans += i.second * (i.second - 1) / 2;
            }
            printf("%lld\n",ans);
        } else if (xx == x || yy == y) {
            printf("0\n");
        }else {
            sub = (yy - y) / (xx - x);
            if ((yy - y) % (xx - x)) {
                puts("0");
                continue;
            }
            rep(i,1,n) {
                a1 = sub - a[i];
                if (a[i] != a1) {
                    k = (xx - x) / (a1 - a[i]) + i;
                    if (k > i && k <= n && a1 == a[k]) ans ++;
                }
            }
            
            printf("%lld\n",ans);
        }
    }
    re0;
}
*/

/*
int main()
{
    string a,b;
    int x['z' + 1];
    int y['z' + 1];
    int ok;
    while (cin >> a >> b) {
        mem(x,0);
        mem(y,0);
        if (a == b) printf("Equal\n");
        else if (a[0] == b[0] && a[a.size() - 1] == b[b.size() - 1]) {
            ok = 1;
            for (int i = 0;a[i];i ++) {
                x[a[i]] ++;
            }
            for (int i = 0;b[i];i ++) {
                y[b[i]] ++;
            }
            rep(i,0,'z') {
                if (x[i] != y[i]) {
                    ok = 0;
                    break;
                }
            }
            puts(ok ? "Yes" : "No");
        } else {
            puts("No");
        }
    }
    re0;
}
*/

/*
int main()
{
    int n;
    
    string str;
    int t['z' + 1] = {0};
    int ans = 0;
    char c;
    while (~sci(n))
    {
        cin >> str;
        mem(t,0);
        ans = 0;
        for (int i = 0;str[i];i ++) {
            c = str[i];
            if (c == 'x') t[c] ++;
            else if (c == 't') {
                if (t['x'] > 0) {
                    t['x'] --;
                    t[c] ++;
                }
            } else if (c == 'C') {
                if (t['t'] > 0) {
                    t['t'] --;
                    t[c] ++;
                }
            } else if (c == 'p') {
                if (t['C'] > 0) {
                    t['C'] --;
                    t[c] ++;
                }
            } else if (c == 'c') {
                if (t['p'] > 0) {
                    t['p'] --;
                    ans ++;
                }
            }
        }
        printf("%d\n",ans);
    }
}
*/

/*
int main()
{
    string str[14];
    int s['z'][10] = {0};
    map<string,int> k;
    REP(i,0,14) cin >> str[i];
    REP(i,0,14) {
        if (isdigit(str[i][0])) {
            s[str[i][1]][str[i][0] - '0'] ++;
        } else {
            k[str[i]] ++;
        }
    }
    set<char> n1;
    set<char> n9;
    if (s['s'][1]) n9.insert('s');
    if (s['s'][9]) n9.insert('s');
    if (s['p'][1]) n9.insert('p');
    if (s['p'][9]) n9.insert('p');
    if (s['w'][1]) n9.insert('w');
    if (s['w'][9]) n9.insert('w');
    
    
    re0;
}
*/

/*
string Manacher(string &s)
{
    //改造字符串
    int n = (int) s.size();
    string res = "$#";
    for (int i = 0;i < n;i ++)
    {
        res += s[i];
        res += "#";
    }

    //数组
    n = (int) res.size();
    vector<int> P(n,0);
    int mi = 0,right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值
    int maxLen = 0,maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点
    for (int i = 1;i < n;i ++)
    {
        P[i] = right > i ? min(P[2 * mi - i],right - i) : 1; //关键句，文中对这句以详细讲解
        while (res[i + P[i]] == res[i - P[i]]) {
            P[i] ++;
        }
        if (right < i + P[i]) //超过之前的最右端，则改变中心点和对应的最右端
        {
            right = i + P[i];
            mi = i;
        }
        if (maxLen < P[i]) //更新最大回文串的长度，并记下此时的点
        {
            maxLen = P[i];
            maxPoint = i;
        }
    }
    return s.substr((maxPoint - maxLen) / 2,maxLen - 1);
}

ll Manacher_n(string &s)
{
    //改造字符串
    int n = (int) s.size();
    string res = "$#";
    for (int i = 0;i < n;i ++)
    {
        res += s[i];
        res += "#";
    }

    //数组
    n = (int) res.size();
    vector<ll> P(n,0);
    ll mi = 0,right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值
    ll maxLen = 0,maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点
    
    ll ans = 0;
    for (ll i = 1;i < n;i ++)
    {
        P[i] = right > i ? min(P[2 * mi - i],right - i) : 1; //关键句，文中对这句以详细讲解
        while (res[i + P[i]] == res[i - P[i]]) {
            P[i] ++;
        }
        if (right < i + P[i]) //超过之前的最右端，则改变中心点和对应的最右端
        {
            right = i + P[i];
            mi = i;
        }
        if (maxLen < P[i]) //更新最大回文串的长度，并记下此时的点
        {
            maxLen = P[i];
            maxPoint = i;
        }
        ans += P[i] / 2;
    }
    return ans;
}



int main()
{
    string mod,str;
    cio
    int n;
    int l,r;
    int ok;
    int T;
    cin >> T;
    while (T --) {
        cin >> mod >> str;
        n = (int) mod.size();
        if (mod == str) {
            _C(Manacher_n(str));
        } else {
            for (l = 0;l < n;l ++) {
                if (str[l] != mod[l]) break;
            }
            for (r = n - 1;r >= 0;r --) {
                if (str[r] != mod[r]) break;
            }
            ok = 1;
            rep(i,l,r) {
                if (mod[i] != str[r - i + l]) {
                    ok = 0;
                    break;
                }
            }
            if (!ok) _C(0)
            else {
                for (int i = l - 1,j = r + 1;i >= 0 && j < n;j ++,i --,ok ++) {
                    if (mod[i] != mod[j]) break;
                }
                _C(ok);
            }
        }
    }

}
*/

/*
const int MAXN = 1e6 + 10;
unordered_map<int,ll> mp;
vector<int> vec[MAXN];
vector<int> g[MAXN];
ll cnt[MAXN];
int vis[MAXN];
int in[MAXN];
int vv[MAXN];

void bfs(int n) {
    queue<int> q;
    q.push(n);
    int t;
    while (!q.empty()) {
        t = q.front();
        q.pop();
        for (auto i : g[t]) {
            in[i] --;
            cnt[i] += cnt[t];
            if (!in[i]) q.push(i);
        }
    }
}

void dfs(int n)
{
    if (vv[n]) return;
    vv[n] = 1;
    for (auto i : g[n]) {
        in[i] ++;
        dfs(i);
    }
}

int main()
{
    int n;
    int t,k,tt;
    int x,y;
    ll v;
    ll mx;
    ll sum;
    __T {
        read(n);
        rep(i,1,n) {
            g[i].clear();
            vv[i] = vis[i] = in[i] = cnt[i] = 0;
            vec[i].clear();
        }
        mp.clear();
        rep(i,1,n) {
            read(t);
            if (t == 1) {
                if (i == n) {
                    sci(k);
                    rep(ii,1,k) {
                        read(tt);
                        mp[tt] ++;
                    }
                    vis[i] = 1;
                } else {
                    sci(k);
                    rep(ii,1,k) {
                        read(tt);
                        vec[i].push_back(tt);
                    }
                    vis[i] = 1;
                }
            } else {
                read(x);
                read(y);
                g[i].push_back(x);
                g[i].push_back(y);
            }
        }

        mx = 0;
        sum = 0;
        if (mp.size()) {
            for (auto j : mp) {
                mx = max(mx,j.second);
                sum += j.second;
            }
        } else {
            cnt[n] = 1;
            dfs(n);
            bfs(n);
            rep(i,1,n-1) {
                if (!cnt[i] || !vis[i]) continue;

                for (auto j : vec[i]) {
                    v = mp[j] += cnt[i];
                    mx = max(mx,v);
                    sum += cnt[i];
                }
            }
        }
        printf("%lld\n", mx * 2 <= sum ? sum : (sum - mx) * 2);

    }
    return 0;
}
*/

/*
8
1 1 1
1 2 2 2
2 1 2
1 3 3 3 3
2 3 4
1 4 4 4 4 4
2 3 6
2 5 7
*/

/*
// 线段树 - 二叉树，节点存的是一个 l，r，区间的内容n
const int MAXN = 1e5 + 10;

struct Node {
    int l,r;
    ll mx;
    ll mn;
    ll sum;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
ll a[MAXN];

void push_up(int i)
{
    tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;
    tree[i].mn = min(tree[i << 1].mn,tree[i << 1 | 1].mn);
    tree[i].mx = max(tree[i << 1].mx,tree[i << 1 | 1].mx);
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy == 1) {
        tree[i << 1].sum += (tree[i << 1].r - tree[i << 1].l + 1) * tree[i].lzn;
        tree[i << 1 | 1].sum += (tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1) * tree[i].lzn;
        
        tree[i << 1].mx += tree[i].lzn;
        tree[i << 1 | 1].mx += tree[i].lzn;
        
        tree[i << 1].mn += tree[i].lzn;
        tree[i << 1 | 1].mn += tree[i].lzn;
        
        tree[i << 1].lzn += tree[i].lzn;
        tree[i << 1 | 1].lzn += tree[i].lzn;
        
        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;
        
        tree[i].lazy = 0;
        tree[i].lzn = 0;
    } else if (tree[i].lazy == 2) {
        tree[i << 1].sum = (tree[i << 1].r - tree[i << 1].l + 1) * tree[i].lzn;
        tree[i << 1 | 1].sum = (tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1) * tree[i].lzn;
        
        tree[i << 1].mx = tree[i].lzn;
        tree[i << 1 | 1].mx = tree[i].lzn;
        
        tree[i << 1].mn = tree[i].lzn;
        tree[i << 1 | 1].mn = tree[i].lzn;
        
        tree[i << 1].lzn = tree[i].lzn;
        tree[i << 1 | 1].lzn = tree[i].lzn;
        
        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;
        
        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].sum = a[l]; // a原数组，把原来的数值给叶子结点
        tree[i].mx = a[l];
        tree[i].mn = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void add(int l,int r,ll x,int i) // 将区间[l,r]整个加上x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum += (tree[i].r - tree[i].l + 1) * x;
        tree[i].mx += x;
        tree[i].mn += x;
        tree[i].lzn += x;
        
        tree[i].lazy = 1;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) add(l,r,x,i << 1);
    if (r > m) add(l,r,x,i << 1 | 1);
    push_up(i);
}

void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum = (tree[i].r - tree[i].l + 1) * x;
        tree[i].mx = x;
        tree[i].mn = x;
        tree[i].lzn = x;
        
        tree[i].lazy = 2;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].sum;
//        return tree[i].mx;
//        return tree[i].mn;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll sum = 0;
//    ll mx = 0;
//    ll mn = INT_INF;
    if (l <= m) {
         sum += query(l,r,i << 1);
//         mx = max(mx,query(l,r,i << 1));
//         mn = min(mn,query(l,r,i << 1));
    }
    if (r > m) {
        sum += query(l,r,i << 1 | 1);
//        mx = max(mx,query(l,r,i << 1 | 1));
//        mn = min(mn,query(l,r,i << 1 | 1));
    }
    return sum;
//    return mx;
//    return mn;
}

int main()
{
    dscii(n,m);
    rep(i,1,n) scl(a[i]);
    build(1, n, 1);
    int k,a,b;
    ll c;
    while (m --) {
        sciii(k,a,b);
        if (k == 1) {
            printf("%lld\n",query(a, b, 1));
        } else if (k == 2) {
            scl(c);
            modify(a, b, c, 1);
            rep(i,1,n) printf("a[%d]=%lld\n",i,query(i, i, 1));
        }
    }
    re0;
}
*/

/*
int n,m;
char mp[110][110];

struct AZ
{
    int x,y;
    char c;
};

AZ A['z'][3];

struct Node {
    int x,y;
    int dis;
    int t;
    bool operator<(const Node &o) const {
        return dis > o.dis;
    }
};

int dis[110][110][3];
int vis[110][110][3];
int dx[] = {0,-1,0,1};
int dy[] = {1,0,-1,0};

void dij(int x,int y)
{
    priority_queue<Node> q;
    mem(dis,-1);
    mem(vis,0);

    int k = 1;
    if (mp[x][y] >= 'A' && mp[x][y] <= 'Z') k = 2;


    Node t;
    int xx,yy;
    q.push({x,y,dis[x][y][1] = dis[x][y][2] = 0,k}); // t=1跑周围，t=2跳跃


    AZ a1,a2;
    while (!q.empty()) {
        t = q.top();
        q.pop();
        if (vis[t.x][t.y][t.t]) continue;
        vis[t.x][t.y][t.t] = 1;

        if (t.t == 2) {
            a1 = A[mp[t.x][t.y]][1];
            a2 = A[mp[t.x][t.y]][2];
            if (t.x == a1.x && t.y == a1.y) {
                // goto 2
                xx = a2.x;
                yy = a2.y;
                if (dis[xx][yy][1] == -1 || dis[t.x][t.y][2] <= dis[xx][yy][1]) {
                    q.push({xx,yy,dis[xx][yy][1] = dis[t.x][t.y][2],1});
                }
            } else {
                // goto 1
                xx = a1.x;
                yy = a1.y;
                if (dis[xx][yy][1] == -1 || dis[t.x][t.y][2] <= dis[xx][yy][1]) {
                    q.push({xx,yy,dis[xx][yy][1] = dis[t.x][t.y][2],1});
                }
            }
        } else {
            rep(i,0,3) {
                xx = t.x + dx[i];
                yy = t.y + dy[i];
                if (xx >= 1 && yy >= 1 && xx <= n && yy <= m) {
                    if (mp[xx][yy] != '1') {
                        k = 1;
                        if (mp[xx][yy] >= 'A' && mp[xx][yy] <= 'Z') k = 2;
                        
                        if (dis[xx][yy][k] == -1 || dis[t.x][t.y][1] + 1 < dis[xx][yy][k]) {
                            q.push({xx,yy,dis[xx][yy][k] = dis[t.x][t.y][1] + 1,k});
                        }
                        
                    }
                }
            }
        }
    }
}

int main()
{
    int v['z'] = {0};
    int k;
    scii(n,m);
    rep(i,1,n) {
        scanf(" ");
        rep(j,1,m) {
            scanf("%c",&mp[i][j]);
            if (mp[i][j] >= 'A' && mp[i][j] <= 'Z') {
                k = 1;
                if (v[mp[i][j]]) k ++;
                v[mp[i][j]] = 1;
                A[mp[i][j]][k] = {i,j,mp[i][j]};
            }
        }
    }
    dij(1,1);

    // rep(i,1,n) {
    //     rep(j,1,m) printf("%d ",dis[i][j]);
    //     puts("");
    // }

    int ans = -1;
    if (dis[n][m][1] != -1) ans = dis[n][m][1];
    if (dis[n][m][2] != -1) {
        if (ans == -1) ans = dis[n][m][2];
        else ans = min(ans,dis[n][m][2]);
    }

    if (ans == -1) puts("No Solution.");
    else printf("%d\n",ans);
    return 0;
}
*/

/*
int main()
{
    int n;
    int s;
    while (~sci(n)) {
        s = 1;
        while (n > 1) {
            if (s) n = n / 9 + (n % 9 ? 1 : 0);
            else n = n / 2 + n % 2;
            s = 1 - s;
        }
        puts(!s ? "Stan wins." : "Ollie wins.");
    }
    
    return 0;
}
*/
/*
int main()
{
    int n;
    int a[1010];
    int t;
    int mx = -1;
    int ans;
    __T {
        sci(n);
        mem(a,0);
        rep(i,1,n) {
            sci(t);
            a[t] ++;
        }
        mx = -1;
        ans = -1;
        rep(i,1,1000) {
            if (mx == -1) {
                mx = a[i];
                ans = i;
            } else if (mx == a[i]) {
                ans = -1;
            } else if (a[i] > mx) {
                mx = a[i];
                ans = i;
            }
        }
        if (ans != -1) printf("%d\n",ans);
        else puts("Nobody");
        
    }
    
}
*/

/*
int main()
{
    int s,m,d;
    pair<int,string> k1[110];
    pair<int,string> k2[110];
    pair<int,string> k3[110];
    int m1,m2,m3;
    int ans;
    __T {
        sciii(s,m,d);
        rep(i,1,s) {
            cin >> k1[i].second >> k1[i].first;
        }
        sort(k1 + 1, k1 + 1 + s);
        
        rep(i,1,m) {
            cin >> k2[i].second >> k2[i].first;
        }
        sort(k2 + 1, k2 + 1 + m);
        
        rep(i,1,d) {
            cin >> k3[i].second >> k3[i].first;
        }
        sort(k3 + 1, k3 + 1 + d);
        
        m1 = s / 2 + 1;
        m2 = m / 2 + 1;
        m3 = d / 2 + 1;
        
        ans = k1[m1].first + k2[m2].first + k3[m3].first;
        printf("%d ",ans);
        cout << k1[m1].second << " " << k2[m2].second << " " << k3[m3].second << endl;
    }
    re0;
}
*/

/*
ll a[100000];
ll t[100000];
ll p[1000010];

int main()
{
    int n;
    ll k;
    ll m;
    ll ans = 0;
    __T {
        sci(n);
        rep(i,1,n) {
            scl(a[i]);
            p[a[i]] = 0;
            t[i] = 0;
        }
        
        for (ll i = 1;i <= n;i ++) {
            if (p[a[i]] != 0) {
                t[i] -= p[a[i]] * (n - i + 1);
            }
            p[a[i]] = i;
//            printf("%lld ",t[i]);
        }
        
//        puts("");
        
        ans = 0;
        k = n - 2;
        m = n;
        rep(i,1,n) {
//            _C(m)
            t[i] += m;
            ans += a[i] * t[i];
            m += k;
            k -= 2;
        }
        printf("%lld\n",ans);
    }
}
*/

/*
struct Node {
    double s;
    int id,pid;
};

int cmp1(const Node &a,const Node &b) {
    return a.s > b.s;
}

int cmp2(const Node &a,const Node &b) {
    return a.id < b.id;
}


int main()
{
    int n,q,s,c;
    // n 队伍
    // q 服务器
    // s score
    // c chk points
    int a;
    Node rs[110];
    
    
    int ss[110][15];
    set<pair<int,int>> ato[110];
    int atk,dfd,svs;
    
    
    int rp[110][15];
    
    
    int u,tt,cnt;
    double all;
    
    
    
    __T {
        scii(n,q);
        scii(s,c);
        rep(i,1,n) {
            rs[i].s = s;
            rs[i].id = i;
        }
        
        rep(ii,1,c) {
            mem(ss,0);
            rep(i,1,n) ato[i].clear();
            
            // attack
            
            sci(a);
            rep(i,1,a) {
                sciii(atk,dfd,svs);
                if (ato[atk].find(mpair(dfd,svs)) == ato[atk].end()) ss[dfd][svs] ++;
                ato[atk].insert(mpair(dfd,svs));
            }
            
            rep(i,1,n) {
                rep(j,1,q) {
                    if (ss[i][j]) rs[i].s -= n - 1;
                }
                for (auto j : ato[i]) {
                    rs[i].s += (n - 1) / (double) ss[j.first][j.second];
                }
            }
            
            // repair
            rep(i,1,q) {
                all = 0;
                cnt = 0;
                rep(j,1,n) {
                    sci(rp[i][j]);
                    if (!rp[i][j]) {
                        rs[j].s -= n - 1;
                        all += n - 1;
                    } else cnt ++;
                }
                rep(j,1,n) {
                    if (rp[i][j]) {
                        rs[j].s += all / (double) cnt;
                    }
                }
            }
//
//            rep(i,1,n) {
//                ok = 1;
//                rep(j,1,q) {
//                    if (!rp[j][i]) ok = 0;
//                }
//                if (ok) cnt ++;
//            }
//
//            rep(i,1,n) {
//                ok = 1;
//                rep(j,1,q) {
//                    if (!rp[j][i]) ok = 0;
//                }
//                if (ok) rs[i].s += all / (double) cnt;
//            }
            
            
            
            // query
            sort(rs + 1, rs + 1 + n, cmp1);
            rs[1].pid = 1;
            rep(i,2,n) {
                if (abs(rs[i].s - rs[i - 1].s) <= 1e-6) rs[i].pid = rs[i - 1].pid;
                else rs[i].pid = i;
            }
            
            sort(rs + 1, rs + 1 + n, cmp2);
            
            sci(u);
            rep(i,1,u) {
                sci(tt);
                printf("%.8f %d\n",rs[tt].s,rs[tt].pid);
            }
        }
        
        
    }
    re0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main() {
    int n,m;
    int a[MAXN];
    int cnt;
    int mn = -1;
    ll ans;
    __T {
        scii(n,m);
        cnt = 0;
        rep(i,1,n) {
            sci(a[i]);
            if (!a[i]) cnt ++;
        }
        if (n == m) {
            puts("Richman");
            continue;
        }
        if (cnt > m) {
            puts("Impossible");
            continue;
        }
        m -= cnt;
        mn = -1;
        ans = 0;
        rep(i,1,n) {
            if (!a[i]) continue;
            if (m > 0) {
                ans += a[i];
                m --;
            } else {
                if (mn == -1) mn = a[i];
                else mn = min(mn,a[i]);
            }
        }
        printf("%lld\n",ans + mn - 1);
        
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    string a,b;
    int aa[1000010];
    int cnt = 0;
    int c1;
    int idx;
    __T {
        sci(n);
        cin >> a >> b;
        c1 = cnt = 0;
        idx = -1;
        rep(i,0,n-1) {
            aa[i + 1] = (a[i] != b[i]);
//            printf("%d",aa[i + 1]);
            if (aa[i + 1]) {
                c1 ++;
                if (idx == -1) idx = i + 1;
            }
        }
//        puts("");
        if (aa[n]) cnt ++;
        rep(i,1,n) {
            if (aa[i] != aa[i - 1] && aa[i - 1]) cnt ++;
        }
//        _C(cnt)
        if (cnt == 2) printf("6\n");
        else if (cnt == 0) {
            printf("%lld\n",(n + 1LL) * n / 2);
        } else if (cnt == 1) {
            printf("%d\n",(n - 1) * 2);
        } else printf("0\n");
    }
    re0;
}
*/

/*
inline double func(double x) {
    return 1 - x - sin(x);
}

int main()
{
    double l = 0,r = 1;
    const double exp = 5e-5;
    double m;
    int cnt = 0;
    while (r - l > exp) {
        m = (l + r) / 2;
        if (func(m) * func(l) < 0) r = m;
        else l = m;
        cnt ++;
    }
    printf("%d %f\n",cnt,l);
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

ll t[55];
ll a[MAXN];

int main()
{
    int n;
    ll x;
    ll ans;
    __T {
        sci(n);
        mem(t,0);
        rep(i,1,n) {
            scl(a[i]);
            for (ll j = 1,k = 1;j <= 1e9;j <<= 1,k ++) {
                if (a[i] >= (j << 1) && a[i] % (j << 1) < j) t[k] ++;
            }
        }
        ans = 0;
        rep(i,1,n) {
            x = log2(a[i]);
            x ++;
            ans += t[x];
        }
        printf("%lld\n",ans);
    }
    
    re0;
}
*/

/*
int main()
{
    map<double,ll> ka;
    ll kb;
    
    ll x1,x2,y1,y2;
    int n;
    ull cnt;
    map<pair<double,double>,ll> sameA;
    map<ll,ll> sameB;
    pair<double,double> l;
    double k;
    ll ans;
    __T {
        kb = cnt = 0;
        sci(n);
        ka.clear();
        sameB.clear();
        sameA.clear();
        rep(ii,1,n) {
            scll(x1,y1);
            scll(x2,y2);
            if (x1 - x2 == 0) {
                kb ++;
                cnt += sameB[x1] ++;
            }
            else {
                ka[k = (y1 - y2) / (double) (x1 - x2)] ++;
                
                l = make_pair(k, (x1 * y2 - x2 * y1) / (double) (x1 - x2));
                cnt += sameA[l] ++;
            }
        }

        ans = 0;
        ans += (n - kb) * kb;
        for (auto i : ka) {
            ans += (n - i.second) * i.second;
        }
        printf("%lld\n",ans / 2 + cnt);
    }
    return 0;
}
*/

/*
struct Node {
    ll l,r;
};

int cmp(const Node &a,const Node &b) {
    return a.r < b.r;
}

int cmp1(const Node &a,const Node &b) {
    return a.l < b.l;
}

int n;

ll get(Node *lx,Node *rx)
{
    ll sumx,subx[100010];
    ll ok;
    ll m1,m2;
    
    sort(rx + 1,rx + 1 + n,cmp);
    sort(lx + 1,lx + 1 + n,cmp1);
    
    subx[n] = lx[n].l;
    pre(i,n - 1,1) subx[i] = subx[i + 1] + lx[i].l;
    
    sumx = 0;
    m1 = -1;
    for (int i = 1,j = 1;i <= n ;i ++) {
        ok = 0;
        while (j <= n) {
            if (lx[j].l > rx[i].r) {
                ok = subx[j];
                break;
            }
            j ++;
        }
        ok -= (n - j + 1) * rx[i].r;
        
        ok += rx[i].r * (i - 1);
        ok -= sumx;
        
        if (m1 == -1) m1 = ok;
        else m1 = min(m1,ok);
        
        sumx += rx[i].r;
    }
            
            
    subx[1] = rx[1].r;
    rep(i,2,n) subx[i] = subx[i - 1] + rx[i].r;
    
    sumx = 0;
    m2 = -1;
    for (int i = n,j = n;i >= 1;i --) {
        ok = 0;
        while (j >= 1) {
            if (rx[j].r < lx[i].l) {
                ok = subx[j];
                break;
            }
            j --;
        }
        ok = j * lx[i].l - ok;
        
        ok -= lx[i].l * (n - i);
        ok += sumx;
        
        if (m2 == -1) m2 = ok;
        else m2 = min(m2,ok);
                
        sumx += lx[i].l;
    }
    return min(m1,m2);
}

int main()
{
    Node lx[100010];
    Node rx[100010];
    
    Node ly[100010];
    Node ry[100010];
    int x1,x2,y1,y2;
    
    __T {
        sci(n);
        rep(i,1,n) {
            scii(x1,y1);
            scii(x2,y2);
            lx[i] = {x1,x2};
            rx[i] = {x1,x2};
            ly[i] = {y1,y2};
            ry[i] = {y1,y2};
        }
        printf("%lld\n",get(lx,rx) + get(ly,ry));
    }
    return 0;
}
*/

/*
ll quickpow(ll a, ll b, ll n)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) {
            if (a == -1) return -1;
            ans = a * ans;
            if (ans >= n) return -1;
        }
        if (a != -1) a = a * a;
        if (a >= n) a = -1;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n,k;
    ll m,l;
    ll ans;
    int i;
    int T = 1;
    __T  {
        scii(n,k);
        if (k == 1) {
            printf("Case #%d: %d\n",T ++,n);
            continue;
        }
        l = 1;
        ans = 0;
        for (i = 2;i <= n;i ++) {
            m = quickpow(i, k, n);
            if (m == -1) break;
            ans += ((m - 1) - l) / (i - 1) + 1;
            l = m;
        }
        ans += (n - l) / (i - 1) + 1;
        printf("Case #%d: %lld\n",T ++,ans);
    }
}
*/

/*
struct Node {
    int n;
    int i;
};

int cmp(const Node &a,const Node &b) {
    return a.n < b.n;
}

int main()
{
    int n,max1;
    ll p;
    Node a[400010];
    int vis[200010];
    Node l,r;
    int li,ri;
    int start;
    int ans;
    int m;
    int T = 1;
    __T {
        max1 = 0;
        sci(n);
        scl(p);
        for (int i = 1,j = 1;i <= n;i ++) {
            sci(a[j ++].n);
            a[j - 1].i = i;
            sci(a[j ++].n);
            a[j - 1].i = i;
            max1 = max(max1,a[j-1].n);
            vis[i] = 0;
        }
        
        
        sort(a + 1,a + 1 + n * 2,cmp);
        
        
        m = ans = 0;
        start = n * 2;
        pre(i,n*2,1) {
            if (a[i].n >= max1) {
                l = {(int) ceil(a[i].n * p / 100.0)};
                r = {a[i].n};
//                _C(">>" << a[i].n)
//                _C(l.n << " " << r.n)
                li = (int) (lower_bound(a + 1, a + 1 + n * 2, l, cmp) - a);
                ri = i;
//                _C("lr> " << li << " " << ri)
                
                pre(j,start,li) {
                    if (!vis[a[j].i]) m ++;
                    vis[a[j].i] ++;
                }
                start = li - 1;
//                _C("m1=" << m)
                if (i + 1 <= n * 2) {
                    vis[a[i + 1].i] --;
//                    _C(vis[a[i + 1].i])
                    if (!vis[a[i + 1].i]) m --;
                }
//                _C("m2=" << m)
                ans = max(ans,m);
            } else break;
        }
        printf("Case #%d: %d\n",T ++, ans);
    }
}
*/

/*
int main()
{
    string str;
    int s;
    int ans;
    __T {
        cin >> str;
        s = str[0] ^ 48;
        ans = 10 * (s - 1);
        for (int i = 0;str[i];i ++) ans += (i + 1);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int a[5010];
    int vis[5010];
    int ok;
    __T {
        sci(n);
        ok = 1;
        rep(i,1,n) {
            sci(a[i]);
            vis[i] = 0;
            if (i != 1) {
                if (a[i] != a[i - 1]) ok = 0;
            }
        }
        if (ok) {
            puts("NO");
            continue;
        }
        puts("YES");
        rep(i,2,n) {
            if (a[i] != a[1]) {
                printf("1 %d\n",i);
                vis[i] = 1;
            }
        }
        rep(i,2,n) {
            if (vis[i]) {
                rep(j,2,n) {
                    if (!vis[j]) {
                        printf("%d %d\n",i,j);
                    }
                }
                break;
            }
        }
    }
    return 0;
}
*/

/*
int cmp(const pair<int,int> &a,const pair<int,int> &b) {
    if (a.second == b.second) return a.first < b.first;
    return a.second < b.second;
}

int main()
{
    
    int n,q;
    scii(n,q);
    pair<int,int> px[2010];
    pair<int,int> py[2010];
    rep(i,1,n) {
        scii(px[i].first,px[i].second);
        py[i] = px[i];
    }
    sort(px + 1,px + 1 + n);
    sort(py + 1,py + 1 + n,cmp);
    int u,v;
    int cnt;
    while (q --) {
        scii(u,v);
        cnt = 0;
        rep(i,1,n) {
            
        }
    }
    return 0;
}
*/


/*
int n,m;

const int MAXN = 500010;

struct Edge {
    Edge(){}
    Edge(int to,int nxt,int v):to(to),nxt(nxt),v(v){}
    int to;
    int nxt;
    int v;
} e[MAXN * 2];
int g[MAXN];

int cnt = 0;

void init()
{
    cnt = 0;
    mem(g,-1);
}

void add(int u,int v)
{
    e[cnt] = Edge(v,g[u],-1);
    g[u] = cnt ++;
}

int vis[MAXN];
int dps[MAXN];
vector<ll> cc;

void dfs(int k,int f,int d)
{
    if (vis[k]) {
        cc.pb(d - dps[k]);
        return;
    }
    vis[k] = 1;
    dps[k] = d;
    for (int i = g[k];~i;i = e[i].nxt) {
        if (e[i].to == f || dps[e[i].to] > d) continue;
        dfs(e[i].to,k,d + 1);
    }
}

const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    scii(n,m);
    init();
    int u,v;
    rep(i,1,m) {
        scii(u,v);
        add(u,v);
        add(v,u);
    }
    rep(i,1,n) {
        if (vis[i]) continue;
        dfs(i,-1,0);
    }
    ll ans = 1;
    ll s = 0;
    for (auto i : cc) {
        s += i;
        ans *= (quickpow(2, i) + mod - 1) % mod;
        ans %= mod;
    }
    
    ans *= quickpow(2, m - s);
    printf("%lld\n",ans % mod);
    re0;
}
*/

/*
char str[100010];

int get(char a[],char b[]) {
    if (a[0] == b[0] && a[1] == b[1] && a[2] == b[2]) return 0;
    if(a[1] == b[0] && a[2] == b[1]) return 1;
    if(a[2] == b[0]) return 2;
    return 3;
}

ll dp[100010][7];

struct Node {
    int n;
    char str[7][3];
} x['Z' + 1];

int main()
{
    x['Y'] = {1,{
        {'Q','Q','Q'}
    }};
    x['V'] = {3,{
        {'Q','Q','W'},
        {'Q','W','Q'},
        {'W','Q','Q'},
    }};
    x['G'] = {3,{
        {'Q','Q','E'},
        {'Q','E','Q'},
        {'E','Q','Q'},
    }};
    x['C'] = {1,{
        {'W','W','W'},
    }};
    x['X'] = {3,{
        {'Q','W','W'},
        {'W','W','Q'},
        {'W','Q','W'},
    }};
    x['Z'] = {3,{
        {'W','E','W'},
        {'W','W','E'},
        {'E','W','W'},
    }};
    x['T'] = {1,{
        {'E','E','E'},
    }};
    x['F'] = {3,{
        {'Q','E','E'},
        {'E','E','Q'},
        {'E','Q','E'},
    }};
    x['D'] = {3,{
        {'W','E','E'},
        {'E','W','E'},
        {'E','E','W'},
    }};
    x['B'] = {6,{
        {'Q','E','W'},
        {'Q','W','E'},
        {'W','Q','E'},
        {'W','E','Q'},
        {'E','Q','W'},
        {'E','W','Q'},
    }};
    char ch;
    int n = 0;
    while ((ch = getchar()) != '\n') {
        str[n ++] = ch;
    }
    str[n] = '\0';
//    puts(str);
    mem(dp,-1);
    REP(i,0,6) {
        dp[0][i] = 3;
    }
//    REP(j,0,6) {
//        printf("%lld ",dp[0][j]);
//    }
//    puts("");
    
//    _C(n)
    
    REP(i,1,n) {
        REP(j,0,x[str[i - 1]].n) {
            REP(k,0,x[str[i]].n) {
                if (dp[i][k] == -1) dp[i][k] = dp[i - 1][j] + get(x[str[i - 1]].str[j],x[str[i]].str[k]);
                else dp[i][k] = min(dp[i - 1][j] + get(x[str[i - 1]].str[j],x[str[i]].str[k]),dp[i][k]);
            }
        }
//        REP(j,0,6) {
//            printf("%lld ",dp[i][j]);
//        }
//        puts("");
    }
    ll ans = -1;
    REP(i,0,6) {
        if (dp[n - 1][i] != -1) {
            if (ans == -1) ans = dp[n - 1][i];
            else ans = min(ans,dp[n - 1][i]);
        }
    }
    printf("%lld\n",ans + n);
}
*/

/////kmp
/*
const int MAXN = 1e6 + 10;
string str;
string p;
int n;
int m;

int nxt[MAXN];

void make()
{
    // nxt(标号从[1,m]，m是匹配串长度)数组意义：nxt[i]是取出从1到i的前缀，对于这个前缀s，存在一个它的子串t，并且t != s，同时t既是s的前缀又是s的后缀，nxt[i] = max(|t|)。
    nxt[0] = -1;
    nxt[1] = 0;
    for (int i = 0,k = -1;i < m;)
    {
        if (k == -1 || p[i] == p[k]) nxt[++ i] = ++ k;
        else k = nxt[k];
    }
}

int kmp()
{
    int ok = 0;
    make();
    
    //int f = 0;
    for (int i = 0,j = 0;i < n;)
    {
        if (str[i] == p[j]) {
            j ++;
            i ++;
            if (j == m) {
                //printf("Found: %lu\n",i - m); // 找到一个p串在str串中的下标
                ok ++;
                //f = 1;
                j = nxt[j];
            }
        }
        else {
            if (j == 0) i ++;
            j = nxt[j];
        }
        
    }
    //if (!f) printf("Not Found!\n");
    return ok;
}

int main()
{
    cin >> str >> p;
    n = (int) str.size();
    m = (int) p.size();
    printf("%d\n",kmp());
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int main()
{
    int f,n;
    scii(f,n);
    int nxt[MAXN];
    int a[MAXN];
    
    int addr,num,next;
    
    mem(nxt,-1);
    rep(i,1,n) {
        sciii(addr,num,next);
        a[addr] = num;
        nxt[addr] = next;
    }
    
    int vis[10010] = {0};
    int ff = -1;
    int cc = ff;
    
    int c = f;
    int l = -1;
    while (c != -1) {
        if (vis[abs(a[c])]) {
            nxt[l] = nxt[c];
            if (ff == -1) {
                ff = c;
                cc = c;
            } else {
                nxt[cc] = c;
                cc = c;
            }
        } else l = c;
        vis[abs(a[c])] = 1;
        c = nxt[c];
        nxt[cc] = -1;
    }
    c = f;
    while (c != -1) {
        printf("%05d %d ",c,a[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    c = ff;
    while (c != -1) {
        printf("%05d %d ",c,a[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    return 0;
}
*/

/*
int main()
{
    int na,nb;
    
    vector<pair<int,int>> a;
    vector<pair<int,int>> b;
    int x,y;
    
    sci(na);
    rep(i,1,na) {
        scii(x,y);
        a.pb(mpair(x,y));
    }
    
    sci(nb);
    rep(i,1,nb) {
        scii(x,y);
        b.pb(mpair(x,y));
    }
    
    int multy[10010];
    int add[10010];
    
    mem(multy,0);
    for (auto i : a) {
        for (auto j : b) {
            multy[i.second + j.second + 3000] += i.first * j.first;
        }
    }
    int f = 1;
    pre(i,10000,0) {
        if (multy[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d %d",multy[i],i - 3000);
        }
    }
    if (f) printf("0 0");
    puts("");
    
    mem(add,0);
    for (auto i : a) {
        add[i.second + 3000] += i.first;
    }
    for (auto i : b) {
        add[i.second + 3000] += i.first;
    }
    
    f = 1;
    pre(i,10000,0) {
        if (add[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d %d",add[i],i - 3000);
        }
    }
    if (f) printf("0 0");
    puts("");
    return 0;
}
*/

/*
const int MAXN = 100010;

int main()
{
    int f,n,k;
    sciii(f,n,k);
    int num[MAXN];
    int nxt[MAXN];
    int pre[MAXN];
    
    int addr,nn,nt;
    
    int last = -1;
    rep(i,1,n) {
        sciii(addr,nn,nt);
        num[addr] = nn;
        nxt[addr] = nt;
    }
    
    int c = f;
    int cc = 0;
    while (c != -1) {
        pre[c] = last;
        last = c;
        c = nxt[c];
        cc ++;
    }
    n = cc;
    
    int cnt = 0;
    int ff = f;
    int sf = 0;
    c = f;
//    int cc;
    
    int x = 0;
    int mx = n / k;
    last = -1;
    while (c != -1) {
        cnt ++;
        nt = nxt[c];
        
        if (x < mx) swap(nxt[c],pre[c]);
        
        if (cnt == k) {
            swap(pre[c],nxt[f]);
            if (nt != -1) pre[nt] = c;
            if (last != -1) nxt[last] = c;
            last = f;
            f = nt;
            if (!sf) {
                sf = 1;
                ff = c;
            }
            cnt = 0;
            x ++;
            
        }
        c = nt;
    }
    
    c = ff;
    while (c != -1) {
        printf("%05d %d ",c,num[c]);
        if (nxt[c] == -1) printf("-1");
        else printf("%05d",nxt[c]);
        puts("");
        c = nxt[c];
    }
    
    re0;
}
*/


// AC自动机
// 给定n个模式串s_i和一个文本串t，求有多少个不同的模式串在文本串里出现过。两个模式串不同当且仅当他们编号不同。

/*
const int MAXN = 5e5 + 10;

struct AC_Auto {
    int next[MAXN][26],fail[MAXN],end[MAXN];
    int root,cnt;

    inline int newNode() {
        for (int i = 0;i < 26;i ++) next[cnt][i] = -1;
        end[cnt ++] = 0;
        return cnt - 1;
    }
    void init() {
        cnt = 0;
        root = newNode();
    }

    void insert(char str[]) {
        int len = (int) strlen(str);
        int now = root;
        for (int i = 0;i < len;i++) {
            if (next[now][str[i] - 'a'] == -1) next[now][str[i] - 'a'] = newNode();
            now = next[now][str[i] - 'a'];
        }
        end[now] ++;
    }

    void build() {
        queue<int> q;
        fail[root] = root;
        for(int i = 0;i < 26;i++)
        {
            if (next[root][i] == -1) next[root][i] = root;
            else
            {
                fail[next[root][i]] = root;
                q.push(next[root][i]);
            }
        }
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            for (int i = 0;i < 26;i++)
            {
                if (next[now][i] == -1) next[now][i] = next[fail[now]][i];
                else
                {
                    fail[next[now][i]] = next[fail[now]][i];
                    q.push(next[now][i]);
                }
            }
        }
    }

    int query(char *s) {
        int len = (int) strlen(s);
        int now = 0,ans = 0;
        for (int i = 0;i < len;i ++){
            now = next[now][s[i] - 'a'];
            for (int t = now;t && ~end[t];t = fail[t]) {
                ans += end[t];
                end[t] = -1;
            }
        }
        return ans;
    }

    void debug() {
        for (int i = 0;i < cnt;i ++) {
            printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]);
            for (int j = 0;j < 26;j ++) printf("%2d",next[i][j]);
            printf("]\n");
        }
    }
};

AC_Auto ac;
char str[MAXN << 1];

int main()
{
    int n;
    __T {
        scanf("%d",&n);
        ac.init();
        rep(i,1,n) {
            scanf("%s",str);
            ac.insert(str);
        }
        ac.build();
        scanf("%s",str);
        printf("%d\n",ac.query(str));
    }
    return 0;
}
*/

//
//int n = 2,m = 2;
//
//// 0 u
//// 1 d
//// 2 l
//// 3 r
//
//int vis[110][110] = {0};
//int ans = 0;
//
//void dfs(int i,int j,int dir,int cnt)
//{
//    _C(i << " " << j)
//    if (vis[i][j]) return;
//    vis[i][j] = 1;
//    if (cnt == n * m) {
//        ans ++;
//        return;
//    }
//    int ii,jj;
//    switch (dir) {
//        case 0:
//            ii = i;
//            jj = j + 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,cnt + 1);
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,cnt + 1);
//            break;
//        case 1:
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,cnt + 1);
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,cnt + 1);
//            break;
//        case 2:
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,cnt + 1);
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,cnt + 1);
//            break;
//        case 3:
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,cnt + 1);
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,cnt + 1);
//            break;
//        default:
//            break;
//    }
//    vis[i][j] = 0;
//}
//
//int main()
//{
//    int ii,jj;
//    rep(i,1,n) {
//        rep(j,1,m) {
//            vis[i][j] = 1;
//
//            ii = i - 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,0,2);
//            puts("");
//            ii = i + 1;
//            jj = j;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,1,2);
//            puts("");
//            ii = i;
//            jj = j - 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,2,2);
//            puts("");
//            ii = i;
//            jj = j + 1;
//            if (ii >= 1 && jj >= 1 && ii <= n && jj <= m) dfs(ii,jj,3,2);
//            puts("");
//            puts("");
//
//            vis[i][j] = 0;
//        }
//    }
//    _C(ans)
//    return 0;
//}
//
//

/*
int main()
{
    int n,m;
    int ans;
    int T = 1;
    __T {
        scii(n,m);
        if (m < n) swap(m, n);
        
        if (n == 1) {
            if (m == 1) ans = 1;
            else ans = 2;
        }
        else if (n == 2) {
            ans = 2 * m;
        } else {
            ans = (n - 2) * 2 + (m - 2) * 2 + 4;
        }
        printf("Case #%d: %d\n",T++,ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int T = 1;
    __T {
        sci(n);
        printf("Case #%d:\n",T ++);
        puts("YES");
        rep(i,1,n) {
            rep(j,i,n) {
                printf("%d %d %d %d %d %d %d %d\n",i,j, 0,j,i , 1,j,i);
            }
        }
    }
    re0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    int a[100010];
    int x;
    ll pre[100010],sub[100010];
    ll ans = 1;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        pre[1] = a[1];
        sub[n] = a[n];
        rep(i,2,n) pre[i] = gcd(a[i],pre[i - 1]);
        pre(i,n - 1,1) sub[i] = gcd(a[i],sub[i + 1]);
        ans = 1;
        rep(i,1,n) {
            if (i == 1) ans = max(ans,sub[i+1]);
            else if (i == n) ans = max(ans,pre[i-1]);
            else ans = max(ans,gcd(pre[i-1],sub[i+1]));
        }
        printf("%d\n",ans);
    }
}*/

/*
struct Node {
    ll pos,c;
    bool operator<(const Node &o) const {
        return pos < o.pos;
    }
};

ll dp[3010][3010];
ll m[3010];
ll jj[3010];

int main()
{
    int n;
    Node a[3010];
    ll pos,c;
    ll ans;
    int t1,t2;
    int last;
    while (~sci(n)) {
        rep(i,1,n) {
            scll(pos,c);
            a[i].pos = pos;
            a[i].c = c;
        }
        sort(a + 1,a + 1 + n);
        jj[1] = m[1] = dp[1][1] = a[1].c;
        

        rep(i,2,n) {
            m[i] = (dp[i][i-1] = jj[i-1] + a[i].pos - a[i-1].pos);
            rep(j,1,i-2) {
                dp[i][j] = dp[i-1][j] + a[i].pos - a[j].pos;
                m[i] = min(m[i],dp[i][j]);
            }
            jj[i] = m[i - 1] + a[i].c;
            m[i] = min(m[i],jj[i]);
        }
        printf("%lld\n",m[n]);
    }
    re0;
}
*/


//
//int main() {
//    string c[10];
//    int a[10];
//    int b[10];
//    const int x = 1 << 5;
//    int niu,niu_cnt,no;
//    int ok1 = 0;
//    int t;
//    __T {
//        rep(i,1,5) cin >> c[i];
//        rep(i,1,5) {
//            if (c[i] == "A") a[i] = 1;
//            else if (c[i] == "10" || c[i] == "J" || c[i] == "K" || c[i] == "Q") a[i] = 10;
//            else a[i] = c[i][0] ^ 48;
//            _C(a[i])
//        }
//
//        rep(i,1,5) cin >> c[i];
//        rep(i,1,5) {
//            if (c[i] == "A") b[i] = 1;
//            else if (c[i] == "10" || c[i] == "J" || c[i] == "K" || c[i] == "Q") b[i] = 10;
//            else b[i] = c[i][0] ^ 48;
//            _C(b[i])
//        }
//
//        ok1 = -1;
//
//        REP(i,0,x) {
//            niu = 0;
//            niu_cnt = 0;
//            no = 0;
//            for (int j = i,k = 1;k <= 5;k ++,j >>= 1) {
//                if (j & 1) {
//                    niu_cnt ++;
//                    niu += a[k];
//                } else no += a[k];
//            }
//            if (niu_cnt == 3) {
//                if (niu % 10 == 0) {
//                    t = no % 10;
//                    if (ok1 == -1 || t == 0) ok1 = t;
//                    else if (ok1 != 0) ok1 = max(ok1,t);
//                }
//            }
//        }
//    }
//    re0;
//}

/*
const double esp = 5e-5;

inline double f(double x) {
    return x * x * x - 2 * x - 5;
}

int main()
{
    double l = 2,r = 3;
    double m;
    while (r - l > esp) {
        m = (l + r) / 2;
        if (f(m) * f(l) < 0) r = m;
        else l = m;
    }
    printf("%f\n",l);
    return 0;
}
*/

/*
const double esp = 1e-4;

inline double f(double x) {
    return x * x * x + 10 * x - 20;
}

int main()
{
    double l = 1,r = 2;
    double m;
    while (r - l > esp) {
        m = (l + r) / 2;
        if (f(m) * f(l) < 0) r = m;
        else l = m;
    }
    printf("%f\n",l);
    return 0;
}
*/

/*
const int MAXN = 1e7 + 10;

int is_prime[MAXN];
int is_prime_small[MAXN];

void segment_sieve(ll a,ll b)
{
    for (ll i = 0;i * i <= b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i <= b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i <= b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j <= b;j += i) is_prime_small[j] = 0;
            for (ll j = max(2LL,(a + i - 1) / i) * i; j <= b;j += i) is_prime[j - a] = 0;
        }
    }
}

ll primes[MAXN];

int main()
{
    ll l,r;
    int cnt;
    ll ln,lx,lnl,lnr,lxl,lxr;
    ll t;
    int cc;
    while (~scll(l,r)) {
        cnt = 0;
        segment_sieve(l, r);
        for (ll i = 0;i <= r - l;i ++) {
            if (is_prime[i]) {
                primes[cnt ++] = i + l;
            }
        }
        ln = -1;
        lx = -1;
        
        cc = 0;
        if (primes[0] != 1) cc ++;
        
        REP(i,1,cnt) {
            if (primes[i] != 1) cc ++;
            if (primes[i] == 1 || primes[i - 1] == 1) continue;
            
            t = primes[i] - primes[i - 1];
            if (ln == -1 || t < ln) {
                ln = t;
                lnl = primes[i-1];
                lnr = primes[i];
            }
            if (t > lx) {
                lx = t;
                lxl = primes[i-1];
                lxr = primes[i];
            }
        }
        if (cc < 2) {
            printf("There are no adjacent primes.\n");
            continue;
        }
        printf("%lld,%lld are closest, %lld,%lld are most distant.\n",lnl,lnr,lxl,lxr);
    }
}
*/

/*
const int S = 9; //随机算法判定次数，一般8~10就够了

// 计算ret = (a*b)%c a,b,c < 2^63
long long mult_mod(ll a,ll b,ll c)
{
    a %= c;
    b %= c;
    ll ret = 0;
    ll tmp = a;
    while (b) {
        if (b & 1) {
            ret += tmp;
            if (ret > c)ret -= c;//直接取模慢很多
        }
        tmp <<= 1;
        if (tmp > c) tmp -= c;
        b >>= 1;
    }
    return ret;
}

// 计算 ret = (a^n)%mod
long long pow_mod(ll a,ll n,ll mod)
{
    ll ret = 1;
    ll temp = a % mod;
    
    while (n)
    {
        if (n & 1) ret = mult_mod(ret,temp,mod);
        temp = mult_mod(temp,temp,mod);
        n >>= 1;
    }
    return ret;
}
    
// 通过 a^(n-1)=1(mod n)来判断n是不是素数
// n-1 = x*2^t 中间使用二次判断
// 是合数返回true, 不一定是合数返回false
bool check(ll a,ll n,ll x,ll t)
{
    ll ret = pow_mod(a,x,n);
    ll last = ret;
    for (int i = 1;i <= t;i ++)
    {
        ret = mult_mod(ret,ret,n);
        if (ret == 1 && last != 1 && last != n-1) return true; //合数
        last = ret;
    }
    if (ret != 1) return true;
    else return false;
}

bool Miller_Rabin(ll n)
{
    if (n < 2) return false;
    if (n == 2) return true;
    if ((n & 1) == 0) return false; //偶数
    ll x = n - 1;
    ll t = 0;
    while ((x & 1) ==0) {
        x >>= 1;
        t ++;
    }
    srand((uint) time(NULL));
    ll a;
    for (int i = 0;i < S;i ++)
    {
        a = rand() % (n - 1) + 1;
        if (check(a,n,x,t)) return false;
    }
    return true;
}

ll factor[100]; //质因素分解结果(刚返回时时无序的)
int tol; //质因素的个数，编号0~tol-1

ll gcd(ll a,ll b) {
    ll t;
    while (b)
    {
        t = a;
        a = b;
        b = t % b;
    }
    if (a >= 0) return a;
    else return -a;
}

// 找出一个因子
ll pollard_rho(ll x,ll c) {
    ll i = 1, k = 2;
    srand((uint) time(NULL));
    ll x0 = rand() % (x - 1) + 1;
    ll y = x0;
    ll d;
    while (1)
    {
        i ++;
        x0 = (mult_mod(x0,x0,x) + c) % x;
        d = gcd(y - x0,x);
        if (d != 1 && d != x) return d;
        if (y == x0) return x;
        if (i == k) {
            y = x0;
            k += k;
        }
    }
}

// 对n进行素因子分解，存入factor. k设置为107左右即可
void findfac(ll n,int k)
{
    if (n == 1) return;
    if (Miller_Rabin(n)) {
        factor[tol ++] = n;
        return;
    }
    ll p = n;
    int c = k;
    while (p >= n) p = pollard_rho(p,c --); // 值变化，防止死循环k
    findfac(p,k);
    findfac(n / p,k);
}



// 找出一个数字所有的质因子，若有重复的质因子，则输出yes CCPC2020威海
int main()
{
    ll n;
    int ok = 0;
    __T {
        scl(n); // 读取一个ll数
        tol = 0; // 质数的个数=0
        findfac(n, 107); // 找出所有的因子
        sort(factor, factor + tol); // 排序
        
        ok = 0;
        REP(i,1,tol) {
            if (factor[i - 1] == factor[i]) { // 找出了一样的了
                ok = 1;
                break;
            }
        }
        puts(ok ? "yes" : "no");
    }
}
*/

/*
int main()
{
    int m,n,k;
    sciii(m,n,k);
    stack<int> s;
    int a[1010];
    int ok;
    int j;
    while (k --) {
        rep(i,1,n) sci(a[i]);
        ok = 0;
        j = 1;
        rep(i,1,n+1) {
            while (s.size() != 0 && s.top() == a[j]) {
                j ++;
                s.pop();
                ok ++;
            }
            if (i <= n && s.size() < m) s.push(i);
        }
        while (!s.empty()) s.pop();
        puts(ok == n ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    int a[1010];
    int b[1010];
    int an = 0,bn = 0;
    int t;
    rep(i,1,n) {
        sci(t);
        if (t & 1) a[++ an] = t;
        else b[++ bn] = t;
    }
    int i = 1,j = 1;
    int cnt = 0;
    int f = 1;
    while (i <= an || j <= bn) {
        cnt ++;
        if (i <= an) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",a[i]);
            i ++;
        }
        if (!(cnt & 1)) {
            if (j <= bn) {
                if (f) f = 0;
                else printf(" ");
                printf("%d",b[j]);
                j ++;
            }
        }
    }
    puts("");
    return 0;
}
*/

/*
int mp[1010][1010];
int mm[1010][1010];
int dx[] = {0,1,-1,0};
int dy[] = {1,0,0,-1};

const int MAXN = 1e6 + 10;
const int mod = 1e9 + 7;

struct Edge {
    int to;
    int nxt;
} e[MAXN << 3];
int g[MAXN];

int cnt;

void add(int u,int v) {
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int in[MAXN];
int out[MAXN];
int id;

ll step[MAXN][5];



ll Tuopu()
{
    queue<int> q;
    rep(i,1,id) {
//        _C(i << " " << in[i])
        if (in[i] == 0) {
            q.push(i);
            step[i][1] = 1;
        }
    }
    int top;
    int to;
    int cnt;
    while (!q.empty()) {
        top = q.front();
        q.pop();
        for (int i = g[top];~i;i = e[i].nxt) {
            to = e[i].to;
            
            rep(i,1,4) {
                cnt = i + 1;
                if (cnt > 4) cnt = 4;
                step[to][cnt] += step[top][i];
                step[to][cnt] %= mod;
            }
            
            in[to] --;
            if (in[to] == 0) q.push(to);
        }
    }
    
    ll ans = 0;
    
    rep(i,1,id) {
        if (out[i] == 0) {
            ans += step[i][4];
            ans %= mod;
        }
    }
    return ans;
}

int main()
{
    mem(g,-1);
    cnt = 0;
    id = 0;
    int n,m;
    scii(n,m);
    rep(i,1,n) {
        rep(j,1,m) {
            sci(mp[i][j]);
            mm[i][j] = ++ id;
        }
    }
    int ii,jj;
    rep(i,1,n) {
        rep(j,1,m) {
            REP(k,0,4) {
                ii = i + dy[k];
                jj = j + dx[k];
                if (ii >= 1 && ii <= n && jj <= m && jj >= 1) {
                    if (mp[i][j] + 1 == mp[ii][jj]) {
                        add(mm[i][j],mm[ii][jj]);
                        in[mm[ii][jj]] ++;
                        out[mm[i][j]] ++;
                    }
                }
            }
        }
    }
    printf("%lld\n",Tuopu());
    re0;
}
*/


/*
const int MAXN = 100010;

vector<int> g[MAXN];

int n;
int color[MAXN];

int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}

int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
//    _C(x << " " << type)
    int t = 0;
    if (!vis[color[x]]) t ++;
    vis[color[x]] += type;
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy)
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留
{
    
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子
        heavy = weight[x];
    }
    
//    _C(">>" << x << " " << keep)
    t += count(x, f, 1);
    heavy = 0;
    ans[x] = t;

    if (!keep) count(x, f, -1);
    return t;
}

int main()
{
    sci(n);

    int u,v;
    rep(i,1,n-1) {
        scii(u,v);
        g[u].pb(v);
        g[v].pb(u);
    }
    rep(i,1,n) sci(color[i]);

    getMaxSon(1, -1);
    dfs(1, -1, 1);

    int t;
    __T {
        sci(t);
        printf("%d\n",ans[t]);
    }
    return 0;
}
*/

/*
const int MAXN = 200010;

vector<int> g[MAXN];

int n;

// -----统计重儿子（节点数最多的儿子）-----
int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}
// ----------------------------------


int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
    int t = 0;
    
    // ---------------在此修改计数方式---------------
    if (vis[x - 1] && vis[x + 1]) t --;
    else if (!vis[x - 1] && !vis[x + 1]) t ++;
    // -------------------------------------------
    
    vis[x] += type;
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy) // 跳过重儿子
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留，调用直接(root,-1,1)
{
    
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子，不保留
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子，保留
        heavy = weight[x]; // 记录当前重儿子
    }
    
    t += count(x, f, 1); // 计算答案
    heavy = -1; // 清空重儿子记录
    ans[x] = t; // 记录答案

    if (!keep) count(x, f, -1); // 不保留直接清除vis
    return t;
}

int main()
{
    int u,v;
    int T = 1;
    __T {
        sci(n);
        rep(i,1,n + 5) {
            g[i].clear();
            ans[i] = vis[i] = 0; // 注意清空
        }
        heavy = -1; // 注意清空
        rep(i,1,n - 1) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        getMaxSon(1, -1);
        dfs(1, -1, 1);
        printf("Case #%d:",T ++);
        rep(i,1,n) printf(" %d",ans[i]);
        puts("");
    }
    return 0;
}
*/


/*
// ***************************************************
// *                                                 *
// *     启发式树上合并：用于统计树上子树中特定节点的个数     *
// *                                                 *
// ***************************************************
const int MAXN = 200010;

vector<int> g[MAXN];

int n;

// -----统计重儿子（节点数最多的儿子）-----
int weight[MAXN];

int getMaxSon(int x,int f)
{
    int mx = -1;
    int nmx = -1;
    int t;
    int ch = 1;
    for (auto i : g[x]) {
        if (i == f) continue;
        t = getMaxSon(i,x);
        if (t > mx) {
            mx = t;
            nmx = i;
        }
        ch += t;
    }
    weight[x] = nmx;
    return ch;
}
// ----------------------------------


int vis[MAXN];
int ans[MAXN];
int heavy;

int count(int x,int f,int type) // type = 1统计，type = -1清空
{
    int t = 0;
    
    // ---------------在此修改计数方式---------------
    if (vis[x - 1] && vis[x + 1]) t --;
    else if (!vis[x - 1] && !vis[x + 1]) t ++;
    // -------------------------------------------
    
    // -----根据题意改变vis什么，若是统计颜色的则vis[color[x]] += type-----
    vis[x] += type;
    // -------------------------------------------------------------
    
    for (auto i : g[x]) {
        if (i == f) continue;
        if (i != heavy) // 跳过重儿子
            t += count(i,x,type);
    }
    return t;
}

int dfs(int x,int f,int keep) // keep 是否保留，调用直接(root,-1,1)
{
    int t = 0;
    for (auto i : g[x]) {
        if (f == i) continue;
        if (weight[x] != i) {
            dfs(i,x,0); // 遍历轻儿子，不保留
        }
    }
    if (weight[x] != -1) {
        t += dfs(weight[x],x,1); // 遍历重儿子，保留
        heavy = weight[x]; // 记录当前重儿子
    }
    
    t += count(x, f, 1); // 计算答案
    heavy = -1; // 清空重儿子记录
    ans[x] = t; // 记录答案

    if (!keep) count(x, f, -1); // 不保留直接清除vis
    return t;
}

int main()
{
    int u,v;
    int T = 1;
    __T {
        sci(n);
        rep(i,1,n + 5) {
            g[i].clear();
            ans[i] = vis[i] = 0; // 注意清空
        }
        heavy = -1; // 注意清空
        rep(i,1,n - 1) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        getMaxSon(1, -1);
        dfs(1, -1, 1);
        printf("Case #%d:",T ++);
        rep(i,1,n) printf(" %d",ans[i]);
        puts("");
    }
    return 0;
}
*/

/*
const int MAXN = 500010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN << 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memset(g, -1, sizeof(int) * n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memset(dis, -1, sizeof(int) * (n + 5));

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

// ***********************************************
// *             二分图匹配 - 网络流算法             *
// *   思路：建立超级源点到各个左部点的联系（权重为1），  *
// * 建立右部点到超级汇点的联系，以及左右部分点之间的联系，*
// *               最后直接最大流板子。              *
// ***********************************************

int main()
{
    // **注意：MAXN尽量开大点，不然很容易RE**
    int nn,mm,e;
    scanf("%d%d%d",&nn,&mm,&e);
    init(nn + mm + 10);
    int u,v;
    // nn + mm + 1 源点
    // nn + mm + 2 汇点
    while (e --) {
        scanf("%d%d",&u,&v);
        add_edge(u, v + nn, 1); // 建立 左部点 到 右部点 的联系
        add_edge(v + nn, u, 0);
    }
    rep(i,1,nn) {
        add_edge(nn + mm + 1, i, 1); // 建立超级源点到各个左部点的联系
        add_edge(i, nn + mm + 1, 0);
    }
    
    rep(i,nn + 1,nn + mm) {
        add_edge(i, nn + mm + 2, 1); // 建立 右部点 到超级汇点的联系
        add_edge(nn + mm + 2, i, 0);
    }
    
    n = nn + mm + 2; // 设置总点量
    s = nn + mm + 1; // 设置起点
    t = nn + mm + 2; // 设置终点
    printf("%lld\n",dinic());
    return 0;
}
*/

/*
const int MAXN = 500010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN << 1];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memset(g, -1, sizeof(int) * n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memset(dis, -1, sizeof(int) * (n + 5));

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

int main()
{
    int nn,m,k;
    sciii(nn,m,k);
    int tmp;
    
    s = 1;
    t = 3;
    int v;
    init(nn + m + 10);
    n = nn + m + 3;
    rep(i,1,nn) {
        sci(tmp);
        while (tmp --) {
            sci(v);
            add_edge(i + 3, v + nn + 3, 1);
            add_edge(v + nn + 3, i + 3, 0);
        }
        add_edge(1, i + 3, 1);
        add_edge(i + 3, 1, 0);
        
        add_edge(2, i + 3, 1);
        add_edge(i + 3, 2, 0);
    }
    
    rep(i,1,m) {
        add_edge(nn + i + 3, 3, 1);
        add_edge(3, nn + i + 3, 0);
    }
    
    add_edge(1, 2, k);
    add_edge(2, 1, 0);
    
    
    printf("%lld\n",dinic());
    
    return 0;
}
*/

/*
const int MAXN = 1e6 + 10;

int a[MAXN];

int isP[MAXN];
vector<int> p[MAXN];

void sheive()
{
    isP[1] = 1;
    rep(i,2,1000000) {
        if (isP[i]) continue;
        p[i].pb(i);
        for (int j = i + i;j <= 1000000;j += i) {
            p[j].pb(i);
            isP[j] = 1;
        }
    }
}

ll last[MAXN];

int main()
{
    sheive();
    int n;
    scanf("%d",&n);
    rep(i,1,n) scanf("%d",a + i);
    ll ans = 0;
    rep(i,1,n) {
        for (auto j : p[a[i]]) {
            ans += (i - last[j]) * (n - i + 1);
            last[j] = i;
        }
    }
    printf("%lld\n",ans);
    
    return 0;
}
*/

/*
struct Node {
    ll i,j,k;
} ans[500];

int main()
{
    ll k,m,n,s;
    int ok;
    int a[500] = {0};
    printf("%lu\n",time(NULL));
    rep(x,0,200) {
        ok = 0;
        for (ll i = -5000;i <= 5000;i ++) {
            for (ll j = -5000;j <= 5000;j ++) {
                k = i*i*i + j*j*j;
                m = x - k;
                n = pow(m,1/3.0);
                s = 0;
                if (n * n * n == m) {
                    s = n;
                    ok = 1;
                } else if ((n+1) * (n+1) * (n+1) == m) {
                    s = n + 1;
                    ok = 1;
                } else if ((n-1) * (n-1) * (n-1) == m) {
                    s = n - 1;
                    ok = 1;
                }
                if (abs(s) > 5000) ok = 0;
                if (ok) {
                    ans[x] = {i,j,s};
                    goto end;
                }
            }
        }
        end:
        a[x] = ok;
        printf("%d\n",x);
    }
    printf("int ok[] = {");
    rep(i,0,200) printf("%d,",a[i]);
    printf("};\n");
    printf("int ans[][3]={");
    rep(i,0,200) printf("{%lld,%lld,%lld},",ans[i].i,ans[i].j,ans[i].k);
    printf("};\n");
    printf("%lu\n",time(NULL));
    return 0;
}
*/

/*
int ok[] = {1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,};
int ans[][3]={{-5000,0,5000},{-5000,1,5000},{-4373,-486,4375},{-5,4,4},{0,0,0},{0,0,0},{-637,-205,644},{-169,44,168},{-5000,2,5000},{-216,-52,217},{-650,-353,683},{-695,-641,843},{-11,7,10},{0,0,0},{0,0,0},{-265,-262,332},{-4114,-588,4118},{-3331,2195,2977},{-1373,-1276,1671},{-95,47,91},{-2816,-741,2833},{-401,-287,445},{0,0,0},{0,0,0},{-10,8,8},{-2683,1839,2357},{-2107,237,2106},{-5000,3,5000},{-2268,-249,2269},{-233,-69,235},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-1555,-244,1557},{-1120,-509,1154},{-3223,2358,2731},{-444,-84,445},{-27,16,25},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-823,-307,837},{-7,-5,8},{-2369,1709,2025},{-758,-473,815},{-141,49,139},{-3950,-1247,3991},{0,0,0},{0,0,0},{-796,602,659},{0,0,0},{-2370,1518,2141},{-3885,-648,3891},{-3329,1837,3131},{-672,505,559},{-998,361,982},{0,0,0},{0,0,0},{-1201,-163,1202},{-966,668,845},{-2744,-1561,2903},{-161,102,146},{-5000,4,5000},{-929,403,903},{1,1,4},{0,0,0},{0,0,0},{-403,134,398},{-2359,824,2325},{-533,401,443},{-432,-104,434},{-335,-146,344},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{-2080,-829,2123},{-706,-196,711},{-1300,-706,1366},{-2368,-1719,2638},{-1317,847,1188},{-3707,1315,3651},{0,0,0},{0,0,0},{0,0,0},{-4126,-1972,4271},{-1390,-1282,1686},{-2514,1953,2036},{-1803,365,1798},{-3389,-2912,3992},{-4052,861,4039},{-248,-98,253},{0,0,0},{0,0,0},{-22,14,20},{-3168,-991,3200},{-2101,-1638,2391},{-893,-622,984},{-1797,-903,1870},{-2327,319,2325},{-239,118,229},{0,0,0},{0,0,0},{-7,-4,8},{-2689,-1165,2760},{-1309,947,1117},{-1165,-948,1345},{-2948,853,2924},{0,0,0},{-4793,-2312,4966},{0,0,0},{0,0,0},{0,0,0},{-12,8,11},{-1906,-757,1945},{-896,-555,962},{-4328,383,4327},{-3677,-1673,3789},{-2804,1219,2725},{0,0,0},{0,0,0},{-37,-16,38},{-1,0,5},{-5000,5,5000},{-2212,-419,2217},{-4034,-3881,4988},{-3989,-726,3997},{-1580,-1238,1801},{0,0,0},{0,0,0},{-1,2,5},{-399,167,389},{-3013,-1766,3203},{-1351,-629,1395},{-1116,816,946},{-758,-428,801},{-86,-77,103},{0,0,0},{0,0,0},{-139,104,116},{-7,-3,8},{0,0,0},{-2746,-2552,3342},{-8,-7,10},{-327,-263,376},{-2366,1528,2131},{0,0,0},{0,0,0},{-367,260,317},{-463,215,447},{-805,486,741},{-3736,-695,3744},{-2135,-516,2145},{-3693,-1049,3721},{0,0,0},{0,0,0},{0,0,0},{-1534,383,1526},{-3874,-1654,3972},{-4767,-2476,4980},{-4125,-1417,4180},{-3423,-2943,4033},{-66,-59,79},{0,0,0},{0,0,0},{0,0,0},{-802,-574,890},{-1354,-1012,1521},{-3834,-2149,4047},{-1328,891,1178},{0,0,0},{0,0,0},{-335,-170,349},{0,0,0},{0,0,0},{-1168,-160,1169},{-13,-10,15},{-2839,1503,2691},{0,0,0},{-4874,974,4861},{-90,-29,91},{-4889,976,4876},{0,0,0},{0,0,0},{-4,5,5},{-1885,-1092,2000},{-1639,318,1635},{-1702,-1403,1974},{-4812,-593,4815},{-377,-215,399},{-20,16,16},{0,0,0},{0,0,0},{0,0,0},{-1057,-579,1112},{-2867,-1606,3026},{-3752,-1347,3809},{-2208,508,2199},{-2318,-638,2334},};

int main()
{
    int x;
    __T {
        scanf("%d",&x);
        if (ok[x]) printf("%d %d %d\n",ans[x][0],ans[x][1],ans[x][2]);
        else puts("impossible");
    }
}
*/

/*
int dp[1010][1010];

int main()
{
    int n,v;
    int val[1010];
    int vol[1010];
    __T {
        scanf("%d%d",&n,&v);
        rep(i,1,n) scanf("%d",val + i);
        rep(i,1,n) scanf("%d",vol + i);
        rep(j,0,v) dp[0][j] = 0;
        rep(i,1,n) {
            rep(j,0,v) {
                if (vol[i] <= j) dp[i][j] = max(dp[i - 1][j - vol[i]] + val[i],dp[i - 1][j]);
                else dp[i][j] = dp[i - 1][j];
            }
        }
        printf("%d\n",dp[n][v]);
    }
}
*/

/*
const int MAXN = 1e5 + 10;

ll a[MAXN];

int n;

int check(ll t) {
    ll x = 0;
    t --;
    rep(i,1,n) {
        if (a[i] < t) x += t - a[i];
    }
    return x <= t;
}


int main()
{
    
    ll l,r,m;
    int T = 1;
    __T {
        scanf("%d",&n);
        rep(i,1,n) {
            scanf("%lld",a + i);
        }
        l = 1;
        r = 1e10;
        while (l < r) {
            m = (l + r) >> 1;
            if (check(m)) l = m + 1;
            else r = m;
        }
        printf("Case #%d: %lld\n",T ++,l - 1);
    }
    return 0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    ll x;
    int T = 1;
    ll n;
    ll ans;
    __T {
        scanf("%lld",&x);
        printf("Case #%d: ",T ++);
        if (x == 6 || x < 5) printf("-1\n");
        else {
            if (x & 1) puts("1");
            else {
                if (x % 4 == 0) printf("2\n");
                else {
                    n = x / 3;
                    ans = 4;
                    repl(i,n-2,n+2) {
                        repl(j,n-2,n+2) {
                            repl(k,n-2,n+2) {
                                if (i + j + k == x && i > 1 && j > 1 && k > 1 && gcd(i,j) == 1 && gcd(i,k) == 1 && gcd(j,k) == 1) {
                                    ans = min(ans,max(i,max(j,k)) - min(i,min(j,k)));
                                }
                            }
                        }
                    }
                    printf("%lld\n",ans);
                }
            }
        }
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

struct Node {
    int l,r;
    ll mx;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
ll a[MAXN];

void push_up(int i)
{
    tree[i].mx = max(tree[i << 1].mx,tree[i << 1 | 1].mx);
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy) {
        tree[i << 1].mx = max(tree[i].lzn,tree[i << 1].mx);
        tree[i << 1 | 1].mx = max(tree[i].lzn,tree[i << 1 | 1].mx);

        tree[i << 1].lzn = max(tree[i].lzn,tree[i << 1].lzn);
        tree[i << 1 | 1].lzn = max(tree[i].lzn,tree[i << 1 | 1].lzn);

        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;

        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].mx = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}


void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].mx = max(x,tree[i].mx);
        
        tree[i].lzn = max(tree[i].lzn,x);
        tree[i].lazy = 1;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].mx;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll mx = 0;
    if (l <= m) {
         mx = max(mx,query(l,r,i << 1));
    }
    if (r > m) {
        mx = max(mx,query(l,r,i << 1 | 1));
    }
    return mx;
}

struct pr {
    pr(int x,int t):x(x),t(t){}
    pr(){}
    int x,t;
    bool operator<(const pr &o) const {
        if (t == o.t) return x > o.x;
        return t < o.t;
    }
    bool operator!=(const pr &o) const {
        return t != o.t;
    }
} p[MAXN],pp[MAXN];

int main()
{
    int n,m;
    int u,v;
    int T = 1;
    int cnt;
    __T {
        read(n);
        read(m);
        build(1, m, 1);
        rep(i,1,n) {
            read(v);
            read(u);
            p[i] = pr(u,v);
        }
        cnt = 0;
        sort(p + 1,p + 1 + n);
        pp[++ cnt] = p[1];
        rep(i,2,n) {
            if (p[i] != p[i - 1]) pp[++ cnt] = p[i];
        }
        
        rep(i,1,cnt) {
            u = pp[i].x;
            v = pp[i].t;
            for (int j = 1;j <= m;j += 2 * v) {
                modify(j, min(m,j + v - 1), u, 1);
            }
        }
        
        
        printf("Case #%d:",T ++);
        rep(i,1,m) {
            printf(" %lld",query(i, i, 1));
        }
        printf("\n");
    }
    
    re0;
}
*/


/*
const int MAXN = 1e6 + 10;

int is_prime[MAXN];
int is_prime_small[MAXN];

void segment_sieve(ll a,ll b)
{
    for (ll i = 0;i * i <= b;i ++) is_prime_small[i] = 1;
    for (ll i = 0;i <= b - a;i ++) is_prime[i] = 1;
    for (ll i = 2;i * i <= b;i ++)
    {
        if (is_prime_small[i])
        {
            for (ll j = 2 * i;j * j <= b;j += i) is_prime_small[j] = 0;
            for (ll j = max(2LL,(a + i - 1) / i) * i; j <= b;j += i) is_prime[j - a] = 0;
        }
    }
}


int main()
{
    int l,r;
    int cnt;
    __T {
        scanf("%d%d",&l,&r);
        if (r - l >= 100) puts("Yes");
        else {
            segment_sieve(l, r);
            cnt = 0;
            rep(i,0,r - l) if (is_prime[i]) cnt ++;
            if (cnt * 3 < r - l + 1) puts("Yes");
            else puts("No");
        }
    }
}
*/

/*
int main()
{
    ll l,r;
    ll s;
    ll kl,kr;
    ll ans;
    ll m;
    ll sub[100],pre[100];
    ll sub_cnt,pre_cnt;
    __T {
        scanf("%lld%lld%lld",&l,&r,&s);
        kl = l;
        kr = r;
        for (ll i = l;;i ++) {
            kl = i;
            if ((i & 1) == 0 && ((i >> 1) & 1) == 0) break;
        }
        for (ll i = r;;i --) {
            kr = i;
            if ((i & 1) == 1 && ((i >> 1) & 1) == 1) break;
        }
//        _C(kl << " " << kr)
        if (kr > kl) {
            ans = 0;
            pre_cnt = sub_cnt = 0;
            pre[0] = sub[0] = 0;
            prel(i,kl-1,l) {
                sub[sub_cnt + 1] = i ^ sub[sub_cnt];
                sub_cnt ++;
            }
            
            repl(i,kr+1,r) {
                pre[pre_cnt + 1] = i ^ pre[pre_cnt];
                pre_cnt ++;
            }
            
            rep(i,0,sub_cnt) {
                rep(j,0,pre_cnt) {
                    if ((sub[i] ^ pre[j]) <= s) {
                        ans = max(ans,(ll)j + i);
                    }
                }
            }
            
//            _C(">>" << ans)
            
            ans += kr - kl + 1;
        } else {
            ans = -1;
            repl(i,l,r) {
                repl(j,i,r) {
                    m = 0;
                    repl(k,i,j) {
                        m ^= k;
                    }
                    if (m <= s) ans = max(ans,j-i+1);
                }
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
struct Node {
    ll first;
    ll second;
    int num;
} x[110];

int cmp(const Node &a,const Node &b)
{
    if (a.first == b.first) return a.second > b.second;
    return a.first > b.first;
}

int main()
{
    int n;
    scanf("%d",&n);
    ll s[110][110];
    rep(i,1,n) {
        rep(j,1,n) scanf("%lld",&s[i][j]);
        x[i] = {0ll,0ll,i};
    }
    
    rep(i,1,n) {
        rep(j,1,n) {
            if (i == j) continue;
            if (s[i][j] > s[j][i]) x[i].first += 3;
            else if (s[i][j] == s[j][i]) x[i].first += 1;
            x[i].second += s[i][j] - s[j][i];
        }
    }
    sort(x+1,x+1+n,cmp);
    
//    rep(i,1,n) {
//        printf("%d ",x[i].num);
//    }
//    puts("");
//    rep(i,1,n) {
//        printf("%lld ",x[i].first);
//    }
//    puts("");
//    rep(i,1,n) {
//        printf("%lld ",x[i].second);
//    }
    
    if (n == 1) printf("1\n");
    else {
        if (x[1].first != x[2].first) printf("%d\n",x[1].num);
        else {
            if (x[1].second != x[2].second) printf("%d\n",x[1].num);
            else puts("play-offs");
        }
    }
    
    return 0;
}
*/

/*
const ll t = 998857459;
ll kk[100010];
ll x[100010];
ll num[100010];

ll ans[100010];

int main()
{
    kk[1] = 1;
    int n,m;
    scanf("%d%d",&n,&m);
    rep(i,2,2802) {
        kk[i] = kk[i-1] * i;
        kk[i] %= t;
    }
    
    int a;
    int cnt = 0;
    x[0] = num[0] = 0;
    int k = -1;
    rep(i,1,n) {
        scanf("%d",&a);
        if (a >= 2803) {
            if (k != -1) k ++;
        } else {
            if (k == -1) k = 1;
            cnt ++;
            x[cnt] = kk[a] + x[cnt - 1];
            num[cnt] = k + num[cnt - 1];
            k = 1;
        }
    }
//    rep(i,1,cnt) {
//        printf("%lld ",x[i]);
//    }
//    puts("");
//
//    rep(i,1,cnt) {
//        printf("%lld ",num[i]);
//    }
//    puts("");
    
    rep(i,1,cnt) {
        rep(j,i,cnt) {
            ans[num[j]-num[i]+1] = max(ans[num[j]-num[i]+1],(x[j] - x[i-1])%t);
        }
    }
    rep(i,2,n) ans[i] = max(ans[i-1],ans[i]);
    
//    rep(i,1,n) printf("%lld ",ans[i]);
//    puts("");
    
    int idx;
    while (m --) {
        sci(a);
        idx = (int) (lower_bound(ans + 1, ans + 1 + n, a) - ans);
        if (idx == n + 1) puts("-1");
        else printf("%d\n",idx);
    }
    return 0;
}
*/

/*
const int MAXN = 5e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

int vis[500010];

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

struct Node {
    int u,v;
    ll w;
    bool operator<(const Node &o) const {
        return w > o.w;
    }
} e[500010];

int main()
{
    int n,m,k;
    int u,v,w,c;
    ll ans;
    int cnt;
    int ok;
    int last;
    int t;
    __T {
        scanf("%d %d %d",&n,&m,&k);
        init(n + 10);
        cnt = ans = 0;
        rep(i,1,m) {
            vis[i] = 0;
            scii(u,v);
            scii(w,c);
            if (c == 0) {
                ans += w;
                bind(u,v);
            } else {
                e[++ cnt] = {u,v,w};
            }
        }
        sort(e + 1, e + 1 + cnt);
        rep(i,1,cnt) {
            if (find(e[i].u) == find(e[i].v)) continue;
            vis[i] = 1;
            bind(e[i].u,e[i].v);
            ans += e[i].w;
            k --;
            if (k <= 0) break;
        }
        ok = 1;
        last = find(1);
        rep(i,2,n) {
            t = find(i);
            if (t != last) {
                ok = 0;
                break;
            }
            last = t;
        }
        if (!ok) puts("-1");
        else {
            rep(i,1,cnt) {
                if (vis[i]) continue;
                ans += e[i].w;
                k --;
                if (k <= 0) break;
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}
*/

/*
const int mod = 1e9+7;

int main()
{
    string str;
    ll a[100010];
    int s[100010];
    int cnt;
    ll ans;
    int k;
    __T {
        cin >> str;
        cnt = 0;
        for (int i = (int) str.size()-1;i >= 0;i --) {
            s[++ cnt] = str[i] ^ 48;
            a[cnt] = 1;
        }
        a[0] = 1;
        ans = 0;
        
        rep(i,1,cnt) {
            if (s[i]) {
                ans += a[i - 1];
                ans %= mod;
                k = 3;
            } else {
                k = 2;
            }
            a[i] = a[i - 1] * k;
            a[i] %= mod;
        }
        ans ++;
        ans %= mod;
        printf("%lld\n",ans);
    }
    return 0;
}
*/

/*
char str[10000010];

int main()
{
    const int m1 = 137;
    const int m2 = 73;
    int a1,a2;
    int T = 1;
    while (~scanf("%s",str)) {
        a1 = a2 = 0;
        for (int i = 0;str[i];i ++) {
            a1 *= 10;
            a1 %= m1;
            
            a2 *= 10;
            a2 %= m2;
            
            a1 += str[i] ^ 48;
            a2 += str[i] ^ 48;
            
            a1 %= m1;
            a2 %= m2;
        }
        printf("Case #%d: ",T++);
        if (a1 == 0 || a2 == 0) puts("YES");
        else puts("NO");
    }
    return 0;
}
*/

/*
int main()
{
    cio
    string str;
    int T;
    cin >> T;
    int n;
    rep(i,1,T) {
        int c['z' + 1] = {0};
        cin >> str;
        for (int i = 0;str[i];i ++) {
            c[str[i]] ++;
        }
        n = 0;
        rep(i,0,'z') if (c[i]) n ++;
        printf("Case #%d: %d\n",i,n);
    }
    reutrn 0;
}
*/

/*
const int MAXN = 1e5+10;

int p[MAXN];
int h[MAXN];
int s[MAXN];
int n;

void pls(int l,int r,int k)
{
    p[l] += k;
    p[r + 1] -= k;
}

void init(int n)
{
    rep(i,0,n) {
        p[i]=0;
    }
}


int main()
{
    int n,m,k;
    
    int a,b;
    int last;
    int idx;
    int ans;
    int T = 1;
    while (~scanf("%d%d%d",&n,&m,&k)) {
        rep(i,1,n) {
            scanf("%d",h + i);
        }
        init(n + 5);
        sort(h + 1,h + 1 + n);
        last = 0;
        rep(i,1,n) if (h[i] <= 1) last = i;
        ans = 0;
        while (m --) {
            scanf("%d%d",&a,&b);
            idx = lower_bound(h+1,h+1+n,a) - h;
            if (idx == n + 1 || h[idx] > a) idx --;
            pls(last+1,idx,1);
            idx = lower_bound(h+1,h+1+n,b) - h;
            if (idx == n + 1 || h[idx] > b) idx --;
            last = idx;
        }
        s[0] = 0;
        rep(i,1,n) {
            s[i] = s[i - 1] + p[i];
            if (s[i] >= k) ans ++;
        }
        printf("Case %d: %d\n",T ++,ans);
    }
    return 0;
}
*/

/*
int main()
{
    int n,w,s;
    int vis[100];
    int cnt;
    int i,j;
    while (~scanf("%d%d%d",&n,&w,&s)) {
        memset(vis,0,sizeof vis);
        i = (w-2+n) % n;
        j = 0;
        cnt = 0;
        while (cnt < n) {
            i ++;
            i %= n;
            if (vis[i]) continue;
            j ++;

            if (j == s) {
                vis[i] = 1;
                printf("%d\n",i + 1);
                cnt ++;
                j = 0;
            }

        }
    }
    return 0;
}
*/

/*
struct Node {
    Node(){}
    Node(const char a[],int b):x(b){
        strcpy(str, a);
    }
    char str[20];
    int x;
};

int main()
{
    int n;
    char k[20];
    int x,y;
    int m;
    sci(n);
    map<int,Node> mp;
    while (n --) {
        scanf("%s %d %d",k,&x,&y);
        mp[x] = Node(k,y);
    }
    scanf("%d",&m);
    while (m --) {
        sci(x);
        printf("%s %d\n",mp[x].str,mp[x].x);
    }
    return 0;
}
*/

/*
int main()
{
    string str;
    int j,k = 0;
    while (cin >> str)
    {
        j = 0;
        for (int i = 0;str[i];i ++)
        {
            if (str[i] != str[j])
            {
                j = 0;
                k = i + 1;
            } else {
                if (j < k - 1) j ++;
                else j = 0;
            }
        }
        if (j != 0) k = (int) str.size();
        printf("%d\n",k);
    }
     
    return 0;
}
*/

/*
struct Node {
    int type; // 0 - num,1 - op
    char c;
    ll num;
};

int priority[130];

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

void getPost(string &str,vector<Node> &post) {
    post.clear();
    stack<char> op_stk;
    ll num = 0;
    int has_num = 0;
    
    for (int i = 0;str[i];i ++) {
        if (str[i] >= '0' && str[i] <= '9') {
            num = num * 10 + (str[i] ^ 48);
            has_num = 1;
        } else {
            if (has_num) post.push_back({0,0,num});
            has_num = num = 0;
            if (str[i] != ')') {
                if (str[i] != '(') while (!op_stk.empty() && priority[op_stk.top()] >= priority[str[i]]) {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.push(str[i]);
            } else {
                while (op_stk.top() != '(') {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.pop();
            }
        }
    }
    if (has_num) post.push_back({0,0,num});
    while (!op_stk.empty()) {
        post.push_back({1,op_stk.top(),0});
        op_stk.pop();
    }
}

ll getAns(vector<Node> &post) {
    ll ans = 0;
    stack<ll> num_stk;
    
    for (auto i : post) {
        if (!i.type) num_stk.push(i.num);
        else {
            switch (i.c) {
                case '+':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans += num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '-':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() - ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '*':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans *= num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '/':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() / ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '^':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = quickpow(num_stk.top(),ans);
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                default:
                    break;
            }
        }
    }
    return num_stk.top();
}

int main() {
    
    
    priority['('] = 1;
    priority['^'] = 4;
    priority['*'] = priority['/'] = 3;
    priority['+'] = priority['-'] = 2;
    
    string str;
    cin >> str;
    vector<Node> post;
    
    getPost(str,post);
    printf("%lld ",getAns(post));
    
    priority['*'] = priority['/'] = 2;
    priority['+'] = priority['-'] = 3;
    
    getPost(str,post);
    printf("%lld\n",getAns(post));
}
*/


/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll s = -1;
    ll l = 0;
    ll lm = 0,sm =-1;
    ll nn = n;
    ll ii;
    for (ll i = 2;i * i <= n;i ++) {
        nn = n;
        if (nn % i == 0) {
            ii = i;
            s = i;
            l = 0;
            while (nn % ii == 0) {
                l ++;
                nn /= ii;
                ii ++;
            }
            if (l > lm) {
                lm = l;
                sm = s;
            }
        }
        
    }
    
    if (lm == 0) printf("1\n%lld\n",n);
    else {
        printf("%lld\n",lm);
        rep(i,1,lm) {
            if (i != 1) printf("*");
            printf("%lld",sm ++);
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    string x[10] = {"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};
    string all[150];
    all['-'] = "fu";
    rep(i,0,9) all[i + '0'] = x[i];
    string str;
    cin >> str;
    for (int i = 0;str[i];i ++) {
        if (i != 0) printf(" ");
        cout << all[str[i]];
    }
    puts("");
}
*/

/*
int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    int j = 0;
    ll ans = 0;
    rep(i,a,b) {
        ans += i;
        if (j == 5) {
            printf("\n");
            j = 0;
        }
        printf("%5d",i);
        j ++;
    }
    printf("\nSum = %lld\n",ans);
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n;
    scanf("%d",&n);
    ll son[110],mot[110];
    ll lcm = 1;
    rep(i,1,n) {
        scanf("%lld/%lld",son + i,mot + i);
        lcm = lcm / gcd(lcm,mot[i]) * mot[i];
    }
    ll sum = 0;
    rep(i,1,n) {
        sum += son[i] * (lcm / mot[i]);
    }
    int f = sum < 0;
    sum = abs(sum);
    ll z = sum / lcm;
    sum -= z * lcm;
    ll g = gcd(sum,lcm);
    sum /= g;
    lcm /= g;
    int p = 0;
    int k = 1;
    if (f) printf("-");
    if (z != 0) {
        printf("%lld",z);
        p = 1;
        k = 0;
    }
    if (sum != 0) {
        if (!k) printf(" ");
        printf("%lld/%lld",sum,lcm);
        p = 1;
    }
    if (!p) printf("0");
    puts("");
    return 0;
}
*/

/*
int main()
{
    set<char> bb;
    string a,b;
    getline(cin, a);
    getline(cin, b);
    for (int i = 0;b[i];i ++) bb.insert(b[i]);
    for (int i = 0;a[i];i ++) {
        if (bb.find(a[i]) != bb.end()) continue;
        printf("%c",a[i]);
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    ll a[20];
    a[1] = 1;
    rep(i,2,10) a[i] = a[i - 1] * i;
    int n;
    scanf("%d",&n);
    ll ans = 0;
    rep(i,1,n) ans += a[i];
    printf("%lld\n",ans);
}
*/

/*
int mp[20][20];
int mmp[20][20];
int op[20];
int ans[20][20];
int times = -1;

int n,m;

int dx[] = {1,-1,0,0,0};
int dy[] = {0,0,-1,1,0};

int tmp[20][20];

void go() {
    int t = 0;
    
    rep(i,1,n) {
        rep(j,1,m) {
            mmp[i][j] = mp[i][j];
        }
    }
    
    int ii,jj;
    rep(i,1,n) {
        rep(j,1,m) {
            tmp[i][j] = op[j];
            if (op[j]) {
                t ++;
                rep(k,0,4) {
                    ii = i + dx[k];
                    jj = j + dy[k];
                    if (ii >= 1 && ii <= n && jj >= 1 && jj <= m) {
                        mmp[ii][jj] = !mmp[ii][jj];
                    }
                }
            }
        }
        rep(j,1,m) op[j] = mmp[i][j];
    }
    
    rep(i,1,m) if (mmp[n][i]) return;
    
    if (times == -1 || t < times) {
        times = t;
        rep(i,1,n) {
            rep(j,1,m) {
                ans[i][j] = tmp[i][j];
            }
        }
    }
}


int main()
{
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        rep(j,1,m) {
            scanf("%d",&mp[i][j]);
        }
    }
    int x = 1 << m;
    int xx;
    REP(i,0,x) {
        xx = i;
        rep(i,1,m) {
            op[i] = xx & 1;
            xx >>= 1;
        }
        go();
    }
    
    if (times == -1) puts("IMPOSSIBLE");
    else {
        rep(i,1,n) {
            rep(j,1,m) {
                if (j != 1) printf(" ");
                printf("%d",ans[i][j]);
            }
            puts("");
        }
    }
    return 0;
}
*/

///????????
/// https://vjudge.net/problem/POJ-1426
/*
int mod;
ull ans;
void dfs(ull n,int dps) {
    if (ans != 0) return;
    if (n % mod == 0) {
        ans = n;
        return;
    }
    if (dps == 19) reutrn;
    dfs(n * 10,dps + 1);
    dfs(n * 10 + 1,dps + 1);
}

int main() {
    while (~scanf("%d",&mod) && mod) {
        ans = 0;
        dfs(1,0);
        printf("%llu\n",ans);
    }
}
*/

/*
int main()
{
    string a,b,str;
    getline(cin,str);
    int ok = 0;
    for (int i = 0;str[i];i ++) {
        if (!ok && str[i] == ' ') {
            ok = 1;
            continue;
        }
        if (!ok) a += str[i];
        else b += str[i];
    }
    int num1 = 0,num2 = 0;
    int has1 = 1,has2 = 1;
    for (int i = 0;a[i];i ++) {
        if (!isdigit(a[i])) {
            has1 = 0;
            break;
        }
        num1 = num1 * 10 + (a[i] ^ 48);
    }
    
    for (int i = 0;b[i];i ++) {
        if (!isdigit(b[i])) {
            has2 = 0;
            break;
        }
        num2 = num2 * 10 + (b[i] ^ 48);
    }
    
    if (num1 < 1 || num1 > 1000) has1 = 0;
    if (num2 < 1 || num2 > 1000) has2 = 0;
    
    if (has1) printf("%d",num1);
    else printf("?");
    printf(" + ");
    if (has2) printf("%d",num2);
    else printf("?");
    printf(" = ");
    if (has1 && has2) printf("%d\n",num1 + num2);
    else printf("?\n");
    return 0;
}
*/

/*
int main()
{
    int aa,bb;
    int n;
    scanf("%d%d%d",&aa,&bb,&n);
    int a,b,c,d;
    int a1,a2;
    int ok = 1;
    while (n --) {
        scii(a,b);
        scii(c,d);
        a1 = 0;
        a2 = 0;
        if (b == a + c) a1 = 1;
        if (d == a + c) a2 = 1;
        if (a1 && a2) continue;
        if (!a1 && !a2) continue;
        if (a1) aa --;
        if (a2) bb --;
        if (aa == 0 || bb == 0) {
            if (ok) {
                if (aa == 0) {
                    puts("A");
                    printf("%d\n",bb);
                } else {
                    puts("B");
                    printf("%d\n",aa);
                }
                ok = 0;
            }
        }
    }
    
    
    return 0;
}
*/

/*
struct Node1 {
    int cur;
    int to;
    int len;
    int time;
    bool operator<(const Node1 &o) const {
        return time > o.time;
    }
};

struct Node2 {
    int cur;
    int to;
    int len;
    int time;
    bool operator<(const Node2 &o) const {
        return len > o.len;
    }
};

vector<Node1> g1[510];
vector<Node2> g2[510];

int dis[510];
int num[510];
int p[510];

void dij1(int s) {
    mem(dis,-1);
    mem(num,-1);
    priority_queue<Node1> q;
    q.push({-1,s,0,dis[s] = 0});
    int cost;
    Node1 top;
    int n,to;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        n = top.to;

        if (dis[n] != -1 && dis[n] < top.time) continue;
        if (dis[n] == top.time) {
            if (num[n] == -1 || top.len < num[n]) {
                num[n] = top.len;
                p[n] = top.cur;
            }
            
        }

        for (auto i : g1[n]) {
            to = i.to;
            cost = dis[n] + i.time;
            if (dis[to] == -1 || dis[to] >= cost) {
                q.push({n,i.to,top.len + i.len,dis[to] = cost});
            }
        }
    }
}

void dij2(int s) {
    mem(dis,-1);
    mem(num,-1);
    priority_queue<Node2> q;
    q.push({-1,s,dis[s] = 0,0});
    int cost;
    Node2 top;
    int n,to;
    while (!q.empty()) {
        top = q.top();
        q.pop();
        n = top.to;

        if (dis[n] != -1 && dis[n] < top.len) continue;
        if (dis[n] == top.len) {
            if (num[n] == -1 || top.time < num[n]) {
                num[n] = top.time;
                p[n] = top.cur;
            }
            
        }

        for (auto i : g1[n]) {
            to = i.to;
            cost = dis[n] + i.len;
            if (dis[to] == -1 || dis[to] >= cost) {
                q.push({n,i.to,dis[to] = cost,top.time + 1});
            }
        }
    }
}

int main()
{
    int n,m;
    scii(n,m);
    int u,v,type,l,t;
    while (m --) {
        scii(u,v);
        sci(type);
        scii(l,t);
        g1[u].push_back({0,v,l,t});
        g2[u].push_back({0,v,l,t});
        if (!type) {
            g1[v].push_back({0,u,l,t});
            g2[v].push_back({0,u,l,t});
        }
    }

    int s;
    scii(s,t);
    dij1(s);
    printf("Time = %d",dis[t]);
    vector<int> a1,a2;

    a1.push_back(t);
    int x = p[t];
    while (x != s) {
        a1.push_back(x);
        x = p[x];
    }
    a1.push_back(s);

    dij2(s);
    a2.push_back(t);
    x = p[t];
    while (x != s) {
        a2.push_back(x);
        x = p[x];
    }
    a2.push_back(s);
    int f = 1;
    if (a1 == a2) {
        printf("; Distance = %d: ",dis[t]);
    } else {
        printf(": ");
        for (vector<int>::reverse_iterator it = a1.rbegin();it != a1.rend();it ++) {
            if (f) f = 0;
            else printf(" => ");
            printf("%d",*it);
        }
        printf("\nDistance = %d: ",dis[t]);
    }
    f = 1;
    for (vector<int>::reverse_iterator it = a2.rbegin();it != a2.rend();it ++) {
        if (f) f = 0;
        else printf(" => ");
        printf("%d",*it);
    }
    return 0;
}
*/

/*
vector<int> g[510];
int vis[510];
int vv[510];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    int k;
    sci(k);
    queue<int> q;
    int top;
    int ok;
    int nn = n;
    int has;
    while (k --) {
        scanf("%d",&u);
        q.push(u);
        while (!q.empty()) {
            top = q.front();
            q.pop();
            if (vis[top] || vv[top]) continue;
            vis[top] = 1;
            for (auto i : g[top]) {
                q.push(i);
            }
        }
        ok = 0;
        has = 0;
        for (auto i : g[u]) {
            if (!vv[i]) {
                has = 1;
                q.push(i);
                break;
            }
        }
        if (has) {
            vis[u] = 2;
            while (!q.empty()) {
                top = q.front();
                q.pop();
                if (vis[top] == 2 || vv[top]) continue;
                vis[top] = 2;
                for (auto i : g[top]) q.push(i);
            }
            rep(i,0,n-1) if (vis[i] == 1) {
                ok = 1;
                break;
            }
        }
        vv[u] = 1;
        if (ok) printf("Red Alert: ");
        printf("City %d is lost",u);
        if (ok) puts("!");
        else puts(".");
        nn --;
        mem(vis,0);
    }
    if (!nn) printf("Game Over.\n");
}
*/

/*
int isZhi(int n)
{
    if (n == 1) return 0;
    for (int i = 2;i * i <= n;i ++) if (n % i == 0) return 0;
    return 1;
}

int get(int k)
{
    int ans = 0;
    int x = k;
    map<int,int> mp;
    int kk;
    do {
        mp[k] = 1;
        kk = 0;
        while (k) {
            kk += (k % 10) * (k % 10);
            k /= 10;
        }
        k = kk;
        ans ++;
        if (k == 1) {
            break;
        }
    } while (!mp[k]);
    return ans * (isZhi(x) ? 2 : 1);
}

int main()
{
    int a,b;
    scii(a,b);
    map<int,int> mp;
    map<int,int> vis;
    int ok;
    int k,kk;
    rep(i,a,b) {
        mp.clear();
        k = i;
        ok = 0;
        if (vis[k] == -1) continue;
        
        do {
            mp[k] = 1;
            kk = 0;
            while (k) {
                kk += (k % 10) * (k % 10);
                k /= 10;
            }
            k = kk;
            if (k == 1) {
                ok = 1;
                break;
            }
        } while (!mp[k]);
        mp.clear();
        
        k = i;
        do {
            if (ok) vis[k] ++;
            else vis[k] = -1;
            mp[k] = 1;
            kk = 0;
            while (k) {
                kk += (k % 10) * (k % 10);
                k /= 10;
            }
            k = kk;
        } while (!mp[k]);
        
    }
    ok = 0;
    for (auto i : vis) {
        if (i.first < a) continue;
        if (i.first > b) break;
        if (i.second == 1) {
            ok = 1;
            printf("%d %d\n",i.first,get(i.first));
        }
    }
    if (!ok) puts("SAD");
    return 0;
}
*/

/*
int main()
{
    int n,m,k;
    sciii(n,m,k);
    stack<int> st;
    int a[1010];
    int mnt;
    while (k --) {
        rep(i,1,n) sci(a[i]);
        mnt = 0;
        rep(i,1,n) {
            if (a[i] == mnt + 1) {
                mnt ++;
                while (!st.empty() && st.top() == mnt + 1) {st.pop();mnt ++;}
            } else {
                if (st.size() >= m) {
                    break;
                }
                st.push(a[i]);
            }
        }
        if (st.empty()) puts("YES");
        else {
            while (!st.empty()) st.pop();
            puts("NO");
        }
    }
}
*/

/*int startWith(string a,string b) {
    if (a.size() < b.size()) return 0;
    return a.substr(0,b.size()) == b;
}

int endsWith(string a,string b) {
    if (a.size() < b.size()) return 0;
    return a.substr(a.size() - b.size(),b.size()) == b;
}

map<string,int> mp;

int g[100010];
int sex[100010];

map<int,int> s1,s2;
int ok;

int main()
{
    int n;
    sci(n);
    string uu[100010],vv[100010];
    string t;
    rep(i,1,n) {
        cin >> uu[i] >> vv[i];
        mp[uu[i]] = i;
        if (endsWith(vv[i], "sson") || endsWith(vv[i], "m")) {
            sex[i] = 1;
        } else if (endsWith(vv[i], "sdottir") || endsWith(vv[i], "f")) {
            sex[i] = 0;
        }
    }
    string u,v;
    rep(i,1,n) {
        u = uu[i];
        v = vv[i];
        t = "";
        if (endsWith(v, "sson")) t = v.substr(0,v.size()-4);
//        if (endsWith(v, "m")) t = v.substr(0,v.size()-1);
        if (endsWith(v, "sdottir")) t = v.substr(0,v.size()-7);
//        if (endsWith(v, "f")) t = v.substr(0,v.size()-1);
        g[i] = mp[t];
    }
    int q;
    sci(q);
    string name;
    string u1,v1,u2,v2;
    int k,dps;
    while (q --) {
        cin >> u1 >> v1 >> u2 >> v2;
        if (mp[u1] == 0 || mp[u2] == 0) puts("NA");
        else if (sex[mp[u1]] == sex[mp[u2]]) puts("Whatever");
        else {
            ok = 1;
            s1.clear();
            s2.clear();
            
            k = mp[u1];
            dps = 1;
            while (k != 0) {
                s1[k] = dps ++;
                k = g[k];
            }
            
            k = mp[u2];
            dps = 1;
            while (k != 0) {
                s2[k] = dps ++;
                k = g[k];
            }
            
            for (auto i : s1) {
                if (s2[i.first]) {
                    if (i.second < 5 || s2[i.first] < 5) {
                        ok = 0;
                        break;
                    }
                    
                }
            }
            
            
            if (ok) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}*/

/*
int isLetter(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

int isDot(char c) {
    return !isLetter(c) && !isdigit(c);
}

int main()
{
    int n;
    sci(n);
    scanf(" ");
    string str;
    vector<string> tmp,words;
    vector<char> dots;
    string x;
    int f;
    rep(i,1,n) {
        getline(cin,str);
        _C(str);
        printf("AI: ");
        stringstream ss(str);
        tmp.clear();
        words.clear();
        dots.clear();
        while (ss >> x) {
            tmp.pb(x);
        }
        f = 1;
        for (auto i : tmp) {
            if (f) f = 0;
            else if (!isDot(i[0])) dots.pb(' ');
            str = "";
            for (int j = 0;i[j];j ++) {
                if (isDot(i[j])) {
                    words.pb(str);
                    str = "";
                    dots.pb(i[j]);
                } else str += i[j];
            }
            if (str != "") words.pb(str);
        }
        _C(words.size());
        _C(dots.size());
        _C("")
    }
    return 0;
}
*/

/*
ll ans[1000010][12];

int main()
{
    int n,b;
    int ii;
    rep(i,1,1000000) {
        rep(j,2,10) {
            ii = i;
            while (ii) {
                ans[i][j] += (ii % j);
                ii /= j;
            }
            ans[i][j] += ans[i - 1][j];
        }
    }
    int T = 1;
    __T {
        scii(n,b);
        printf("Case #%d: %lld\n",T++,ans[n][b]);
    }
}
*/

/*
int main()
{
    int n,m;
    int l,r;
    map<int,pair<int,int>> num; // 1,-1
    ll ans,t;
    int f;
    int T = 1;
    __T {
        scii(n,m);
        num.clear();
        ans = 0;
        while (m --) {
            scii(l,r);
            num[l].first ++;
            num[r+1].second ++;
        }
        t = 0;
        f = -1;
        for (auto i : num) {
            if (f != -1 && (t & 1)) ans += i.first - f;
            t += i.second.first;
            t -= i.second.second;
            f = i.first;
        }
        printf("Case #%d: %lld\n",T++,ans);
    }
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int a[1010] = {0};
    rep(i,1,n) sci(a[i]);
    int u,v;
    scanf("%d%d",&u,&v);
    int cur = u;
    set<int> x;
    if (!a[u]) {
        printf("ERROR: T[%d] is NULL\n",u);
        return 0;
    }
    if (!a[v]) {
        printf("ERROR: T[%d] is NULL\n",v);
        return 0;
    }
    while (a[cur]) {
        x.insert(cur);
        cur >>= 1;
    }
    cur = v;
    while (a[cur]) {
        if (x.find(cur) != x.end()) {
            printf("%d %d\n",cur,a[cur]);
            break;
        }
        cur >>= 1;
    }
    re0;
}
*/

/*
struct Node {
    Node(){}
    Node(ll c,Node *l,Node *r):n(c),l(l),r(r){}
    ll n;
    Node *l;
    Node *r;
};

void build(Node* &node)
{
    ll ch;
    scanf("%lld",&ch);
    if (ch == 0) return;
    node = new Node(ch,NULL,NULL);
    build(node -> l);
    build(node -> r);
}

ll tg;

ll a[110];

vector<vector<ll>> ans;

void dfs(Node *node,int num,int dps)
{
    num += node -> n;
    a[dps] = node -> n;
    if (num == tg && node -> l == NULL && node -> r == NULL) {
        vector<ll> k;
        rep(i,1,dps) k.pb(a[i]);
        ans.pb(k);
    }
    if (node -> l != NULL) dfs(node -> l,num,dps + 1);
    if (node -> r != NULL) dfs(node -> r,num,dps + 1);
}

int main()
{
    Node *root;
    build(root);
    scanf("%lld",&tg);
    dfs(root,0,1);
    printf("%lu\n",ans.size());
    for (auto i : ans) {
        for (auto j : i) {
            printf("%lld ",j);
        }
        puts("");
    }
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n & 1) {
            pre(i,n,n/2+2) printf("%d ",i);
            pre(i,n/2,1) printf("%d ",i);
            printf("%d",n/2+1);
        } else {
            pre(i,n,1) {
                if (i != n) printf(" ");
                printf("%d",i);
            }
        }
        puts("");
    }
}
*/

/*
map<int,int> a;
map<int,int> b;

int main()
{
    int n,t;
    int ans;
    __T {
        a.clear();
        sci(n);
        rep(i,1,n) {
            sci(t);
            a[t] ++;
            b[t] = i;
        }
        ans = -1;
        for (auto i : a) {
            if (i.second == 1) {
                ans = b[i.first];
                break;
            }
        }
        printf("%d\n",ans);
    }
    
    return 0;
}
*/

/*
int a[200010];
map<int,int> pos;
map<int,int> ans;

int main()
{
    int n;
    int t,l=0;
    int cnt;
    int m;
    __T {
        sci(n);
        cnt = 0;
        pos.clear();
        ans.clear();
        rep(i,1,n) {
            sci(t);
            if (i != 1) {
                if (l != t) a[++cnt] = t;
            } else a[++cnt] = t;
            l = t;
        }
//        rep(i,1,cnt) printf("%d ",a[i]);
//        puts("");
        rep(i,1,cnt) {
            if (pos[a[i]] != i) ans[a[i]] ++;
            pos[a[i]] = i;
        }
        ans[a[cnt]] --;
        ans[a[1]] --;
//        _C("----");
        m = INT_INF;
        for (auto i : ans) {
            m = min(m,i.second);
//            printf("%d %d\n",i.first,i.second);
        }
        printf("%d\n",m+1);;
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    map<ll,int> a;
    ll nn;
    int ans;
    ll all[100];
    __T {
        scl(n);
        a.clear();
        nn = n;
        for (ll i = 2;i * i <= n;i ++) {
            while (nn % i == 0) {
                a[i] ++;
                nn /= i;
            }
        }
        if (nn != 1) a[nn] ++;
        ans = 1;
        for (auto i : a) {
            ans = max(ans,i.second);
        }
        rep(i,1,ans) all[i] = 1;
        for (auto i : a) {
            for (int j = 1,k = ans;j <= i.second;j ++,k --) {
                all[k] *= i.first;
            }
        }
        printf("%d\n",ans);
        rep(i,1,ans) {
            if (i != 1) printf(" ");
            printf("%lld",all[i]);
        }
        puts("");
    }
    return 0;
}
*/

/*
vector<int> g[200010];
int d[100010];
int vis[100010];
int c[100010];

int s;
int mnt;

void find_cir(int u,int dps,int f)
{
    if (vis[u]) {
        if (!c[u]) {
            s = u;
            mnt = dps - vis[u];
        }
        return;
    }
    vis[u] = dps;
    for (auto i : g[u]) {
        if (f == i) continue;
        find_cir(i,dps + 1,u);
        if (s != -1) {
            if (s == u) s = -1;
            c[u] = 1;
            break;
        }
    }
}

int get(int u,int f) {
    int cnt = 0;
    for (auto i : g[u]) {
        if (f == i) continue;
        get(i,u);
    }
    return cnt + 1;
}

int main()
{
    int n;
    int u,v;
    __T {
        sci(n);
        rep(i,1,n) {
            g[i].clear();
            vis[i] = c[i] = d[i] = 0;
        }
        rep(i,1,n) {
            scii(u,v);
            g[u].pb(v);
            g[v].pb(u);
        }
        rep(i,1,n) d[i] /= 2;
        s = -1;
        find_cir(1,1,-1);
//        rep(i,1,n) printf("%d ",c[i]);
//        puts("");
//        printf("%d\n",mnt);
        
    }
    return 0;
}
*/

//const int MAXN = 200010;
//
//int ST[MAXN][40];
//int st[MAXN][40];
//int a[MAXN];
//
//int n;
//
//void init() {
//    // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
//    rep(i,1,n) ST[i][0] = a[i];
//
//    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
//        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
//            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]); // 套公式
//        }
//    }
//
//    rep(i,1,n) st[i][0] = a[i];
//
//    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
//        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
//            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); // 套公式
//        }
//    }
//}
//
//inline int qmax(int l, int r)
//{
//    int x = log2(r - l + 1);
//    return max(ST[l][x],ST[r - (1 << x) + 1][x]);
//}
//
//inline int qmin(int l, int r)
//{
//    int x = log2(r - l + 1);
//    return min(st[l][x],st[r - (1 << x) + 1][x]);
//}
//
//int prefix[MAXN];
//int sufix[MAXN];
//
//int main()
//{
//    int l,r;
//    itn aa,bb,cc;
//    __T
//    {
//        sci(n);
//        rep(i,1,n) sci(a[i]);
//        init();
//        prefix[1] = a[1];
//        rep(i,2,n) prefix[i] = max(a[i],prefix[i - 1]);
//        sufix[n] = a[n];
//        pre(i,n-1,1) sufix[i] = max(a[i], sufix[i + 1]);
////        rep(i,1,n) printf("%d ",prefix[i]);
////        puts("");
////        rep(i,1,n) printf("%d ",sufix[i]);
////        puts("");
//        rep(i,1,n) {
//            l = (int) (lower_bound(sufix + 1, sufix + 1 + n, prefix[i], greater<int>()) - sufix);
//            r = (int) (upper_bound(sufix + 1, sufix + 1 + n, prefix[i], greater<int>()) - sufix);
////            _C(l << " " << r)
//            l = max(l,i+1);
//            pre(j,r-1,l) {
//                if (i+1>j-1) break;
////                _C("[1," << i << "] [" << i + 1 << "," << j - 1 << "] [" << j << "," << n << "]")
////                _C(prefix[i] << " " << qmin(i+1, j-1) << " " << sufix[j])
//                if (prefix[i] == sufix[j] && qmin(i+1, j-1) == prefix[i]) {
//                    aa = i;
//                    bb = j - i - 1;
//                    cc = n - j + 1;
//                    goto end;
//                }
//            }
//        }
//        puts("NO");
//        continue;
//        end:
//        puts("YES");
//        printf("%d %d %d\n",aa,bb,cc);
//    }
//
//    return 0;
//}

/*
int main()
{
    int n;
    int k;
    int tg;
    char x;
    __T {
        sci(n);
        x = 'a';
        while (n > 0) {
            k = sqrt(n * 2 + 0.25) - 0.5;
            tg = (1+k)*k/2;
            rep(i,1,k) printf("%c",x);
            n = n - tg;
            x ++;
        }
        puts("");
    }
}
*/

/*
const int MAXN = 50;

struct Node {
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}

    int n;
    Node *l;
    Node *r;
} *root;

int gin[MAXN];
int gpost[MAXN];

void build(int *in,int *post,int len,Node **node)
{
    if (len <= 0) return;
    int mid = post[len-1];
    int x = 0;
    REP(i,0,len) {
        if (in[i] == mid) {
            x = i;
            break;
        }
    }
    *node = new Node(mid,NULL,NULL);
    build(in,post,x,&((*node) -> l));
    build(in + x + 1, post + x, len - x - 1, &((*node) -> r));
}

void dfs(Node *node) {
    printf(" %d",node -> n);
    if (node -> l != NULL) dfs(node -> l);
    if (node -> r != NULL) dfs(node -> r);
}

int main()
{
    int n;
    sci(n);
    REP(i,0,n) sci(gpost[i]);
    REP(i,0,n) sci(gin[i]);
    build(gin, gpost, n, &root);
    printf("Preorder:");
    dfs(root);
    puts("");
}
*/

/*
vector<int> g[100010];
vector<int> c[100010];

int m = 0;

void dfs(int n,int dps)
{
    m = max(m,dps);
    c[dps].pb(n);
    for (auto i : g[n]) {
        dfs(i,dps + 1);
    }
}

int main()
{
    int n;
    sci(n);
    int t;
    rep(i,1,n) {
        sci(t);
        if (t == -1) t = 0;
        g[t].pb(i);
    }
    dfs(0,0);
    printf("%d\n",m);
    sort(c[m].begin(),c[m].end());
    int f = 1;
    for (auto i : c[m]) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
}
*/

/*
struct Node {
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}
    int n;
    Node *l;
    Node *r;
} *root;

int n,m;

void build()
{
    int t;
    read(t);
    root = new Node(t,NULL,NULL);
    Node *node;
    rep(i,2,n) {
        read(t);
        node = root;
        while (1) {
            if (t <= node -> n) {
                if (node -> l == NULL) {
                    node -> l = new Node(t,NULL,NULL);
                    break;
                }
                else node = node -> l;
            } else {
                if (node -> r == NULL) {
                    node -> r = new Node(t,NULL,NULL);
                    break;
                }
                else node = node -> r;
            }
        }
    }
}

int find(int n)
{
    Node *node = root;
    while (node != NULL) {
        if (node -> n == n) return 1;
        if (n < node -> n) node = node -> l;
        else node = node -> r;
    }
    return 0;
}

int main()
{
    read(m);
    read(n);
    build();
    int u,v;
    set<int> f;
    Node *node;
    int hasU,hasV;
    rep(i,1,m) {
        read(u);
        read(v);
        hasU = find(u);
        hasV = find(v);
        if (!hasU && !hasV) printf("ERROR: %d and %d are not found.\n",u,v);
        else if (!hasU) printf("ERROR: %d is not found.\n",u);
        else if (!hasV) printf("ERROR: %d is not found.\n",v);
        else {
            node = root;
            while (node != NULL) {
                if (u == node -> n) {
                    printf("%d is an ancestor of %d.\n",u,v);
                    break;
                } else if (v == node -> n) {
                    printf("%d is an ancestor of %d.\n",v,u);
                    break;
                } else if ((u < node -> n && v > node -> n) || (v < node -> n && u > node -> n)) {
                    printf("LCA of %d and %d is %d.\n",u,v,node -> n);
                    break;
                } else {
                    if (u < node -> n) node = node -> l;
                    if (u > node -> n) node = node -> r;
                }
            }
        }
    }
}
*/

/*
int main()
{
    int ans = 0;
    rep(a,1,9) {
        rep(b,1,9) {
            rep(c,1,9) {
                rep(d,1,9) {
                    rep(e,1,9) {
                        if (a == b || a == c || a == d || a == e ||
                            b == c || b == d || b == e ||
                            c == d || c == e ||
                            d == e) continue;
                        if ((a * 10 + b) * (c * 100 + d * 10 + e) == (a * 100 + d * 10 + b) * (c * 10 + e)) ans ++;
                    }
                }
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
*/

/*
int get(int x) {
    int ans = 0;
    while (x) {
        ans += x /= 5;
    }
    return ans;
}

int main()
{
    int n;
    int l,r;
    int m,k;
    int f;
    int x = 0;
    __T {
        sci(n);
        l = 1;
        f = 0;
        r = 1000000000;
        
        while (l <= r) {
            m = (l + r) / 2;
            k = get(m);
            if (k < n) l = m + 1;
            else if (k > n) r = m - 1;
            else {
                r = m - 1;
                x = m;
                f = 1;
            }
        }
        if (f) printf("%d\n",x);
        else puts("QAQ");
    }
    
}
*/

/*
int dp[3010][5010];
int main()
{
    int n;
    int a[3010];
    int sum;
    int ans;
    __T {
        sci(n);
        sum = 0;
        rep(i,1,n) {
            sci(a[i]);
            sum += a[i];
        }
        ans = 0;
        rep(i,1,n) {
            for (int j = 0;j <= sum;j ++) {
                if (j >= a[i]) dp[i][j] = max(dp[i-1][j],min(dp[i - 1][j - a[i]] + a[i],sum - dp[i - 1][j - a[i]] - a[i]));
                else dp[i][j] = dp[i-1][j];
                ans = max(dp[i][j],ans);
            }
        }
        printf("%d\n",ans);
        
    }
}
*/

/*
struct Node {
    Node *nxt[10];
    Node() {
        rep(i,0,9) nxt[i] = NULL;
    }
};

Node *root;

void add(ll num) {
    vector<int> k;
    Node *node = root;
    while (num) {
        k.pb(num % 10);
        num /= 10;
    }
    while (k.size() < 10) k.pb(0);
    for (vector<int>::reverse_iterator i = k.rbegin();i != k.rend();i ++) {
        if (node -> nxt[*i] == NULL) {
            node -> nxt[*i] = new Node();
        }
        node = node -> nxt[*i];
    }
}

void dfs(Node *node,int num)
{
    printf("%d ",num);
    rep(i,0,9) {
        if (node -> nxt[i] != NULL) dfs(node -> nxt[i],i);
    }
}

int main()
{
    int n,r;
    scii(n,r);
    root = new Node();
    ll t;
    rep(i,1,n) {
        scl(t);
        add(t);
    }
    
    int q;
    sci(q);
    vector<int> k;
    Node *node;
    int mx,mj;
    Node *pm = NULL;
    ll num;
    ll ans;
    while (q --) {
        k.clear();
        scl(t);
        node = root;
        ans = 0;
        while (t) {
            k.pb(t % 10);
            t /= 10;
        }
        while (k.size() < 10) k.pb(0);
        num = 0;
        for (vector<int>::reverse_iterator i = k.rbegin();i != k.rend();i ++) {
            mx = -1;
            mj = -1;
            rep(j,0,9) {
                if (node -> nxt[j] != NULL) {
                    if (((j + *i) % r) > mx) {
                        mx = (j + *i) % r;
                        pm = node -> nxt[j];
                        mj = j;
                    }
                }
            }
            num *= 10;
            num += mj;
            node = pm;
            ans *= 10;
            ans += mx;
        }
        _C(ans)
    }
}
*/

/*
const int MAXN = 2e5 + 10;

struct Node {
    int l,r;
    ll sum;
    ll lazy;
} tree[MAXN << 2];
void push_up(int i)
{
    tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy) {
        tree[i << 1].sum = tree[i << 1].r - tree[i << 1].l + 1 - tree[i << 1].sum;
        tree[i << 1 | 1].sum = tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1 - tree[i << 1 | 1].sum;

        tree[i << 1].lazy = !tree[i << 1].lazy;
        tree[i << 1 | 1].lazy = !tree[i << 1 | 1].lazy;

        tree[i].lazy = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    if (l == r) {
        tree[i].sum = 0;
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void add(int l,int r,int i) // 将区间[l,r]整个加上x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum = tree[i].r - tree[i].l + 1 - tree[i].sum;
        tree[i].lazy = !tree[i].lazy;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) add(l,r,i << 1);
    if (r > m) add(l,r,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].sum;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll sum = 0;
    if (l <= m) {
         sum += query(l,r,i << 1);
    }
    if (r > m) {
        sum += query(l,r,i << 1 | 1);
    }
    return sum;
}

vector<int> g[MAXN];

int dfn = 0;
int in[MAXN],out[MAXN];

void dfs(int k,int f)
{
    in[k] = ++ dfn;
    for (vector<int>::iterator i = g[k].begin();i != g[k].end();i ++)
    {
        if (*i != f) {
            dfs(*i,k);
        }
    }
    out[k] = dfn;
}

int main() {
    int n,q;
    scii(n,q);
    int u,v;
    rep(i,1,n-1) {
        scii(u,v);
        g[u].pb(v);
    }
    dfs(1,-1);
    build(1, n, 1);
    while (q --) {
        scii(u,v);
        if (u == 1) {
            add(in[v], out[v], 1);
        } else {
            printf("%lld\n",query(in[v], out[v], 1));
        }
    }
}
*/

/*
int main()
{
    const int mod = 1e9 + 7;
    ll n,m,na,ma,nb,mb,a,b;
    __T {
        scll(n,m);
        na = n + 1;
        nb = n;
        ma = m + 1;
        mb = m;
        if (na % 2 == 0) na /= 2;
        if (nb % 2 == 0) nb /= 2;
        if (ma % 2 == 0) ma /= 2;
        if (mb % 2 == 0) mb /= 2;
        na %= mod;
        nb %= mod;
        ma %= mod;
        mb %= mod;
        a = na * nb % mod;
        b = ma * mb % mod;
        printf("%lld\n",a * b % mod);
    }
}*/

/*
struct Node {
    int n;
    Node *l;
    Node *r;
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}
} *root;

Node* RR(Node *node)
{
    Node *l = node -> l;
    node -> l = l -> r;
    l -> r = node;
    return l;
}

Node* LL(Node *node)
{
    Node *r = node -> r;
    node -> r = r -> l;
    r -> l = node;
    return r;
}

Node* LR(Node *node)
{
    node -> l = LL(node -> l);
    return RR(node);
}

Node* RL(Node *node)
{
    node -> r = RR(node -> r);
    return LL(node);
}

int getHeight(Node *n) {
    if (n == NULL) return 0;
    int x = 0;
    x = max(x,getHeight(n -> l));
    x = max(x,getHeight(n -> r));
    return x + 1;
}

int getF(Node *node)
{
    return getHeight(node -> l) - getHeight(node -> r);
}

Node* insert(Node *node,int n)
{
    if (node == NULL) {
        node = new Node(n,NULL,NULL);
    } else if (n < node -> n) {
        node -> l = insert(node -> l, n);
        if (getF(node) == 2) {
            if (n < node -> l -> n) node = RR(node);
            else node = LR(node);
        }
    } else if (n > node -> n) {
        node -> r = insert(node -> r, n);
        if (getF(node) == -2) {
            if (n > node -> r -> n) node = LL(node);
            else node = RL(node);
        }
    }
    return node;
}

void dfs(Node *node)
{
    if (node == NULL) return;
    printf("%d ",node -> n);
    dfs(node -> l);
    dfs(node -> r);
}

int main()
{
    int n;
    sci(n);
    int t;
    rep(i,1,n) {
        sci(t);
        root = insert(root,t);
    }
    printf("%d\n",root -> n);
}
*/

/*
int a[100010]; // 从1开始
int n = 0;

void up(int i)
{
    int p = i / 2;
    while (p != 0 && a[i] > a[p])
    {
        swap(a[i], a[p]);
        i = p;
        p /= 2;
    }
}

void down(int i)
{
    int k = i * 2;
    if (k + 1 <= n && a[k + 1] > a[k]) k ++;
    while (k <= n && a[i] < a[k])
    {
        swap(a[i], a[k]);
        i = k;
        k *= 2;
        if (k + 1 <= n && a[k + 1] > a[k]) k ++;
    }
}

void push(int num)
{
    a[++ n] = num;
    up(n);
}

void pop()
{
    if (n > 0)
    {
        swap(a[1], a[n --]);
        down(1);
    }
}

void heapify()
{
    for (int i = n / 2;i >= 1;i --)
    {
        down(i);
    }
}

int main() {
    int m;
    scanf("%d%d",&n,&m);
    rep(i,1,n) sci(a[i]);
    heapify();
    int t,x;
    while (m --) {
        sci(t);
        if (t == 0) {
            pop();
        } else if (t == 1) {
            sci(x);
            push(x);
        } else if (t == 2) {
            sci(x);
            printf("%d\n",a[x]);
        }
    }
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

int main()
{
    int n,m;
    int a[MAXN];
    scii(n,m);
    rep(i,1,m) {
        sci(a[i]);
    }
    int k;
    sci(k);
    int u,v;
    init(n + 5);
    rep(i,1,k) {
        scii(u,v);
        bind(u,v);
    }
    int ok = 0;
    int x = find(1);
    rep(i,1,m) {
        if (x == find(a[i])) {
            ok = 1;
            break;
        }
    }
    puts(ok ? "YES" : "NO");
    return 0;
}
*/

/*
int a[100010]; // 从1开始
int n = 0;

void up(int i)
{
    int p = i / 2;
    while (p != 0 && a[i] < a[p])
    {
        swap(a[i], a[p]);
        i = p;
        p /= 2;
    }
}

void down(int i)
{
    int k = i * 2;
    if (k + 1 <= n && a[k + 1] < a[k]) k ++;
    while (k <= n && a[i] > a[k])
    {
        swap(a[i], a[k]);
        i = k;
        k *= 2;
        if (k + 1 <= n && a[k + 1] < a[k]) k ++;
    }
}

void push(int num)
{
    a[++ n] = num;
    up(n);
}

void pop()
{
    if (n > 0)
    {
        swap(a[1], a[n --]);
        down(1);
    }
}

void heapify()
{
    for (int i = n / 2;i >= 1;i --)
    {
        down(i);
    }
}

int main() {
    int n,m;
    scii(n,m);
    int t;
    rep(i,1,n) {
        sci(t);
        push(t);
    }
    int f;
    rep(i,1,m) {
        sci(t);
        f = 1;
        while (t > 0) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",a[t]);
            t >>= 1;
        }
        puts("");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    ll t;
    priority_queue<ll,vector<ll>,greater<ll>> q;
    rep(i,1,n) {
        scl(t);
        q.push(t);
    }
    ll sum;
    ll ans = 0;
    while (q.size() >= 2) {
        sum = q.top();
        q.pop();
        sum += q.top();
        q.pop();
        q.push(sum);
        ans += sum;
    }
//    ans += q.top();
    printf("%lld\n",ans);
}
*/

//int a[1000010];
//
//int main()
//{
//    int m,n;
//    while (~scii(m,n)) {
//        rep(i,1,n) sci(a[i]);
//
//    }
//
//    return 0;
//}

/*
struct Node {
    int type; // 0 - num,1 - op
    char c;
    ll num;
};

int priority[130];

void getPost(string &str,vector<Node> &post) {
    post.clear();
    stack<char> op_stk;
    ll num = 0;
    int has_num = 0;
    
    for (int i = 0;str[i];i ++) {
        if (str[i] >= '0' && str[i] <= '9') {
            num = num * 10 + (str[i] ^ 48);
            has_num = 1;
        } else {
            if (has_num) post.push_back({0,0,num});
            has_num = num = 0;
            if (str[i] != ')') {
                if (str[i] != '(') while (!op_stk.empty() && priority[op_stk.top()] >= priority[str[i]]) {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.push(str[i]);
            } else {
                while (op_stk.top() != '(') {
                    post.push_back({1,op_stk.top(),0});
                    op_stk.pop();
                }
                op_stk.pop();
            }
        }
    }
    if (has_num) post.push_back({0,0,num});
    while (!op_stk.empty()) {
        post.push_back({1,op_stk.top(),0});
        op_stk.pop();
    }
}

ll getAns(vector<Node> &post) {
    ll ans = 0;
    stack<ll> num_stk;
    
    for (auto i : post) {
        if (!i.type) num_stk.push(i.num);
        else {
            switch (i.c) {
                case '+':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans += num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '-':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans = num_stk.top() - ans;
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                case '*':
                    ans = num_stk.top();
                    num_stk.pop();
                    ans *= num_stk.top();
                    num_stk.pop();
                    num_stk.push(ans);
                    break;
                default:
                    break;
            }
        }
    }
    return num_stk.top();
}

vector<Node> post;
set<ll> ans;
ll t;
void dfs(int i,string str)
{
    if (i == str.size()) {
        if (str.size() == 4) return;
        post.clear();
        getPost(str,post);
        t = getAns(post);
        if (t >= 0) ans.insert(t);
        return;
    }
    dfs(i + 1,str);
    dfs(i + 2,str.substr(0,i) + '+' + str.substr(i));
    dfs(i + 2,str.substr(0,i) + '-' + str.substr(i));
    dfs(i + 2,str.substr(0,i) + '*' + str.substr(i));
}

inline void getStr(string &str,int a)
{
    str += (char)(a + '0');
}

int main()
{
    int a[4];
    scii(a[0],a[1]);
    scii(a[2],a[3]);
    // 4
    int p[] = {0,1,2,3};
    
    priority['('] = 1;
    priority['*'] = 3;
    priority['+'] = priority['-'] = 2;
    string str;
    do {
        str = "";
        getStr(str,a[p[0]]);
        getStr(str,a[p[1]]);
        getStr(str,a[p[2]]);
        getStr(str,a[p[3]]);
        dfs(1,str);
    } while (next_permutation(p, p + 4));
    printf("%lu\n",ans.size());
}
*/

/*
int main()
{
    int n,m;
    int t;
    __T {
        scii(n,m);
        rep(i,1,n) {
            sci(t);
        }
        rep(i,1,m) {
            sci(t);
        }
        if (n == 1 && m == 1) puts("1");
        else if (n == 1 && m == 2) puts("1");
        else if (n == 2 && m == 1) puts("1");
        else puts("7");
    }
    return 0;
}
*/

/*
const int MAXN = 1e4 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

struct Edge {
    int u,v;
    ll w;
};

bool cmp(const Edge &a,const Edge &b) {
    return a.w > b.w;
}

bool cmp1(const Edge &a,const Edge &b) {
    return a.w < b.w;
}

Edge ed[500010];

struct Eg {
    int to;
    ll w;
    int nxt;
} e[500010 * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init_g(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

ll ans = 0;

void dfs(int u,int f,ll m)
{
    ll k;
    if (m != -1) ans += m;
    for (int i = g[u];~i;i = e[i].nxt) {
        if (e[i].to == f) continue;
        k = m;
        if (m == -1 || e[i].w < m) k = e[i].w;
        dfs(e[i].to,u,k);
    }
}

int main()
{
    int n,m;
    scii(n,m);
    int u,v;
    ll w;
    init(n + 5);
    
    rep(i,1,m) {
        scii(u,v);
        scl(w);
        ed[i] = {u,v,w};
    }
    sort(ed + 1,ed + 1 + m,cmp);
    ll k = 0;
    for (auto i : ed) {
        u = find(i.u);
        v = find(i.v);
        if (u != v) {
            bind(u,v);
            k = i.w;
        }
    }
    sort(ed + 1,ed + 1 + m,cmp1);
    init(n + 5);
    init_g(n + 5);
    rep(i,1,m) {
        if (ed[i].w == k) k = -1;
        if (k != -1) continue;
        u = find(ed[i].u);
        v = find(ed[i].v);
        if (u != v) {
            bind(ed[i].u,ed[i].v);
            add_edge(ed[i].u, ed[i].v, ed[i].w);
            add_edge(ed[i].v, ed[i].u, ed[i].w);
        }
    }
    rep(i,1,n) dfs(i,-1,-1);
    printf("%lld\n",ans / 2);
    return 0;
}
*/

/*
int a[10010][10010];

int main()
{
    int n,k,x,y;
    __T {
        scii(n,k);
        if (n == 1) {
            printf("%d\n",0);
            continue;
        }
        a[0][0] = k - 1;
        REP(i,0,n - 1) {
            rep(j,0,i) {
                a[i + 1][j] = 0;
                a[i + 1][j + 1] = 0;
            }
            rep(j,0,i) {
                a[i + 1][j] += a[i][j] / 2;
                a[i + 1][j + 1] += a[i][j] / 2;
                if (a[i][j] & 1) a[i + 1][j] ++;
            }
        }
        x = y = 0;
        do {
            if (a[x][y] & 1) y ++;
            x ++;
        } while (x < n - 1);
        printf("%d\n",y);
    }
}
*/

/*
int main()
{
    double n;
    double ans;
    int i,j;
    __T {
        scd(n);
        ans = 0;
        i = 1;
        j = 1;
        while (1.0 / i >= n) {
            ans += pow(-1,j + 1) * 1 / i;
            i += 2;
            j ++;
        }
        printf("%.6f\n",ans);
    }
    
    return 0;
}
*/

/*
int main()
{
    string str;
    int num,ans;
    char type;
    __T {
        cin >> str;
        num = 0;
        ans = 0;
        type = '+';
        for (int i = 0;str[i];i ++) {
            if (isdigit(str[i])) {
                num *= 10;
                num += str[i] ^ 48;
            } else {
                switch (type) {
                    case '+':
                        ans += num;
                        break;
                    case '-':
                        ans -= num;
                        break;
                    case '*':
                        ans *= num;
                        break;
                    case '/':
                        ans /= num;
                        break;
                }
                num = 0;
                type = str[i];
            }
        }
        printf("%d\n",ans);
    }
}
*/

/*
int check(int n)
{
    int k = 0;
    int nn = n;
    while (n) {
        k += (n % 10) * (n % 10) * (n % 10);
        n /= 10;
    }
    return k == nn;
}

int main()
{
    int u,v;
    __T {
        scii(u,v);
        rep(i,u,v) {
            if (check(i)) printf("%d\n",i);
        }
    }
    return 0;
}
*/

/*int main()
{
    int n,m;
    string str;
    int k;
    __T {
        scii(n,m);
        cin >> str;
        k = 0;
        rep(i,1,n) {
            rep(j,1,m) {
                printf("%c",str[k ++]);
            }
            puts("");
        }
        
    }
}
*/

/*
int a[35][35];
int b[35][35];

int main()
{
    int n,mx;
    int cnt;
    while (~scanf("%d",&n)) {
        if (n == 0) break;
        rep(i,1,n) {
            rep(j,1,n) sci(a[i][j]);
        }
        cnt = mx = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                sci(b[i][j]);
                if (a[i][j] == b[i][j]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[j][n-i+1]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[n-i+1][n-j+1]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        cnt = 0;
        rep(i,1,n) {
            rep(j,1,n) {
                if (a[i][j] == b[n-j+1][i]) cnt ++;
            }
        }
        mx = max(cnt,mx);
        printf("%d\n",mx);
    }
    return 0;
}
*/

/*
struct Node {
    Node(const string &name,int type):name(name),type(type){}
    Node(){}
    string name;
    map<string,Node*> pNxt;
    int type;
};

Node *root;

void insert(string &str,vector<string> &pv,int t)
{
    string x;
    pv.clear();
    x = "";
    for (int i = 0;str[i];i ++) {
        if (str[i] == '/') {
            pv.pb(x);
            x = "";
        } else x += str[i];
    }
    pv.pb(x);
    Node *node = root;
    Node *p;
    int tt;
    for (auto i = pv.begin();i != pv.end();i ++) {
        p = node -> pNxt[*i];
        if (p != NULL) {
            node = p;
        } else {
            if (i == pv.end() - 1) tt = t;
            else tt = 0;
            p = new Node(*i,tt);
            node -> pNxt[*i] = p;
            node = p;
        }
    }
}

int dfs(Node *node)
{
    if (node == NULL) return 0;
    int size = (int) node -> pNxt.size();
    int sum = 0;
    for (auto i : node -> pNxt) {
        sum += dfs(i.second);
    }
//    _C(node -> name << "=" << node -> type << " " << sum << "/" << size);
    if (node -> type == 0 && sum == size && node -> pNxt.size() != 0 && node -> name != "/") {
        node -> type = 1;
    }
    return node -> type;
}

int ans;

void pre_dfs(Node *node)
{
    if (node == NULL) return;
//    _C(node -> name << " " << node -> type)
    if (node -> type) {
        ans ++;
        return;
    }
    for (auto i : node -> pNxt) {
        pre_dfs(i.second);
    }
}

int main()
{
    int n,m;
    string str;
    vector<string> p;
    string x;
    __T {
        scii(n,m);
        root = new Node("/",0);
        rep(i,1,n) {
            cin >> str;
            insert(str,p,1);
        }
        rep(i,1,m) {
            cin >> str;
            insert(str,p,0);
        }
        dfs(root);
//        _C("=========")
        ans = 0;
        pre_dfs(root);
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main()
{
    ll n;
    scanf("%lld",&n);
    ll k = n / 3;
    printf("%lld\n",(k - 1) * k + k * (n % 3) + (1 + k * 3) * k / 2);
}
*/

/*
char a[1010][1010];
char b[1010][1010];

int main()
{
    int n,m;
    scii(n,m);
    REP(i,0,n) {
        scanf("%s",a[i]);
    }
    REP(i,0,n) {
        scanf("%s",b[i]);
    }
    int sum = 0;
    REP(i,0,n) {
        REP(j,0,m) {
            if (a[i][j] != b[i][j]) sum ++;
        }
    }
    if (sum <= m * n / 2) REP(i,0,n) puts(a[i]);
    else REP(i,0,n) {
        REP(j,0,m) {
            if (a[i][j] == '.') printf("X");
            else printf(".");
        }
        puts("");
    }

    return 0;
}
*/

/*
int main()
{
    double n,p1,v1,p2,v2,ans;
    double l,r,m,t1,t2;
    __T {
        scd(n);
        scdd(p1,v1);
        scdd(p2,v2);
        if (p1 > p2) {
            swap(p1,p2);
            swap(v1,v2);
        }
        // <->
        ans = (n + p1 + n - p2) / (v1 + v2);
        // -><-
        ans = min(ans,(n + p2 - p1) / (v1 + v2));
        // full
        ans = min(ans,(n + p1) / v1); // <- 1
        ans = min(ans,(n + n - p1) / v1); // 1 ->
        
        ans = min(ans,(n + p2) / v2); // <- 2
        ans = min(ans,(n + n - p2) / v2); // 2 ->
        // common
        l = p1;
        r = p2;
        rep(i,1,500) {
            m = (l + r) / 2;
            t1 = (m + m - p1) / v1;
            t2 = (n + n - m - p2) / v2;
            if (t1 > t2) r = m;
            else l = m;
        }
        ans = min(ans,t1);
        l = p1;
        r = p2;
        rep(i,1,500) {
            m = (l + r) / 2;
            t1 = (m + p1) / v1;
            t2 = (n - m + p2 - m) / v2;
            if (t1 > t2) r = m;
            else l = m;
        }
        ans = min(ans,t1);
        printf("%.10f\n",ans);
    }
    return 0;
}
*/

/*
struct Node {
    int n;
    int i;
} a[100010];

inline bool cmp(const Node &a,const Node &b) {
    return a.n < b.n;
}

int main()
{
    int n,m;
    Node t;
    ll sum1,sum2;
    ll ans;
    while (~scanf("%d",&n)) {
        rep(i,1,n) {
            scanf("%d",&a[i].n);
            a[i].i = i;
        }
        scanf("%d",&m);
        sort(a + 1,a + 1 + n,cmp);
        sum1 = sum2 = 0;
        while (m --) {
            scanf("%d",&t.n);
            ans = lower_bound(a + 1, a + 1 + n,t,cmp) -> i;
            sum1 += ans;
            sum2 += n - ans + 1;
//            _C(ans << " " << n - ans + 1)
        }
        printf("%lld %lld\n",sum1,sum2);
    }
}
*/

/*
const int MAXN = 1e2 + 10;

struct Node {
    Node (int to,int step):to(to),step(step){}
    int to;
    int step;
};

vector<Node> g[MAXN];
int vis[MAXN][2];

int s,t;
int ok = 0;

void dfs(int u,int s)
{
    if (vis[u][s]) return;
    vis[u][s] = 1;
    if (u == t) ok = 1;
    if (ok) return;
    vis[u][s] = 1;
    for (auto i : g[u]) {
        if (i.step == s) {
            dfs(i.to,!s);
        }
    }
}

int main()
{
    int n,m;
    int u,v;
    int T;
    scanf("%d",&T);
    while (T --) {
        scanf("%d%d",&n,&m);
        scanf("%d%d",&s,&t);
        for (int i = 1;i <= n;i ++) g[i].clear();
        memset(vis,0,sizeof vis);
        ok = 0;
        while (m --) {
            scanf("%d%d",&u,&v);
            g[u].pb(Node(v,0));
            g[v].pb(Node(u,1));
        }
        dfs(s,0);
        puts(ok ? "YES" : "NO");
    }
    return 0;
}
*/

/*
const int MAXN = 1e2 + 10;

vector<int> g[MAXN << 1];
int vis[MAXN << 1];

int s,t,n,m;
int ok = 0;

void dfs(int u)
{
    if (vis[u]) return;
    vis[u] = 1;
    if (u == t || u == t + n) ok = 1;
    if (ok) return;
    vis[u] = 1;
    for (auto i : g[u]) {
        dfs(i);
    }
}

int main()
{
    int u,v;
    int T;
    scanf("%d",&T);
    while (T --) {
        scanf("%d%d",&n,&m);
        scanf("%d%d",&s,&t);
        for (int i = 1;i <= n * 2;i ++) g[i].clear();
        memset(vis,0,sizeof vis);
        ok = 0;
        while (m --) {
            scanf("%d%d",&u,&v);
            g[u].pb(v + n);
            g[v + n].pb(u);
        }
        dfs(s);
        puts(ok ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    int a[110];
    rep(i,1,n) sci(a[i]);
    rep(i,1,k) {
        rep(j,1,n-i) {
            if (a[j] > a[j + 1]) swap(a[j],a[j + 1]);
        }
    }
    rep(i,1,n) {
        if (i != 1) printf(" ");
        printf("%d",a[i]);
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    int a,b;
    scii(a,b);
    int k,kk;
    map<int,int> p;
    int n,ans;
    int ok;
    int kok = 0;
    rep(i,a,b) {
        k = i * i + 1;
        kk = k;
        p.clear();
        for (int j = 2;j * j <= kk;j ++) {
            while (k % j == 0) {
                p[j] ++;
                k /= j;
            }
        }
        if (k != 1) p[k] ++;
        ok = 1;
        for (auto j : p) {
            n = i;
            ans = 0;
            while (n) {
                n /= j.first;
                ans += n;
            }
            if (ans < j.second) {
                ok = 0;
                break;
            }
        }
        if (ok) {
            printf("%d\n",i);
            kok = 1;
        }
    }
    if (!kok) puts("None");
}
*/

/*
int main()
{
    int a,b;
    __T {
        scii(a,b);
        if (a > b) swap(a,b);
        if (a == 1 && b == 3) puts("1 sheng 3");
        else if (a == 1 && b == 5) puts("5 sheng 1");
        else if (a == 2 && b == 4) puts("2 sheng 4");
        else if (a == 2 && b == 3) puts("3 sheng 2");
        else if (a == 4 && b == 5) puts("4 sheng 5");
        else {
            if (a == 1 && b == 4) swap(a,b);
            if (a == 3 && b == 5) swap(a,b);
            printf("%d ke %d\n",a,b);
        }
    }
    return 0;
}
*/

//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int a[1010];
//    rep(i,1,n) sci(a[i]);
//    int ed = n;
//    vector<int> ans;
//    rep(i,1,ed) {
//        if (a[i] != a[ed]) ans.pb(a[i]);
//        else ed --;
//    }
//    int f = 1;
//    for (auto i = ans.rbegin();i != ans.rend();i ++) {
//        if (f) f = 0;
//        else printf(" ");
//        printf("%d",*i);
//    }
//    if (f) rep(i,1,n) {
//        if (f) f = 0;
//        else printf(" ");
//        printf("%d",a[i]);
//    }
//    puts("");
//    return 0;
//}



/*
int a[10010];
int n;

inline bool judge(int s)
{
    for (int i = s;i <= (n + s) / 2;i ++) {
        if (a[i] != a[n + s - i]) return 0;
    }
    return 1;
}


int main()
{
    scanf("%d",&n);
    for (int i = 1;i <= n;i ++) scanf("%d",a + i);
    for (int i = 1;i <= n;i ++) {
        if (judge(i)) {
            if (i == 1) {
                for (int j = 1;j <= n;j ++) {
                    if (j != 1) printf(" ");
                    printf("%d",a[j]);
                }
            } else {
                for (int j = i - 1;j >= 1;j --) {
                    if (j != i - 1) printf(" ");
                    printf("%d",a[j]);
                }
            }
            break;
        }
    }
    puts("");
}
*/

/*
int main()
{
    ll n,a,b;
    __T {
        sclll(n,a,b);
        if (b / 2.0 < a) {
            if (n & 1) printf("%lld\n",n / 2 * b + a);
            else printf("%lld\n",n / 2 * b);
        } else printf("%lld\n",a * n);
    }
    
}
*/

/*
int main()
{
    int n,m;
    scii(n,m);
    int p[20];;
    rep(i,1,n + m) p[i] = i;
    int a[20];
    int cnt = 0;
    rep(i,1,n) a[++ cnt] = 0;
    rep(i,1,m) a[++ cnt] = 1;
    int base = 0;
    int x[20] = {0};
    do {
        base ++;
        rep(i,1,n + m) {
            if (a[p[i]]) {
                x[i] ++;
                break;
            }
        }
    } while (next_permutation(p + 1, p + 1 + n + m));
    int ans = 0;
    rep(i,1,n + m) {
        ans += x[i] * i;
    }
    printf("%.6f\n",ans / (double) base);
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n <= 2) puts("Hugin");
        else puts("Steve");
    }
}
*/

/*
struct Node {
    int id;
    int s;
    int p;
} s[110];

inline int cmp(const Node &a,const Node &b) {
    if (a.s == b.s) return a.id < b.id;
    return a.s > b.s;
}

int main()
{
    int n,R,L;
    sciii(n,R,L);
    rep(i,1,n) sci(s[i].id);
    rep(i,1,n) sci(s[i].s);
    rep(i,1,n) sci(s[i].p);
    while (n > 1) {
        sort(s + 1,s + 1 + n,cmp);
        n = n - n / 2;
        rep(i,1,min(n,10)) {
            s[i].s += R;
        }
        if (n >= 6) rep(i,1,3) {
            s[i].s -= L;
        }
        if (n == 1) break;
        rep(i,1,n) {
            s[i].s += s[i].p;
        }
    }
    printf("%d %d\n",s[1].id,s[1].s);
}
*/

/*
ll sum[2][500010];

int main()
{
    int k;
    string str;
    cin >> k >> str;
    for (int i = 0;str[i];i ++) {
        sum[str[i] ^ 48][i + 1] ++;
    }
    int n = (int) str.size();
    rep(i,1,n) {
        sum[0][i] += sum[0][i - 1];
        sum[1][i] += sum[1][i - 1];
    }
    ll ans = 0;
    for (int i = 0;str[i];i ++) {
        ans += sum[!(str[i] ^ 48)][min(n,i + k + 1)] - sum[!(str[i] ^ 48)][i];
    }
    printf("%lld\n",ans);
}
*/

/*
int main()
{
    int n;
    int p;
    int f;
    __T {
        sci(n);
        p = n;
        for (int i = 2;i * i <= n;i ++) {
            if (n % i == 0) {
                p = i;
                break;
            }
        }
        f = 1;
        printf("%d\n",n - 1);
        for (int i = 1,num = 1;i <= n - 1;) {
            for (int j = num + p - 2,jj = p - 1;jj >= 1;j --,jj --) {
                if (f) f = 0;
                else printf(" ");
                printf("%d",j);
                i ++;
            }
            if (i <= n - 1) {
                if (f) f = 0;
                else printf(" ");
                printf("1");
                i ++;
            }
//            _C(i)
            num = i;
        }
        puts("");
    }
    return 0;
}
*/

/*
struct Node {
    int a,d,k;
} p[100010];

inline int cmp(const Node &a,const Node &b) {
    return a.k < b.k;
}

int main()
{
    int n,m;
    ll c1,k1,c2,k2;
    int ans = 0;
    __T {
        scii(n,m);
        scll(c1,k1);
        scll(c2,k2);
        rep(i,1,n) sci(p[i].a);
        rep(i,1,n) sci(p[i].d);
        rep(i,1,n) {
            p[i].k = INT_INF;
            if (c1 - p[i].d * k1 > 0) {
                p[i].k = min((int)ceil((double) p[i].a / (c1 - p[i].d * k1)),p[i].k);
            }
            if (c2 - p[i].d * k2 > 0) {
                p[i].k = min((int)ceil((double) p[i].a / (c2 - p[i].d * k2)),p[i].k);
            }
        }
        sort(p + 1,p + 1 + n,cmp);
        ans = 0;
        rep(i,1,n) {
            if (p[i].k <= m) {
                ans ++;
                m -= p[i].k;
            }
        }
        printf("%d\n",ans);
    }
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n == 1) puts("0.5");
        else puts("1.0");
    }
    return 0;
}
*/

//int main()
//{
//    int xa,ya,xb,yb;
//    int xc,yc,xd,yd;
//    int x0,y0,a,b,c,k;
//    int da,db;
//    double ans;
//    double t;
//    __T {
//        scii(xa,ya);
//        scii(xb,yb);
//        scii(xc,yc);
//        scii(xd,yd);
//
//        if (xb == xa) {
//            swap(xa,xc);
//            swap(ya,yc);
//            swap(xb,xd);
//            swap(yb,yd);
//        }
//
//        da = (xb - xa) / abs(xb - xa);
//        db = (yd - yc) / abs(yd - yc);
//        x0 = xc;
//        y0 = ya;
//        a = xa - x0;
//        b = yc - y0;
//        c = a * da + b * db;
//        k = min(abs(xb - xa),abs(yd - yc));
//        if (c / 2.0 >= 0) ans = sqrt(a * a + b * b);
//        else {
//            if (fabs(c / 2.0) > k) {
//                t = min((c * c / 4.0),(k + c / 2.0) * (k + c / 2.0));
//                ans = sqrt(2 * t * t + a * a + b * b - c * c / 2.0);
//            } else ans = sqrt(a * a + b * b - c * c / 2.0);
//        }
//        printf("%.2f\n",ans);
//    }
//}

/*
struct Node {
    string name;
    int cnt;
    double k;
};

int cmp(const Node &a,const Node &b)
{
    if (a.cnt == b.cnt) return a.k < b.k;
    return a.cnt > b.cnt;
}

int main()
{
    int n;
    scanf("%d",&n);
    Node p[110];
    int k;
    int a[1010];
    rep(i,1,n) {
        cin >> p[i].name >> k;
        rep(j,1,k) {
            scanf("%d",a + j);
        }
        sort(a + 1,a + 1 + k);
        p[i].cnt = (int) (unique(a + 1, a + 1 + k) - a - 1);
        p[i].k = (double) k / p[i].cnt;
    }
    sort(p + 1,p + 1 + n,cmp);
    int f = 1;
    rep(i,1,min(n,3)) {
        if (f) f = 0;
        else printf(" ");
        cout << p[i].name;
    }
    REP(i,n,3) {
        if (f) f = 0;
        else printf(" ");
        printf("-");
    }
    puts("");
}
*/

/*
struct Node {
    string id;
    int num;
    int which;
    int ps;
    int p;
} x[100000];

int cmp(const Node &a,const Node &b) {
    if (a.num == b.num) return a.id < b.id;
    return a.num > b.num;
}

int main()
{
    int n;
    scanf("%d",&n);
    int k,l,j;
    int cnt = 0;
    rep(ii,1,n) {
        scanf("%d",&k);
        rep(i,1,k) {
            cnt ++;
            cin >> x[cnt].id >> x[cnt].num;
            x[cnt].which = ii;
        }
        sort(x + 1 + cnt - k,x + 1 + cnt,cmp);
        l = -1;
        j = 1;
//        _C(1 + cnt - k << " " << cnt << " " << k)
        rep(i,1 + cnt - k,cnt) {
            if (x[i].num == l) x[i].ps = x[i - 1].ps;
            else x[i].ps = j;
            l = x[i].num;
            j ++;
        }
    }
    sort(x + 1,x + 1 + cnt,cmp);
    printf("%d\n",cnt);
    l = -1;
    rep(i,1,cnt) {
        if (x[i].num == l) x[i].p = x[i - 1].p;
        else x[i].p = i;
        l = x[i].num;
    }
    rep(i,1,cnt) {
        cout << x[i].id << " " << x[i].p << " " << x[i].which << " " << x[i].ps << endl;
    }
    return 0;
}
*/

/*
int a[100010];
int sum[100010][3];

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%d",a + i);
        a[i] %= 3;
    }
    sum[n + 1][0] = sum[n + 1][1] = sum[n + 1][2] = 0;
    pre(i,n,1) {
        rep(j,0,2) {
            sum[i][j] = sum[i + 1][j] + (a[i] == j);
        }
    }
    ll ans = 0;
    rep(i,1,n) {
        rep(j,a[i],2) {
            ans += sum[i + 1][j];
        }
    }
    printf("%lld\n",ans);
}
*/

/*
struct Node {
    ll b,j;
} x[10010];

int cmp(const Node &a,const Node &b) {
    return a.j > b.j;
}

int main()
{
    int n;
    int T = 1;
    ll ans = 0;
    while (~scanf("%d",&n) && n != 0) {
        rep(i,1,n) {
            scanf("%lld%lld",&x[i].b,&x[i].j);
        }
        sort(x + 1, x + 1 + n, cmp);
        ans = 0;
        rep(i,1,n) {
            ans += x[i].b;
        }
        ans += x[n].j;
        printf("Case %d: %lld\n",T ++,ans);
    }
    
    
}
*/

/*
struct Node {
    ll x,y;
    ll j;
} x[100010];

int cmp(const Node &a,const Node &b)
{
    return a.x * a.x + a.y * a.y < b.x * b.x + b.y * b.y;
}

const int mod = 1e9 + 7;

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%lld%lld",&x[i].x,&x[i].y);
        x[i].j = i;
    }
    sort(x + 1,x + 1 + n,cmp);
    ll ans = 0;
    ll k;
    rep(i,1,n) {
        k = (x[i].x * x[i].x % mod + x[i].y * x[i].y % mod) % mod;
        k *= (i + x[i].j) % mod;
        k %= mod;
        ans += k;
        ans %= mod;
    }
    _C(ans)
}
*/

/*
int main() {
    int n,ans;
    __T {
        sci(n);
        switch(n) {
            case 1:
                puts("9");
                break;
            case 2:
                puts("98");
                break;
            case 3:
                puts("989");
                break;
            default:
                printf("989");
                ans = 0;
                rep(i,0,n - 4) {
                    printf("%d",ans ++);
                    ans %= 10;
                }
                puts("");
                break;
        }
    }
}
*/

/*
const int MAXN = 3e5 + 10;

int a[MAXN];
int n;

int is(int i)
{
    if (i - 1 >= 1 && i + 1 <= n && a[i] > a[i - 1] && a[i] > a[i + 1]) return 1;
    if (i - 1 >= 1 && i + 1 <= n && a[i] < a[i - 1] && a[i] < a[i + 1]) return 1;
    return 0;
}

int main()
{
    int ans;
    int t;
    int m,o,x;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        ans = 0;
        rep(i,2,n - 1) {
            ans += is(i);
        }
//        _C(ans);
        m = ans;
        rep(i,1,n) {
            t = a[i];
            o = 0;
            if (i - 1 >= 1) o += is(i - 1);
            o += is(i);
            if (i + 1 <= n) o += is(i + 1);
//            _C(">" << o)
            if (i - 1 >= 1) {
                a[i] = a[i - 1];
                x = 0;
                if (i - 1 >= 1) x += is(i - 1);
                x += is(i);
                if (i + 1 <= n) x += is(i + 1);
                m = min(m,ans - o + x);
            }
            if (i + 1 <= n) {
                a[i] = a[i + 1];
                x = 0;
                if (i - 1 >= 1) x += is(i - 1);
                x += is(i);
                if (i + 1 <= n) x += is(i + 1);
                m = min(m,ans - o + x);
            }
            a[i] = t;
        }
        printf("%d\n",m);
    }
}
*/

/*
struct Node {
    Node(){}
    Node(const Node &o) {
        m = o.m;
        sum = o.sum;
    }
    ll m;
    ll sum;
} x[5],o[5];

int cmp(const Node &a,const Node &b) {
    if (a.m == b.m) return a.sum < b.sum;
    return a.m < b.m;
}

int main()
{
    int n[5];
    ll t;
    rep(i,1,3) sci(n[i]);
    rep(i,1,3) {
        x[i].sum = 0;
        rep(j,1,n[i]) {
            scl(t);
            x[i].sum += t;
            if (j == 1) x[i].m = t;
            else x[i].m = min(x[i].m,t);
        }
        x[i].sum -= x[i].m;
    }
    o[1] = x[1];
    o[2] = x[2];
    o[3] = x[3];
    int a[] = {1,2,3};
    ll ans = -1;
    do {
        x[1] = o[1];
        x[2] = o[2];
        x[3] = o[3];
        x[a[0]].m -= x[a[1]].sum + x[a[2]].sum;
        x[a[1]].m -= x[a[0]].sum;
        if (x[1].m >= 0 && x[2].m >= 0 && x[3].m >= 0) {
            sort(x + 1,x + 1 + 3,cmp);
            ans = max(ans,x[2].m + x[3].m - x[1].m);
        } else {
            ans = max(ans,abs(x[1].m) + abs(x[2].m) + abs(x[3].m));
        }
    } while (next_permutation(a, a + 3));
    printf("%lld\n",ans);
}
*/

/*
struct Node {
    int s;
    int l;
};

int main()
{
    int n;
    sci(n);
    n = 1 << n;
    vector<Node> s[2];
    int t;
    int k = 0;
    rep(i,1,n) {
        sci(t);
        s[k].pb({t,i});
        s[!k].pb({t,i});
    }
    int w,wi;
    int m;
    while (n > 2) {
        m = 0;
        for (int i = 0;i < n;i += 2) {
            w = s[k][i].s;
            wi = s[k][i].l;
            if (s[k][i + 1].s > w) {
                w = s[k][i + 1].s;
                wi = s[k][i + 1].l;
            }
            s[!k][m ++] = {w,wi};
        }
        k = !k;
        n /= 2;
//        REP(i,0,n) printf("%d ",s[k][i].s);
//        puts("");
    }
    int ans;
    if (s[k][0].s < s[k][1].s) ans = s[k][0].l;
    else ans = s[k][1].l;
    printf("%d\n",ans);
    
}
*/

/*
int main()
{
    int n;
    ll C;
    sci(n);
    scl(C);
    map<int,ll> k;
    int a,b,c;
    rep(i,1,n) {
        sciii(a,b,c);
        k[a] += c;
        k[b + 1] -= c;
    }
    ll ans = 0;
    ll base = 0;
    int last = 0;
    ll x;
    for (auto i : k) {
        x = min(base,C);
        ans += x * (i.first - last);
        base += i.second;
        last = i.first;
    }
    _C(ans)
}
*/

/*
int val[200010];
int mn[200010];
int vis[200010];
int in[200010];

vector<int> g[200010];
int n,m;

void tuopu()
{
    queue<int> q;
    rep(i,1,n) {
        if (!in[i]) q.push(i);
    }
    int top;
    while (!q.empty()) {
        top = q.front();
        q.pop();
        for (auto i : g[top]) {
            in[i] --;
            if (!in[i]) q.push(i);
            mn[i] = min(mn[i],min(mn[top],val[top]));
        }
    }
}


int main()
{
    scii(n,m);
    rep(i,1,n) {
        sci(val[i]);
        mn[i] = INT_INF;
    }
    int u,v;
    rep(i,1,m) {
        scii(u,v);
        g[u].pb(v);
        in[v] ++;
    }
    tuopu();
    int ans = -INT_INF;
    rep(i,1,n) ans = max(ans,val[i] - mn[i]);
    _C(ans)
    return 0;
}
*/

/*
int main()
{
    int x[10];
    scanf("%d%d%d",&x[1],&x[2],&x[3]);
    rep(i,1,3) x[i] %= 10;
     
    rep(i,1,10) {
        rep(i,1,3) {
            x[i] ++;
            x[i] %= 10;
        }
        sort(x + 1,x + 4);
        if (x[1] == 3 && x[2] == 6 && x[3] == 9) {
            printf("%d\n",i);
            return 0;
        }
    }
    printf("so sad!\n");
}
*/



//// 特点&稳定性
//const int MAXN = 100010;
//
///**
// * features:
// *  1. 时间复杂度O(n^2)
// *  2. 空间复杂度O(1)
// *  3. 稳定排序
// *  4. 可用作链式储存结构排序
// *  5. 移动较多，平均时间性能比插入排序差
// */
//void bubble_sort(int *s,int *e)
//{
//    for (int *i = s;i < e - 1;i ++) {
//        for (int *j = e - 1;j > i;j --) {
//            if (*j < *(j - 1)) swap(*j,*(j - 1));
//        }
////        for (int *i = s;i < e;i ++) printf("%d ",*i);
////        puts("");
//    }
//}
//
///**
// * features:
// *  1. 时间复杂度O(n^2)
// *  2. 空间复杂度O(1)
// *  3. 稳定排序
// *  4. 可用作链式储存结构排序
// *  5. 移动较少，平均时间性能比插入排序好
// */
//void select_sort(int *s,int *e)
//{
//    int mx;
//    int *x;
//    for (int *i = s;i < e;i ++) {
//        mx = *i;
//        x = i;
//        for (int *j = i + 1;j < e;j ++) {
//            if (*j < mx) {
//                mx = *j;
//                x = j;
//            }
//        }
//        swap(*i,*x);
////        for (int *i = s;i < e;i ++) printf("%d ",*i);
////        puts("");
//    }
//}
//
///**
// * features:
// *  1. 时间复杂度O(n^2)
// *  2. 空间复杂度O(1)
// *  3. 稳定排序
// *  4. 可用作链式储存结构排序
// *  5. 更适合基本有序的数列
//*/
//void insert_sort(int *s,int *e)
//{
//    int num;
//    int *j;
//    for (int *i = s + 1;i < e;i ++) {
//        num = *i;
//        for (j = i - 1;j >= s;j --) {
//            if (num < *j) *(j + 1) = *j;
//            else break;
//        }
//        *(j + 1) = num;
//    }
//}
//
//void shell_insert(int *s,int *e,int dk)
//{
//    int num;
//    int *j;
//    for (int *i = s + dk;i < e;i ++) {
//        num = *i;
//        for (j = i - dk;j >= s;j -= dk) {
//            if (num < *j) *(j + dk) = *j;
//            else break;
//        }
//        *(j + dk) = num;
//    }
//}
//
///**
// * features:
// *  1. 时间复杂度O(n^(3/2))
// *  2. 空间复杂度O(1)
// *  3. 不稳定排序
// *  4. 不可用作链式储存结构排序
// *  5. 适合 无序 和 n较大 的数列
//*/
//void shell_sort(int *s,int *e)
//{
//    for (int d = (int) (e - s) >> 1;d > 0;d >>= 1) shell_insert(s, e, d);
//}
//
//void quick_sort(int *s,int *e)
//{
//    // partition
//    int base = *s;
//    int *l = s,*r = e - 1;
//
//    while (l < r) {
//        while (l < r && *r >= base) r --;
//        *l = *r;
//        while (l < r && *l <= base) l ++;
//        *r = *l;
//    }
//    *l = base;
////    for (int *i = s;i < e;i ++) printf("%d ",*i);
////    puts("");
//
//    // sort
//    if (s >= e) return;
//    quick_sort(s, l);
//    quick_sort(l + 1, e);
//}
//
//int tmp[MAXN];
//int a[MAXN];
//
//void merge_sort(int *s,int *e) {
//    int n = (int) (e - s);
//    int m = n >> 1;
//    if (n == 1) return;
//    merge_sort(s, s + m);
//    merge_sort(s + m, e);
//    int cnt = 0;
//    int *i,*j;
//    for (i = s,j = s + m;i < s + m && j < e;) {
//        if (*i < *j) {
//            tmp[cnt ++] = *i;
//            i ++;
//        } else {
//            tmp[cnt ++] = *j;
//            j ++;
//        }
//    }
//    for (;i < s + m;i ++) tmp[cnt ++] = *i;
//    for (;j < e;j ++) tmp[cnt ++] = *j;
//    for (int *i = s,j = 0;i < e;i ++,j ++) {
//        *i = tmp[j];
//    }
//}
//
//int main()
//{
//
//    int n;
//    scanf("%d",&n);
//    rep(i,1,n) scanf("%d",a + i);
////    shell_sort(a + 1,a + 1 + n);
////    insert_sort(a + 1,a + 1 + n);
////    quick_sort(a + 1, a + 1 + n);
////    merge_sort(a + 1, a + 1 + n);
////    select_sort(a + 1, a + 1 + n);
//    bubble_sort(a + 1,a + 1 + n);
//    rep(i,1,n) {
//        if (i != 1) printf(" ");
//        printf("%d",a[i]);
//    }
//    puts("");
//}

/*
vector<char> g[150];
int in[150];
set<char> s;
vector<char> ans;
void bfs()
{
    priority_queue<char,vector<char>,greater<char> > q;
    for (set<char>::iterator i = s.begin();i != s.end();i ++) {
        if (!in[*i]) q.push(*i);
    }
    char top;
    while (!q.empty()) {
        top = q.top();
        ans.pb(top);
        q.pop();
        for (vector<char>::iterator i = g[top].begin();i != g[top].end();i ++) {
            in[*i] --;
            if (!in[*i]) q.push(*i);
        }
    }
}

int main()
{
    char a,b,type;
    while (~scanf(" %c%c%c",&a,&type,&b)) {
        s.insert(a);
        s.insert(b);
        if (type == '>') {
            g[a].pb(b);
            in[b] ++;
        } else {
            g[b].pb(a);
            in[a] ++;
        }
    }
    bfs();
    if (ans.size() == s.size()) {
        for (vector<char>::iterator i = ans.begin();i != ans.end();i ++) {
            printf("%c",*i);
        }
    } else printf("No Answer!");
    puts("");
}
*/

/*
int main()
{
    string str;
    int s,ans;
    __T {
        cin >> str;
        ans = 0;
        s = 1;
        for (int i = 0;str[i];i ++) {
            if (str[i] == 'O') {
                ans += s ++;
            } else s = 1;
        }
        printf("%d\n",ans);
    }
    return 0;
}
*/

/*
int main() {
    string str;
    double ans,x;
    int cnt;
    __T {
        cin >> str;
        ans = 0;
        cnt = 0;
        x = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] >= '0' && str[i] <= '9') {
                cnt = cnt * 10 + str[i] - '0';
            } else {
                if (cnt == 0) cnt ++;
                ans += x * cnt;
                cnt = 0;
                if (str[i] == 'C') {
                    x = 12.01;
                } else if (str[i] == 'H') {
                    x = 1.008;
                } else if (str[i] == 'O') {
                    x = 16;
                } else if (str[i] == 'N') {
                    x = 14.01;
                }
            }
        }
        if (cnt == 0) cnt ++;
        ans += x * cnt;
        printf("%.3f\n",ans);
    }
}
*/

/*
int main()
{
    string str;
    int n;
    int a[15];
    __T {
        scanf("%d",&n);
        str = "";
        rep(i,1,n) {
            str += to_string(i);
        }
        rep(i,0,9) a[i] = 0;
        for (int i = 0;str[i];i ++) {
            a[str[i] ^ 48] ++;
        }
        rep(i,0,9) {
            if (i != 0) printf(" ");
            printf("%d",a[i]);
        }
        puts("");
    }
    
    
    return 0;
}
*/

/*
char str[100010];

int main()
{
    int k;
    int ans;
    int len;
    int T;
    scanf("%d",&T);
    rep(x,1,T) {
        scanf("%s",str);
        len = (int) strlen(str);
        ans = len;
        for (int i = 0;i < len;i ++) {
            k = 1;
            if (len % (i + 1)) continue;
            for (int j = 0;j < len - i;j += i + 1) {
                for (int x = j,y = 0;y <= i;x ++,y ++) {
                    if (str[x] != str[y]) {
                        k = 0;
                        goto end;
                    }
                }
            }
        end:
            if (k) {
                ans = i + 1;
                break;
            }
        }
        printf("%d\n",ans);
        if (x != T) printf("\n");
    }
}
*/

/*
ll gcd(ll a,ll b) {
    return b ? gcd(b,a % b) : a;
}

void simplify(ll &a,ll &b) {
    ll x = gcd(a,b);
    a /= x;
    b /= x;
}

ll ans[1000010];
ll tmp[1000010];
int n;
int found;

 int dfs(int d,int cur,ll a,ll b)
 {
     simplify(a,b);
     if (b <= cur) return 0;
     if (d == 1) {
         if (a == 1) {
             if (found && ans[d] <= b) return 0;
             found = 1;
             tmp[d] = b;
             rep(i,1,n) ans[i] = tmp[i];
             return 1;
         }
         return 0;
     }
     int x = ceil(b * d / (double) a);
     for (int i = cur;i <= x;i ++) {
         tmp[d] = i;
         dfs(d - 1,i,a * i - b,b * i);
     }
     return found;
 }

int main()
{
    int a,b;
    while (~scanf("%d%d",&a,&b)) {
         printf("%d/%d=",a,b);
        found = n = 0;
        while (!dfs(++ n,1,a,b));
         pre(i,n,1) printf("%s1/%lld",i == n ? "" : "+",ans[i]);
        printf("\n");
//        pre(i,n,1) printf("%lld%c",ans[i]," \n"[i == 1]);
        



        // 埃及分数，斐波那契解法，不是最优解
        // int q,r;
        //
        // while (1) {
        //     q = b / a;
        //     r = b % a;
        //     printf("%d/%d+",1,q + 1);
        //     a -= r;
        //     b *= q + 1;
        //     if (b % a == 0) {
        //         printf("%d/%d\n",1,b / a);
        //         break;
        //     }
        // }
    }
    return 0;
}
*/

//
//ll gcd(ll a,ll b) {
//    return b ? gcd(b,a % b) : a;
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    int a[10000];
//    rep(i,1,n) scanf("%d",a + i);
//    ll ansa,ansb;
//    ansa = 1;
//    ansb = 0;
//    rep(i,1,n) {
//        ansa *= a[i];
//    }
//    rep(i,1,n) ansb += ansa / a[i];
//    ll t = gcd(ansa,ansb);
//    ansa /= t;
//    ansb /= t;
//    printf("%lld/%lld",ansb,ansa);
//}

/*
int main() {
    ll n;
    __T {
        scl(n);
        for (;!(n & 1);n /= 2);
        puts(n != 1 ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    int l,k;
    __T {
        scanf("%d",&n);
        l = n % 2020;
        k = n / 2020;
        puts(l <= k ? "YES" : "NO");
    }
}
*/

/*
const int MAXN = 200010;

ll a[MAXN],b[MAXN];
ll ta[MAXN],tb[MAXN];
pair<ll,ll> p[MAXN];

int main() {
    ll na,nb,k,ans;
    map<pair<ll,ll>,ll> ps;
    __T {
        sclll(na,nb,k);
        rep(i,1,na) ta[i] = 0;
        rep(i,1,nb) tb[i] = 0;
        ps.clear();
        ans = 0;
        rep(i,1,k) {
            scl(a[i]);
            ta[a[i]] ++;
        }
        rep(i,1,k) {
            scl(b[i]);
            tb[b[i]] ++;
            ps[p[i] = mpair(a[i],b[i])] ++;
        }
        rep(i,1,k) {
            ans += k - i + 1;
            ans -= ta[a[i]] -- + tb[b[i]] --;
            ans += ps[p[i]] --;
        }
        printf("%lld\n",ans);
    }
}
*/

/*
const int MAXN = 200010;

ll tmp[MAXN];
ll a[3][MAXN];

int main()
{
    int n,m;
    ll k,ans;
    int nq[3],t;
    int i,j;
    __T {
        scanf("%d%d",&n,&m);
        nq[1] = nq[2] = 0;
        rep(i,1,n) scanf("%lld",tmp + i);
        rep(i,1,n) {
            scanf("%d",&t);
            a[t][++ nq[t]] = tmp[i];
        }
        sort(a[1] + 1,a[1] + 1 + nq[1],greater<ll>());
        sort(a[2] + 1,a[2] + 1 + nq[2],greater<ll>());
        ans = k = 0;
        
        for (i = 1,j = 1;k < m && i <= nq[1] && j <= nq[2];) {
            if (a[1][i] >= a[2][j]) {
                k += a[1][i ++];
                ans ++;
            } else {
                if (k + a[1][i] >= m) {
                    k += a[1][i ++];
                    ans ++;
                    break;
                }
                if (i <= nq[1] - 1) {
                    if (a[1][i] + a[1][i + 1] > a[2][j]) {
                        k += a[1][i ++];
                        ans ++;
                    } else {
                        k += a[2][j ++];
                        ans += 2;
                    }
                } else {
                    k += a[2][j ++];
                    ans += 2;
                }
            }
        }
        for (;k < m && i <= nq[1];i ++) {
            k += a[1][i];
            ans ++;
        }
        for (;k < m && j <= nq[2];j ++) {
            k += a[2][j];
            ans += 2;
        }
        if (k < m) puts("-1");
        else printf("%lld\n",ans);
    }
}
*/

/*
map<ll,ll> mp;
ll a[1010];

const int mod = 1e9 + 7;
const int MAXN = 1010;

ll fac[MAXN],invfac[MAXN],invn[MAXN];
ll C(ll n,ll m){
    if (n < 0 || m < 0 || n < m) return 0;
    return fac[n] * invfac[m] % mod * invfac[n - m] % mod;
}
void init() {
    fac[0] = fac[1] = invn[0] = invn[1] = invfac[0] = invfac[1] = 1;
    REP(i,2,MAXN){
        fac[i] = fac[i - 1] * i % mod;
        invn[i] = (mod - mod / i) * invn[mod % i] % mod;
        invfac[i] = invfac[i - 1] * invn[i] % mod;
    }
}

int main()
{
    int n,k;
    ll ans;
    int x;
    ll t;
    init();
    __T {
        ans = 0;
        scanf("%d%d",&n,&k);
        mp.clear();
        rep(i,1,n) {
            scanf("%lld",a + i);
            mp[a[i]] ++;
        }
        sort(a + 1,a + 1 + n,greater<ll>());
        x = 1;
        t = a[1];
        rep(i,2,k) {
            if (a[i] != t) {
                x = 1;
                t = a[i];
            } else x ++;
        }
        printf("%lld\n",C(mp[t],x));
    }
    return 0;
}
*/

/*
int main()
{
    const int n = 5;
    char mp[10][10];
    char t;
    int j = 0;
    char oper[100010];
    int x,y;
    int ok;
    int T = 1;
    while (1)
    {
        y = x = -1;
        REP(i,0,n) {
            
            REP(j,0,n) {
                if ((t = getchar()) == '\n') {
                    j --;
                    continue;
                }
                if (t == 'Z') return 0;
                mp[i][j] = t;
                if (t == ' ') {
                    x = i;
                    y = j;
                }
            }
        }
        for (j = 0;(t = getchar()) != '0';j ++) {
            if (t == '\n') {
                j --;
                continue;
            }
            oper[j] = t;
        }
        ok = 1;
        if (x != -1 && y != -1)
        {
            for (int i = 0;i < j;i ++) {
                switch (oper[i]) {
                    case 'A':
                        if (x > 0) {
                            swap(mp[x - 1][y],mp[x][y]);
                            x --;
                        } else ok = 0;
                        break;
                    case 'B':
                        if (x < n - 1) {
                            swap(mp[x + 1][y],mp[x][y]);
                            x ++;
                        } else ok = 0;
                        break;
                    case 'L':
                        if (y > 0) {
                            swap(mp[x][y - 1],mp[x][y]);
                            y --;
                        } else ok = 0;
                        break;
                    case 'R':
                        if (y < n - 1) {
                            swap(mp[x][y + 1],mp[x][y]);
                            y ++;
                        } else ok = 0;
                        break;
                }
                if (!ok) break;
            }
        } else ok = 0;
        if (T != 1) puts("");
        printf("Puzzle #%d:\n",T ++);
        if (!ok) puts("This puzzle has no final configuration.");
        else {
            REP(i,0,n) {
                REP(j,0,n) {
                    printf(j == 0 ? "%c" : " %c",mp[i][j]);
                }
                printf("\n");
            }
        }
        
    }
}
*/

/*
char mp[20][20];
int vis[20][20];
int im[20][20];

int main()
{
    int n,m;
    char t;
    pair<int,int> st[110];
    int is,k;
    int T = 0;
    while (~scanf("%d",&n)) {
        if (n == 0) break;
        scanf("%d",&m);
        k = is = 0;
        rep(i,1,n) {
            rep(j,1,m) {
                t = getchar();
                if (t == '\n') {
                    j --;
                    continue;
                }
                mp[i][j] = t;
                if (t != '*' && (i == 1 || j == 1 || mp[i - 1][j] == '*' || mp[i][j - 1] == '*')) {
                    st[++ is] = mpair(i,j);
                    im[i][j] = ++ k;
                }
            }
        }
        if (T) puts("");
        printf("puzzle #%d:\n",++ T);
        rep(i,1,n)
            rep(j,1,m) vis[i][j] = 0;
        printf("Across\n");
        rep(i,1,is) {
            if (vis[st[i].first][st[i].second]) continue;
            printf("%3d.",im[st[i].first][st[i].second]);
            for (int j = st[i].second;j <= m && mp[st[i].first][j] != '*';j ++) {
                vis[st[i].first][j] = 1;
                printf("%c",mp[st[i].first][j]);
            }
            puts("");
        }
        rep(i,1,n)
            rep(j,1,m) vis[i][j] = 0;
        printf("Down\n");
        rep(i,1,is) {
            if (vis[st[i].first][st[i].second]) continue;
            printf("%3d.",im[st[i].first][st[i].second]);
            for (int j = st[i].first;j <= n && mp[j][st[i].second] != '*';j ++) {
                vis[j][st[i].second] = 1;
                printf("%c",mp[j][st[i].second]);
            }
            puts("");
        }
    }
    
    
    return 0;
}
*/

/*
int main()
{
    int n,m;
    char str[60][1010];
    char ans[1010];
    int a;
    map<char,int> t;
    int mx;
    char ch;
    __T {
        a = 0;
        scanf("%d%d",&n,&m);
        rep(i,1,n) scanf("%s",str[i]);
        REP(i,0,m) {
            mx = -1;
            ch = 'A';
            t.clear();
            rep(j,1,n) {
                t[str[j][i]] ++;
            }
            for (auto j : t) {
                if (j.second > mx) {
                    ch = j.first;
                    mx = j.second;
                }
            }
            ans[i] = ch;
            a += n - mx;
        }
        ans[m] = 0;
        puts(ans);
        printf("%d\n",a);
    }
    return 0;
}
*/

/*
int n;
int str[30];
int cnt;

int tmp[30];
int sub[30];

int ans[30];
int fd;

void dfs(int i)
{
    int m = 0;
    if (i > cnt) {
        if (!fd) pre(j,cnt,1) ans[j] = tmp[j];
        else {
            pre(j,cnt,1) {
                if (tmp[j] < ans[j]) {
                    m = 1;
                    break;
                }
                else if (tmp[j] > ans[j]) break;
            }
            if (m) {
                pre(j,cnt,1) ans[j] = tmp[j];
            }
        }
        fd = 1;
        return;
    }
    rep(x,0,9) {
        if ((x * tmp[1] * 2 + sub[i]) % 10 != str[i] % 10) continue;
        tmp[i] = x;
        sub[i + 1] += (x * tmp[1] * 2 + sub[i]) / 10;
        for (int j = 2,k = i + 1;j < i && k <= cnt;j ++,k ++) {
            sub[k] += tmp[i] * tmp[j] * 2;
        }
        if (i * 2 - 1 <= cnt) {
            sub[i * 2 - 1] += tmp[i] * tmp[i];
        }
        
        dfs(i + 1);
        
        sub[i + 1] -= (x * tmp[1] * 2 + sub[i]) / 10;
        for (int j = 2,k = i + 1;j < i && k <= cnt;j ++,k ++) {
            sub[k] -= tmp[i] * tmp[j] * 2;
        }
        if (i * 2 - 1 <= cnt) {
            sub[i * 2 - 1] -= tmp[i] * tmp[i];
        }
    }
}

void call(int x) {
    tmp[1] = x;
    sub[2] = (x * x) / 10;
    dfs(2);
}

int main()
{
    int f;
    __T {
        scanf("%d",&n);
        fd = 0;
        cnt = 0;
        while (n) {
            str[++ cnt] = n % 10;
            n /= 10;
        }
        switch (str[1]) {
            case 0:
                call(0);
                break;
            case 1:
                call(1);
                call(9);
                break;
            case 4:
                call(2);
                call(8);
                break;
            case 5:
                call(5);
                break;
            case 6:
                call(4);
                call(6);
                break;
            case 9:
                call(3);
                call(7);
                break;
            default:
                break;
        }
        f = 1;
        if (!fd) printf("None");
        else pre(i,cnt,1) {
            if (ans[i] != 0) f = 0;
            if (!f) printf("%d",ans[i]);
        }
        printf("\n");
    }
    return 0;
}
*/


/*
int a[1000000];

ll cal(ll s,ll t) {
    ll n = t - s + 1;
    return (1 + n) * n / 2;
}

int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        scanf("%d",a + i);
    }
    int s = 1;
    ll ans = 0;
    rep(i,2,n) {
        if (a[i] < a[i - 1]) {
            ans += cal(s,i - 1);
//            _C(s << " " << i - 1 << " " << cal(s,i - 1))
            s = i;
        }
    }
    ans += cal(s,n);
    printf("%lld\n",ans);
}
*/

/*
int a[100010];
int m[100010];

map<int,pair<int,int>> mp;

int main()
{
    int n,k;
    int ans;
    __T {
        scanf("%d%d",&n,&k);
        mp.clear();
        m[0] = 0;
        rep(i,1,n) {
            scanf("%d",a + i);
            m[i] = (m[i - 1] + a[i]) % k;
            if (mp[m[i]].first == 0) mp[m[i]].first = i;
            else mp[m[i]].second = i;
        }
        ans = max(mp[0].first,mp[0].second);
        for (auto i : mp) {
            ans = max(ans,i.second.second - i.second.first);
        }
        printf("%d\n",ans == 0 ? -1 : ans);

        
    }
}
*/

/*
int main()
{
    int n;
    int ok;
    __T {
        scanf("%d",&n);
        ok = 0;
        rep(i,2,15) {
            if (n % ((ll)pow(2,i) - 1) == 0) {
                ok = 1;
                break;
            }
        }
        puts(ok ? "YE5" : "N0");
    }
}
*/

/*
int main()
{
    int n,k;
    __T {
        scanf("%d%d",&n,&k);
        puts(n % (k + 1) != 1 ? "yo xi no forever!" : "ma la se mi no.1!");
    }
}
*/

/*
ll pos[100010];

int n,k;

int check(ll ans)
{
    int x = 0;
    ll len;
    rep(i,2,n) {
        len = pos[i] - pos[i - 1];
        x += len / ans - ((len % ans) ? 0 : 1);
    }
//    _C(ans << " " << x)
    return x <= k;
}

int main()
{
    scanf("%d%d",&n,&k);
    rep(i,1,n) scanf("%lld",pos + i);
    sort(pos + 1,pos + 1 + n);
    ll l = 1,r = 1e12;
    ll m;
    while (l < r) {
        m = (l + r) >> 1;
        if (check(m)) {
            r = m;
        } else l = m + 1;
    }
    printf("%lld\n",r);
    
}
*/

/*
const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n,m;
    __T {
        scanf("%d%d",&n,&m);
        if (n == 0) printf("1\n");
        else {
            if (m == 0) {
                if (n == 1) printf("2\n");
                else if (n >= 2) printf("%d\n",(n + 2) % mod);
            } else if (m == 1) {
                printf("%lld\n",(n * 2ll) % mod);
            } else if (m == 2) {
                printf("%lld\n",quickpow(2, n));
            }
        }
    }
    return 0;
}
*/

/*
struct Node {
    int to;
    ll w;
};

vector<Node> g[1000];
int vis[1000];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    ll w;
    while (m --) {
        scanf("%d%d%lld",&u,&v,&w);
        g[u].pb({v,w});
        g[v].pb({u,w});
    }
    int k;
    scanf("%d",&k);
    ll ans = -1;
    int ok;
    int has;
    int nn;
    while (k --) {
        scanf("%d",&nn);
        w = 0;
        ok = 1;
        v = 0; // cur
        
        if (nn != n) ok = 0;
        rep(i,1,n) vis[i] = 0;
        
        while (nn --) {
            scanf("%d",&u);
            vis[u] ++;
            has = 0;
            for (auto i : g[v]) {
                if (i.to == u) {
                    has = 1;
                    w += i.w;
                    break;
                }
            }
            if (!has) ok = 0;
            v = u;
        }
        has = 0;
        for (auto i : g[v]) {
            if (i.to == 0) {
                has = 1;
                w += i.w;
                break;
            }
        }
        if (!has) ok = 0;
        rep(i,1,n) {
            if (vis[i] != 1) {
                ok = 0;
                break;
            }
        }
        if (ok) {
            if (ans == -1) ans = w;
            else ans = min(ans,w);
        }
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
struct Node {
    int grade,sex,id;
};

vector<string> a[110];
unordered_map<string,Node> mp;

int main()
{
    cio
    int n;
    cin >> n;
    string name;
    int grade,sex,id;
    rep(i,1,n) {
        cin >> name >> grade >> sex >> id;
        a[grade].pb(name);
        mp[name] = {grade,sex,id};
    }
    rep(i,0,100) {
        sort(a[i].begin(),a[i].end());
    }
    
    int T;
    cin >> T;
    int m;
    string nm;
    Node node;
    while (T --) {
        cin >> m;
        if (m == 1) {
            cin >> nm;
            if (mp.find(nm) == mp.end()) continue;
            node = mp[nm];
            cout << node.grade << " " << node.id << " " << node.sex << endl;
        } else {
            cin >> grade;
            for (auto i : a[grade]) {
                cout << i << endl;
            }
        }
    }
}
*/

/*
int vis[3000010];
int base[3000010];

int main()
{
    int n,x;
    int a,b;
    int ok;
    int j = 0,i = 0;
    for (i = 0;i <= 3000000;i ++) {
        while (vis[j]) j ++;
        vis[j] = 1;
        vis[j + i] = 1;
        base[i] = j;
        if (i + j > 3000000) break;
    }
    int p1;
    __T {
        scanf("%d%d",&n,&x);
        a = x - 1;
        b = n - x;
        if (a > b) swap(a,b);
        p1 = (int) (lower_bound(base, base + i + 1, a) - base);
        ok = 1;
        if (base[p1] == a && b == base[p1] + p1) ok = 0;
        
        puts(ok ? "yo xi no forever!" : "ma la se mi no.1!");
    }
}
*/

/*
int main()
{
    string str;
    cin >> str;
    string a,b;
    for (int i = 0;str[i];i ++) {
        if (isdigit(str[i])) a += str[i];
        else b += str[i];
    }
    for (int i = 0;b[i];i ++) {
        for (int j = '0';j < a[i];j ++) {
            if (b[i] == 'z') b[i] = 'A';
            if (b[i] == 'Z') b[i] = 'a';
            b[i] ++;
        }
    }
    pre(i,3,0) printf("%c",b[i]);
    pre(i,7,4) printf("%c",b[i]);
    pre(i,11,8) printf("%c",b[i]);
    pre(i,15,12) printf("%c",b[i]);
    puts("");
}
*/

/*
int main()
{
    int n,k;
    int arr[100010];
    int mx;
    int mi;
    ll l,r,a,b;
    ll sum;
    ll m;
    int ok;
    __T {
        scii(n,k);
        mx = -1;
        mi = 1;
        sum = 0;
        rep(i,1,n) {
            scanf("%d",arr + i);
            if (arr[i] > mx) {
                mx = arr[i];
                mi = i;
            }
            sum += arr[i];
        }
        l = n - 1 + mx;
        r = sum;
        
        a = mi - 1;
        b = 0;
        rep(i,1,mi-1) b += arr[i];
//        _C(l << " " << r)
//        _C(a << " " << b)
        ok = 0;
        m = 0;
        while (1) {
            if (a + l * m >= k) break;
            if (b + r * m >= k) {
                ok = 1;
                break;
            }
            m ++;
        }
        
        puts(ok ? "YES" : "NO");
    }
}
*/

/*
int num[100000];
map<int,int> vis;

int main()
{
    int a,b;
    int st;
    int i;
    while (~scanf("%d%d",&a,&b))
    {
        printf("%d/%d = %d.",a,b,a / b);
        a = a % b;
        i = 0;
        vis.clear();
        while (1)  {
            a *= 10;
            if (vis[a]) {
                st = vis[a];
                break;
            }
            vis[a] = ++ i;
            num[i] = a / b;
            a = a % b;
        }
        rep(j,1,min(50,i)) {
            if (j == st) {
                printf("(");
            }
            printf("%d",num[j]);
        }
        if (i > 50) printf("...");
        printf(")\n   %d = number of digits in repeating cycle\n\n",i - st + 1);
    }
}
*/

/*
int main()
{
    string a,b;
    int j;
    while (cin >> a >> b)
    {
        j = 0;
        for (int i = 0;b[i];i ++) {
            if (b[i] == a[j]) {
                j ++;
            }
        }
        puts(j == a.size() ? "Yes" : "No");
    }
    
}
*/

/*
int main()
{
    pair<int,int> ab[10];
    map<pair<int,int>,int> vis;
    pair<int,int> x[10];
    int cnt;
    int k;
    int y[10];
    int iy[] = {1,2,3,4,5,6};
    int ok;
    while (~scanf("%d%d",&ab[1].first,&ab[1].second)) {
        vis.clear();
        if (ab[1].first > ab[1].second) swap(ab[1].first, ab[1].second);
        rep(i,2,6) {
            scanf("%d%d",&(ab + i) -> first,&(ab + i) -> second);
            if (ab[i].first > ab[i].second) swap(ab[i].first,ab[i].second);
        }
        
        cnt = 0;
        rep(i,1,6) {
            if (vis[ab[i]]) {
                vis[ab[i]] = 0;
                x[++ cnt] = ab[i];
                continue;
            }
            vis[ab[i]] = 1;
        }
        
        if (cnt != 3) {
            puts("IMPOSSIBLE");
        } else {
            k = 0;
            rep(i,1,cnt) {
                y[++ k] = x[i].first;
                y[++ k] = x[i].second;
            }
            ok = 0;
            rep(i,0,5) iy[i] = i + 1;
            do {
                if (y[iy[0]] == y[iy[2]] && y[iy[3]] == y[iy[5]] && y[iy[1]] == y[iy[4]]) {
                    ok = 1;
                    break;
                }
            } while (next_permutation(iy, iy + 6));
            puts(ok ? "POSSIBLE" : "IMPOSSIBLE");
        }
    }
    return 0;
}
*/

/*
int main()
{
    string a,b;
    int n,ok;
    int ans,x;
    while (cin >> a >> b) {
        if (a.size() > b.size()) swap(a, b);
        n = (int) (a.size() + b.size() - 1);
        ans = -1;
        for (int j = 0;j < n;j ++) {
            ok = 1;
            for (int i = max(0,(int) a.size() - j - 1),k = max(0,j - (int)a.size() + 1);a[i] && b[k];i ++,k ++) {
                if (a[i] == '2' && b[k] == '2') {
                    ok = 0;
                    break;
                }
            }
            if (ok) {
                x = max((int) b.size() - 1,j) - min(0,j - (int) a.size() + 1) + 1;
                if (ans == -1 || x < ans) ans = x;
            }
        }
        printf("%d\n",ans == -1 ? (int) (a.size() + b.size()) : ans);
    }
    return 0;
}
*/

/*
int main()
{
    string a,b;
    map<char,int> vis;
    map<char,int> vis2;
    int ok;
    int cnt1,cnt2;
    int aa[50],bb[50];
    while (cin >> a >> b) {
        vis.clear();
        vis2.clear();
        for (int i = 0;a[i];i ++) {
            vis[a[i]] ++;
        }
        for (int i = 0;b[i];i ++) {
            vis2[b[i]] ++;
        }
        ok = 1;
        cnt1 = cnt2 = 0;
        for (auto i : vis) {
            aa[++ cnt1] = i.second;
        }
        for (auto i : vis2) {
            bb[++ cnt2] = i.second;
        }
        sort(aa + 1,aa + 1 + cnt1);
        sort(bb + 1,bb + 1 + cnt2);
        if (cnt1 != cnt2) ok = 0;
        rep(i,1,cnt1) {
            if (aa[i] != bb[i]) {
                ok = 0;
                break;
            }
        }
        puts(ok ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    int T;
    string a,b;
    set<char> all;
    int vis['z' + 1];
    int cnt;
    int ans;
    while (~scanf("%d",&T))
    {
        if (T == -1) break;
        cin >> a >> b;
        rep(i,'a','z') vis[i] = 0;
        all.clear();
        for (int i = 0;a[i];i ++) {
            all.insert(a[i]);
        }
        ans = cnt = 0;
        for (int i = 0;b[i];i ++) {
            if (all.find(b[i]) != all.end()) {
                if (!vis[b[i]]) ans ++;
                vis[b[i]] = 1;
            } else cnt ++;
            if (cnt == 7 || ans == all.size()) break;
        }
//        _C(cnt)
        printf("Round %d\n",T);
        if (cnt != 7) {
            if (ans == all.size()) puts("You win.");
            else puts("You chickened out.");
        } else puts("You lose.");
    }
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    char a[110];
    char b[110];
    rep(i,1,n) scanf(" %c",a + i);
    rep(i,1,n) scanf(" %c",b + i);
    int mn = 0,mx = 0;
    rep(i,1,n) {
        if (a[i] != b[i]) mx ++;
        else mx += 2;
    }
    printf("%d %d\n",mx,mn);
}
*/


/*
int main()
{
    int k;
    scanf("%d",&k);
    if (k == 0) {
        puts(")(");
        return 0;
    }
    int l = k;
    map<int,int> a;
    while (l > 1) {
        k = sqrt(l);
        l -= k * k;
        a[k] ++;
    }
    a[l] ++;
    int j = 1;
    for (auto i : a) {
        for (;j <= i.first;j ++) printf("(");
        rep(p,1,i.second * i.first) printf(")");
    }
}
*/

/*
const int MAXN = 26;
const int mod = 1e9 + 7;

ll aa[1000010];

int main()
{
    ll n;
    scl(n);
    ll ans = 1;
    ll k = MAXN - 1;
    aa[1] = ans;
    rep(i,2,n - 1) {
        ans *= MAXN;
        ans %= mod;
        
        ans += k * i % mod;
        ans %= mod;
        
        k *= (MAXN - 1);
        k %= mod;
        
        aa[i] = ans;
    }
    aa[0] = 0;
    rep(i,1,n - 1)
    {
        aa[i] += aa[i - 1];
        aa[i] %= mod;
    }
    printf("%lld\n",aa[n - 1]);
}
*/

/*
int vis[100010];
int main()
{
    int n,k;
    scii(n,k);
    if (n < 6 && k == n / 2) puts("-1");
    else {
        int f = 1;
        
        if (k == n / 2) {
            for (int i = 2;i <= n;i += 2) {
                if (i == 6) continue;
                if (f) f = 0;
                else printf(" ");
                printf("%d",i);
            }
            if (f) f = 0;
            else printf(" ");
            printf("6 3");
            for (int i = 1;i <= n;i += 2) {
                if (i == 3) continue;
                if (f) f = 0;
                else printf(" ");
                printf("%d",i);
            }
        } else {
            for (int i = 2,j = 1;j <= k + 1;i += 2,j ++) {
                if (f) f = 0;
                else printf(" ");
                printf("%d",i);
                vis[i] = 1;
            }
            rep(i,1,n) {
                if (!vis[i]) {
                    if (f) f = 0;
                    else printf(" ");
                    printf("%d",i);
                }
            }
        }
        puts("");
    }
}
*/

/*
const int MAXN = 1.6 * 1e8;
const int mod = 1e9 + 7;

int num[MAXN+10], primes[MAXN+10]; // primes数组存的是所有的质数
int p_cnt = 0;
void Euler_Sieve(int n) {
    memset(num, -1, sizeof(num));
    for (int i = 2;i <= n;i ++){
        if (num[i]) primes[p_cnt ++] = i;
        for (int j = 0;j < p_cnt && 1LL * i * primes[j] <= n;j ++){
            num[i * primes[j]] = 0;
            if (i % primes[j] == 0) break;
        }
    }
}

ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n;
    scanf("%d",&n);
    Euler_Sieve(n+5);
    int k;
    ll j;
    if (n < 6) {
        puts("empty");
        return 0;
    }

    ll ans = 1;
    REP(i,0,p_cnt) {
        k = 0;
        for (j = primes[i];j <= n;j *= primes[i],k ++);
        j /= primes[i];
        if (j * 2 > n) k --;
        if (primes[i] == 2) {
            if (j / 2 * 3 > n) k --;
        }
        ans *= quickpow(primes[i], k);
        ans %= mod;
    }
    printf("%lld\n",ans);
}
*/

/*
int main()
{
    double a,R;
    scdd(a,R);
    double k = sqrt(6) * a / 12;
    double k2 = a * a / 24;
    double p = sqrt(3) * a / 6;
    double p2 = a * a / 12;
    double ans = 0;
    
    if (R < k) {
        ans = 0;
    } else {
        double r = sqrt(R * R - k2);
        double r2 = R * R - k2;
        if (r2 <= p2) {
            ans = pi * r2;
        } else if (r > 2 * p) {
            ans = a * p * 3 / 2;
        } else {
            ans = pi * r2;
            double s = r2 * acos(p / r);
            s -= p * sqrt(r2 - p2);
            ans -= s * 3;
        }
    }
    printf("%.5f\n",ans * 4);
    return 0;
}
*/

/*
int a[100010];

int main()
{
    int n,q;
    int k;
    int *ans;
    int T = 1;
    while (~scanf("%d%d",&n,&q) && n != 0 && q != 0) {
        rep(i,1,n) {
            scanf("%d",a + i);
        }
        sort(a + 1,a + 1 + n);
        printf("CASE# %d:\n",T ++);
        while (q --) {
            sci(k);
            ans = lower_bound(a + 1, a + 1 + n, k);
            if (ans == a + 1 + n || *ans != k) {
                printf("%d not found\n",k);
            } else {
                printf("%d found at %d\n",k,(int) (ans - a));
            }
        }
    }
}
*/

/*
vector<int> v[30];

int n;

int find(int a) {
    REP(i,0,n) {
        for (auto j : v[i]) {
            if (a == j) {
                return i;
            }
        }
    }
    return -1;
}


int main()
{
    scanf("%d",&n);
    
    REP(i,0,n) v[i].pb(i);
    
    string cmd;
    int a,b;
    int ia,ib;
    vector<int>::iterator it;
    while (cin >> cmd) {
        if (cmd == "quit") break;
        if (cmd == "move") {
            cin >> a >> cmd >> b;
            ia = find(a);
            ib = find(b);
            if (ia == ib) continue;
            for (auto i = v[ia].rbegin();i != v[ia].rend();) {
                if (*i == a) {
                    v[ia].erase((++ i).base());
                    break;
                }
                v[*i].pb(*i);
                v[ia].erase((++ i).base());
            }
            if (cmd == "onto") {
                for (auto i = v[ib].rbegin();i != v[ib].rend();) {
                    if (*i == b) break;
                    v[*i].pb(*i);
                    v[ib].erase((++ i).base());
                }
            }
            v[ib].pb(a);
        } else {
            cin >> a >> cmd >> b;
            ia = find(a);
            ib = find(b);
            if (ia == ib) continue;
            if (cmd == "onto") {
                for (auto i = v[ib].rbegin();i != v[ib].rend();) {
                    if (*i == b) {
                        break;
                    }
                    v[*i].pb(*i);
                    v[ib].erase((++ i).base()); // 逆向迭代器删除过程
                }
            }
            for (auto i = v[ia].begin();i != v[ia].end();i ++) {
                if (*i == a) {
                    it = i;
                    break;
                }
            }
            for (auto i = it;i != v[ia].end();) {
                v[ib].pb(*i);
                i = v[ia].erase(i); // 正向迭代器删除过程
            }
        }
    }
    REP(i,0,n) {
        printf("%d:",i);
        for (auto j : v[i]) {
            printf(" %d",j);
        }
        puts("");
    }
}
*/

/*
int main()
{
    string str;
    string line;
    cio
    while (getline(cin,line)) {
        for (int i = 0;line[i];i ++) {
            if (!((line[i] >= 'a' && line[i] <= 'z') || (line[i] >= 'A' && line[i] <= 'Z'))) {
                line[i] = ' ';
            }
            if (line[i] >= 'A' && line[i] <= 'Z') {
                line[i] -= 'A';
                line[i] += 'a';
            }
        }
        str += line;
        str += '\n';
    }
    stringstream ss(str);
    string s;
    set<string> w;
    while (ss >> s) {
        w.insert(s);
    }
    for (auto i : w) {
        cout << i << endl;
    }
}
*/

/*
int main()
{
    cio
    string word;
    vector<string> all;
    map<string,int> cnt;
    while (cin >> word) {
        if (word[0] == '#') break;
        all.pb(word);
        for (int i = 0;word[i];i ++) word[i] = tolower(word[i]);
        sort(word.begin(),word.end());
        cnt[word] ++;
    }
    sort(all.begin(),all.end());
    
    string t;
    for (auto i : all) {
        t = i;
        for (int i = 0;t[i];i ++) t[i] = tolower(t[i]);
        sort(t.begin(),t.end());
        if (cnt[t] == 1) {
            cout << i << endl;
        }
    }
}
*/

/*
map<set<int>,int> id;
vector<set<int>> v;

int cid = 0;

int getID(set<int> st)
{
    if (id.find(st) != id.end()) return id[st];
    v.pb(st);
    return id[st] = ++ cid;
}

int main()
{
    int n;
    stack<int> s;
    string cmd;
    int a,b;
    set<int> c;
    __T {
        cid = 0;
        v.clear();
        id.clear();
        
        v.pb(set<int>());
        id[set<int>()] = 0;
        
        while (!s.empty()) s.pop();
        sci(n);
        while (n --) {
            cin >> cmd;
            if (cmd == "PUSH") {
                s.push(0);
            } else if (cmd == "DUP") {
                s.push(s.top());
            } else if (cmd == "ADD") {
                a = s.top();
                s.pop();
                b = s.top();
                s.pop();
                c.clear();
                c.insert(a);
                for (auto i : v[b]) {
                    c.insert(i);
                }
                s.push(getID(c));
            } else if (cmd == "UNION") {
                a = s.top();
                s.pop();
                b = s.top();
                s.pop();
                c.clear();
                for (auto i : v[a]) {
                    c.insert(i);
                }
                for (auto i : v[b]) {
                    c.insert(i);
                }
                s.push(getID(c));
            } else if (cmd == "INTERSECT") {
                a = s.top();
                s.pop();
                b = s.top();
                s.pop();
                c.clear();
                for (auto i : v[a]) {
                    if (v[b].find(i) != v[b].end()) c.insert(i);
                }
                s.push(getID(c));
            }
            printf("%lu\n",v[s.top()].size());
        }
        puts("***");
    }
}
*/

/*
int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        rep(j,1,n) {
            printf("%d",(j + i) % 2);
        }
        puts("");
    }
    return 0;
}
*/
/*
const int mod = 1e9 + 7;

ll ten[10];

ll f(int n) {
    ll ans = 0;
    int nn = n;
    for (int i = 2;i * i <= nn;i ++) {
        while (n % i == 0) {
            ans *= ten[(int) log10(i) + 1];
            ans %= mod;
            ans += i;
            ans %= mod;
            n /= i;
        }
    }
    if (n != 1)  {
        ans *= ten[(int) log10(n) + 1];
        ans %= mod;
        ans += n;
        ans %= mod;
    }
    return ans;
}

ll k[] = {0,741799129,742265792,863064554,342936632,194033216,947375317,630113027,78067368,50376546,631719342,536048746,935663975,249718427,563305090,401918035,215702507,594894586,576347729,777128726,220078001,564875627,670818682,1761162,298372095,653656304,829794733,906607881,585538227,695406916,827425989,408593842,21416491,46949477,20854394,521036956,180621151,891070357,402970709,493967777,542917237};

int main()
{
    ten[1] = 10;
    rep(i,2,8) {
        ten[i] = ten[i - 1] * 10;
        ten[i] %= mod;
    }
    int n;
    scanf("%d",&n);
    ll ans = k[n / 100000];
    rep(i,(n / 100000) * 100000 + 1,n) {
        ans += f(i);
        ans %= mod;
    }
    printf("%lld\n",ans);
//    ll ans = 0;
//    rep(i,2,4000000) {
//        ans += f(i);
//        ans %= mod;
//        if (i % 100000 == 0) printf("%lld,",ans);
//    }
}
*/

/*
ll f[100010];

int main()
{
    f[1] = f[0] = 1;
    for(int i = 2;i <= 30; i++) {
        f[i] = f[i-1] + f[i-2];
    }
    for(int i = 30;i <= 100010; i++) {
        f[i] = 1;
    }
    
    int n;
    sci(n);
    for (int i = 2;i <= n+1;i++) {
        if (i != 2) printf(" ");
        printf("%lld",f[i]);
    }
    return 0;
}
*/

/*
int a[100010];
deque<int> q;

int t = 1;

void push_back(int x)
{
    if (t) q.push_back(x);
    else q.push_front(x);
}

void push_front(int x)
{
    if (!t) q.push_back(x);
    else q.push_front(x);
}

void pop_back() {
    if (t) q.pop_back();
    else q.pop_front();
}

void pop_front()
{
    if (!t) q.pop_back();
    else q.pop_front();
}

int back()
{
    if (t) return q.back();
    else return q.front();
}

int front()
{
    if (!t) return q.back();
    else return q.front();
}

int main()
{
    int n;
    scanf("%d",&n);
    int k = 1;
    rep(i,1,n) {
        scanf("%d",a + i);
    }
    int j = 1,i;
    for (j = 1,i = 1;j <= n;j ++,i ++) {
        if (a[i] != i) break;
    }
    rep(i,j,n) {
        if (a[i] == j) {
            k = i - j + 1;
            break;
        }
    }
    
    rep(i,1,k) {
        push_back(a[i]);
    }
    
    j = 1;
    rep(i,k + 1,n) {
        if (front() != j) t ^= 1;
        if (front() == j) {
            pop_front();
            j ++;
            push_back(a[i]);
        } else break;
    }
    
    if (front() != j) t ^= 1;
    for (;j <= n;j ++) {
        if (front() == j) pop_front();
        else break;
    }
    
    if (j == n + 1) {
        puts("yes");
        printf("%d\n",k);
    } else puts("no");
}
*/

/*
int cal(int n) {
    int ans = 0;
    while (n) {
        ans += n % 10;
        n /= 10;
    }
    return ans;
}

int main()
{
    int n;
    scanf("%d",&n);
    int k = cal(n);
    int ans = -1;
    rep(i,n+1,100000) {
        if (cal(i) == k) {
            ans = i;
            break;
        }
    }
    printf("%d\n",ans);
}
*/

/*
const int MAXN = 1e6 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

int mx[MAXN];
int num[MAXN];
int a[MAXN];

int main() {
    int n,m;
    scii(n,m);
    init(n+5);
    rep(i,1,n) sci(a[i]);
    int u,v;
    while (m --) {
        scii(u,v);
        bind(u,v);
    }
    int k;
    rep(i,1,n) {
        k = find(i);
        mx[k] = max(mx[k],a[i]);
        num[k] ++;
    }
    ll ans = 0;
    rep(i,1,n) {
        ans += (ll)num[i] * mx[i];
    }
    printf("%lld\n",ans);
}
*/

/*
int main()
{
    int n;
    scanf("%d",&n);
    int t;
    int odd = 0,even = 0;
    rep(i,1,n) {
        sci(t);
        if (t % 2) odd ++;
        else even ++;
    }
    rep(i,1,n-1) {
        if (i & 1) {
            if (odd && even) {
                even --;
            } else if (odd >= 2) {
                odd --;
            } else {
                even --;
            }
        } else {
            if (odd >= 2) {
                odd -= 2;
                even ++;
            } else if (odd && even) {
                odd --;
            } else even --;
        }
    }
    if (even) puts("NiuMei");
    else puts("NiuNiu");
}
*/

/*
const int MAXN = 1e6 + 10;

int a[MAXN];
int nxt[MAXN];
int pre[MAXN];
int lst[MAXN];
int vis[MAXN];

int main()
{
    int n;
    sci(n);
    int dp[MAXN][2];
    rep(i,1,n) sci(a[i]);
    rep(i,1,n) {
        if (lst[a[i]] != 0) {
            nxt[lst[a[i]]] = i;
            pre[i] = lst[a[i]];
        }
        lst[a[i]] = i;
    }
    memset(lst,-1,sizeof lst);
    lst[a[1]] = 0;
    dp[1][0] = dp[1][1] = 0;
    rep(i,2,n) {
        dp[i][0] = max(dp[i - 1][0],dp[i - 1][1]);
        if (lst[a[i]] == -1) dp[i][1] = 0;
        else dp[i][1] = lst[a[i]] + 1;
        lst[a[i]] = max(dp[i][0],dp[i][1]);
    }
    _C(lst[a[n]])
}
*/

/*
int conv(char a) {
    return a - 'a' + 1;
}

char reconv(int a) {
    return 'a' + a - 1;
}

int main()
{
    string str;
    cin >> str;
    int ok = -1;
    int tp = -1;
    for (int i = 0;str[i];i ++) {
        if (conv(str[i]) >= 11 && conv(str[i]) != 20) {
            ok = i;
            tp = 1;
            break;
        }
        if (i > 0) {
            if (conv(str[i - 1]) <= 9 && conv(str[i]) <= 9 && conv(str[i - 1]) * 10 + conv(str[i]) <= 26) {
                ok = i - 1;
                tp = 2;
                break;
            }
        }
    }
    if (ok == -1) puts("-1");
    else {
        for (int i = 0;str[i];) {
            if (i == ok) {
                if (tp == 1) {
                    printf("%c",reconv(conv(str[i]) / 10));
                    printf("%c",reconv(conv(str[i ++]) % 10));
                } else {
                    printf("%c",reconv(conv(str[i]) * 10 + conv(str[i + 1])));
                    i += 2;
                }
            } else {
                printf("%c",str[i ++]);
            }
        }
    }
}
*/

/*
string pre,suf;

int main()
{
    int n;
    scanf("%d",&n);
    string str;
    int s;
    int ok = -1;
    int len = 0;
    int len_s = 0;
    while (n --) {
        cin >> str;
        if (ok == -1) {
            s = (int) str.size();
            for (int i = 0;str[i] != '#';i ++) {
                if (i < len)
                {
                    if (str[i] != pre[i]) {
                        ok = 0;
                        break;
                    }
                } else {
                    pre += str[i];
                    len ++;
                }
            }
            if (ok == 0) continue;
            for (int i = s - 1,l = 0;str[i] != '#';i --,l ++) {
                if (l < len_s) {
                    if (str[i] != suf[l]) {
                        ok = 0;
                        break;
                    }
                } else {
                    suf += str[i];
                    len_s ++;
                }
            }
        }
    }
    printf("%d\n",ok);
    return 0;
}
*/

/*
struct Enemy {
    int x,y,r;
} e[15];

int vis[15];

struct Node {
    int x,y;
} a[250];

int cnt = 0;

inline int dis(int x1,int y1,int x2,int y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

int main()
{
    int n,k,R;
    sciii(n,k,R);
    rep(i,1,n) sciii(e[i].x,e[i].y,e[i].r);
    rep(i,-7,7) {
        rep(j,-7,7) {
            a[++ cnt] = {i,j};
        }
    }
    int v,ans = 0;
    if (k == 1) {
        rep(i,1,cnt) {
            v = 0;
            rep(x,1,n) {
                if (dis(e[x].x,e[x].y,a[i].x,a[i].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
            }
            rep(x,1,n) {
                if (vis[x]) v ++;
                vis[x] = 0;
            }
            ans = v > ans ? v : ans;
            
        }
    } else if (k == 2) {
        rep(i,1,cnt) {
            rep(j,i + 1,cnt) {
                v = 0;
                rep(x,1,n) {
                    if (dis(e[x].x,e[x].y,a[i].x,a[i].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
                    if (dis(e[x].x,e[x].y,a[j].x,a[j].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
                }
                rep(x,1,n) {
                    if (vis[x]) v ++;
                    vis[x] = 0;
                }
                ans = v > ans ? v : ans;
            }
        }
    } else if (k == 3) {
        rep(i,1,cnt) {
            rep(j,i + 1,cnt) {
                rep(k,j + 1,cnt) {
                    v = 0;
                    rep(x,1,n) {
                        if (dis(e[x].x,e[x].y,a[i].x,a[i].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
                        if (dis(e[x].x,e[x].y,a[j].x,a[j].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
                        if (dis(e[x].x,e[x].y,a[k].x,a[k].y) <= (e[x].r + R) * (e[x].r + R)) vis[x] = 1;
                    }
                    rep(x,1,n) {
                        if (vis[x]) v ++;
                        vis[x] = 0;
                    }
                    ans = v > ans ? v : ans;
                }
            }
        }
    }
    
    printf("%d\n",ans);
}
*/

/*
/// https://ac.nowcoder.com/acm/contest/9983/E
/// 线段树 带修改 统计区间是否包含相同的值，线段树维护 （每个数字的下一个和他相同数字的下标）最小值，最终和区间r进行对比即可
const int MAXN = 1e6 + 10;

struct Node {
    int l,r;
    ll mn;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
int nxt[MAXN];

void push_up(int i)
{
    tree[i].mn = min(tree[i << 1].mn,tree[i << 1 | 1].mn);
}

void push_down(int i) //下推标记
{
    if (tree[i].lazy == 2) {
        tree[i << 1].mn = tree[i].lzn;
        tree[i << 1 | 1].mn = tree[i].lzn;

        tree[i << 1].lzn = tree[i].lzn;
        tree[i << 1 | 1].lzn = tree[i].lzn;

        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;

        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].mn = nxt[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].mn = x;
        tree[i].lzn = x;

        tree[i].lazy = 2;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].mn;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll mn = INT_INF;
    if (l <= m) {
         mn = min(mn,query(l,r,i << 1));
    }
    if (r > m) {
        mn = min(mn,query(l,r,i << 1 | 1));
    }
    return mn;
}

int a[MAXN];
set<int> x[MAXN];
int tmp[MAXN];

int main()
{
    int n,q;
    scii(n,q);
    
    rep(i,1,n) nxt[i] = INT_INF;
    
    rep(i,1,n) {
        scanf("%d",a + i);
        x[a[i]].insert(i);
    }
    
    memset(tmp, 0, sizeof tmp);
    
    pre(i,n,1) {
        if (tmp[a[i]] != 0) {
            nxt[i] = tmp[a[i]];
        }
        tmp[a[i]] = i;
    }
    
    build(1, n, 1);
    
    int t,l,r;
    
    set<int>::iterator it;
    int pre;
    
    while (q --) {
        scii(t,l);
        if (t == 1) {
            it = x[a[l]].find(l);
            if (it != x[a[l]].begin()) {
                it --;
                pre = *it;
                it ++;
                if (it != -- x[a[l]].end()) {
                    it ++;
                    modify(pre, pre, *it, 1);
                    it --;
                } else {
                    modify(pre, pre, INT_INF, 1);
                }
            }
            x[a[l]].erase(it);
            modify(l, l, INT_INF, 1);
        } else {
            sci(r);
            printf("%d\n",query(l, r, 1) <= r);
        }
        
    }
    
}
*/

/*
int main()
{
    queue<int> ques;
    queue<int> q[1010];
    map<int,int> belongs;
    set<int> in;
    int t,n,id;
    string cmd;
    int T = 1;
    while (~scanf("%d",&t))
    {
        if (t == 0) break;
        rep(i,0,1000) {
            while (!q[i].empty()) q[i].pop();
        }
        while (!ques.empty()) ques.pop();
        belongs.clear();
        in.clear();
        
        rep(i,1,t) {
            scanf("%d",&n);
            while (n --) {
                scanf("%d",&id);
                belongs[id] = i;
            }
        }
        printf("Scenario #%d\n",T ++);
        while (cin >> cmd) {
            if (cmd == "STOP") break;
            if (cmd == "ENQUEUE") {
                scanf("%d",&id);
                if (in.find(belongs[id]) == in.end()) {
                    ques.push(belongs[id]);
                    in.insert(belongs[id]);
                }
                q[belongs[id]].push(id);
            } else {
                if (ques.empty()) continue;
                t = ques.front();
                printf("%d\n",q[t].front());
                q[t].pop();
                if (q[t].empty()) {
                    ques.pop();
                    in.erase(in.find(t));
                }
            }
        }
        printf("\n");
    }
    
}
*/

/*
int main()
{
    int n;
    stack<int> s;
    int a[1010];
    int ok;
    int j;
    while (~scanf("%d",&n) && n != 0) {
        while (~sci(a[1]) && a[1] != 0) {
            rep(i,2,n) sci(a[i]);
            ok = 0;
            j = 1;
            rep(i,1,n+1) {
                while (s.size() != 0 && s.top() == a[j]) {
                    j ++;
                    s.pop();
                    ok ++;
                }
                if (i <= n) s.push(i);
            }
            while (!s.empty()) s.pop();
            puts(ok == n ? "Yes" : "No");
        }
        puts("");
        
    }
    return 0;
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    ll a,b,p;
    ll x,y;
    __T {
        scanf("%lld%lld%lld",&a,&b,&p);
        if (a == 0 && b == 0) {
            puts("0 0 0");
            continue;
        }
        // gcd(x,y) = gcd(a + pi,b + pj)，因为gcd(a,b) = gcd(b,a % b)，代入得gcd(b + pj,a % b + p * k)，计算 => gcd(x,y) = gcd(a + pi,b + pj) = gcd(a,b) + pk。要求gcd(x,y) % p = (gcd(a,b) + pk) % p = (gcd(a,b) % p + k) % p，因为k可以取任意值，所以最大值就是p - 1
        printf("%lld ",p - 1);
        // 已知x = a + p * i，而若需gcd(x,y) = p - 1，则x % (p - 1) = 0，y % (p - 1) = 0。而x * (p - 1) % (p - 1) = 0，故x = (a + p * i) * (p - 1) = a * (p - 1) + (p - 1) * p * i
        
        y = b * (p - 1) + (p - 1) * p;
        x = a * (p - 1) + (p - 1) * p;
        while (gcd(x,y) != p - 1) x += (p - 1) * p;
        printf("%lld %lld\n",x,y);
    }
    return 0;
}

*/

/*
struct Node {
    ll n,m;
};

Node mp['z' + 1];

int main()
{
    int n;
    sci(n);
    char c;
    int a,b;
    while (n --) {
        scanf(" %c",&c);
        scanf("%d%d",&a,&b);
        mp[c] = {a,b};
    }
    string str;
    stack<Node> st;
    deque<Node> k;
    Node aa,bb;
    ll ans;
    while (cin >> str) {
        ans = 0;
        while (!st.empty()) st.pop();
        while (!k.empty()) k.pop_front();
        for (int i = 0;str[i];i ++) {
            if (str[i] != ')' && str[i] != '(') st.push(mp[str[i]]);
            else {
                if (str[i] == '(') st.push({-1,-1});
                else {
                    while (!st.empty() && st.top().m != -1) {
                        k.push_back({st.top().n,st.top().m});
                        st.pop();
                    }
                    st.pop();
                    while (k.size() > 1) {
                        bb = k.front();
                        k.pop_front();
                        aa = k.front();
                        k.pop_front();
                        if (aa.m == bb.n) {
                            ans += aa.n * aa.m * bb.m;
                            k.push_front({aa.n,bb.m});
                        } else {
                            goto end;
                        }
                    }
                    
                    if (!k.empty()) {
                        st.push(k.front());
                        k.pop_front();
                    }
                }
            }
        }
        goto ok;
    end:
        puts("error");
        continue;
    ok:
        _C(ans)
    }
}
*/

/*
int main()
{
    list<char> a;
    string str;
    list<char>::iterator it;
    while (cin >> str) {
        a.clear();
        it = a.begin();
        for (int i = 0;str[i];i ++) {
            if (str[i] == '[') it = a.begin();
            else if (str[i] == ']') it = a.end();
            else a.insert(it,str[i]);
        }
        for (auto i : a) {
            printf("%c",i);
        }
        puts("");
    }
}
*/

/*
const int MAXN = 1e5 + 10;

int nxt[MAXN];
int pre[MAXN];

int re;

inline int *ppre(int n) {
    if (!re) return pre + n;
    return nxt + n;
}

inline int *nnxt(int n) {
    if (!re) return nxt + n;
    return pre + n;
}


int main()
{
    int n,m;
    
    int op;
    int x = 0,y = 0;
    
    int t,tt;
    
    ll ans = 0;
    int T = 1;
    
    while (~scanf("%d%d",&n,&m)) {
        rep(i,0,n) nxt[i] = i + 1;
        rep(i,1,n + 1) pre[i] = i - 1;
        pre[0] = -1;
        nxt[n + 1] = -1;
        
        re = 0;
        
        while (m --) {
            sci(op);
            if (op != 4) {
                scii(x,y);
                if (x == y) continue;
            }
            if (op == 1) {
                
                if (*ppre(x) != -1) *nnxt(*ppre(x)) = *nnxt(x);
                if (*nnxt(x) != -1) *ppre(*nnxt(x)) = *ppre(x);
                
                if (*ppre(y) != -1) *nnxt(*ppre(y)) = x;
                
                *ppre(x) = *ppre(y);
                
                *ppre(y) = x;
                *nnxt(x) = y;
                
            } else if (op == 2) {
                
                if (*ppre(x) != -1) *nnxt(*ppre(x)) = *nnxt(x);
                if (*nnxt(x) != -1) *ppre(*nnxt(x)) = *ppre(x);
                
                if (*nnxt(y) != -1) *ppre(*nnxt(y)) = x;
                
                *nnxt(x) = *nnxt(y);
                
                *nnxt(y) = x;
                *ppre(x) = y;
                
                
            } else if (op == 3) {
                // debug
                
                t = *nnxt(x);
                tt = *nnxt(y);
                
                if (*ppre(x) != -1) *nnxt(*ppre(x)) = y;
                if (*ppre(y) != -1) *nnxt(*ppre(y)) = x;
                
                if (t != -1) *ppre(t) = y;
                if (tt != -1) *ppre(tt) = x;
                
                t = *ppre(x);
                *ppre(x) = *ppre(y);
                *ppre(y) = t;
                
                t = *nnxt(x);
                *nnxt(x) = *nnxt(y);
                *nnxt(y) = t;
                
            } else if (op == 4) {
                re ^= 1;
            }
//            for (int i = *nnxt(re ? n + 1 : 0);~i;i = *nnxt(i)) {
//                if (i == n + 1 || i == 0) break;
//                printf("%d ",i);
//            }
//            puts("");
        }
        ans = 0;
        for (int i = *nnxt(re ? n + 1 : 0),j = 1;~i;i = *nnxt(i),j ++) {
            if (i == n + 1 || i == 0) break;
            ans += j % 2 ? i : 0;
        }
        printf("Case %d: %lld\n",T ++,ans);
    }
}
*/

/*
int main()
{
    int T;
    int d,n;
    int ans;
    while (~scanf("%d",&T) && ~T) {
        while (T --) {
            ans = 1;
            scii(d,n);
            n --;
            REP(i,1,d) {
                ans = ans << 1 | (n & 1);
                n >>= 1;
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
*/

/*
struct Node {
    int n;
    Node *l;
    Node *r;
    Node(int n,Node *l,Node *r):n(n),l(l),r(r) {}
};

Node *root;

int ok;

void add(int n,char *pos)
{
    Node *node = root;
    for (int i = 0;pos[i] != ')';i ++) {
        if (pos[i] == 'L') {
            if (node -> l == NULL) node -> l = new Node(-1,NULL,NULL);
            node = node -> l;
        } else {
            if (node -> r == NULL) node -> r = new Node(-1,NULL,NULL);
            node = node -> r;
        }
    }
    if (node -> n != -1) ok = 0;
    node -> n = n;
}

vector<int> ans;

int out()
{
    queue<Node*> q;
    q.push(root);
    Node *top;
    while (!q.empty()) {
        top = q.front();
        q.pop();
        if (top -> n == -1) return 0;
        ans.pb(top -> n);
        if (top -> l != NULL) q.push(top -> l);
        if (top -> r != NULL) q.push(top -> r);
    }
    return 1;
}

int main()
{
    int num;
    char str[1000];
    char pos[1000];
    root = new Node(-1,NULL,NULL);
    int f;
    ok = 1;
    while (~scanf("%s",str)) {
        if (!strcmp(str, "()")) {
            if (ok && out()) {
                f = 1;
                for (auto i : ans) {
                    if (f) f = 0;
                    else printf(" ");
                    printf("%d",i);
                }
                puts("");
            } else puts("not complete");
            root = new Node(-1,NULL,NULL);
            ans.clear();
            ok = 1;
            continue;
        }
        sscanf(str, "(%d,%s",&num,pos);
        add(num,pos);
    }
}
*/

/*
int main()
{
    int n,m,k;
    int p;
    while (~scanf("%d%d%d",&n,&m,&k)) {
        p = 0;
        for(int i = 2;i <= n - 1;i ++)
        {
            p = (p + k) % i;
        }
        p ++;
        printf("%d\n",(p + m) % n);
    }
}
*/

/*
int mp[110][110];
int dp[110][110];

int main()
{
    int n;
    int ans;
    __T {
        sci(n);
        rep(i,1,n) {
            rep(j,1,i) {
                sci(mp[i][j]);
                dp[i][j] = 0;
            }
        }
        dp[1][1] = mp[1][1];
        rep(i,2,n) {
            rep(j,1,i) {
                if (j - 1 >= 1) dp[i][j] = dp[i - 1][j - 1];
                if (j < i) dp[i][j] = max(dp[i][j],dp[i - 1][j]);
                dp[i][j] += mp[i][j];
            }
        }
        ans = 0;
        rep(i,1,n) ans = max(ans,dp[n][i]);
        printf("%d\n",ans);
    }
}
*/

/*
const int MAXN = 1e6 + 10;

ll c[MAXN];
ll arr[MAXN];

int n,m;

inline void add(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

inline ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

inline ll query(int a,int b) {
    return sum(b) - sum(a - 1);
}

int main() {
    int t;
    int a,b;
    int cur;
    while (~scanf("%d%d",&n,&m)) {
        memset(c,0,sizeof(ll) * (n + 5));
        memset(arr,0,sizeof(ll) * (n + 5));
        while (m --) {
            scanf("%d%d%d",&t,&a,&b);
            if (a > b) swap(a, b);
            if (t == 1) {
                arr[a] ++;
                arr[b + 1] --;
                add(a,1);
                add(b + 1,-1);
            } else {
                cur = sum(a - 1) % 2;
                rep(i,a,b) {
                    if (arr[i] % 2) cur ^= 1;
                    printf("%d",cur);
                }
                puts("");
            }
        }
    }
}
*/

/*
struct Node {
    int n;
    int num;
} d[100];

int cmp(const Node &a,const Node &b) {
    return a.num > b.num;
}

int main()
{
    int n;
    int ok;
    int ans[15][15];
    __T {
        sci(n);
        rep(i,1,n) {
            sci(d[i].num);
            d[i].n = i;
        }
        memset(ans,0,sizeof ans);
        ok = 1;
        rep(i,1,n) {
            sort(d + i,d + 1 + n,cmp);
            if (i + d[i].num > n) {
                ok = 0;
                break;
            }
            rep(j,i + 1,i + d[i].num) {
                ans[d[i].n][d[j].n] = 1;
                ans[d[j].n][d[i].n] = 1;
                d[j].num --;
                if (d[j].num < 0) {
                    ok = 0;
                    goto end;
                }
            }
        }
        end:
        if (ok) {
            puts("YES");
            rep(i,1,n) {
                rep(j,1,n) {
                    if (j != 1) printf(" ");
                    printf("%d",ans[i][j]);
                }
                puts("");
            }
        } else puts("NO");
        puts("");
    }
}
*/

/*
int t[25];
int ac[25];
int ok[25];


int main()
{
    int m,n;
    scii(m,n);
    int num;
    string type;
    rep(i,1,n) ok[i] = 1;
    while (m --) {
        cin >> num >> type;
        t[num] ++;
        if (type == "AC") ac[num] ++;
        if (t[num] != 0 && ac[num] / (double) t[num] < 0.5) {
            ok[num] = 0;
        }
    }
    int f = 1;
    rep(i,1,n) {
        if (ok[i] && t[i]) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",i);
        }
    }
    if (f) printf("-1");
    puts("");
}
*/

/*
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll ele[10010];
int cnt[10010];

ll x[10010];
ll p[10010];

int main()
{
    int n;
    sci(n);
    rep(i,1,n) scl(x[i]);
    rep(i,1,n) scl(p[i]);
    ll xx,t;
    rep(i,1,n) {
        xx = x[i];
        for (int j = 2;j * j <= x[i];j ++) {
            t = 0;
            while (xx % j == 0) {
                t ++;
                xx /= j;
            }
            if (t != 0) {
                if (ele[j] == 0) ele[j] = t * p[i];
                else ele[j] = min(ele[j],t * p[i]);
                cnt[j] ++;
            }
        }
        if (xx != 1) {
            if (ele[xx] == 0) ele[xx] = p[i];
            else ele[xx] = min(ele[xx],p[i]);
            cnt[xx] ++;
        }

    }
    ll ans = 1;
    rep(i,1,10010) {
//        printf(":%lld ",ele[i]);
        if (cnt[i] == n) {
//            _C(i << " " << ele[i])
            ans *= quickpow(i,ele[i]);
            ans %= mod;
        }
    }
    printf("%lld\n",ans);
}
*/

/*
struct xyk {
    int x,y,k;
} q[3010];

int p[2010][2010];
int go[2010][2010];

inline int cal(xyk n,int i,int j)
{
    int x = i - n.x + 1;
    int y = j - n.y + 1;
    if (x & 1) {
        return (x - 1) * n.k + y;
    } else {
        return (x - 1) * n.k + n.k - y + 1;
    }
}

int main()
{
    int n,m;
    scii(n,m);
    int x,y,k;
    
    
    rep(i,1,m) {
        sciii(x,y,k);
        q[i] = {x,y,k};
    }
    
    int xx,yy;
    
    pre(ii,m,1) {
        xx = q[ii].x + q[ii].k - 1;
        yy = q[ii].y + q[ii].k - 1;
        rep(i,q[ii].x,xx) {
            rep(j,q[ii].y,yy) {
                if (!p[i][j]) {
                    p[i][j] = ii;
                    go[i][j] = yy;
                } else j = go[i][j];
            }
        }
    }
    
    rep(i,1,n) {
        rep(j,1,n) {
            if (j != 1) printf(" ");
            if (p[i][j] == 0) printf("0");
            else printf("%d",cal(q[p[i][j]], i, j));
        }
        puts("");
    }
   
}
*/

/*
struct Node {
    int to;
    char op;
};

const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

const int MAXN = 1e5 + 10;

vector<Node> g[MAXN];
ll v[MAXN];

int f[MAXN];

ll a[MAXN];


void dfs(int u,ll pls,ll mul)
{
    ll ans = pls;
    if (mul) {
        mul *= v[u];
        mul %= mod;
        ans += mul;
    } else {
        ans += v[u];
    }

    ans %= mod;
    a[u] = ans;

//    _C(u << ": " << pls << " " << mul << " " << ans)

    for (auto i : g[u]) {
        if (i.op == '+' || i.op == '-') {
            dfs(i.to,ans,0);
        } else {
            if (mul) dfs(i.to,pls,mul);
            else dfs(i.to,pls,v[u]);
        }
    }
}

int main()
{
    int n;
    sci(n);
    rep(i,1,n) scl(v[i]);

    rep(i,2,n) {
        sci(f[i]);
    }
    scanf(" ");
    char t;
    rep(i,2,n) {
        scanf("%c",&t);
        g[f[i]].pb({i,t});
        if (t == '-') v[i] = (mod-v[i]) % mod;
        else if (t == '/') v[i] = quickpow(v[i], mod - 2);
    }
    dfs(1,0,0);
    rep(i,1,n) {
        if (i != 1) printf(" ");
        printf("%lld",a[i]);
    }
    puts("");
}
*/



/*
int main()
{
    int n;
    int u,v;
    int nn;
    __T {
        scanf("%d",&n);
        nn = n - 1;
        while (nn --) scii(u,v);
        if (n == 1) puts("1");
        else puts("2");
    }
}
*/

// 组合数公式：https://www.zybang.com/question/6c5da15707d5ddfaff3eff3dc012d24f.html
/*
const int MAXN = 2000010;
const int mod = 998244353;

ll fac[MAXN],invfac[MAXN],invn[MAXN];

ll C(ll n,ll m){
    if (n < 0 || m < 0 || n < m) return 0;
    return fac[n] * invfac[m] % mod * invfac[n - m] % mod;
}

void init() {
    fac[0] = fac[1] = invn[0] = invn[1] = invfac[0] = invfac[1] = 1;
    for (int i = 2;i < MAXN;i ++){
        fac[i] = fac[i - 1] * i % mod;
        invn[i] = (mod - mod / i) * invn[mod % i] % mod;
        invfac[i] = invfac[i - 1] * invn[i] % mod;
    }
}

int main()
{
    init();
    ll n,m;
    scll(n,m);
    if (m == 1) {
        puts("0");
        return 0;
    }
    m -= 2;

    ll mul;
    ll ans = 0;
    // C a+b-1 b：a个不同元素，可以取b次
    ll a,b,t;
    for (ll i = 1;i <= n - 1;i ++) {
        mul = i * (n - i) % mod;
//        _C(i << " " << n - i << " = " << mul)
        a = i + 1;
        b = m;
        t = C(a + b - 1,b);
//        _C(t << " " << mul)
        ans += t * mul % mod;
        ans %= mod;
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
const int MAXN = 1e5 + 10;

ll a[MAXN];
ll c[MAXN];

int main()
{
    int n;
    ll k;
    ll ans;
    __T {
        sci(n);
        scl(k);
        rep(i,0,n-1) scl(a[i]);
        n --;
        rep(i,1,n) c[i] = a[i] - a[i - 1];
        
        ans = 0;
        rep(i,1,n - k + 1) {
            if (c[i] < 0) {
                ans += abs(c[i]);
                if (i + k <= n) c[i + k] -= abs(c[i]);
                c[i] = 0;
            }
        }
        pre(i,n,k) {
            if (c[i] > 0) {
                ans += c[i];
                if (i - k >= 1) c[i - k] += c[i];
                c[i] = 0;
            }
        }
        
        rep(i,1,n) {
            if (c[i] != 0) {
                ans = -1;
                break;
            }
        }
        printf("%lld\n",ans);
    }
}
*/


/*
/// HDU http://acm.hdu.edu.cn/showproblem.php?pid=2899
/// 三分
inline double gpow(double x,int times) {
    double ans = 1;
    rep(i,1,times) ans *= x;
    return ans;
}

inline double f(double x,double y) {
    return 6 * gpow(x,7) + 8 * gpow(x,6) + 7 * gpow(x,3) + 5 * gpow(x,2) - y * x;
}

int main()
{
    double y;
    double l,r,l3,r3;
    __T {
        scanf("%lf",&y);
        l = 0;
        r = 100;
        do {
            l3 = (l * 2 + r) / 3; // 三等分左半边
            r3 = (l + r * 2) / 3; // 三等分右半边
            if (f(l3,y) > f(r3,y)) l = l3; // 计算两个函数值，题目要求最小值，可根据图像得出（👀假设两个点在单调区间上，比较容易确定怎么赋值）
            else r = r3;
        } while (fabs(l3 - r3) > 1e-7);
        printf("%.4f\n",f(l3,y));
    }
}
*/

/*
// 扩展kmp https://segmentfault.com/a/1190000008663857
const int MAXN = 1e5 + 10;

int nxt[MAXN];
int extend[MAXN];

string T,S;

// 求解 T 中 next[]，注释参考 exkmp()
void make()
{
    int a = 0, p = 0;
    int m = (int) T.size();
    nxt[0] = m;

    for (int i = 1; i < m; i++)
    {
        if (i >= p || i + nxt[i - a] >= p)
        {
            if (i >= p)
                p = i;

            while (p < m && T[p] == T[p - i])
                p++;

            nxt[i] = p - i;
            a = i;
        }
        else
            nxt[i] = nxt[i - a];
    }
}

// 求解 extend[]
void exkmp()
{
    make();
    
    int a = 0, p = 0;
    int n = (int) S.size();
    int m = (int) T.size();
    
    for (int i = 0; i < n; i++)
    {
        if (i >= p || i + nxt[i - a] >= p) // i >= p 的作用：举个典型例子，S 和 T 无一字符相同
        {
            if (i >= p) p = i;
            while (p < n && p - i < m && S[p] == T[p - i]) p ++;
            extend[i] = p - i;
            a = i;
        } else extend[i] = nxt[i - a];
    }
}

/// 2021牛客寒假算法基础集训营4B
/// https://ac.nowcoder.com/acm/contest/9984/B
int main()
{
    cin >> T >> S;
    exkmp();
    int n = (int) S.size();
    int k = extend[0];
    ll ans = 0;
    int tg = min(k,n-1);
    rep(i,1,tg)
    {
        ans += extend[i];
    }
    printf("%lld\n",ans);
    return 0;
}
*/

/*
const int mod = 1000;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    int n;
    
        while (~scanf("%d",&n))
        printf("%03lld\n",quickpow(5, n));
    
    return 0;
}
*/

/*
int main()
{
    int n;
    __T {
        sci(n);
        if (n == 0) puts("1");
        else puts("0");
    }
}
*/

/*
struct Node {
    int n;
    ll w;
    int operator<(const Node &o) const {
        return w > o.w;
    }
};

vector<Node> g[200010];
map<string,int> mp;

ll dis[200010];
int vis[200010] = {0};

ll prime(int s)
{
    mem(dis,-1);
    mem(vis,0);
    
    priority_queue<Node> q;
    q.push({s,dis[s] = 0});
    
    Node current;
    ll k;
    
    ll ans = 0;
    
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;
        
        ans += current.w;
        
        for (auto to : g[current.n]) {
            k = to.w;
            if (dis[to.n] == -1 || dis[to.n] > k) {
                q.push({to.n,dis[to.n] = k});
            }
        }
    }
    return ans;
}

int cnt;

int get(string tmp)
{
    return mp[tmp] ? mp[tmp] : (mp[tmp] = ++ cnt);
}

int main()
{
    int n,q;
    int s;
    string tmp;
    int u,v;
    ll w;
    ll ans;
    int ok = 1;
    while (~scii(n,q)) {
        rep(i,1,n) {
            g[i].clear();
        }
        cnt = 0;
        mp.clear();
        cin >> tmp;
        s = get(tmp);
        
        while (q --) {
            cin >> tmp;
            u = get(tmp);
            cin >> tmp;
            v = get(tmp);
            cin >> w;
            g[u].pb({v,w});
            g[v].pb({u,w});
        }
        ans = prime(s);
        ok = 1;
        rep(i,1,n) {
            if (!vis[i]) {
                ok = 0;
                break;
            }
        }
        if (!ok) puts("No!");
        else printf("%lld\n",ans);
    }
    
}
*/

/*
// long long组合数带mod模版，Lucas定理
//const int mod = 998244353;
//
//ll quick_mod(ll a, ll b)
//{
//    if (b<0) return 1;
//    ll ans = 1;
//    a %= mod;
//    while(b)
//    {
//        if(b & 1)
//        {
//            ans = ans * a % mod;
//            b--;
//        }
//        b >>= 1;
//        a = a * a % mod;
//    }
//    return ans;
//}
//
//ll C(ll n, ll m)
//{
//    if(m > n) return 0;
//    ll ans = 1;
//    for(int i=1; i<=m; i++)
//    {
//        ll a = (n + i - m) % mod;
//        ll b = i % mod;
//        ans = ans * (a * quick_mod(b, mod-2) % mod) % mod;
//    }
//    return ans;
//}
//
//ll Lucas(ll n, ll m)
//{
//    if(m == 0) return 1;
//    return C(n % mod, m % mod) * Lucas(n / mod, m / mod) % mod;
//}
//ll gcd(ll a,ll b)
//{
//    if (a % b == 0) return b;
//    return gcd(b, a % b);
//}
//
//int main()
//{
//    ll sum;
//    rep(ii,0,64) {
//        if (ii % 4) continue;
//        _C(">>" << ii)
//        sum = 0;
//        rep(i,0,ii) {
//            if (i % 4 == 0) {
//                sum += Lucas(ii, i);
//                sum %= mod;
//            }
//        }
//        _C(sum)
////        ll p = quick_mod(2, ii-1);
////        p -= sum;
////        ll g = gcd(p,sum);
////        _C(sum / g << ":" << p / g << " " << p / g - 1)
//    }
//
//
//}


const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll n;
    ll x,y,ans;
    while (~scl(n)) {
        if (n == 0) {
            puts("1");
            continue;
        }
        n /= 4;
        x = quickpow(2,n * 2 - 1);
        y = quickpow(2,n * 2);

        ans = quickpow(2, n * 4 - 1);
        ans *= quickpow(y, mod - 2);
        ans %= mod;
        if (n & 1) ans *= (x + mod - 1) % mod;
        else ans *= (x + 1) % mod;
        printf("%lld\n",ans % mod);
    }

}
*/

/*
struct Node {
    lll a;
    lll b;
} line[30];

int cmp(const Node &first,const Node &second) {
    return first.a * second.b + first.b < second.a * first.b + second.b;
}

int main()
{
    int n,x;
    lll ans;
    while (~scii(n,x)) {
        rep(i,1,n) {
            read(line[i].a);
            read(line[i].b);
        }
        
        sort(line + 1,line + 1 + n,cmp);
        
        ans = x;
        rep(i,1,n) {
            ans = line[i].a * ans + line[i].b;
        }
        print_lll(ans);
        puts("");
    }
}
*/

//int a[1010][1010];
//
//int w(int x) {
//    return x + __builtin_popcount(x);
//}
//
//int main()
//{
//    int n,m;
//    scii(n,m);
//    rep(i,1,n) {
//        rep(j,1,m) sci(a[i][j]);
//    }
//    rep(i,1,n) {
//        rep(j,2,m) {
//            printf("%d ",w(a[i][j] ^ a[i][j-1]));
//        }
//        puts("");
//    }
//}

/*
const int MAXN = 1e5 + 10;

int find_set[MAXN];
int depth[MAXN];

int find(int a)
{
    if (find_set[a] == a) return a;
    return find_set[a] = find(find_set[a]);
}

inline void bind(int a,int b)
{
    int x = find(a), y = find(b);
    if (depth[x] >= depth[y]) { // 如果a的 根的子树深度 比b的 根的子树深度 大，那a的根继续做根
        find_set[y] = x; // 改变b节点的根的根为a的根
        if (depth[x] == depth[y]) { // 俩根深度一样
            if (x != y) depth[x] ++; // 作为a的根，自然子树的深度++
        }
    } else find_set[x] = y;
}

void init(int n)
{
    rep(i,0,n) {
        find_set[i] = i;  // 每个种类初始状态只有自己一个点
        depth[i] = 1;  // 初始化秩
    }
}

struct Edge {
    int u,v;
    ll w;
    bool operator<(const Edge &o) const {
        return w < o.w;
    }
} e[MAXN];

Edge s[MAXN];

int n;

ll kuask(int l,int r)
{
    int cnt = 0;
    rep(i,l,r) {
        s[++ cnt] = e[i];
    }
    sort(s + 1,s + 1 + cnt);
    init(n + 5);
    int ok = 0;
    ll ans = 0;
    rep(i,1,cnt) {
        if (find(s[i].u) != find(s[i].v)) {
            ok ++;
            ans += s[i].w;
            bind(s[i].u,s[i].v);
        }
    }
    if (ok != n - 1) return -1;
    return ans;
}

int main()
{
    int m,q;
    sciii(n,m,q);
    int u,v;
    ll w;
    rep(i,1,m) {
        scii(u,v);
        scl(w);
        e[i] = {u,v,w};
    }
    int opt;
    int l,r;
    ll ans;
    int x,y,z,t;
    while (q --) {
        sci(opt);
        if (opt == 1) {
            scii(x,y);
            scii(z,t);
            e[x] = {y,z,t};
        } else {
            scii(l,r);
            ans = kuask(l, r);
            if (ans == -1) puts("Impossible");
            else printf("%lld\n",ans);
        }
    }
}
*/

/*
int main()
{
    ll n;
    int a[10];
    set<ll> s;
    __T {
        n = 0;
        rep(i,1,5) {
            sci(a[i]);
        }
        sort(a + 1,a + 6);
        rep(i,1,5) {
            n *= 10;
            n += a[i];
        }
        if (s.find(n) != s.end()) puts("pass");
        else {
            s.insert(n);
            puts("buy");
        }
    }
}
*/

/*
const int MAXN = 1e5 + 10;

ll dis[MAXN];
int vis[MAXN];

struct Node {
    int n;
    ll w;
    
    Node(int n,ll w):n(n),w(w){}
    Node(){}

    bool operator< (const Node &other) const {
        return w > other.w;
    }
};

vector<Node> g[MAXN];

void dij(int s) {
    mem(dis,-1);
    mem(vis,0);

    priority_queue<Node> q;
    q.push({s,dis[s] = 0});

    Node current;
    ll k;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;

        for (vector<Node>::iterator to = g[current.n].begin();to != g[current.n].end();to ++) {
            k = current.w + to->w;
            if (dis[to->n] == -1 || dis[to->n] > k) {
                q.push({to->n,dis[to->n] = k});
            }
        }
    }
}

int main()
{
    int n,m;
    int u,v;
    int s,t;
    ll w;
    __T {
        scii(n,m);
        rep(i,1,n) {
            g[i].clear();
        }
        while (m --) {
            scii(u,v);
            scl(w);
            g[u].pb(Node(v,w));
            g[v].pb(Node(u,w));
        }
        scii(s,t);
        dij(s);
        printf("%lld\n",dis[t]);
    }
}
*/

/*
int dis[20][20];
int vis[20][20];

char mp[20][20];

int dx[] = {0,0,-1,1};
int dy[] = {1,-1,0,0};

struct Node {
    int x,y;
    int w;
    
    Node(int x,int y,int w):x(x),y(y),w(w){}
    Node(){}

    bool operator< (const Node &other) const {
        return w > other.w;
    }
};

int n,m;

void dij(int sx,int sy) {
    mem(dis,-1);
    mem(vis,0);

    priority_queue<Node> q;
    q.push(Node(sx,sy,dis[sx][sy] = 0));

    Node current;
    int k;
    int xx,yy;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.x][current.y]) continue;
        vis[current.x][current.y] = 1;
        
        rep(i,0,3) {
            xx = current.x + dx[i];
            yy = current.y + dy[i];
            if (xx >= 1 && yy >= 1 && xx <= n && yy <= m) {
                if (mp[xx][yy] != 'X') {
                    k = current.w + 1;
                    if (dis[xx][yy] == -1 || dis[xx][yy] > k) {
                        q.push({xx,yy,dis[xx][yy] = k});
                    }
                }
            }
        }
    }
}


int main()
{
    int st;
    sciii(n,m,st);
    vector<pair<int,int> > t,s;
    rep(i,1,n) {
        scanf(" ");
        rep(j,1,m) {
            scanf("%c",&mp[i][j]);
            if (mp[i][j] == 'S') {
                s.pb(mpair(i,j));
            } else if (mp[i][j] == 'D') {
                t.pb(mpair(i,j));
            }
        }
    }
    
    for (vector<pair<int, int> >::iterator sit = s.begin();sit != s.end();sit ++) {
        dij(sit -> first,sit -> second);
        for (vector<pair<int, int> >::iterator it = t.begin();it != t.end();it ++) {
            if (dis[it -> first][it -> second] != -1) {
                if (dis[it -> first][it -> second] <= st) {
                    puts("YES");
                    return 0;
                }
            }
        }
    }
    
    printf("NO\n");
}
*/

/*
int mp[20][20];
ll dp[20][140000];

int main()
{
    int n;
    sci(n);
    REP(i,0,n) {
        REP(j,0,n) {
            sci(mp[i][j]);
        }
    }
    int nn = 1 << n;
    REP(i,0,n) { // 便利第i个小孩子
        REP(k,0,nn) { // 遍历2^n种状态
            REP(j,0,n) { // 遍历第i个小孩子第j个礼物
                if ((k | (1 << j)) == k) continue; // 如果发现上个状态这个礼物已经选过了，那就滚，其实就是要找到二进制中0的位置，也就是当前可以放礼物
                if (i == 0) dp[i][k | (1 << j)] = mp[i][j]; // 一开始没有人选过礼物，直接选就好，k | (1 << j) 就是让自己的那个位置变成1，因为原来是1的已经continue掉了，所以放的一定可以放礼物的，直接塞
                else dp[i][k | (1 << j)] = max(dp[i][k | (1 << j)],dp[i - 1][k] + mp[i][j]); // 和i-1的相同状态进行对比，找到最大即可
                printf("(%d,%d) ",i,k | (1 << j));
            }
            puts("");
        }
    }
    ll ans = 0;
    REP(i,0,n) {
        ans = max(ans,dp[i][nn - 1]);
    }
    _C(ans)
}
*/

/*
int dp[25010];
int cnt[25010];


int main()
{
    int n;
    int a[110];
    int mx;
    int ans;
    __T {
        sci(n);
        mx = -1;
        rep(i,1,n) {
            sci(a[i]);
            mx = max(mx,a[i]);
        }
        sort(a + 1,a + 1 + n);
        mem(dp,0);
        mem(cnt,0);
        rep(i,1,n) {
            dp[0] = 1;
            rep(j,a[i],mx) {
                dp[j] += dp[j-a[i]];
                if (dp[j]) cnt[j] ++;
                
            }
        }
        ans = 0;
        rep(i,1,n) {
            if (cnt[a[i]] > 1) ans ++;
        }
        _C(n-ans)
    }
}
*/

/*
const int mod = 998244353;

ll ans = 0;
set<ll> s;

void cal(ll y)
{
    ll a,b;
    
    set<ll>::iterator it = s.lower_bound(y);
    b = *it;
    if (it != s.begin()) {
        a = *(-- it);
        if (abs(b-y)<abs(a-y)) {
            s.erase(++ it);
            ans += abs(b - y);
        } else {
            s.erase(it);
            ans += abs(a - y);
        }
    } else {
        s.erase(it);
        ans += abs(b - y);
    }
    ans %= mod;
}

int main()
{
    int x;
    ll y;
    int type = -1;
    int T;
    scanf("%d",&T);
    while (T --) {
        scanf("%d%lld",&x,&y);
        if (x == 0) {
            if (s.size() == 0 || type == 0) {
                s.insert(y);
                type = 0;
            } else cal(y);
        } else {
            if (s.size() == 0 || type == 1) {
                s.insert(y);
                type = 1;
            } else cal(y);
        }
        
    }
    printf("%lld\n",ans);
}
*/

/*
//-----ST表 BEGIN-----
// https://www.jianshu.com/p/19a2cf1af279
const int MAXN = 100010;

int st[MAXN][20];
int a[MAXN];

int n;

void init() {
    // 定义 st[i][j] 是从i开始，到i + 2^j这一段，即[i,i + 2^j]这一段中的最大/小值
    rep(i,1,n) st[i][0] = a[i];

    for (int j = 1;(1 << j) <= n;j ++) { // 遍历所有的j，j是一个很小的数字，最大值=log2(n)
        rep(i,1,n - (1 << j) + 1) { // 在[1,n]区间范围内，确定j的情况下，把所有的i都遍历求值一遍
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); // 套公式
        }
    }
}

int query(int l, int r)
{
    int x = log2(r - l + 1);
    return min(st[l][x],st[r - (1 << x) + 1][x]);
}
// -----ST表 END-----

int pre_max[MAXN],sub_max[MAXN];

// 基本定律:
// 1. 区间最小值会随着区间长度增大而保持不变或者减小
// 2. 区间最大值会随着区间长度增大而保持不变或者增大

int main()
{
    int l,r,m;
    int al,am,ar;
    int ansl,ansm;
    __T {
        sci(n);
        rep(i,1,n) {
            sci(a[i]);
        }
        // ST表初始化
        init();
        // 预处理
        pre_max[1] = a[1];
        rep(i,2,n) {
            pre_max[i] = max(pre_max[i - 1],a[i]);
        }
        sub_max[n] = a[n];
        pre(i,n - 1,1) {
            sub_max[i] = max(sub_max[i + 1],a[i]);
        }
        
        ansl = -1;
        ansm = -1;
        // 枚举左区间
        rep(i,1,n) {
            l = i + 1;
            r = n - 1;
            // 二分m=中区间和有区间的中间的隔板的位置
            while (l <= r) {
                m = (l + r) >> 1;
                al = pre_max[i]; // 左区间
                am = query(i + 1, m); // 中区间
                ar = sub_max[m + 1]; // 右区间
                // 记录答案
                if (al == am && al == ar) {
                    if (ansl == -1 || (i < ansl || (i == ansl && m - i < ansm))) {
                        ansl = i;
                        ansm = m - i;
                    }
                }
                
                if (am > al) {
                    l = m + 1; // 增大中间区间的长度以减小最小值
                } else if (am < al) {
                    r = m - 1; // 缩小中间区间的长度以增大最小值
                } else {
                    if (ar > al) l = m + 1; // 缩小右边区间以缩小最大值
                    else r = m - 1; // 增大右边区间以增大最大值，同时为了保证字典序，所以=的时候也减小m的值
                }
            }
        }
        
        if (ansl != -1) {
            printf("YES\n%d %d %d\n",ansl,ansm,n - ansl - ansm);
        } else puts("NO");
    }
}
*/

/*
const int MAXN = 1e5 + 10;

int a[MAXN];
map<int,int> mp;
map<int,pair<int,int> > pos;

int main()
{
    int n;
    int num;
    int ans;
    int t;
    __T {
        scanf("%d",&n);
        mp.clear();
        pos.clear();
        // 输入+预处理
        rep(i,1,n) {
            scanf("%d",a + i);
            // 如果这个数字没有出现过，则记录他的第一次出现的位置于pair.first
            if (pos[a[i]].first == 0) pos[a[i]].first = i;
            else {
                // 计算两个相同数字是否相邻，不相邻，操作数++
                if (i != pos[a[i]].second + 1) mp[a[i]] ++;
            }
            // 记录数字在序列中最后出现的位置
            pos[a[i]].second = i;
        }
        // 计算答案
        num = -1;
        ans = -1;
        // 枚举数字x
        rep(i,1,n) {
            t = mp[a[i]];
            if (pos[a[i]].first != 1) t ++; // 加头计算操作数
            if (pos[a[i]].second != n) t ++; // 加尾计算操作数
            if (ans == -1 || t < ans) { // 操作数比较小的时候
                num = a[i];
                ans = t;
            } else if (t == ans) { // 操作数相同
                if (a[i] < num) { // 比较数字大小
                    num = a[i];
                    ans = t;
                }
            }
        }
        printf("%d %d\n",num,ans); // 输出答案
        
    }
}
*/

/*
const int MAXN = 2e5+10;

ll a[MAXN],b[MAXN];

ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    rep(i,1,n) scanf("%lld",a + i);
    rep(i,1,m) scanf("%lld",b + i);
    sort(a + 1,a + 1 + n);
    if (n == 1) {
        rep(i,1,m) {
            if (i != 1) printf(" ");
            printf("%lld",a[i] + b[i]);
        }
        puts("");
        return 0;
    }
    ll g = a[2] - a[1];
    rep(i,2,n) {
        g = gcd(a[i] - a[i - 1],g);
    }
    rep(i,1,m) {
        if (i != 1) printf(" ");
        printf("%lld",gcd(b[i] + a[1],g));
    }
    puts("");
}
*/

// 单哈希
/*
const int MAXN = 10010;

char str[MAXN];

ull a[MAXN];

ull getHash() {
    ull ans = 0;
    for (int i = 0;str[i];i ++) {
        ans = ans * 131;
        ans += str[i];
    }
    return ans;
}

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%s",str);
        a[i] = getHash();
    }
    int ans = 0;
    sort(a + 1,a + 1 + n);
    rep(i,1,n) {
        if (i == 1 || a[i] != a[i - 1]) ans ++;
    }
    printf("%d\n",ans);
}
*/


// 双哈希
/*
const int MAXN = 10010;

char str[MAXN];

pair<ull,ull> a[MAXN];
const ull mod = 212370440130137957ULL;

pair<ull,ull> getHash() {
    ull ans = 0,ans2 = 0;
    for (int i = 0;str[i];i ++) {
        ans = ans * 131;
        ans += str[i];
        ans2 = ans * 131 % mod;
        ans2 += str[i];
    }
    return mpair(ans,ans2);
}

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%s",str);
        a[i] = getHash();
    }
    int ans = 0;
    sort(a + 1,a + 1 + n);
    rep(i,1,n) {
        if (i == 1 || a[i] != a[i - 1]) ans ++;
    }
    printf("%d\n",ans);
}
*/

//pair<ull,int> h[50];
//
//pair<ull,int> tg;
//
//ull get_hash(string &str)
//{
//    ull ans = 0;
//    for (int i = 0;str[i];i ++) {
//        ans *= 131;
//        ans += str[i];
//    }
//    return ans;
//}
//
//ull quickpow(ull a, ull b)
//{
//    ull ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans;
//        a = a * a;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int n;
//
//int ans = 0;
//
//ull dp[45][5000010];
//int num[45][5000010];
//
//int main()
//{
//    scanf("%d",&n);
//    string str;
//    cin >> str;
//    tg.first = get_hash(str);
//    tg.second = (int) str.length();
//    rep(i,1,n) {
//        cin >> str;
//        h[i] = mpair(get_hash(str),str.length());
//    }
//    ull t;
//    rep(i,1,n) {
//
//        rep(j,h[i].second,tg.second) {
//            t = quickpow(131, h[i].second);
//            dp[i][j] = dp[i - 1][j - h[i].second] * t + h[i].first;
//        }
//        if (dp[i][tg.second] == tg.first) ans ++;
//    }
//    printf("%d\n",ans);
//}

/*
/// dp免费馅饼(数塔): http://acm.hdu.edu.cn/showproblem.php?pid=1176
/// 数塔：大的问题转变为小的问题
const int MAXN = 1e5 + 10;

ll dp[MAXN][11];
ll cake[MAXN][11];

int main()
{
    int n,x,T,maxT;
    ll t;
    while (~scanf("%d",&n))
    {
        if (n == 0) break;
        mem(dp, 0);
        mem(cake, 0);
        maxT = 0;
        rep(i,1,n) {
            scanf("%d%d",&x,&T);
            cake[T][x] ++;
            maxT = max(T,maxT);
        }
        pre(i,maxT,0) {
            rep(j,0,10) {
                t = dp[i + 1][j];
                if (j > 0) t = max(t,dp[i + 1][j - 1]);
                if (j < 10) t = max(t,dp[i + 1][j + 1]);
                dp[i][j] = t + cake[i][j];
            }
//            rep(j,0,10) printf("%lld ",dp[i][j]);
//            puts("");
        }
        
        printf("%lld\n",dp[0][5]);
    }
    
}
*/

/*
/// 最长上升子序列FatMouse's Speed http://acm.hdu.edu.cn/showproblem.php?pid=1160
struct Node {
    int w,s,x;
    bool operator<(const Node &o) const {
        return w > o.w;
    }
} mice[1010];

int dp[1010];
int from[1010];

int main()
{
    int n = 0;
    for (;~scanf("%d%d",&mice[n+1].w,&mice[n+1].s);n ++) {
        mice[n+1].x = n + 1;
    }
    sort(mice + 1,mice + 1 + n);
    int ans = 0;
    int end = 1;
    dp[1] = 1;
    mem(from, -1);
    rep(i,2,n) {
        REP(j,1,i) {
            if (mice[i].s > mice[j].s) {
                if (dp[i] < dp[j]) {
                    dp[i] = dp[j];
                    from[i] = j;
                }
            }
        }
        if (++ dp[i] > ans) {
            ans = dp[i];
            end = i;
        }
    }
    printf("%d\n",ans);
    do {
        printf("%d\n",mice[end].x);
        end = from[end];
    } while (end != -1);
    return 0;
}
*/

/*
// 最长上升子序列LIS_dp http://acm.hdu.edu.cn/showproblem.php?pid=1257
const int MAXN = 1e5 + 10;

int a[MAXN];
int dp[MAXN];

int LIS(int *a,int n) // start from zero
{
    memset(dp,0,sizeof(dp));
    dp[0] = 1;
    int ans = 1;
    REP(i,1,n) {
        REP(j,0,i) {
            if (a[i] > a[j]) {
                dp[i] = max(dp[i],dp[j]);
            }
        }
        ans = max(ans,++ dp[i]);
    }
    return ans;
}

int main()
{
    int n;
    while (~scanf("%d",&n)) {
        rep(i,1,n) scanf("%d",a + i);
        printf("%d\n",LIS(a + 1,n));
    }
    
}
*/

/*
// 最长上升子序列LIS_greedy http://acm.hdu.edu.cn/showproblem.php?pid=1257
const int MAXN = 1e5 + 10;

int a[MAXN];
int low[MAXN];

int LIS(int *a,int n) // start from zero
{
    int cnt = 0;
    int t;
    REP(i,0,n) {
        t = (int) (lower_bound(low, low + cnt, a[i]) - low);
        low[t] = a[i];
        if (t == cnt) cnt ++;
    }
    return cnt;
}

int main()
{
    int n;
    while (~scanf("%d",&n)) {
        rep(i,1,n) scanf("%d",a + i);
        printf("%d\n",LIS(a + 1,n));
    }
}
*/

/*
// dp: http://acm.hdu.edu.cn/showproblem.php?pid=1421
const int MAXN = 2e3 + 10;

ll a[MAXN];
ll dp[MAXN][MAXN];

int main()
{
    int n,k;
    ll t;
    while (~scanf("%d%d",&n,&k)) {
        rep(i,1,n) {
            scanf("%lld",a + i);
        }
        sort(a + 1,a + 1 + n);
        rep(i,1,k) {
    //        REP(j,0,2 * k) {
    //            dp[i][j] = 0;
    //        }
            t = 0;
            for (int j = 2;j <= 2 * i;j += 2) {
                t += (a[j] - a[j - 1]) * (a[j] - a[j - 1]);
            }
            dp[i][2 * i] = t;
            rep(j,2 * i + 1,n) {
                dp[i][j] = min(dp[i][j - 1],dp[i - 1][j - 2] + (a[j] - a[j - 1]) * (a[j] - a[j - 1]));
            }
        }
        printf("%lld\n",dp[k][n]);
    }
    return 0;
}
*/

/*
const double EPS = 1e-6;

const int MAXN = 5010;

struct Node3d {
    double x,y,z;
} a[MAXN];

struct Node {
    double x, y;
} s[MAXN];

Node o;//圆心坐标
double r;//半径

double dis(Node a, Node b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

void getr(Node p1, Node p2, Node p3) {//三个点求三角形圆心坐标和半径
    double a, b, c, d, e, f;
    a = p2.y - p1.y;
    b = p3.y - p1.y;
    c = p2.x - p1.x;
    d = p3.x - p1.x;
    f = p3.x * p3.x + p3.y * p3.y - p1.x * p1.x - p1.y * p1.y;
    e = p2.x * p2.x + p2.y * p2.y - p1.x * p1.x - p1.y * p1.y;
    o.x = (a * f - b * e) / (2 * a * d - 2 * b * c);
    o.y = (d * e - c * f) / (2 * a * d - 2 * b * c);
    r = dis(o, p1);
}

int n;

void cal()
{
//    random_shuffle(s + 1, s + n + 1);
    o = s[1];
    r = 0;
    for (int i = 2; i <= n; i++) {
        if (dis(s[i], o) > r + EPS) {
            o = s[i];
            r = 0;//第一个点为圆心
            for (int j = 1; j < i; j++) {
                if (dis(o, s[j]) > r + EPS) {
                    o.x = (s[i].x + s[j].x) / 2;
                    o.y = (s[i].y + s[j].y) / 2;
                    r = dis(o, s[j]);//第一个点和第二个点中点为圆心，距离为直径
                    for (int k = 1; k < j; k++) {
                        if (dis(o, s[k]) > r + EPS) {
                            getr(s[i], s[j], s[k]);//三点定圆
                        }
                    }
                }
            }
        }
    }
}

int main()
{
    scanf("%d",&n);
    rep(i,1,n) {
        scddd(a[i].x,a[i].y,a[i].z);
        s[i].x = a[i].x;
        s[i].y = a[i].y;
    }
    cal();
    double ans = r;
    
    rep(i,1,n) {
        s[i].x = a[i].x;
        s[i].y = a[i].z;
    }
    cal();
    ans = min(ans,r);
    
    
    rep(i,1,n) {
        s[i].x = a[i].y;
        s[i].y = a[i].z;
    }
    
    
    cal();
    ans = min(ans,r);
    printf("%.10f\n",ans * 2);
}
*/

/*
const int MAXN = 1e5 + 10;

ll w[MAXN];
ll sum[MAXN];

int main()
{
    int n;
    scanf("%d",&n);
    map<ll,ll> mp;
    rep(i,1,n) {
        scl(w[i]);
        mp[w[i]] ++;
    }
    sort(w + 1,w + 1 + n);
    rep(i,1,n) {
        sum[i] = sum[i - 1] + w[i];
    }
    int ri;
    ll l,r;
    rep(i,0,20001) {
        ri = (int) (lower_bound(w + 1, w + 1 + n, i) - w);
        l = sum[ri - 1];
        r = sum[n] - l;
        if (mp[i] > 0) {
            if (mp[i] & 1) {
                // odd
                r -= i * (mp[i] / 2 + 1);
                l += i * (mp[i] / 2);
            } else {
                // even
                r -= i * mp[i] / 2;
                l += i * mp[i] / 2;
            }
        }
        
//        _C(i << " " << l << " " << r << " " << mp[i])
        
        if (l == r) {
            printf("%d\n",i);
            return 0;
        }
        
    }
    
    
}
*/

/*
const int MAXN = 2e5 + 10;

struct Node {
    int n;
//    int last;
} u[MAXN];

int a[MAXN];
int vis[MAXN];

int cnt[MAXN];
int lst[MAXN];

int main()
{
    _C(1)
    int n,k;
    scii(n,k);
    int last = -1;
    int ucnt = 0;
    rep(i,1,n) {
        scanf("%d",a + i);
        if (last != a[i]) {
            u[++ ucnt].n = a[i];
        }
        last = a[i];
    }
    
    
//    rep(i,1,ucnt) {
//        printf("%d ",u[i].n);
//    }
    
    pre(i,ucnt,1) {
        if (!lst[i]) lst[u[i].n] = i;
    }
    
    vector<int> ans;
    
    rep(i,1,ucnt) {
        if (vis[u[i].n]) continue;
//        if (cnt[u[j].n] == 1) {
//            ans.pb(u[j].n);
//            continue;
//        }
        rep(j,i + 1,ucnt) {
            if (vis[u[j].n]) continue;
            if (u[j].n < u[i].n) break;
        }
        if (!vis[u[i].n]) {
            cnt[u[i].n] --;
            if (!cnt[u[i].n]) {
                ans.pb(u[i].n);
                vis[u[i].n] = 1;
            }
        }
        
    }
    int f = 1;
    for (auto i : ans) {
        if (f) f = 0;
        else printf(" ");
        printf("%d",i);
    }
    puts("");
    
}
*/

/*
const int MAXN = 50010; // 开比边大

int n,father[MAXN],vst[MAXN],match[MAXN],pre[MAXN],type[MAXN];

vector<int> g[MAXN];
queue<int> q;

void add_edge(int u,int v) {
    g[u].push_back(v);
}

int LCA(int x,int y) {
    static int times = 0;
    times ++;
    x = father[x];
    y = father[y]; //已知环位置
    while (vst[x] != times) {
        if (x) {
            vst[x] = times;
            x = father[pre[match[x]]];
        }
        swap(x,y);
    }
    return x;
}

void blossom(int x,int y,int lca) {
    while (father[x] != lca) {
        pre[x] = y;
        y = match[x];
        if (type[y] == 1) {
            type[y] = 0;
            q.push(y);
        }
        father[x] = father[y] = father[lca];
        x = pre[y];
    }
}

int augument(int s) {
    for (int i = 1; i <= n;i ++) father[i]=i;
    memset(type,-1,sizeof(type));

    q = queue<int>();
    type[s] = 0;
    q.push(s); //仅入队o型点

    int cur;
    while (!q.empty()) {
        cur = q.front();
        q.pop();
        for (int next : g[cur]) {
            if (type[next] == -1) {
                pre[next] = cur;
                type[next] = 1; //标记为i型点
                if(!match[next]) {
                    for(int to = next,from = cur; to; from = pre[to]) {
                        match[to] = from;
                        swap(match[from],to);
                    }
                    return true;
                }
                type[match[next]] = 0;
                q.push(match[next]);
            } else if (type[next] == 0 && father[cur] != father[next]) {
                int lca = LCA(cur,next);
                blossom(cur,next,lca);
                blossom(next,cur,lca);
            }
        }
    }
    return false;
}

int matching() {
    int ans = 0;
    for(int i=n; i>=1; i--)
        if(!match[i]) ans += augument(i);
    return ans;
}

int main() {
    sci(n);
    string str[510];
    cin >> str[1];
    int len = (int) str[1].size();
    int cnt;
    rep(i,2,n) {
        cin >> str[i];
        REP(j,1,i) {
            cnt = 0;
            REP(k,0,len) {
                if (str[i][k] != str[j][k]) {
                    cnt ++;
                }
            }
            if (cnt == 2) {
                add_edge(i,j);
                add_edge(j,i);
            }
        }
    }
    printf("%d\n",n - matching());
    rep(i,1,n) {
        printf("%d %d\n",i,match[i]);
    }
    return 0;
}
*/

/*
int cnt = 0;

const int MAXN = 2e5 + 10;

int st[MAXN];
int a[MAXN];

int mp[MAXN];
int vis[MAXN];

int main()
{
    int n,k;
    scii(n,k);
    rep(i,1,n) {
        sci(a[i]);
        mp[a[i]] ++;
    }
    
    rep(i,1,n) {
        mp[a[i]] --;
        if (vis[a[i]]) continue;
        if (cnt == 0) {
            st[++ cnt] = a[i];
            vis[a[i]] = 1;
        }
        else {
            while (st[cnt] > a[i] && mp[st[cnt]] != 0 && cnt != 0)
            {
                vis[st[cnt]] = 0;
                cnt --;
            }
            if (!vis[a[i]]) {
                st[++ cnt] = a[i];
                vis[a[i]] = 1;
            }
        }
        
    }
    
    rep(i,1,cnt) {
        if (i != 1) printf(" ");
        printf("%d",st[i]);
    }
    puts("");
    return 0;
}
*/

/*
set<int> mul[10];

int ans[25];
int fans[25];
string num;
int n;

int ok = 0;


void dfs(int u)
{
    if (ok) return;
    if (u >= n) {
        int o = 1;
        int t;
        REP(i,0,n) {
            t = 0;
            rep(j,0,i) {
                t += ans[n - j - 1] * ans[n - (i - j) - 1] % 10;
                t %= 10;
            }
            if (t != (num[n * 2 - i - 2] ^ 48)) {
                o = 0;
                break;
            }
        }
        if (o) {
            ok = 1;
            rep(i,0,n-1) fans[i] = ans[i];
        }
        return;
    }
    if (u == 0) {
        if (mul[num[u] ^ 48].size() == 0) {
            return;
        }
        for (auto i : mul[num[u] ^ 48]) {
            if (ok) return;
            ans[u] = i;
            dfs(u + 1);
        }
    } else {
        int k = 0,m = num[u] ^ 48;
        int x;
        rep(i,1,u-1) {
            k += ans[i] * ans[u - i];
        }
        rep(t,0,2500) {
            if ((m + 10 * t - k) % (2 * ans[0]) == 0) {
                x = (m + 10 * t - k) / (2 * ans[0]);
                if (x < 10 && x >= 0) {
                    if (ok && fans[u] < x) {
                        return;
                    }
                    ans[u] = x;
                    dfs(u + 1);
                }
            }
        }
    }
}

int main()
{
    cin >> num;
    n = (int) num.size();
    if (!(n & 1)) {
        puts("-1");
        return 0;
    }
    
    n /= 2;
    n ++;
    
    rep(i,0,9) {
        mul[i * i % 10].insert(i);
    }
    dfs(0);
    if (ok) {
        REP(i,0,n) {
            printf("%d",fans[i]);
        }
        puts("");
    } else puts("-1");
}
*/

/*
int main() {
    int n,m;
    string str;
    int k;
    int i;
    __T {
        scii(n,m);
        cin >> str;
        k = (int) str.size();
        if (!m) {
            puts("YES");
            continue;
        }
        if (m << 1 >= n) {
            puts("NO");
            continue;
        }
        for (i = 0;i < m && str[k - i - 1] == str[i];i ++);
        puts(i == m ? "YES" : "NO");
    }
    return 0;
}
*/

/*
int main()
{
    set<int> s;
    int n,k;
    int t;
    int j;
    int mex,mx;
    ll ans;
    const int step = 2;
    __T {
        s.clear();
        scii(n,k);
        rep(i,1,n) {
            sci(t);
            s.insert(t);
        }
        
        rep(i,1,min(step,k)) {
            j = 0;
            mx = *(-- s.end());
            if (mx == s.size() - 1) {
                s.insert(mx + 1);
            } else {
                for (auto it = s.begin();it != s.end();it ++,j ++) {
                    if (j != *it) {
                        mex = j;
                        s.insert((mx + mex) / 2 + (mx + mex) % 2);
                        break;
                    }
                }
            }
        }
        
        k -= step;
        k = max(0,k);
        
        ans = s.size();
        
        if (*(-- s.end()) == s.size() - 1) {
            ans += k;
        }
        
        printf("%lld\n",ans);
        
        
    }
}
*/

/*
const int MAXN = 3e5 + 10;

struct Dot {
    ll x,y;
} miner[MAXN],dm[MAXN];

int cmp1(const Dot &a,const Dot &b) {
    return abs(a.x) < abs(b.x);
}

int cmp2(const Dot &a,const Dot &b) {
    return abs(a.y) < abs(b.y);
}

int main()
{
    int n;
    ll x,y;
    int cnt_m,cnt_d;
    double ans;
    __T {
        cnt_m = cnt_d = 0;
        sci(n);
        rep(i,1,n * 2) {
            scll(x,y);
            if (x == 0) miner[++ cnt_m] = {x,y};
            else if (y == 0) dm[++ cnt_d] = {x,y};
        }
        sort(miner + 1,miner + 1 + cnt_m,cmp2);
        sort(dm + 1,dm + 1 + cnt_d,cmp1);
        ans = 0;
        rep(i,1,n) {
            ans += sqrt(miner[i].y * miner[i].y + dm[i].x * dm[i].x);
        }
        printf("%.15f\n",ans);
    }
}
*/

/*
const int MAXN = 1e5+10;

int a[MAXN];

struct Node {
    int l,r;
} all[MAXN];

int l[MAXN];
int r[MAXN];

int check(int l,int r)
{
    if (!l || !r) return 0;
    if (l == r && l % 2 == 1) return 1;
    return 0;
}

int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        sci(a[i]);
    }
    int st = 0;
    int x = 0;
    rep(i,2,n) {
        if (a[i] > a[i - 1]) {
            // up
            if (st != 1) x ++;
            x ++;
            st = 1;
        } else {
            l[i - 1] = x;
            x = 0;
            st = -1;
        }
    }
    if (st == 1) l[n] = x;
    st = 0;
    x = 0;
    pre(i,n,2) {
        if (a[i] < a[i - 1]) {
            // down
            if (st != 1) x ++;
            x ++;
            st = 1;
        } else {
            r[i] = x;
            x = 0;
            st = -1;
        }
    }
    if (st == 1) r[1] = x;

//    rep(i,1,n) {
//        _C(l[i] << " " << r[i])
//    }


    int mx = -1;
    int t;

    int ok = 0;

    rep(i,1,n) {
//        printf("%d %d\n",l[i],r[i]);
        t = max(l[i],r[i]);
        if (t >= mx) ok = 0;
        if (check(l[i],r[i])) {
            if (t > mx) ok = 1;
        }
        mx = max(t,mx);
    }
    printf("%d\n",ok);
    return 0;
}
*/

/*
double fact[40000];

int main()
{
    // 处理阶乘
    rep(i,1,40000) {
        fact[i] = fact[i - 1] + log10(i);
    }
    
    int n;
    sci(n);
    ll a[500];
    ll m = 0; // 总人数
    int cnt[400] = {0};
    rep(i,1,n) {
        scl(a[i]);
        m += a[i];
        cnt[a[i]] ++;
    }
    // 总情况数365^m
    double base = log10(365) * m;
    
    // 1. 从365天中选出n天: C_365^n
    double p1 = 0;
    int t = 365;
    rep(i,1,n)
    {
        p1 += log10(t --);
    }
    rep(i,1,n) {
        p1 -= log10(i);
    }
    
    // 2. 不重复分组C_m^a[1] * C_{m-a[1]}^a[2]*...*C_a[n]^a[n] / (\prod A_cnt[i]^cnt[i])
    double p2 = fact[m];
    rep(i,1,n) {
        p2 -= fact[a[i]];
    }
    
    rep(i,1,100) {
        p2 -= fact[cnt[i]];
    }
    
    // 3. 将日期分配给每个小组
    double p3 = fact[n];
    
    double ans = p1 + p2 + p3;
    printf("%.15f\n",ans - base);
    
}
*/

/*
const int MAXN = 1e6 + 10;

ll a[MAXN];

const int mod = 1e9 + 7;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

ll fac[MAXN],invfac[MAXN],invn[MAXN];

ll C(ll n,ll m){
    if (n < 0 || m < 0 || n < m) return 0;
    return fac[n] * invfac[m] % mod * invfac[n - m] % mod;
}

void init() {
    fac[0] = fac[1] = invn[0] = invn[1] = invfac[0] = invfac[1] = 1;
    for (int i = 2;i < MAXN;i ++){
        fac[i] = fac[i - 1] * i % mod;
        invn[i] = (mod - mod / i) * invn[mod % i] % mod;
        invfac[i] = invfac[i - 1] * invn[i] % mod;
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    
    init();
    
    rep(i,1,n) {
        scanf("%lld",a + i);
    }
    
    sort(a + 1,a + 1 + n);
    
    int db = 0;
    
    for (int i = 2;i <= n;i ++) {
        if (a[i] == a[i - 1]) db ++;
    }

    ll ans = 0;
    
    ll t;
    
    int k = n - db;
    ll child = 1;
    
    rep(i,1,k) {
        child *= i;
        child %= mod;
    }
    
    ll base = quickpow(2, mod - 2);
    
    int j = db % 2;
    
    rep(i,1,db + 1) {
        t = child;
        
        t *= C(db,i - 1);
        t %= mod;
        
        if (!j) ans += t;
        else ans = (ans + mod - t) % mod;
        j ^= 1;
        ans %= mod;
        
        child *= ++ k;
        child %= mod;
        child *= base;
        child %= mod;
    }
    
    printf("%lld\n",ans);
    
}
*/

/*
int main()
{
    int n;
    sci(n);
    map<string,string> patch;
    string key;
    while (n --) {
        cin >> key;
        scanf(" ");
        getline(cin,patch[key]);
    }
    string str;
    stringstream ss;
    sci(n);
    scanf(" ");
    string word;
    string ans;
    int f = 1;
    while (n --) {
        getline(cin, str);
        ss = stringstream(str);
        ans = "";
        f = 1;
        while (ss >> word) {
            if (f) f = 0;
            else ans += " ";
            if (patch.find(word) != patch.end()) {
                ans += patch[word];
            } else ans += word;
        }
        _C(ans)
    }
}
*/

/*
int main()
{
    int n,p;
    __T {
        scii(n,p);
        
        printf("Circus Act %d:\n",T);
        if (n== 1) {
            puts("Chester can do it!");
            puts("");
            continue;
        }
        if (n * 2.5 <= p) {
            puts("Chester can do it!");
        } else puts("Chester will fail!");
        puts("");
    }
    
    
}
*/

/*
struct Point {
    double x,y;
};

inline double getDis(const Point &a,const Point &b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

inline double getDis2(const Point &a,const Point &b)
{
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

int main()
{
    Point center,start,finish;
    int n;
    Point dots[15];
    double a,b;
    double r,r2,k2,deg,k;
    
    Point sf,cs;
    double z;
    int T = 1;
    while (~scanf("%lf%lf%lf%lf%lf%lf",&center.x,&center.y,&start.x,&start.y,&finish.x,&finish.y)) {
        if (center.x == 0 && center.y == 0 && start.x == 0 && start.y == 0 && finish.x == 0 && finish.y == 0) break;
        scanf("%d",&n);
        rep(i,1,n) {
            scanf("%lf%lf",&dots[i].x,&dots[i].y);
        }
        
        r2 = getDis2(center, start);
        k2 = getDis2(start, finish);
        r = sqrt(r2);
        k = sqrt(k2);
        deg = acos((2 * r2 - k2) / (2 * r2));
        
        sf = {finish.x - start.x,finish.y - start.y};
        cs = {start.x - center.x,start.y - center.y};
        z = sf.x * cs.y - sf.y * cs.x;
        if (z > 0) deg = 2 * pi - deg;

        
        a = r * deg;
        b = 0;
        
        b += getDis(start,dots[1]);
        rep(i,2,n) {
            b += getDis(dots[i - 1],dots[i]);
        }
        b += getDis(dots[n],finish);
        
        printf("Case #%d: ",T ++);
        if (a < b) puts("Stick to the Circle.");
        else puts("Watch out for squirrels!");
        puts("");
    }
}
*/

/*
int main()
{
    ll n;
    ll k,nn;
    __T {
        scl(n);
        k = log2(n);
        nn = n;
        if ((1 << k) < n) nn = 1 << (k + 1);
        printf("Input value: %lld\n%lld\n\n",n,nn);
        
    }
}
*/
/*
int main()
{
    double n,p,m;
    __T {
        scddd(n,p,m);
        printf("%.2f\n",n * p / 100.0 * m);
    }
}
*/

/*
const int MAXN = 2e5 + 10;

int a[MAXN];
int ans[MAXN];

int main()
{
    int n;
    int cnt;
    __T {
        sci(n);
        rep(i,1,n) sci(a[i]);
        cnt = 0;
        pre(i,n,1) {
            cnt = max(a[i],cnt);
            ans[i] = 0;
            if (cnt) {
                ans[i] = 1;
                cnt --;
            }
        }
        rep(i,1,n) {
            if (i != 1) printf(" ");
            printf("%d",ans[i]);
        }
        puts("");
    }
}
*/

/*
const int MAXN = 110;

int a[MAXN];
int b[MAXN];
int t[MAXN];

int main()
{
    int n;
    ll ans;
    int k;
    __T {
        sci(n);
        rep(i,1,n) scii(a[i],b[i]);
        b[0] = 0;
        rep(i,1,n) {
            sci(t[i]);
            t[i] += a[i] - b[i - 1];
        }
        ans = 0;
        
        rep(i,1,n) {
            ans += t[i];
            if (i != n) {
                k = (b[i] - a[i]) / 2 + (b[i] - a[i]) % 2;
                ans = max(ans + k,(ll) b[i]);
            }
        }
        printf("%lld\n",ans);
        
        
    }
}
*/

/*
const int MAXN = 1e5 + 10;

int a[MAXN];
int ans[MAXN];
multiset<int> s;

int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        sci(a[i]);
    }
    s.insert(a[1]);
    rep(i,2,n) {
        s.insert(a[i]);
        ans[i] = *(--(-- s.end()));
    }
    int q;
    sci(q);
    int t;
    while (q --) {
        sci(t);
        printf("%d\n",ans[t]);
    }
}
*/

/*
const int MAXN = 1e6 + 10;
const int mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int w[MAXN];
ll sub[MAXN];

int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        sci(w[i]);
    }
    sub[n] = w[n];
    pre(i,n - 1,1) {
        sub[i] = (sub[i + 1] + w[i]) % mod;
    }
    ll ans = 1;
    rep(i,2,n-1) {
//        _C(w[i+1] * quickpow(sub[i], mod - 2) % mod)
        ans *= w[i] * quickpow(sub[i], mod - 2) % mod;
        ans %= mod;
    }
    printf("%lld\n",ans);
    
}
*/

/*
int ok(int a,int b,int c) {
    return a + b > c && a + c > b && b + c > a;
}

int main()
{
    int a[6];
    int p[6];
    int o;
    __T {
        rep(i,0,5) {
            sci(a[i]);
            p[i] = i;
        }
        o = 0;
        do {
            if (ok(a[p[0]],a[p[1]],a[p[2]]) && ok(a[p[3]],a[p[4]],a[p[5]])) {
                o = 1;
                break;
            }
        } while (next_permutation(p, p + 6));
        puts(o ? "Yes" : "No");
    }
}
*/

/*
int main()
{
    int n;
    int cur;
    int vis[40];
    int ans = 0;
    __T {
        sci(n);
        memset(vis, 0, sizeof vis);
        cur = 0;
        ans = 0;
        while (n) {
//            _C(n << " " << lowbit(n))
            if (lowbit(n) > (1 << cur)) {
                if (vis[cur]) {
                    cur ++;
                }
            }
            n -= (1 << cur);
            vis[cur] = 1;
            ans ++;
        }
        printf("%d\n",ans);
    }
    
}
*/

/*
int a[3][6][6];

int k[30];

int judge(int w)
{
    int t;
    rep(i,1,5) {
        t = 1;
        rep(j,1,5) {
            if (a[w][i][j]) {
                t = 0;
                break;
            }
        }
        if (t) return 1;
    }
    
    rep(j,1,5) {
        t = 1;
        rep(i,1,5) {
            if (a[w][i][j]) {
                t = 0;
                break;
            }
        }
        if (t) return 1;
    }
    
    t = 1;
    rep(i,1,5) {
        if (a[w][i][i]) {
            t = 0;
            break;
        }
    }
    if (t) return 1;
    
    t = 1;
    rep(i,1,5) {
        if (a[w][5 - i + 1][i]) {
            t = 0;
            break;
        }
    }
    if (t) return 1;
    
    return 0;
}

int main()
{
    int aa,bb;
    __T {
        rep(i,1,5) {
            rep(j,1,5) {
                sci(a[0][i][j]);
            }
        }
        rep(i,1,5) {
            rep(j,1,5) {
                sci(a[1][i][j]);
            }
        }
        rep(i,1,25) sci(k[i]);
        rep(x,1,25) {
            rep(i,1,5) {
                rep(j,1,5) {
                    if (a[0][i][j] == k[x]) {
                        a[0][i][j] = 0;
                    }
                }
            }
            rep(i,1,5) {
                rep(j,1,5) {
                    if (a[1][i][j] == k[x]) {
                        a[1][i][j] = 0;
                    }
                }
            }
            aa = judge(0);
            bb = judge(1);
            if (aa && !bb) puts("1");
            else if (!aa && bb) puts("2");
            else if (aa && bb) puts("0");
            if (aa || bb) break;
        }
        
    }
}

*/

/*
int const mod = 2019;
int main()
{
    int a,b,c,d;
    scanf("%d%d%d%d",&a,&b,&c,&d);
    printf("%d\n",max(a,b) - min(d,c));
    return 0;
}
*/

/*
int const mod = 2019;
int main()
{
    string s;
    cin>>s;
    int n =s.length();
    for(int i=0;i<n;i++) {
        if(s[i] !='.') printf("%c",s[i]);
        else break;
    }
    puts("");
    return 0;
}
*/

/*
int main()
{
    ll n;
    scl(n);
    int len = log10(n) + 1;
    ll mx = len / 2 - !(len & 1);
    ll ans = 0;
    ll ed = 9;
    ll st = 1;
    rep(i,1,mx) {
        ans += ed - st + 1;
        st *= 10;
        ed *= 10;
        ed += 9;
    }
    ll a,b;
    if (len % 2 == 0) {
        ll k = 1;
        rep(i,1,len / 2)
        {
            k *= 10;
        }
        a = n / k;
        b = n % k;
        k /= 10;
        rep(i,k,a) {
            if (i * k * 10 + i > n) break;
            ans ++;
        }
    }
    printf("%lld\n",ans);
}
*/

//ll a,b;
//
//ll xx;
//
//void dfs(ll x,ll sum) {
//    if (x <= 0) {
//        xx = min(xx,sum);
//        return;
//    }
//    dfs(x - 2,sum + a);
//    dfs(x - 3,sum + b);
//}
//
//int main()
//{
//    ll n;
//    ll ans;
//    ll k;
//    ll m;
//    __T {
//        sclll(n,a,b);
//        k = n / 6;
//        m = k * 6;
//        ans = min(m / 2 * a,m / 3 * b);
//        n -= m;
//        xx = 1e18;
//        dfs(n,0);
//        ans += xx;
//        printf("%lld\n",ans);
//    }
//}

/*
const int MAXN = 30;

int x[MAXN];

int main()
{
    int n;
    sci(n);
    char t;
    rep(i,1,n) {
        scanf(" %c",&t);
        if (t == 'T') x[i] = 1;
        else x[i] = 0;
    }
    stack<int> s;
    int a,b;
    while (~scanf(" %c",&t)) {
        if (t >= 'A' && t <= 'Z') {
            s.push(x[t - 'A' + 1]);
        } else {
            if (t == '-') {
                a = s.top();
                s.pop();
                s.push(!a);
            } else {
                b = s.top();
                s.pop();
                a = s.top();
                s.pop();
                if (t == '*') {
                    s.push(a & b);
                } else {
                    s.push(a | b);
                }
            }
        }
    }
    printf("%s\n",s.top() ? "T" : "F");
    
}
*/

/*
const int MAXN = 1e5 + 10;

ll A[MAXN],B[MAXN];

int main()
{
    int n,d;
    scii(n,d);
    int w;
    ll a,b;
    ll all = 0;
    rep(i,1,n) {
        sci(w);
        scll(a,b);
        all += a + b;
        A[w] += a;
        B[w] += b;
    }
    ll wa = 0,wb = 0;
    rep(i,1,d) {
        if (A[i] > B[i]) {
            printf("A %lld %lld\n",a = A[i] - (A[i] + B[i]) / 2 - 1,b = B[i]);
            wa += a;
            wb += b;
        } else {
            printf("B %lld %lld\n",a = A[i],b = B[i] - (A[i] + B[i]) / 2 - 1);
            wa += a;
            wb += b;
        }
    }
    printf("%.10f\n",abs(wa - wb) / (double) all);
    
}
*/

/*
const int MAXN = 1e6 + 10;

ll a[MAXN];

ll pre[MAXN];
ll sub[MAXN];

double pp[MAXN];
double ss[MAXN];

int main()
{
    int n;
    sci(n);
    double mx = 0;
    rep(i,1,n) {
        scl(a[i]);
        pre[i] = pre[i - 1] + a[i];
        
        mx = max(pre[i] / (double) i,mx);
    }
    
    pre(i,n,1) {
        sub[i] = sub[i + 1] + a[i];
        mx = max(sub[i] / (double) (n - i + 1),mx);
    }
    printf("%.10f\n",mx);
    
    
    return 0;
}
*/

/*
const int MAXN = 510;
const ll inf = 0x7ffffffffffff;

ll mp[MAXN][MAXN];
ll mp2[MAXN][MAXN];

int n,m,t,d;

void init()
{
    for (int i = 1;i <= n;i ++){
        mp[i][i] = mp2[i][i] = 0;
        for (int j = 1;j <= n;j ++){
            mp[i][j] = mp2[i][j] = inf;
        }
    }
}

void floyd()
{
    for (int k = 1;k <= n;k ++)
    {
        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= n;j ++)
            {
                mp[i][j] = min(mp[i][j],mp[i][k] + mp[k][j]);
            }
        }
    }
}

int st[MAXN];

int main()
{
    scii(n,m);
    scii(t,d);
    init();
    int u,v;
    ll w;
    
    rep(i,1,t) {
        sci(st[i]);
    }
    st[++ t] = 1;
    st[++ t] = n;
    
    while (m --) {
        scii(u,v);
        scl(w);
        mp[u][v] = w;
        mp[v][u] = w;
    }
    floyd();
    
    rep(i,1,t) {
        rep(j,1,t) {
            if (mp[st[i]][st[j]] <= d) {
                mp2[st[i]][st[j]] = mp[st[i]][st[j]];
                mp2[st[j]][st[i]] = mp[st[i]][st[j]];
            }
        }
    }
    rep(i,1,n) {
        rep(j,1,n) {
            mp[i][j] = mp2[i][j];
//            printf("%lld ",mp[i][j] == inf ? -1 : mp[i][j]);
        }
//        puts("");
    }
    floyd();
    
    if (mp[1][n] != inf) printf("%lld\n",mp[1][n]);
    else puts("stuck");
    
}
*/

/*
// 线段树 - 二叉树，节点存的是一个 l，r，区间的内容n
const int MAXN = 1e5 + 10;
 
struct P {
    ll mn;
    ll sum1;
    ll sum2;
    ll mx;
};
 
struct Node {
    int l,r;
    ll mx;
    ll mn;
    ll sum1;
    ll sum2;
} tree[MAXN << 2][20];
ll a[MAXN];
 
void push_up(int i,int t)
{
//    _C(i << " " << tree[i << 1].mn << " " << tree[i << 1 | 1].mn)
     
    tree[i][t].mn = min(tree[i << 1][t].mn,tree[i << 1 | 1][t].mn);
    tree[i][t].mx = max(tree[i << 1][t].mx,tree[i << 1 | 1][t].mx);
     
    tree[i][t].sum1 = max(tree[i << 1][t].sum1,tree[i << 1 | 1][t].sum1);
    tree[i][t].sum1 = max(tree[i][t].sum1,max(0ll,tree[i << 1 | 1][t].mx - tree[i << 1][t].mn));
     
    tree[i][t].sum2 = max(tree[i << 1][t].sum2,tree[i << 1 | 1][t].sum2);
    tree[i][t].sum2 = max(tree[i][t].sum2,max(0ll,tree[i << 1][t].mx - tree[i << 1 | 1][t].mn));
}
 
// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i,int t)
{
    tree[i][t].l = l;
    tree[i][t].r = r;
    if (l == r) {
        tree[i][t].sum1 = tree[i][t].sum2 = 0; // a原数组，把原来的数值给叶子结点
        tree[i][t].mx = a[l];
        tree[i][t].mn = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1,t);
    build(m + 1,r,i << 1 | 1,t);
    push_up(i,t);
}
 
P query(int l,int r,int i,int t) //查询
{
     
    if (l <= tree[i][t].l && r >= tree[i][t].r) return {tree[i][t].mn,tree[i][t].sum1,tree[i][t].sum2,tree[i][t].mx};
    int m = (tree[i][t].l + tree[i][t].r) >> 1;
    P sum;
    P a = {-1,-1,-1},b = {-1,-1,-1};
 
    if (l <= m) {
        a = query(l,r,i << 1,t);
    }
    if (r > m) {
        b = query(l,r,i << 1 | 1,t);
    }
     
    if (a.mn == -1) return b;
    if (b.mn == -1) return a;
     
    sum.mn = min(a.mn,b.mn);
    sum.mx = max(a.mx,b.mx);
     
    sum.sum1 = max(a.sum1,b.sum1);
    sum.sum1 = max(sum.sum1,max(0ll,b.mx - a.mn));
     
    sum.sum2 = max(a.sum2,b.sum2);
    sum.sum2 = max(sum.sum2,max(0ll,a.mx - b.mn));
     
    return sum;
}
 
ll v[MAXN],d[MAXN];
 
int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        scll(v[i],d[i]);
    }
     
    int w,k;
     
    rep(i,1,7) {
        w = i;
        rep(j,1,n) {
            if (w <= 4) k = w - 1;
            else k = 7 - w;
            a[j] = v[j] + d[j] * k;
            w ++;
            if (w == 8) w = 1;
        }
        build(1, n, 1, i);
    }
     
    rep(i,1,7) {
        w = i;
        pre(j,n,1) {
            if (w <= 4) k = w - 1;
            else k = 7 - w;
            a[j] = v[j] + d[j] * k;
            w ++;
            if (w == 8) w = 1;
        }
        build(1, n, 1, i + 7);
    }
     
     
    int q;
    sci(q);
    int s,t;
    ll ans;
    int x;
    while (q --) {
        scii(s,t);
        if (s <= t) {
            x = (7 - (s - 1) % 7 + 1) % 7;
            x = x ? x : 7;
            ans = query(s, t, 1, x).sum1;
        } else {
            x = (7 - (n - s) % 7 + 1) % 7;
            x = x ? x : 7;
            ans = query(t, s, 1, x + 7).sum2;
        }
        printf("%lld\n",ans);
//        _C(x.mn << " " << x.sum1 << " " << x.sum2 << " " << x.mx)
    }
     
     
}
*/

//ll a[310][310];
//ll sum[310][310];
//
//int main()
//{
//    int n,m,k;
//    sciii(n,m,k);
//    rep(i,1,n) {
//        rep(j,1,m) {
//            scl(a[i][j]);
//        }
//    }
//    ll ans = 0;
//    ll s;
//    rep(ii,1,n) {
//        rep(jj,1,m) {
//            if (ii * jj <= k) {
//                s = 0;
//                pre(i,ii,1) {
//                    pre(j,jj,1) {
//                        s += a[i][j];
//                        if (s > sum[i][j]) sum[i][j] = s;
//                    }
//                }
//            }
//        }
//    }
//    printf("%lld\n",sum[1][1]);
//}

//int main()
//{
//    ll n,x,y;
//    __T {
//        sclll(n,x,y);
//        if (n == 1) {
//            printf("%lld\n",min(x,y));
//            continue;
//        }
//        x += n - 2;
//        y += n - 2;
//        while (x != y) {
//            if (x > y) {
//                x /= n;
//                x ++;
//            } else if (x < y) {
//                y /= n;
//                y ++;
//            }
//        }
//        _C(x)
//
//    }
//}

//ll Manacher_n(string &s)
//{
//    //改造字符串
//    int n = (int) s.size();
//    string res = "$#";
//    for (int i = 0;i < n;i ++)
//    {
//        res += s[i];
//        res += "#";
//    }
//
//    _C(res)
//
//    //数组
//    n = (int) res.size();
//    vector<ll> P(n,0);
//    ll mi = 0,right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值
//    ll maxLen = 0,maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点
//
//    ll ans = 0;
//    for (ll i = 1;i < n;i ++)
//    {
//        P[i] = right > i ? min(P[2 * mi - i],right - i) : 1; //关键句，文中对这句以详细讲解
//        while (res[i + P[i]] == res[i - P[i]]) {
//            P[i] ++;
//        }
//        if (right < i + P[i]) //超过之前的最右端，则改变中心点和对应的最右端
//        {
//            right = i + P[i];
//            mi = i;
//        }
//        if (maxLen < P[i]) //更新最大回文串的长度，并记下此时的点
//        {
//            maxLen = P[i];
//            maxPoint = i;
//        }
//        _C(i << " > " << maxPoint << " " << maxLen << " " << P[i])
////        if (maxPoint)
//        ans += P[i] / 2;
//    }
//    return ans;
//}
//
//
//int main()
//{
//    string str;
//    cin >> str;
//    _C(Manacher_n(str))
//}

/*
const int MAXN = 200010;

int nxt[MAXN];
int extend[MAXN];

string T,S;

// 求解 T 中 next[]，注释参考 exkmp()
void make()
{
    int a = 0, p = 0;
    int m = (int) T.size();
    nxt[0] = m;

    for (int i = 1; i < m; i++)
    {
        if (i >= p || i + nxt[i - a] >= p)
        {
            if (i >= p)
                p = i;

            while (p < m && T[p] == T[p - i])
                p++;

            nxt[i] = p - i;
            a = i;
        }
        else
            nxt[i] = nxt[i - a];
    }
}

// 求解 extend[]
void exkmp()
{
    make();

    int a = 0, p = 0;
    int n = (int) S.size();
    int m = (int) T.size();

    for (int i = 0; i < n; i++)
    {
        if (i >= p || i + nxt[i - a] >= p) // i >= p 的作用：举个典型例子，S 和 T 无一字符相同
        {
            if (i >= p) p = i;
            while (p < n && p - i < m && S[p] == T[p - i]) p ++;
            extend[i] = p - i;
            a = i;
        } else extend[i] = nxt[i - a];
    }
}

int pre[MAXN];
int pcnt;

ull hs[MAXN];
ull bin[MAXN];
const int p = 131;

string str;

void getHash()
{
    bin[0] = 1;
    for (int i = 1;str[i - 1];i ++) {
        hs[i] = hs[i - 1] * p + str[i - 1] - 'a';
        bin[i] = bin[i - 1] * p;
    }
}

ull getSub(int l,int r)
{
    return hs[r] - hs[l - 1] * bin[r - l + 1];
}

int main()
{
    cin >> str;
    int n = (int) str.size();
    T = S = "";
    REP(i,0,n) {
        T += str[i];
        S += str[n - i - 1];
    }
    
    exkmp();
    
    pre[++ pcnt] = 1;
    for (int i = 0;str[i];i ++) {
        if (extend[i] == n - i) {
            pre[++ pcnt] = n - i;
        }
    }

    sort(pre + 1,pre + 1 + pcnt);
    pcnt = (int) (unique(pre + 1, pre + 1 + pcnt) - pre) - 1;
    
    getHash();
    int ans = 0;
    for (int i = 1,k = 1;str[i - 1] && k <= pcnt;i ++) {
        if (i == pre[k]) {
            k ++;
            if (i * 2 <= n) {
                if (getSub(1, i) == getSub(i + 1,i * 2)) {
                    ans ++;
                }
            }
            if (i * 2 - 1 <= n) {
                if (getSub(1, i) == getSub(i,i * 2 - 1)) {
                    ans ++;
                }
            }
        }
    }
    printf("%d\n",ans);
}
*/

/*
const int MAXN = 1e5 + 10;
const int mod = 1e9 + 7;

ll x[MAXN],y[MAXN];

int main()
{
    int n,m;
    scii(n,m);
    rep(i,1,n) scl(x[i]);
    rep(i,1,m) scl(y[i]);
    sort(x + 1,x + 1 + n);
    sort(y + 1,y + 1 + m);

    ll a = n - 3,b = m - 3;
    ll aa = 0,bb = 0;
    
    ll k;
    ll num = n - 1;
    
    rep(i,2,n) {
        k = x[i] - x[i - 1];
        aa += k * num % mod;
        aa %= mod;
        
        num += a;
        a -= 2;
    }
    
    num = m - 1;
    
    rep(i,2,m) {
        k = y[i] - y[i - 1];
        bb += k * num % mod;
        bb %= mod;
        
        num += b;
        b -= 2;
    }
//    _C(a << " " << b)
//    _C(aa * a)
//    _C(bb * b)
    printf("%lld\n",aa * bb % mod);
}
*/

/*
inline ll cal(ll n)
{
    ll ans = 0;
    while (n) {
        ans += (n % 10) * (n % 10);
        n /= 10;
    }
    return ans;
}

int main()
{
    ll n;
    
        scl(n);
        rep(i,1,100000) {
            if (n == 1) {
                puts("HAPPY");
                return 0;
            }
            n = cal(n);
        }
    puts("UNHAPPY");
    
}
*/

/*
const int MAXN = 1e4 + 10;

int dd[MAXN];
int dir[MAXN];

struct Node {
    int x,y;
};

int ans[MAXN];

int l,r,u,d;

int main()
{
    int n;
    scanf("%d",&n);
    int t;
    rep(i,1,n) {
        scanf("%d %d",&t,dd + i);
    }
    
    dir[1] = 4;
    rep(i,2,n) {
        if (dir[i - 1] == 1) {
            if (dd[i - 1] == 1) dir[i] = 3;
            else if (dd[i - 1] == -1) dir[i] = 4;
        } else if (dir[i - 1] == 2) {
            if (dd[i - 1] == 1) dir[i] = 4;
            else if (dd[i - 1] == -1) dir[i] = 3;
        } else if (dir[i - 1] == 3) {
            if (dd[i - 1] == 1) dir[i] = 2;
            else if (dd[i - 1] == -1) dir[i] = 1;
        } else if (dir[i - 1] == 4) {
            if (dd[i - 1] == 1) dir[i] = 1;
            else if (dd[i - 1] == -1) dir[i] = 2;
        }
    }
    // 1 up
    // 2 down
    // 3 l
    // 4 r
    
    Node pos = {0,0};
    
    
    rep(i,1,n) {
        if (dir[i] == 1) {
            ans[i] = u + 1 - pos.y;
            u ++;pos.y = u;
            
        } else if (dir[i] == 2) {
            ans[i] = pos.y - d + 1;
            d --;
            pos.y = d;
            
        } else if (dir[i] == 3) {
            ans[i] = pos.x - l + 1;
            l --;pos.x = l;
            
        } else if (dir[i] == 4) {
            ans[i] = r + 1 - pos.x;
            
            r ++;pos.x = r;
            
        }
    }
    rep(i,1,n) {
        if (i != 1) printf(" ");
        printf("%d",ans[i]);
    }
    puts("");
}
*/

/*
int main()
{
    ll n;
    scl(n);
    printf("%lld\n",n * (n - 1) / 2);
}
*/

/*
int main()
{
    vector<int> ans;
    int n;
    sci(n);
    rep(i,1,n) {
        if (i & 1) {
            if (i % 9 == 0) ans.pb(i);
        } else {
            if (i % 7) ans.pb(i);
        }
    }
    int x = 0;
    for (vector<int>::iterator i = ans.begin();i != ans.end();i ++) {
        x += log10(*i) + 1;
    }
    _C(x);
}
*/

/*
const int mod = 10007;

char prime[100];

void shai()
{
    memset(prime,1,sizeof prime);
    for (int i = 2;i < 100;i ++) {
        for (int j = i + i;j < 100;j += i) {
            prime[j] = 0;
        }
    }
    prime[1] = 0;
    prime[0] = 0;
}

int dp[1010][10];

int main()
{
    int k;
    sci(k);
    int s;
    shai();
    rep(i,0,9) dp[1][i] = 1;
    rep(ii,2,k) {
        s = 0;
        if (ii == 2) s = 1;
        rep(i,s,9) {
            rep(j,0,9) {
                if (prime[i * 10 + j]) {
                    dp[ii][j] += dp[ii - 1][i];
                    dp[ii][j] %= mod;
                }
            }
        }
    }
    ll ans = 0;
    rep(i,0,9) {
        ans += dp[k][i];
        ans %= mod;
    }
    printf("%lld\n",ans);
}
*/

/*
inline ll ceil(ll a,ll b) {
    return a / b + (a % b ? 1 : 0);
}

int main()
{
    ll hp,atk,n,h,a,t;
    ll k,times,lt;
    ll end;
    ll dmg = 0;
    __T {
        scll(hp,atk);
        sclll(n,h,a);
        scl(t);
        k = ceil(h,atk);
        times = t / k;
        lt = t % k;
        end = max(0ll,n - times + 1);
//        _C(times)
//        _C(end);
        dmg = (n + end) * (n - end + 1) / 2 * k * a;
        if (lt) {
            dmg += lt * max(0ll,end - 1) * a;
        }
        puts(dmg >= hp ? "Yes" : "No");
    }
}
*/

/*
const int MAXN = 100010;

struct Edge {
    int to;
    ll w;
    Edge(int to,ll w):to(to),w(w){}
    Edge(){}
};

vector<Edge> g[MAXN];
int in[MAXN];

int vis[MAXN];

int n;

void find_circle() {
    queue<int> q;
    rep(i,1,n) {
        if (in[i] == 1) {
            q.push(i);
        }
    }
    int top;
    while (!q.empty()) {
        top = q.front();
        q.pop();
        for (vector<Edge>::iterator it = g[top].begin();it != g[top].end();it ++) {
            if (in[it -> to]) {
                in[it -> to] --;
                in[top] --;
                if (in[it -> to] == 1) {
                    q.push(it -> to);
                }
            }
        }
    }
}

int st;
ll x;
int fd;

void run(int u,int f,ll num)
{
    if (fd) return;
    if (f != -1 && st == u) {
        x = num / 2;
        fd = 1;
        return;
    }
    for (vector<Edge>::iterator it = g[u].begin();it != g[u].end();it ++) {
        if (it -> to != f)
            run(it -> to,u,it -> w - num);
    }
}

ll ww[MAXN];

void dfs(int u,ll s)
{
    if (vis[u]) return;
    vis[u] = 1;
    ww[u] = s;
    for (vector<Edge>::iterator it = g[u].begin();it != g[u].end();it ++) {
        dfs(it -> to,it -> w - s);
    }
}

int main()
{
    sci(n);
    int u,v;
    ll w;
    rep(i,1,n) {
        scii(u,v);
        scl(w);
        g[u].pb(Edge(v,w));
        g[v].pb(Edge(u,w));
        in[u] ++;
        in[v] ++;
    }
    find_circle();
    rep(i,1,n) {
        if (in[i]) {
            st = i;
            run(i,-1,0);
            dfs(i,x);
            break;
        }
    }
    rep(i,1,n) {
        printf("%lld\n",ww[i]);
    }
}
*/

/*
const int MAXN = 1e5 + 10;

int a[MAXN];
multiset<int> s;

int main()
{
    int n,k;
    scii(n,k);
    int t;
    rep(i,1,n) {
        sci(t);
        s.insert(t);
    }
    int l = 1;
    int fd;
    multiset<int>::iterator it;
    int die = 0;
    while (!s.empty()) {
        fd = 0;
        it = s.find(l);
        if (it != s.end()) {
            s.erase(it);
            die ++;
            fd = 1;
        }
        if (!fd) {
            it = s.find(l + k);
            if (it != s.end())
            {
                s.erase(it);
                die ++;
                fd = 1;
            }
        }
        if (!fd) break;
        l ++;
    }
    for (it = s.begin();it != s.end();it ++) {
        if (*it - k <= l) die ++;
    }
    printf("%d %d\n",die,l);
}
*/

/*
struct big{
    int d;ll a[N>>2];
    void rd(){
        scanf("%s",S),d=strlen(S);
        for(int i=1;i<=d;i++)
        a[d-i>>3]=a[d-i>>3]*10+S[i-1]-'0';
        d=d-1>>3;
    }
    void upd(){while(d&&!a[d])d--;}
    void div(){
        for(int i=d;i>=0;i--)
        i?a[i-1]+=a[i]%p*V:0,a[i]/=p;
        upd();
    }
    int mod(int k){
        LL ret=0;
        for(int i=d;i>=0;i--)
        ret=(ret*V+a[i])%k;
        return ret;
    }
}
//ll operator%(Wint a,ll mod)
//{
//    ll ans = 0;
//    for (Wint::reverse_iterator it = a.rbegin();it != a.rend();it ++) {
//        ans *= 10;
//        ans %= mod;
//        ans += *it;
//        ans %= mod;
//    }
//    return ans;
//}


int p;

ll eular(ll x)
{
    ll ans = x;
    for (int i = 2;i * i <= x;i ++)
    {
        if (x % i == 0)
        {
            ans = ans / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) ans = ans / x * (x - 1);
    return ans;
}

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}

const int MAXXN = 1e6 + 10;

BigNum l,r;

int pr[MAXXN];
int cnt_p;

char sheiv[MAXXN];

inline ll solve()
{
    
    mem(sheiv,1);
    
    int pp = p;
    for (int i = 2;i * i <= p && pp != 1;i ++) {
        if (pp % i == 0) pr[++ cnt_p] = i;
        while (pp % i == 0) pp /= i;
    }
    if (pp != 1) pr[++ cnt_p] = pp;
    sort(pr + 1,pr + 1 + cnt_p);
    
    //
//    rep(i,1,cnt_p) {
//        printf("%d ",pr[i]);
//    }
//    puts("");
    //
    sheiv[0] = 0;
    for (int i = 1;i <= cnt_p;i ++) {
        for (int j = pr[i];j < p;j += pr[i]) sheiv[j] = 0;
    }
    //
//    REP(i,0,p) printf("%3d",i);
//    puts("");
//    REP(i,0,p) printf("%3d",sheiv[i]);
//    puts("");
    //
    
    r - l + 1;
    
    int stp = (int) (l % p);
    
    ll cycle = 1;
    for (int i = 0,j = stp;i < p;i ++,j = (j + 1) % p) {
        if (sheiv[j]) {
            cycle *= j;
            cycle %= p;
        }
    }
    _C(cycle)
    
    r = l / p;
    _C("aaa")
    ll e = eular(p);
    _C(e)
    ll ans = quickpow(cycle % p, (r % e) + e);
    _C(ans)
    
    ll left = l % p;
    for (ll i = 0,j = stp;i < left;i ++,j = (j + 1) % p) {
        if (sheiv[j]) {
            ans *= j;
            ans %= p;
        }
    }
    
    ll ans = 0;
    return ans;
}



int main()
{
    cin >> l >> r >> p;
    _C(solve());


}
*/

/*
struct Wint:vector<int>//用标准库vector做基类，完美解决位数问题，同时更易于实现
{
    //将低精度转高精度的初始化，可以自动被编译器调用
    //因此无需单独写高精度数和低精度数的运算函数，十分方便
    Wint(int n = 0)//默认初始化为0，但0的保存形式为空
    {
        push_back(n);
        check();
    }
    Wint& check()//在各类运算中经常用到的进位小函数，不妨内置
    {
        while(!empty()&&!back())pop_back();//去除最高位可能存在的0
        if(empty())return *this;
        for(int i=1; i<size(); ++i)//处理进位
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;//为使用方便，将进位后的自身返回引用
    }
};
//输入输出
istream& operator>>(istream &is,Wint &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i = (int) s.size() - 1; i>=0; --i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const Wint &n)
{
    if(n.empty())os<<0;
    for(int i = (int) n.size() - 1; i>=0; --i)os<<n[i];
    return os;
}
//比较，只需要写两个，其他的直接代入即可
//常量引用当参数，避免拷贝更高效
bool operator!=(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return 1;
    for(int i = (int) a.size() -1; i>=0; --i)
        if(a[i]!=b[i])return 1;
    return 0;
}
bool operator==(const Wint &a,const Wint &b)
{
    return !(a!=b);
}
bool operator<(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return a.size()<b.size();
    for(int i = (int) a.size()-1; i>=0; --i)
        if(a[i]!=b[i])return a[i]<b[i];
    return 0;
}
bool operator>(const Wint &a,const Wint &b)
{
    return b<a;
}
bool operator<=(const Wint &a,const Wint &b)
{
    return !(a>b);
}
bool operator>=(const Wint &a,const Wint &b)
{
    return !(a<b);
}
//加法，先实现+=，这样更简洁高效
Wint& operator+=(Wint &a,const Wint &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
    return a.check();
}
Wint operator+(Wint a,const Wint &b)
{
    return a+=b;
}
//减法，返回差的绝对值，由于后面有交换，故参数不用引用
Wint& operator-=(Wint &a,Wint b)
{
    if(a<b)swap(a,b);
    for(int i=0; i!=b.size(); a[i]-=b[i],++i)
        if(a[i]<b[i])//需要借位
        {
            int j=i+1;
            while(!a[j])++j;
            while(j>i)
            {
                --a[j];
                a[--j]+=10;
            }
        }
    return a.check();
}
Wint operator-(Wint a,const Wint &b)
{
    return a-=b;
}
//乘法不能先实现*=，原因自己想
Wint operator*(const Wint &a,const Wint &b)
{
    Wint n;
    n.assign(a.size()+b.size()-1,0);
    for(int i=0; i!=a.size(); ++i)
        for(int j=0; j!=b.size(); ++j)
            n[i+j]+=a[i]*b[j];
    return n.check();
}
Wint& operator*=(Wint &a,const Wint &b)
{
    return a=a*b;
}
//除法和取模先实现一个带余除法函数
Wint divmod(Wint &a,int b)
{
    Wint ans;
    int n = (int) a.size();
    int sum = 0;
    for(int i = n-1;i >= 0;i--) {
        sum = sum * 10 + a[i];
        ans.push_back(sum/b);
        sum%=b;
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
Wint operator/(Wint &a,int &b)
{
    return divmod(a,b);
}
Wint& operator/=(Wint &a,int &b)
{
    return a=a/b;
}
Wint& operator%=(Wint &a,int &b)
{
    divmod(a,b);
    return a;
}

ll operator%(Wint a,ll mod)
{
    ll ans = 0;
    for (Wint::reverse_iterator it = a.rbegin();it != a.rend();it ++) {
        ans *= 10;
        ans %= mod;
        ans += *it;
        ans %= mod;
    }
    return ans;
}


int p;

ll eular(ll x)
{
    ll ans = x;
    for (int i = 2;i * i <= x;i ++)
    {
        if (x % i == 0)
        {
            ans = ans / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) ans = ans / x * (x - 1);
    return ans;
}

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}

const int MAXN = 1e6 + 10;

int pr[MAXN];
int cnt_p;

char sheiv[MAXN];
Wint l,r;

inline ll solve()
{
    
    mem(sheiv,1);
    int pp = p;
    for (int i = 2;i * i <= p && pp != 1;i ++) {
        if (pp % i == 0) pr[++ cnt_p] = i;
        while (pp % i == 0) pp /= i;
    }
    
    if (pp != 1) pr[++ cnt_p] = pp;
    sort(pr + 1,pr + 1 + cnt_p);

    sheiv[0] = 0;
    for (int i = 1;i <= cnt_p;i ++) {
        for (int j = pr[i];j < p;j += pr[i]) sheiv[j] = 0;
    }

    
    Wint len = r - l + 1;
    int stp = (int) (l % p);
    
    ll cycle = 1;
    
    for (int i = 0,j = stp;i < p;i ++,j = (j + 1) % p)  {
        if (sheiv[j]) {
            cycle *= j;
            cycle %= p;
        }
    }
    
    Wint times = len / p;
    
    ll e = eular(p);
    ll ans = quickpow(cycle % p, (times % e) + e);

    ll left = len % p;
    for (ll i = 0,j = stp;i < left;i ++,j = (j + 1) % p) {
        if (sheiv[j]) {
            ans *= j;
            ans %= p;
        }
    }
    return ans;
}


int main()
{
    
    cin >> l >> r >> p;
    _C(solve());
    
}
*/

/*
int main()
{
    int n,m;
    string str;
    __T {
        scanf("%d%d",&n,&m);
        cin >> str;
        for (int i = 0,j = 0;str[i];i ++,j ++) {
            if (j == m) {
                puts("");
                j = 0;
            }
            printf("%c",str[i]);
        }
        puts("");
    }
}
*/

/*
const int MAXN = 1e5 + 10;
char str[MAXN];

ull hs[MAXN]; // 哈希数组，定义成ull自动取模
ull bin[MAXN]; // 记录p的次方数
const int p = 131; // 进制数


void getHash()
{
    bin[0] = 1;
    for (int i = 1;str[i - 1];i ++) {
        hs[i] = hs[i - 1] * p + str[i - 1] - 'a'; // 算哈希值，把他当一个大数字来看待
        bin[i] = bin[i - 1] * p; // 计算p的次方数
    }
}

inline ull getSub(int l,int r) // 获取其中的一段subString的哈希值hash[l...r]
{
    return hs[r] - hs[l - 1] * bin[r - l + 1];
}

int main()
{
    int m,l;
    map<ull,int> x;
    int ans;
    ull t;
    int len;
    while (~scanf("%d%d",&m,&l)) {
        scanf("%s",str);
        getHash();
        ans = 0;
        len = (int) strlen(str);
        for (int i = 0;i < l && i + m * l - 1 < len;i ++) {
            x.clear();
            for (int j = i,k = 0;k < m && j + l - 1 < len;j += l,k ++) {
                x[getSub(j + 1, j + l)] ++;
            }
            if (x.size() == m) ans ++;
            for (int j = i + l * m;j + l - 1 < len;j += l) {
                t = getSub(j - l * m + 1, j - l * m + l);
                x[t] --;
                if (!x[t]) x.erase(x.find(t));
                t = getSub(j + 1,j + l);
                x[t] ++;
                if (x.size() == m) ans ++;
                
            }
        }
        printf("%d\n",ans);
    }
    
}
*/

/*
int a[50][50];
int b[50][50];
int n;

void rotate()
{
    int tmp[50][50];
    rep(i,1,n) {
        rep(j,1,n) {
            tmp[j][n - i + 1] = a[i][j];
        }
    }
    rep(i,1,n) {
        rep(j,1,n) {
            a[i][j] = tmp[i][j];
        }
    }
}

int eq() {
    int ans = 0;
    rep(i,1,n) {
        rep(j,1,n) {
            ans += a[i][j] == b[i][j];
        }
    }
    return ans;
}

int main()
{
    int ans;
    while (~scanf("%d",&n)) {
        if (n == 0) break;
        rep(i,1,n) {
            rep(j,1,n) {
                scanf("%d",&a[i][j]);
            }
        }
        rep(i,1,n) {
            rep(j,1,n) {
                scanf("%d",&b[i][j]);
            }
        }
        ans = 0;
        rep(i,0,3) {
            ans = max(eq(),ans);
            rotate();
        }
        printf("%d\n",ans);
    }
}
*/

/*
int main()
{
    ll a[3];
    ll ans = 0;
    set<int> l[2];
    while (~scanf("%lld%lld%lld",a,a + 1,a + 2)) {
        l[0].clear();
        l[1].clear();
        ans = 0;
        for (int i = 0;i < 6;i ++) {
            if (a[i % 3]) {
                ans += l[0].size();
                ans += l[1].size();
                if (l[0].size() < l[1].size()) {
                    if (l[0].find(i % 3) == l[0].end()) l[0].insert(i % 3);
                    else l[1].insert(i % 3);
                } else {
                    if (l[1].find(i % 3) == l[1].end()) l[1].insert(i % 3);
                    else l[0].insert(i % 3);
                }
                a[i % 3] --;
            }
        }
        ans += (l[0].size() + l[1].size()) * (a[0] + a[1] + a[2]);
        printf("%lld\n",ans);
    }
}
*/

/*
const double eps = 1e-8;
int sgn(double x) {
    if(fabs(x) < eps)return 0;
    if(x < 0)return -1;
    else return 1;
}
struct Point
{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y) {}
    Point(const Point &p):x(p.x),y(p.y) {}
    
    Point operator-(const Point &b)const
    {
        return Point(x - b.x,y - b.y);
    }
    
    //绕原点旋转角度B（弧度值），后x,y的变化
    void transXY(double B)
    {
        double tx = x,ty = y;
        x = tx * cos(B) - ty * sin(B);
        y = tx * sin(B) + ty * cos(B);
    }
    
    void identity() {
        double k = sqrt(x * x + y * y);
        x /= k;
        y /= k;
    }
    
    void print()
    {
        printf("%f %f\n",x,y);
    }
    
    void abs() {
        x = fabs(x);
        y = fabs(y);
    }
    
    bool operator<(const Point &o) const {
        if (sgn(x - o.x) == 0) return sgn(y - o.y) == 1;
        return sgn(x - o.x) == 1;
    }
};

const int MAXN = 1e3 + 10;

Point a[MAXN];
map<Point,map<Point,int>> mp;

int main()
{
    int n;
    sci(n);
    rep(i,1,n) {
        scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    Point node,t;
    rep(i,1,n) {
        rep(j,1,n) {
            if (i == j) continue;
            node = a[j] - a[i];
            node.identity();
            mp[a[i]][node] ++;
        }
    }
    int ans = 0;
    rep(i,1,n) {
        rep(j,i + 1,n) {
            node = {(a[i].x + a[j].x) / 2,(a[i].y + a[j].y) / 2};
            t = a[i] - a[j];
            t.identity();
            t.abs();
            if (!((sgn(t.x - 1) == 0 && sgn(t.y) == 0) || (sgn(t.y - 1) == 0 && sgn(t.x) == 0))) continue;
            
            t = a[i] - a[j];
            t.identity();
            t.transXY(pi / 2);
            
            ans += mp[node][t];
            
            t = a[i] - a[j];
            t.identity();
            t.transXY(-pi / 2);
            
            ans += mp[node][t];
        }
    }
    _C(ans)
}
*/

/*
const int MAXN = 1e6 + 10;
 
int mp[4][15];
 
#define WAN 0
#define BING 1
#define SUO 2
#define ZI 3
struct Node {
    int type;
    int n;
    int hash()
    {
        return type * 9 + n;
    }
    bool operator<(const Node &o) const {
        if (type == o.type) return n < o.n;
        return type < o.type;
    }
    bool operator==(const Node &o) const {
        return type == o.type && n == o.n;
    }
} cards[20];

set<Node> ans[100];
 
char n2c[] = {'w','b','s','z'};
 
int xx[15];
bool dfs(int i)
{
    if (i > 9) return 1;
    if (xx[i] == 0)return dfs(i+1);
    if (i <= 7 && xx[i + 1] >= xx[i] && xx[i + 2] >= xx[i]) {
        xx[i + 1] -= xx[i];
        xx[i + 2] -= xx[i];
        if (dfs(i + 1)) return 1;
        xx[i + 1] += xx[i];
        xx[i + 2] += xx[i];
    }
    if (xx[i] >= 3) {
        xx[i] -= 3;
        if (dfs(i)) return 1;
        xx[i] += 3;
    }
    return 0;
}
 
inline bool single(Node type) {
    int k;
 
    for (int i = 1;i <= 7;i ++) {
        k = mp[ZI][i] - (type.type == ZI && type.n == i ? 2 : 0);
        if (k % 3) return 0;
    }
 
    int ok = 1;
    for (int t = 0;t < 3;t ++) {
        for (int i = 1;i <= 9;i ++) {
            k = mp[t][i] - (type.type == t && type.n == i ? 2 : 0);
            xx[i] = k;
        }
        ok = ok && dfs(1);
    }
    return ok;
}
 
inline bool check()
{
    for (int i = 0;i < 4;i ++) {
        // 找对子
        for (int j = 1;j <= 9;j ++) {
            if (mp[i][j] >= 2){
                if (single({i,j})) return 1;
            }
        }
    }
    return 0;
}
 
inline void add(Node x)
{
    // 把所有牌都加一遍
    for (int i = 1;i <= 9;i ++) {
        for (int t = 0;t < 3;t ++) {
            if (x.type == t && x.n == i) continue;
            mp[t][i] ++;
            if (check()) ans[x.hash()].insert({t,i});
            mp[t][i] --;
        }
    }
 
    // z
    for (int i = 1;i <= 7;i ++) {
        if (x.type == ZI && x.n == i) continue;
        mp[ZI][i] ++;
        if (check()) ans[x.hash()].insert({ZI,i});
        mp[ZI][i] --;
    }
}

inline int getNum(int i) {
    return i % 9 ? i % 9 : 9;
}

inline char getType(int i)
{
    return n2c[(i - 1) / 9];
}
 
int main()
{
    char str[35];
    int t;
    int cc;
    int k;
    __T {
        scanf("%s",str);
        memset(mp,0,sizeof(mp));
        rep(i,1,40) ans[i].clear();
        cc = 1;
        for (int i = 0;str[i];i ++) {
            if (i & 1) {
                cards[cc].n = t;
                if (str[i] == 's') {
                    mp[SUO][t] ++;
                    cards[cc].type = SUO;
                } else if (str[i] == 'b') {
                    mp[BING][t] ++;
                    cards[cc].type = BING;
                } else if (str[i] == 'w') {
                    mp[WAN][t] ++;
                    cards[cc].type = WAN;
                } else if (str[i] == 'z') {
                    mp[ZI][t] ++;
                    cards[cc].type = ZI;
                }
                cc ++;
            } else {
                t = str[i] ^ 48;
            }
        }
        if (check()) {
            puts("Tsumo!");
            continue;
        }
 
        // 找牌进行丢卡
        for (int i = 1;i <= 14;i ++) {
            if (cards[i] == cards[i - 1]) continue;
            t = cards[i].type;
            mp[t][cards[i].n] --;
            add(cards[i]);
            mp[t][cards[i].n] ++;
        }
        
        k = 0;
        for (int i = 1;i <= 40;i ++) {
            if (ans[i].size() != 0) k ++;
        }
        
        printf("%d\n",k);
        for (int i = 1;i <= 40;i ++) {
            if (!ans[i].size()) continue;
            printf("%d%c ",getNum(i),getType(i));
            for (auto jt = ans[i].begin();jt != ans[i].end();jt ++) {
                printf("%d%c",jt -> n,n2c[jt -> type]);
            }
            puts("");
        }
    }
}
*/


/*
const double eps = 1e-8;

int sign(double x)
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}

struct Point
{
    double x,y;
    Point() {}
    Point(double _x,double _y):x(_x),y(_y) {}
    Point(const Point &o):x(o.x),y(o.y) {}
    
    Point operator-(const Point &b) const
    {
        return Point(x - b.x,y - b.y);
    }
    
    // 叉积
    double operator^(const Point &b) const
    {
        return x * b.y - y * b.x;
    }
    
    // 点积
    double operator*(const Point &b) const
    {
        return x * b.x + y * b.y;
    }
    
    // 变成单位向量
    void identity() {
        double k = sqrt(x * x + y * y);
        x /= k;
        y /= k;
    }
    
    // 绕原点旋转角度B（弧度值），后x,y的变化
    void transXY(double B)
    {
        double tx = x,ty = y;
        x = tx * cos(B) - ty * sin(B);
        y = tx * sin(B) + ty * cos(B);
    }
};


struct Line
{
    Point s,e;
    Line() {}
    Line(Point _s,Point _e):s(_s),e(_e) {}
    
    // 两直线相交求交点
    // 第一个值为0表示直线重合，为1表示平行，为0表示相交,为2是相交
    // 只有第一个值为2时，交点才有意义
    pair<int,Point> operator &(const Line &b) const
    {
        Point res = s;
        if (sign((s - e) ^ (b.s - b.e)) == 0)
        {
            if (sign((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(0,res); // 重合
            else return make_pair(1,res); // 平行
        }
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));
        res.x += (e.x-s.x) * t;
        res.y += (e.y-s.y) * t;
        return make_pair(2,res);
    }
};

// *两点间距离
double dis(Point a,Point b)
{
    return sqrt((a - b) * (a - b));
}

// *判断线段相交
bool inter(Line a,Line b)
{
    return max(a.s.x,a.e.x) >= min(b.s.x,b.e.x) &&
        max(b.s.x,b.e.x) >= min(a.s.x,a.e.x) &&
        max(a.s.y,a.e.y) >= min(b.s.y,b.e.y) &&
        max(b.s.y,b.e.y) >= min(a.s.y,a.e.y) &&
        sign((b.s - a.e) ^ (a.s - a.e)) * sign((b.e - a.e) ^ (a.s - a.e)) <= 0 &&
        sign((a.s - b.e) ^ (b.s - b.e)) * sign((a.e - b.e) ^ (b.s - b.e)) <= 0;
}

// 判断直线和线段相交
bool isLineAcrossSegment(Line a,Line b) // 判断直线a和线段b是否相交
{
    return sign((b.s - a.e) ^ (a.s - a.e)) * sign((b.e - a.e) ^ (a.s - a.e)) <= 0;
}

// 点到直线距离
// 返回为result,是点到直线最近的点
Point pointToLine(Point P,Line L)
{
    Point result;
    double t = ((P - L.s) * (L.e - L.s)) / ((L.e - L.s) * (L.e - L.s));
    result.x = L.s.x + (L.e.x - L.s.x) * t;
    result.y = L.s.y + (L.e.y - L.s.y) * t;
    return result;
}

// 点到线段的距离
// 返回点到线段最近的点
Point nearestPointToLineSeg(Point P,Line L)
{
    Point result;
    double t = ((P - L.s) * (L.e - L.s)) / ((L.e - L.s) * (L.e - L.s));
    if (t >= 0 && t <= 1)
    {
        result.x = L.s.x + (L.e.x - L.s.x) * t;
        result.y = L.s.y + (L.e.y - L.s.y) * t;
    } else {
        if (dis(P,L.s) < dis(P,L.e))
            result = L.s;
        else result = L.e;
    }
    return result;
}

// 计算多边形面积
// 点的编号从0~n-1
double calcArea(Point p[],int n)
{
    double res = 0;
    for (int i = 0;i < n;i++)
        res += (p[i] ^ p[(i + 1) % n]) / 2;
    return fabs(res);
}

// *判断点在线段上
bool isOnSeg(Point P,Line L)
{
    return sign((L.s - P) ^ (L.e - P)) == 0 &&
        sign((P.x - L.s.x) * (P.x - L.e.x)) <= 0 &&
        sign((P.y - L.s.y) * (P.y - L.e.y)) <= 0;
}

vector<Point> a[1010];
 
Point s,t,all[1010];
 
bool cmp(const Point &a,const Point &b) {
    return dis(a,s) < dis(b,s);
}
 
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
 
    scanf("%lf%lf%lf%lf",&s.x,&s.y,&t.x,&t.y);
    rep(i,1,n) {
        scanf("%lf%lf",&all[i].x,&all[i].y);
    }
    Line l;
    Line st(s,t);
    pair<int,Point> pr;
    rep(i,1,n) {
        rep(j,1,n) {
            if (i == j) continue;
            l = Line(all[i],all[j]);
            if (isLineAcrossSegment(l,st)) {
                pr = l & st;
                if (pr.first == 2) a[i].pb(pr.second);
            }
        }
    }
    rep(i,1,n) {
        sort(a[i].begin(),a[i].end(),cmp);
    }
    int h,k;
    while (m --) {
        scanf("%d%d",&h,&k);
        if (a[h].size() < k) puts("-1");
        else {
            printf("%.10f %.10f\n",a[h][k - 1].x,a[h][k - 1].y);
        }
    }
}
*/

/*
template <typename _Tp> inline void read(_Tp&x) {
    char ch;x=0;
    ch=getchar();
    while(!isdigit(ch)){ch=getchar();}
    while(isdigit(ch)){ch=getchar();}
    ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
}


int main()
{
    int n;
    double ans;
    int t;
    while (~scanf("%d",&n)) {
        ans = 0;
        rep(i,1,n) {
            read(t);
            if (t % 10 >= 5) ans += 10 - t % 10;
            else ans -= t % 10;
        }
        printf("%.3f\n",ans / 1000.0);
    }
}
*/

/*
int a[1010],b[1010];

int main()
{
    int n,m;
    int ok;
    int ter;
    int aa,bb;
    while (~scanf("%d%d",&n,&m)) {
        rep(i,1,n) sci(a[i]);
        rep(i,1,m) sci(b[i]);
        sort(a + 1,a + 1 + n);
        sort(b + 1,b + 1 + m);
        ter = max(a[n],b[m]) + 1;
        
        rep(t,0,ter) {
            ok = 1;
            for (int i = 1,j = 1;i <= n && j <= m;) {
                aa = a[i];
                bb = b[j] + t;
                if (aa == bb) {
                    ok = 0;
                    break;
                }
                if (aa < bb) {
                    i ++;
                } else {
                    j ++;
                }
            }
            if (ok) {
                printf("%d\n",t);
                break;
            }
        }
        
    }
}
*/

//const int mod = 1000000007;
//
//ll quickpow(ll a, ll b)
//{
//    ll ans = 1;
//    while (b)
//    {
//        if (b & 1) ans = a * ans % mod;
//        a = a * a % mod;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int main()
//{
//    ll n;
//    ll ans;
//    ll t;
//    while (~scl(n)) {
//        ans = 0;
//        for (ll r1 = 1;r1 <= n;r1 ++) {
//            t = r1 * r1 % mod;
//            t *= n - r1 + 1;
//            t %= mod;
//            ans += quickpow(t, mod - 2);
//            ans %= mod;
//        }
//        printf("%lld\n",ans);
//    }
//}

//struct Node {
//    int l,r;
//} k[1000];
//
//
//int main()
//{
//    _C(3 * quickpow(4, mod - 2))
//    rep(n,1,10) {
//        int cnt = 0;
//        rep(r,1,n) {
//            rep(l,1,r) {
//                k[++ cnt] = {l, r};
//            }
//        }
//        int ok = 0;
//        rep(i,1,cnt) {
//            rep(j,1,cnt) {
//                if (k[j].l >= k[i].l && k[j].l <= k[i].r) ok ++;
//                else if (k[j].r >= k[i].l && k[j].r <= k[i].r) ok ++;
//                else if (k[i].l >= k[j].l && k[i].r <= k[j].r) ok ++;
//            }
//        }
//        _C(ok << " " << cnt * cnt)
//    }
//
//}


/*
const ll mod = 1000000007;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll n;
    while (~scl(n)) {
        printf("%lld\n",(n+1) * quickpow(n * 2, mod - 2) % mod);
    }
}
*/

/*
int main()
{
    string str;
    ll ans;
    ll t;
    char last;
    __T
    {
        cin >> str;
        ans = 0;
        t = 0;
        last = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] != last) {
                ans += (1 + t) * t / 2;
                t = 1;
            } else t ++;
            last = str[i];
        }
        ans += (1 + t) * t / 2;
        printf("%lld\n",ans);
    }
}
*/

/*
int main()
{
    ll n;
    ll ans;
    __T {
        scl(n);
        ans = 1;
        for (ll k = 1;k <= 12;k ++) {
            ans *= k;
            if (ans % n == 0) {
                printf("%lld\n",k);
                break;
            }
        }
    }
}
*/

/*
char str[1010];

struct Node {
    string str;
    int n;
    int type; // 0 - str,1 - num
};

int main()
{
    list<string> ans;
    stack<Node> st;
    string tmp,k;
    Node a;
    __T {
        scanf("%s",str);
        tmp = "";
        
        for (int i = 0;str[i];i ++) {
            if (str[i] == ']') {
                // calc
                st.push({tmp,0,0});
                k = tmp = "";
                while (st.top().type == 0) {
                    k = st.top().str + k;
                    st.pop();
                }
                
                a = st.top();
                st.pop();
                rep(i,1,a.n) {
                    tmp += k;
                }
                st.push({tmp,0,0});
                tmp = "";
            } else if (str[i] >= '0' && str[i] <= '9') {
                st.push({tmp,0,0});
                tmp = "";
                st.push({"",str[i] ^ 48,1});
            } else if (str[i] != '[') {
                tmp += str[i];
            }
        }
        st.push({tmp,0,0});
        
        tmp = "";
        while (!st.empty()) {
            a = st.top();
            st.pop();
            tmp = a.str + tmp;
        }
        cout << tmp << endl;
    }
}
*/

/*
struct Node {
    int num;
    Node *pre;
    Node *nxt;
};

Node *all[100010];

inline void init(int n) {
    rep(i,1,n) {
        all[i] -> num = i;
        all[i] -> pre = all[i - 1];
        all[i] -> nxt = all[i + 1];
    }
    all[1] -> pre = NULL;
    all[n] -> nxt = NULL;
}

int re;

Node *preNode(Node *node)
{
    if (!re) return node -> pre;
    return node -> nxt;
}

Node *nxtNode(Node *node)
{
    if (!re) return node -> nxt;
    return node -> pre;
}

void setNxtNode(Node *node,Node *value)
{
    if (node == NULL) return;
    if (!re) node -> nxt = value;
    else node -> pre = value;
}

void setPreNode(Node *node,Node *value)
{
    if (node == NULL) return;
    if (!re) node -> pre = value;
    else node -> nxt = value;
}

Node *findHead(int n)
{
    rep(i,1,n) {
        if (preNode(all[i]) == NULL)
            return all[i];
    }
    return NULL;
}

void print(int n)
{
    Node *node = findHead(n);
    while (node != NULL) {
        printf("%d ",node -> num);
        node = nxtNode(node);
    }
    puts("");
}

ll getAns(int n)
{
    ll ans = 0;
    Node *node = findHead(n);
    int i = 1;
    while (node != NULL) {
        if (i & 1) ans += node -> num;
        node = nxtNode(node);
        i ++;
    }
    return ans;
}


int main()
{
    rep(i,1,100000) {
        all[i] = new Node();
    }
    
    int n,m;
    int t,aa = 0,bb = 0;
    Node *a = NULL,*b = NULL,*c = NULL,*d = NULL,*e = NULL,*f = NULL;
    
    
    while (~scanf("%d%d",&n,&m)) {
        init(n);
        re = 0;
        
        while (m --) {
//            print(n);
            scanf("%d",&t);
            if (t != 4) {
                scanf("%d%d",&aa,&bb);
            }
            
            if (t == 1) {
                b = all[aa];
                e = all[bb];
                a = preNode(b);
                c = nxtNode(b);
                
                d = preNode(e);
                
                if (b == d) continue;
                
                setNxtNode(a, c);
                setPreNode(c, a);
                setNxtNode(d, b);
                
                setPreNode(b, d);
                setNxtNode(b, e);
                setPreNode(e, b);
                
            } else if (t == 2) {
                b = all[aa];
                e = all[bb];
                a = preNode(b);
                c = nxtNode(b);
                
                d = preNode(e);
                f = nxtNode(e);
                
                if (b == f) continue;
                setNxtNode(a, c);
                setPreNode(c, a);
                
                setNxtNode(b, f);
                setPreNode(b, e);
                setNxtNode(e, b);
                setPreNode(f, b);
                
                
            } else if (t == 3) {
                swap(all[aa] -> num,all[bb] -> num);
                swap(all[aa],all[bb]);
            } if (t == 4) {
                re ^= 1;
            }
        }
        printf("%lld\n",getAns(n));
    }
}
*/

/*
int main()
{
    string str;
    char c;
    while (getline(cin, str)) {
        if (str == "I quacked the code!") {
            
            break;
        }
        c = str[str.size() - 1];
        if (c == '?') {
            printf("Quack!\n");
        } else if (c == '.') {
            printf("*Nod*\n");
        }
    }
    return 0;
}
*/

/*
ll a[100010];
int t[20];

int main()
{
    int n,m;
    ll time;
    __T {
        scii(m,n);
        rep(i,1,m) {
            scl(a[i]);
        }
        sort(a + 1,a + 1 + m);
        
        time = 0;
        rep(i,1,n) {
            sci(t[i]);
        }
        sort(t + 1,t + 1 + n);
        for (int i = 1,j = 1;i <= m;i ++) {
            t[j] --;
            time += 20;
            if (t[j] == 0) {
                j ++;
                time -= 20;
                time += a[i];
            }
        }
        printf("Case %d: %lld\n",T,time);
    }
}
*/

/*
double getAns(double a1,double b1,double a2,double b2)
{
    if (b1 > b2) return a2 * fabs(b1 - b2) / 2;
    return a1 * fabs(b1 - b2) / 2;
}

int main() {
    double a1,b1,a2,b2;
    double ans;
    __T {
        scdd(a1,b1);
        scdd(a2,b2);
        ans = getAns(a1,b1,a2,b2);
        ans = min(ans,getAns(b1, a1, a2, b2));
        ans = min(ans,getAns(a1, b1, b2, a2));
        ans = min(ans,getAns(b1, a1, b2, a2));
        
        ans = min(ans,getAns(a2,b2,a1,b1));
        ans = min(ans,getAns(b2, a2, a1, b1));
        ans = min(ans,getAns(a2, b2, b1, a1));
        ans = min(ans,getAns(b2, a2, b1, a1));
        
        printf("Case %d: %.1f\n",T,ans + a1 * b1 + a2 * b2);
    }
}
*/

/*
const int MAXN = 1e6 + 10;

struct Edge {
    int to;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v)
{
    e[cnt] = {v,g[u]};
    g[u] = cnt ++;
}

int vis[MAXN];
int lost = -1;

void dfs(int u)
{
    if (u == lost) return;
    if (vis[u]) return;
    vis[u] = 1;
    for (int i = g[u];~i;i = e[i].nxt) {
        dfs(e[i].to);
    }
}

int main()
{
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    init(n + 5);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        add_edge(u, v);
        add_edge(v, u);
    }
    int cnt;
    while (k --) {
        scanf("%d",&u);
        lost = u;
        cnt = 0;
        for (int i = 1;i <= n;i ++) vis[i] = 0;
        rep(i,1,n) {
            if (i == lost) continue;
            if (!vis[i]) {
                cnt ++;
                dfs(i);
            }
        }
        printf("%d\n",cnt - 1);
    }
}

*/

/*
int a[45];

int main()
{
    int n;
    scanf("%d",&n);
    rep(i,1,n) {
        scanf("%d",a + i);
    }
    sort(a + 1,a + 1 + n);
    ll x = 1ll << n;
    double ans = 0;
    rep(i,1,n) {
        ans += (double) a[i] / x;
        x >>= 1;
    }
    printf("%.10f\n",ans);
}
*/

/*
int main()
{
    int w,h;
    scii(w,h);
    double k = sqrt(w * w + h * h);
    printf("%.10f\n",w + h - k);
}
*/

//ll toLL(vector<int> &vec) {
//    ll ans = 0;
//    pre(j,(int) vec.size() - 1,0) {
//        ans *= 10;
//        ans += vec[j];
//    }
//    return ans;
//}
//
//int main()
//{
//    int n;
//    scanf("%d",&n);
//    ll a[10000];
//    rep(i,1,n) {
//        scanf("%lld",a + i);
//    }
//    vector<int> sep;
//    vector<int> last;
//
//    int len = 0;
//    ll t;
//    int ok = -1;
//    int k;
//    rep(i,1,n) {
//        t = a[i];
//        sep.clear();
//        ok = k = 0;
//        while (t) {
//            sep.pb(t % 10);
//            t /= 10;
//            k ++;
//        }
//        pre(j,(int)sep.size() - 1,0) {
//            if (sep[j] == 9) sep[j] = 6;
//        }
//
//        if (k > len) ok = 1;
//        if (k < len) ok = -1;
//        if (k == len) {
//            pre(j,(int) sep.size() - 1,0) {
//                if (sep[j] > last[j]) {
//                    ok = 1;
//                    break;
//                }
//                if (sep[j] != 6) {
//                    if ()
//                }
//            }
//        }
//
//        if (ok == -1) {
//            break;
//        }
//
//        last = vector<int>(sep);
//        len = k;
//    }
//    if (ok == -1) printf("impossible\n");
//    else {
//        puts("possible");
//        rep(i,1,n) {
//            printf("%lld\n",a[i]);
//        }
//    }
//}


/*
int main()
{
    string name;
    int a,b;
    __T {
        cin >> name >> a >> b;
        if (a < 15 || a > 20 || b > 70 || b < 50) _C(name)
    }
}
*/

/*
int main()
{
    int a,b;
    int cnta = 0,cntb = 0;
    scanf("%d%d",&a,&b);
    int ahan,a_hua,bhan,b_hua;
    int aa,bb;
    __T {
        scanf("%d%d%d%d",&ahan,&a_hua,&bhan,&b_hua);
        aa = 0;
        bb = 0;
        if (a_hua == ahan + bhan) aa = 1;
        if (b_hua == ahan + bhan) bb = 1;
        if ((aa && bb) || (!aa && !bb)) continue;
        if (aa) cnta ++;
        if (bb) cntb ++;
        if (cnta == a + 1) {
            printf("A\n%d\n",cntb);
            break;
        }
        if (cntb == 1 + b) {
            printf("B\n%d\n",cnta);
            break;
        }
    }
}
*/

/*
int cnt[10];

int ok(char *str,int &n) {
    rep(i,0,9) cnt[i] = 0;
    rep(i,0,3) {
        cnt[str[i]^48] ++;
    }
    int cc = 0;
    rep(i,0,9) if (cnt[i]) cc ++;
    return n == cc;
}

int main()
{
    int y,n;
    int k = 0;
    scanf("%d%d",&y,&n);
    char str[5];
    do {
        sprintf(str,"%04d",y);
        y ++;
        k ++;
    } while (!ok(str,n));
    printf("%d %s\n",k - 1,str);
}
*/

/*
int main()
{
    double w,h;
    scanf("%lf%lf",&w,&h);
    double ans = w / (h * h);
    printf("%.1f\n",ans);
    if (ans > 25) puts("PANG");
    else puts("Hai Xing");
}
*/

/*
int id[100000];
int vis[100000];

int main()
{
    int n;
    scanf("%d",&n);
    int k;
    int t;
    set<int> st;
    rep(i,1,n) {
        scanf("%d",&k);
        st.clear();
        rep(j,1,k) {
            scanf("%d",&t);
            st.insert(t);
        }
        if (st.size() > 1) {
            for (auto x : st) {
                id[x] ++;
            }
            
        }
    }
    int m;
    scanf("%d",&m);
    int f = 1;
    int cnt = 0;
    while (m --) {
        scanf("%d",&t);
        if (vis[t]) continue;
        vis[t] = 1;
        if (!id[t]) {
            if (f) f = 0;
            else printf(" ");
            printf("%05d",t);
            cnt ++;
        }
    }
    if (cnt == 0) printf("No one is handsome");
    puts("");
}
*/

/*
int main()
{
    int n;
    char a;
    scanf("%d %c ",&n,&a);
    string str;
    getline(cin, str);
    if (n >= str.size()) {
        ulong k = n - str.size();
        rep(i,1,k) printf("%c",a);
        _C(str)
    } else _C(str.substr(str.size() - n))
    
}
*/

/*
const int MAXN = 510;

vector<int> g[MAXN];

int vis[MAXN];
int die[MAXN];

void dfs(int u)
{
    if (vis[u] || die[u]) return;
    vis[u] = 1;
    for (auto i : g[u]) {
        if (die[i] || vis[i]) continue;
        dfs(i);
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    while (m --) {
        scanf("%d%d",&u,&v);
        g[u].pb(v);
        g[v].pb(u);
    }
    int k;
    scanf("%d",&k);
    
    int t;
    int cnt,org;
    rep(i,1,k) {
        scanf("%d",&t);
        
        memset(vis,0,sizeof vis);
        org = 0;
        rep(i,0,n-1) {
            if (!(vis[i] || die[i])) {
                dfs(i);
                org ++;
            }
        }
        
        die[t] = 1;
        
        memset(vis,0,sizeof vis);
        cnt = 0;
        rep(i,0,n-1) {
            if (!(vis[i] || die[i])) {
                dfs(i);
                cnt ++;
            }
        }
        if (cnt > org) {
            printf("Red Alert: ");
        }
        printf("City %d is lost",t);
        if (cnt > org) {
            puts("!");
        } else puts(".");
    }
    if (k == n) puts("Game Over.");
}
*/

/*
int tree[1 << 21];

int main()
{
    int n;
    scanf("%d",&n);
    int num;
    sci(num);
    tree[1] = num;
    int k;
    rep(i,1,n-1) {
        scanf("%d",&num);
        k = 1;
        while (1)
        {
            if (num > tree[k]) {
                if (tree[k << 1]) k <<= 1;
                else {
                    tree[k << 1] = num;
                    break;
                }
            } else {
                if (tree[k << 1 | 1]) k = k << 1 | 1;
                else {
                    tree[k << 1 | 1] = num;
                    break;
                }
            }
        }
    }
    queue<int> q;
    q.push(1);
    int f = 1;
    int node;
    while (!q.empty()) {
        node = q.front();
        q.pop();
        if (!f) printf(" ");
        else f = 0;
        printf("%d",tree[node]);
        if (tree[node << 1]) q.push(node << 1);
        if (tree[node << 1|1]) q.push(node << 1|1);
    }
    puts("");
    int ok = 1;
    rep(i,1,n) {
        if (!tree[i]) {
            ok = 0;
            break;
        }
    }
    puts(ok ? "YES" : "NO");
    
}
*/

/*
const int MAXN = 510;

vector<int> g[MAXN];

int vis[MAXN];
int col[MAXN];

int ok = 1;

void dfs(int u)
{
    if (!ok) return;
    if (vis[u]) return;
    vis[u] = 1;
    for (auto i : g[u]) {
        if (col[u] == col[i]) {
//            _C(u << " " << i)
            ok = 0;
            return;
        }
        dfs(i);
    }
}

int main()
{
    int n,m,k;
    sciii(n,m,k);
    int u,v;
    while (m --) {
        scii(u,v);
        g[u].pb(v);
        g[v].pb(u);
    }
    int q;
    sci(q);
    set<int> st;
    while (q --) {
        st.clear();
        rep(i,1,n) {
            scanf("%d",col + i);
            st.insert(col[i]);
            vis[i] = 0;
        }
        ok = 1;
        if (st.size() != k) ok = 0;
        rep(i,1,n)
            dfs(i);
        puts(ok ? "Yes" : "No");
    }
}
*/

/*
const int MAXN = 1e5 + 10;

vector<int> g[MAXN];
int vis[MAXN];

double r;

double d[MAXN];
double ans = 0;

void dfs(int u,double from)
{
    if (vis[u]) return;
    vis[u] = 1;

    ans += d[u] * from;
    for (auto i : g[u]) {
        dfs(i,from * (1 - r / 100));
    }
}

int main()
{
    int n;
    double val;
    scanf("%d%lf%lf",&n,&val,&r);
    
    int k;
    int v;
    double t;
    rep(i,0,n-1) {
        scanf("%d",&k);
        if (k == 0) {
            scanf("%lf",&t);
            d[i] = t;
        }
        else
            rep(j,1,k) {
                scanf("%d",&v);
                g[i].pb(v);
            }
    }
    dfs(0,val);
    printf("%.0f\n",floor(ans));
}

*/

//const int MAXN = 1e4 + 10;
//
//ull hs[510][MAXN]; // 哈希数组，定义成ull自动取模
//ull bin[MAXN]; // 记录p的次方数
//const int p = 131; // 进制数
//
//char str[510][MAXN]; // 字符串
//
//void getHash(int j) // str是从0开始的下标
//{
//    bin[0] = 1;
//    for (int i = 1;str[j][i - 1];i ++) {
//        hs[j][i] = hs[j][i - 1] * p + str[j][i - 1] - 'a'; // 算哈希值，把他当一个大数字来看待
//        bin[i] = bin[i - 1] * p; // 计算p的次方数
//    }
//}
//
//ull getSub(int j,int l,int r) // 获取其中的一段subString的哈希值hash[l...r]，l和r均为从1开始的下标
//{
//    return hs[j][r] - hs[j][l - 1] * bin[r - l + 1];
//}
//
//int main()
//{
//    int n,len;
//    scanf("%d%d",&n,&len);
//    rep(i,1,n) {
//        scanf("%s",str[i]);
//        getHash(i);
//    }
//    set<ull> s;
//    int st = 1;
//    rep(i,1,len) {
//        s.clear();
//        rep(j,1,n) {
//            s.insert(getSub(j, st, i));
//        }
//
//    }
//}

/*
int main()
{
    int n1,n2;
    char op;
    scanf("a+%d%c%d",&n1,&op,&n2);
    int X = (1ll << 31ll) - 1;
    if (op == '>') {
        _C(X - n2)
    } else {
        _C(-((ll)(X + 1) - n2))
    }
}
*/

/*
/// 网络流-最大流模板 Dinic算法 前向星
/// https://www.luogu.com.cn/problem/P3376
const int MAXN = 500010;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN << 1];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memset(g, -1, sizeof(int) * n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}

int s,t,n,m;
int dis[MAXN];
int cur[MAXN]; // 替代g数组，记住上次dfs最后跑到的地方，优化，减少dfs的跑的次数

int bfs()
{
    memset(dis, -1, sizeof(int) * (n + 5));

    queue<int> q;
    q.push(s);
    dis[s] = 0;

    int to,current,k;

    while (!q.empty()) {
        current = q.front();
        q.pop();

        for (int i = g[current];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current] + 1;
            if (dis[to] == -1 && e[i].w > 0) { // 只有没有访问过的，且该通路可以走(w > 0)
                dis[to] = k;
                if (to == t) return 1;
                q.push(to);
            }
        }
    }

    return 0;
}

ll dfs(int node,ll flow)
{
    if (node == t) return flow;
    int to;
    ll d;
    for (int &i = cur[node];~i;i = e[i].nxt) { // 改变i的同时，cur[node]的值也会被改变
        to = e[i].to;
        if (dis[node] + 1 == dis[to] && e[i].w > 0) {
            d = dfs(to,min(e[i].w,flow));
            if (d > 0) {
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}

ll dinic()
{
    ll ans = 0;
    ll d;
    while (bfs()) {
        rep(i,1,n) cur[i] = g[i];
        while ((d = dfs(s,INT_INF)))
            ans += d;
    }
    return ans;
}

int main()
{
    int cnt;
    scanf("%d",&cnt);
    s = 1;
    n = 1;
    string str;
    int k;
    init(cnt * 2 + 10);
    rep(i,1,cnt) {
        n ++;
        add_edge(1, n, 1);
        add_edge(n, 1, 0);
//        _C("add:" << 1 << " " << n)
    }
//    _C("222")
    rep(i,1,cnt) {
        scanf("%d",&k);
        n ++;
        set<char> st;
        rep(j,1,k) {
            cin >> str;
            if (st.find(str[0]) != st.end()) continue;
            st.insert(str[0]);
            if (str[0] - 'a' + 1 > cnt) continue;
            add_edge(str[0] - 'a' + 2, n, 1);
            add_edge(n, str[0] - 'a' + 2, 0);
            
//            _C("add:" << str[0] - 'a' + 2 << " " << n)
        }
    }
    n ++;
    rep(i,cnt+2,n-1) {
        add_edge(i, n, 1);
        add_edge(n, i, 0);
//        _C("add:" << i << " " << n)
    }
    t = n;
//    _C(111)
    puts(dinic() == cnt ? "Yes" : "No");
    return 0;
}
*/

/*
ll a[100010];

int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    int cnt = 0;
    rep(i,1,n) scanf("%lld",a + i);
    rep(i,1,n)
    {
        if (i != 1) {
            if (abs(a[i] - a[i - 1]) < k) {
                a[i] = 1e18;
                cnt ++;
            }
        }
    }
    _C(cnt)
}
*/

/*
int main()
{
    string s,t;
    int cnt;
    __T {
        cin >> s >> t;
        cnt = 0;
        if (t.size() != s.size() - 2) {
            puts("0");
            continue;
        }
        for (int i = 0,j = 0;s[i];i ++) {
            if (j >= t.size()) {
                cnt ++;
                continue;
            }
            if (s[i] == t[j]) j ++;
            else {
                cnt ++;
            }
        }
        printf("%d\n",cnt == 2);
    }
}
*/

/*
int main()
{
    ll n;
    int cnt;
    __T {
        scanf("%lld",&n);
        cnt = 0;
        if (n % 17 == 0) cnt ++;
        if (n % 18 == 0) cnt ++;
        _C(cnt)
    }
}
*/

/*
int judge(int *a) {
    if (a[1] == 1 && a[2] == 2 && a[3] == 3 && a[4] == 4) return 1;
    if (a[1] == 2 && a[2] == 3 && a[3] == 4 && a[4] == 1) return 1;
    if (a[1] == 3 && a[2] == 4 && a[3] == 1 && a[4] == 2) return 1;
    if (a[1] == 4 && a[2] == 1 && a[3] == 2 && a[4] == 3) return 1;
    reutnr 0;
}

int s(int *a,int i,int j)
{
    int ok = 0;
    swap(a[i],a[j]);
    if (judge(a)) ok = 1;
    swap(a[i],a[j]);
    return ok;
}

int main()
{
    int a[10];
    rep(i,1,4) {
        scanf("%d",a + i);
    }
    if (judge(a)) {
        puts("0");
        return 0;
    }
    int ok = 0;
    ok |= s(a,1,2);
    ok |= s(a,1,4);
    ok |= s(a,2,3);
    ok |= s(a,3,4);
    puts(ok ? "1" : "2");
}
*/

/*
int main()
{
    ll x;
    scl(x);
    int i;
    ll k = 2;
    for (i = 3;k <= x;i ++,k += k / 2);
    _C(i-1)
}
*/

/*
int main()
{
    ll n;
    ll k;
    scanf("%lld%lld",&n,&k);
    k ++;
    int p = 1;
    for (ll i = 2;i * i <= k;i ++) {
        if (k % i == 0) {
            p = 0;
            break;
        }
    }
    
    puts(p && k * 2 > n + 1 ? "1" : "2");
}
*/

/*
const int MAXN = 2e5 + 10;

struct Edge {
    int to;
    ll w;
    int nxt;
} e[MAXN * 2];
int g[MAXN]; // Please call init() to memset it to -1!
int cnt = 0;

void init(int n)
{
    cnt = 0;
    memn(g,-1,int,n);
}

void add_edge(int u,int v,ll w)
{
    e[cnt] = {v,w,g[u]};
    g[u] = cnt ++;
}


ll dis[MAXN];
int vis[MAXN];

struct Node {
    int n;
    ll w;

    bool operator< (const Node &other) const {
        return w > other.w;
    }
};

void dij(int s) {
    mem(dis,-1);
    mem(vis,0);

    priority_queue<Node> q;
    q.push({s,dis[s] = 0});

    Node current;
    ll k;
    int to;
    while (!q.empty()) {
        current = q.top();
        q.pop();
        if (vis[current.n]) continue;
        vis[current.n] = 1;

        for (int i = g[current.n];~i;i = e[i].nxt) {
            to = e[i].to;
            k = dis[current.n] + e[i].w;
            if (dis[to] == -1 || dis[to] > k) {
                q.push({to,dis[to] = k});
            }
        }
    }
}

ll height[MAXN];

int main()
{
    int n,m;
    ll k;
    scanf("%d%d%lld",&n,&m,&k);
    rep(i,1,n) {
        scanf("%lld",height + i);
    }
    int u,v;
    ll w;
    ll x;
    init(n + 5);
    while (m --) {
        scanf("%d%d%lld",&u,&v,&w);
        x = w;
        if (height[v] - height[1] > k) {
            x += (height[v] - height[1] - k) * (height[v] - height[1] - k);
        }
        add_edge(u, v, x);
        
        x = w;
        if (height[u] - height[1] > k) {
            x += (height[u] - height[1] - k) * (height[u] - height[1] - k);
        }
        add_edge(v, u, x);
    }
    dij(1);
    
    printf("%lld\n",dis[n]);
    return 0;
}
*/


//const int MAXN = 6e3 + 10;
//
//struct Node {
//    int i;
//    string str;
//} a[MAXN];
//
//int cmp(const Node &a,const Node &b) {
//    if (a.str.size() == b.str.size()) {
//        return a.str > b.str;
//    }
//    return a.str.size() > b.str.size();
//}
//
//int main()
//{
//    int n;
//    __T {
//        scanf("%d",&n);
//        rep(i,1,n) {
//            cin >> a[i].str;
//            a[i].i = i;
//        }
//        sort(a + 1,a + 1 + n,cmp);
//        printf("Case #%d: ",T);
//        if (a[1].i > a[2].i) swap(a[1],a[2]);
//        _C(a[1].str << a[2].str);
//    }
//}

/*
const int MAXN = 1e5 + 10;

int indoor[MAXN];
int outdoor[MAXN];

int main()
{
    int n,m,t,k;
    scanf("%d%d%d%d",&n,&m,&t,&k);
    rep(i,1,n) scanf("%d",indoor + i);
    rep(i,1,m) scanf("%d",outdoor + i);
    priority_queue<double> in,out;
    rep(i,1,n) in.push(indoor[i]);
    rep(i,1,m) out.push(outdoor[i]);
    double ti,to;
    k = t - k;
    double ans = 0;
    rep(i,1,t) {
        ti = in.top();
        to = out.top();
        if (to >= ti) {
            if (k > 0) {
                out.pop();
                out.push(to * 0.6);
                ans += to;
                k --;
            } else {
                if (to * 0.8 >= ti) {
                    out.pop();
                    out.push(to * 0.6);
                    ans += to * 0.8;
                } else {
                    in.pop();
                    in.push(ti * 0.6);
                    ans += ti;
                }
            }
        } else {
            in.pop();
            in.push(ti * 0.6);
            ans += ti;
        }
    }
    printf("%.2f\n",ans);
}
*/

//const int mod = 1e9 + 7;
//
//class Matrix
//{
//    const static int MAXN = 10;
//
//    ll a[MAXN][MAXN];
//
//public:
//    int w;
//    int h;
//
//    Matrix(int h,int w):w(w),h(h)
//    {
//        mem(a,0);
//    }
//
//    Matrix(const char format[], ...) {
//
//        va_list args;
//        w = 0;
//        h = 0;
//
//        char buf[1000];
//
//        va_start(args, format);
//        vsprintf(buf, format, args);
//        va_end(args);
//
//        stringstream ss(buf);
//        stringstream num;
//        ll n;
//        string line;
//        while (getline(ss, line)) {
//            num.clear();
//            num << line;
//            w = 0;
//            while (num >> n) {
//                a[h + 1][++ w] = n;
//            }
//            h ++;
//        }
//    }
//
//    void E()
//    {
//        if (w == h) {
//            mem(a,0);
//            rep(i,1,w) a[i][i] = 1;
//        }
//    }
//
//    void print()
//    {
//        int f = 1;
//        rep(i,1,h) {
//            f = 1;
//            rep(j,1,w) {
//                if (f) f = 0;
//                else printf(" ");
//                printf("%lld",a[i][j]);
//            }
//            puts("");
//        }
//    }
//
//    void read_in()
//    {
//        rep(i,1,h) {
//            rep(j,1,w) {
//                scanf("%lld",&a[i][j]);
//            }
//        }
//    }
//
//    Matrix operator* (const Matrix &B) const
//    {
//        if (w != B.h) return Matrix(0,0); // invalid
//
//        Matrix ans(h,B.w);
//        rep(i,1,h) {
//            rep(j,1,B.w) {
//                rep(k,1,w) {
////                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j]); // Not Moduled
//                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j] % mod) % mod; // Moduled
//                }
//            }
//        }
//        return ans;
//    }
//
//    const ll* operator[] (int i) const {
//        return a[i];
//    }
//
//    ll* operator[] (int i) {
//        return a[i];
//    }
//};
//
//Matrix quickpow(Matrix a, ll b)
//{
//    if (a.h != a.w) return Matrix(0,0); // invalid
//
//    Matrix ans(a.h,a.w);
//    rep(i,1,ans.h) ans[i][i] = 1; // Set ans matrix to E
//    while (b)
//    {
//        if (b & 1) ans = a * ans;
//        a = a * a;
//        b >>= 1;
//    }
//    return ans;
//}
//
//int main()
//{
//    Matrix p("5 -1\n1 0");
//    Matrix base("1\n5");
//    ll n;
//    scanf("%lld",&n);
//    printf("%lld\n",(quickpow(p, n - 2) * base)[1][1]);
//}


/*
/// 矩阵模版 快速幂
const int mod = 1e9 + 7;

class Matrix
{
    const static int MAXN = 10;

    ll a[MAXN][MAXN];

public:
    int w;
    int h;

    Matrix(int h,int w):w(w),h(h)
    {
        mem(a,0);
    }

    Matrix(const char format[], ...) {

        va_list args;
        w = 0;
        h = 0;

        char buf[1000];

        va_start(args, format);
        vsprintf(buf, format, args);
        va_end(args);

        stringstream ss(buf);
        stringstream num;
        ll n;
        string line;
        while (getline(ss, line)) {
            num.clear();
            num << line;
            w = 0;
            while (num >> n) {
                a[h + 1][++ w] = n;
            }
            h ++;
        }
    }

    void E()
    {
        if (w == h) {
            mem(a,0);
            rep(i,1,w) a[i][i] = 1;
        }
    }

    void print()
    {
        int f = 1;
        rep(i,1,h) {
            f = 1;
            rep(j,1,w) {
                if (f) f = 0;
                else printf(" ");
                printf("%lld",a[i][j]);
            }
            puts("");
        }
    }

    void read_in()
    {
        rep(i,1,h) {
            rep(j,1,w) {
                scanf("%lld",&a[i][j]);
            }
        }
    }

    Matrix operator* (const Matrix &B) const
    {
        if (w != B.h) return Matrix(0,0); // invalid

        Matrix ans(h,B.w);
        rep(i,1,h) {
            rep(j,1,B.w) {
                rep(k,1,w) {
//                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j]); // Not Moduled
                    ans[i][j] = (ans[i][j] + a[i][k] * B[k][j] % mod + mod) % mod; // Moduled
                }
            }
        }
        return ans;
    }

    const ll* operator[] (int i) const {
        return a[i];
    }

    ll* operator[] (int i) {
        return a[i];
    }
};

Matrix quickpow(Matrix a, ll b)
{
    if (a.h != a.w) return Matrix(0,0); // invalid

    Matrix ans(a.h,a.w);
    rep(i,1,ans.h) ans[i][i] = 1; // Set ans matrix to E
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

int main()
{
    Matrix p("5 -1\n1 0");
    Matrix base("1\n0");
    ll n;
    scanf("%lld",&n);
    printf("%lld\n",((quickpow(p, n - 1) * base)[1][1] * ((n * n) % mod)) % mod);
}
*/

/*
ll gcd(ll a,ll b)
{
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

int n;

const int MAXN = 1e5 + 10;

int a[MAXN]; // 原数组
ll c[MAXN]; // 求和树状数组

void modify(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

int mx[MAXN]; // 最大值数状数组

void modify_m(int i,int x)
{
    int low;
    a[i] = x; // 会直接修改数组的值
    for (;i <= n;i += lowbit(i)) {
        mx[i] = a[i];
        low = lowbit(i);
        for (int j = 1;j < low;j <<= 1) {
            mx[i] = max(mx[i], mx[i - j]);
        }
    }
}

int query_max(int l,int r)
{
    int ans = max(a[l],a[r]);
    while(true)
    {
        ans = max(ans, a[r]);
        if (l == r) break;
        r --;
        for (;r - l > lowbit(r);r -= lowbit(r))
        {
            ans = max(ans,mx[r]);
        }
    }
    return ans;
}

int main()
{
    ll x;
    double ans = -1;
    ll aa,bb,t;
    while (~scanf("%d%lld",&n,&x)) {
        rep(i,1,n) mx[i] = 0;
        rep(i,1,n) {
            scanf("%d",a + i);
            modify_m(i, a[i]);
        }
        ans = -1;
        aa = bb = 0;
        rep(i,1,n-1) {
            t = query_max(i + 1, n);
            if (ans == -1 || t / (double) a[i] > ans) {
                ans = t / (double) a[i];
                
                aa = t * x;
                bb = a[i];
            }
        }
        x = gcd(aa,bb);
        aa /= x;
        bb /= x;
        printf("%lld/%lld\n",aa,bb);
    }
}
*/

/*
const int MAXN = 5e6;
const int MAXNN = 5e7;

//主席树
int L[MAXNN],R[MAXNN],Sum[MAXNN],o[MAXN];
int TP;

void Add(int &rt,int l,int r,int x){//建立新树
    ++TP;L[TP]=L[rt];R[TP]=R[rt];Sum[TP]=Sum[rt]+1;rt=TP;//复制&新建
    if(l==r) return;
    int m=(l+r)>>1;
    if(x <= m) Add(L[rt],l,m,x);
    else  Add(R[rt],m+1,r,x);
}
int Search(int TL,int TR,int l,int r,int k){//区间查询第k大
    if(l==r) return l;//返回第k大的下标
    int m=(l+r)>>1;
    if(Sum[L[TR]]-Sum[L[TL]]>=k) return Search(L[TL],L[TR],l,m,k);
    else return Search(R[TL],R[TR],m+1,r,k-Sum[L[TR]]+Sum[L[TL]]);
}

int n,m;
int value[MAXN];

struct A{
    int x,id;
    bool operator<(const A&B)const{return x>B.x;}
}ID[MAXN];

map<int,int> MP;
int Rank[MAXN];

int main()
{
    int n,w;
    int f;
    while (~scanf("%d%d",&n,&w))
    {
        rep(i,1,n) {
            sci(value[i]);
            ID[i] = {value[i],i};
        }
        
        sort(ID + 1,ID + n + 1);
        
        MP.clear();
        
        rep(i,1,n) {
            Rank[i] = ID[i].x;
            MP[ID[i].x] = i;
        }
        
        L[0] = R[0] = Sum[0] = o[0] = TP = 0;
        
        rep(i,1,n) {
            o[i] = o[i - 1];
            Add(o[i],1,n,MP[value[i]]);
        }

        f = 1;
        rep(i,1,n - w + 1) {
            if (f) f = 0;
            else printf(" ");
            printf("%d",Rank[Search(o[i - 1],o[i + w - 1],1,n,3)]);
        }
        _C("")
    }
    return 0;
}
*/

//const int MAXN = 1e5 + 10;
//
//int a[MAXN],b[MAXN],c[MAXN];
//int la[MAXN],ra[MAXN];
//int lb[MAXN],rb[MAXN];
//int n,m,l;
//
//int main()
//{
//
//    int ok = 1;
//    int i,j;
//    int cnt;
//    multiset<int> aa,bb;
//    int sa,ta,sb,tb;
//    while (~scanf("%d%d%d",&n,&m,&l)) {
//        rep(i,1,n) sci(a[i]);
//        rep(i,1,m) sci(b[i]);
//        rep(i,1,l) sci(c[i]);
//        ok = 1;
//
//        // a
//        for (i = 1,j = 1;i <= n && j <= l;i ++) {
//            if (a[i] == c[j]) {
//                la[j ++] = i;
//            }
//        }
//        if (j != l + 1) {
//            ok = 0;
//            goto end;
//        }
//        cnt = 1;
//        for (i = n,j = l;i >= 0 && j >= 0;i --) {
//            if (a[i] == c[j]) {
//                ra[j --] = i;
//            }
//        }
//        if (j != -1) {
//            ok = 0;
//            goto end;
//        }
//
//        // b
//        for (i = 1,j = 1;i <= m && j <= l;i ++) {
//            if (b[i] == c[j]) {
//                lb[j ++] = i;
//            }
//        }
//        if (j != l + 1) {
//            ok = 0;
//            goto end;
//        }
//        cnt = 1;
//        for (i = m,j = l;i >= 0 && j >= 0;i --) {
//            if (b[i] == c[j]) {
//                rb[j --] = i;
//            }
//        }
//        if (j != -1) {
//            ok = 0;
//            goto end;
//        }
//
//        /*
//        puts("a");
//        rep(i,1,l) {
//            printf("%d ",la[i]);
//        }
//        puts("");
//        rep(i,1,l) {
//            printf("%d ",rb[i]);
//        }
//        puts("");
//
//        puts("b");
//        rep(i,1,l) {
//            printf("%d ",lb[i]);
//        }
//        puts("");
//        rep(i,1,l) {
//            printf("%d ",ra[i]);
//        }
//        puts("");
//         */
//
//        lb[0] = la[0] = 1;
//        rb[l + 1] = m + 1;
//        ra[l + 1] = n + 1;
//
//
//        // ok &= judge(la,rb);
//        aa.clear();
//        bb.clear();
//
//
//
//
//        sa = sb = 0;
//        for (i = 2;i <= l;i ++) {
//            ta = ra[i];
//            tb = rb[i];
//            // del
////            _C("del a: " << sa + 1 << " " << la[i - 1])
//            REP(j,sa + 1,la[i - 1]) {
//                aa.erase(aa.find(a[j]));
//            }
////            _C("del b: " << sb + 1 << " " << lb[i - 1])
//            REP(j,sb + 1,lb[i - 1]) {
//                bb.erase(bb.find(b[j]));
//            }
//
//            if (i == 1) {
//                sa = 0;
//                sb = 0;
//            } else {
//                sa = la[i - 1];
//                sb = lb[i - 1];
//            }
//
//            // add
////            _C("add a: " << sa + 1 << " " << ra[i])
//            REP(j,sa + 1,ra[i]) {
//                aa.insert(a[j]);
//                if (bb.find(a[j]) != bb.end()) {
//                    ok = 0;
//                    goto end;
//                }
//            }
////            _C("add b: " << sb + 1 << " " << rb[i])
//            REP(j,sb + 1,rb[i]) {
//                bb.insert(b[j]);
//                if (aa.find(b[j]) != aa.end()) {
//                    ok = 0;
//                    goto end;
//                }
//            }
//        }
//
//
//        // ok &= judge(lb,ra);
//
//    end:
//        puts(ok ? "YES" : "NO");
//    }
//}
//
//

/*
const int MAXN = 2e5 + 10;

ll x[MAXN],y[MAXN];

int main()
{
    int n;
    scanf("%d",&n);
    int cx,cy;
    ll ansx = 0,ansy = 0;
    rep(i,1,n) {
        scii(cx,cy);
        x[cx] ++;
        ansx += 4;
        if (x[cx - 1] >= x[cx]) ansx -= 2;
        if (x[cx + 1] >= x[cx]) ansx -= 2;
        if (x[cx] != 1) ansx -= 2;
        
        y[cy] ++;
        ansy += 4;
        if (y[cy - 1] >= y[cy]) ansy -= 2;
        if (y[cy + 1] >= y[cy]) ansy -= 2;
        if (y[cy] != 1) ansy -= 2;
        
        printf("%lld %lld\n",ansx,ansy);
    }
    
}
*/

/*
// kmp板子，不用管
const int MAXN = 1e3 + 10;
char str[MAXN][MAXN];
char p[MAXN];
int n;
int m;

int nxt[MAXN];

void make()
{
    // nxt(标号从[1,m]，m是匹配串长度)数组意义：nxt[i]是取出从1到i的前缀，对于这个前缀s，存在一个它的子串t，并且t != s，同时t既是s的前缀又是s的后缀，nxt[i] = max(|t|)。
    nxt[0] = -1;
    nxt[1] = 0;
    for (int i = 0,k = -1;i < m;)
    {
        if (k == -1 || p[i] == p[k]) nxt[++ i] = ++ k;
        else k = nxt[k];
    }
}

int kmp(int k)
{
    for (int i = 0,j = 0;i < n;)
    {
        if (j == -1 || str[k][i] == p[j]) {
            j ++;
            i ++;
            if (j == m) {
                return i - m; // 找到了直接返回下标号
            }
        }
        else {
            j = nxt[j];
        }

    }
    return -1;
}

// demo
struct Node {
    int len;
    int match_index; // 匹配下标
    int which_index; // 原数组对应的下标
} ele[MAXN];

int cmp(const void *a,const void *b) {
    return ((Node*)a) -> len - ((Node*)b) -> len;
}

int main()
{
    // 读入模式串
    scanf("%s",p);
    m = (int) strlen(p);
    make();
    // 读入所有串
    int cnt;
    scanf("%d",&cnt);
    int t;
    for (int i = 0;i < cnt;i ++) {
        scanf("%s",str[i]);
        n = (int) strlen(str[i]);
        if ((t = kmp(i)) != -1) {
            ele[i].len = n;
            ele[i].match_index = t;
        } else {
            ele[i].len = -1;
        }
        ele[i].which_index = i;
    }
    
    // 排序
    qsort(ele, cnt, sizeof(Node), cmp);
    puts("str matching index");
    for (int i = 0;i < cnt;i ++) {
        if (ele[i].len == -1) continue;
        printf("%s %.2f%% %d\n",str[ele[i].which_index],m / (double) ele[i].len * 100,ele[i].match_index);
    }
    
    return 0;
}
*/

//
//const int MAXN = 1e4 + 10;
//
//int n;
//
//int a[MAXN];
//ll dp[MAXN][2];
//int s[MAXN];
//
//int main()
//{
//    scanf("%d",&n);
//    rep(i,1,n) {
//        scanf("%d",a + i);
//    }
//    if (a[1] == 0) {
//        dp[1][0] = 1;
//        dp[1][1] = 0;
//    } else if (a[1] == 1) {
//        dp[1][0] = 1;
//        dp[1][1] = 1;
//    } else if (a[1] == 2) {
//        dp[1][0] = 0;
//        dp[1][1] = 1;
//    }
//    memset(s, -1, sizeof s);
//    rep(i,2,n) {
//        if (a[i] == 0) {
//            dp[i - 1][1] = 0;
//            dp[i][1] = 0;
//            dp[i + 1][1] = 0;
//
//            dp[i][0] = dp[i - 1][0];
//        } else if (a[i] == 1) {
//
//        } else if (a[i] == 2) {
//
//        } else if (a[i] == 3) {
//
//        }
//    }
//
//    printf("%lld\n",dp[n][0] + dp[n][1]);
//}

/*
const int MAXN = 1e5 + 10;

int a[MAXN],b[MAXN];
int n,m;

int main()
{
    int ans;
    __T {
        scanf("%d%d",&n,&m);
        rep(i,1,n) {
            sci(a[i]);
        }
        rep(i,1,m) {
            sci(b[i]);
        }
        sort(a + 1,a + 1 + n);
        sort(b + 1,b + 1 + m);
        ans = 0;
        b[0] = 0;
        b[m + 1] = 1e9 + 7;
        rep(i,0,m) {
            ans = max(ans,(int)(lower_bound(a + 1, a + 1 + n, b[i + 1]) - upper_bound(a + 1, a + 1 + n, b[i])));
        }
        if (!ans) puts("Impossible");
        else printf("%d\n",ans);
    }
}
*/

/*
const int MAXN = 5e5 + 10;

ll dp[MAXN];
const int mod = 998244353;

int main() {
    int n;
    scanf("%d",&n);
    int j,k;
    dp[0] = 1;
    REP(i,1,n) {
        j = i - 1;
        k = 2;
        while (j >= 0) {
            dp[i] += ((k / 2) & 1) ? dp[j] : -dp[j];
            j -= k % 2 ? k : k / 2;
            k ++;
        }
        dp[i] = (dp[i] % mod + mod) % mod;
    }
    printf("%lld\n",dp[n - 1]);
    return 0;
}
*/

/*
int main()
{
    int n;
    sci(n);
    printf("print(%d)\n",n);
}*/

/*
int main()
{
    ll n,m,s;
    sclll(n,m,s);
    ll lt = n - m * s;
    printf("hai sheng %lld mi! ",lt);
    if (n / 2.0 >= lt) puts("chong ya!");
    else puts("jia you ya!");
}
*/

/*
int main(){
    string str;
    cin >> str;
    rep(i,1,520) {
        _C(str)
    }
}
*/


/*
int judge(int n,int &d)
{
    while (n) {
        if (n % 10 == d) return 0;
        n /= 10;
    }
    return 1;
}

int main()
{
    int n,d;
    scii(n,d);
    int ans = 0;
    rep(i,1,n) if (judge(i,d)) ans ++;
    printf("%d\n",ans);
}
*/

/*
ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}

int main() {
    ll n;
    scanf("%lld",&n);
    ll ans = sqrt(quickpow(n, 4) + 2 * quickpow(n, 3) + quickpow(n, 2)) + quickpow(n, 2);
    int f = 1;
    repl(i,ans,ans + n) {
        if (f) f = 0;
        else printf(" + ");
        printf("%lld^2",i);
    }
    printf(" =\n");
    f = 1;
    repl(i,ans + 1 + n,ans + n * 2) {
        if (f) f = 0;
        else printf(" + ");
        printf("%lld^2",i);
    }
    puts("");
}
*/

/*
const int maxn = 110;
int a[maxn][maxn];

int main()
{
    int n,k,x;
    sciii(n,k,x);
    rep(i,1,n) {
        rep(j,1,n) {
            sci(a[i][j]);
        }
    }
    int mod = 0;
    rep(i,1,n) {
        if (i % 2 == 0) {
            pre(j,n,mod+2) {
                a[j][i] = a[j - mod - 1][i];
            }
            rep(j,1,mod+1) {
                a[j][i] = x;
            }
            mod ++;
            mod %= k;
        }
    }
    
    ll ans[maxn];
    ll sum;
    rep(i,1,n) {
        sum = 0;
        rep(j,1,n) sum += a[i][j];
        ans[i] = sum;
    }
    rep(i,1,n) {
        if(i!=1)printf(" ");printf("%lld",ans[i]);
    }
    puts("");
}
*/

/*
deque<int> q[110][2];

int vecA[110][110];
int vecB[110][110];

int cnt[110][2];
int done[110][2];

void init()
{
    rep(i,1,105) {
        rep(j,0,1) {
            q[i][j].push_back(-10000);
            q[i][j].push_back(-10000);
        }
    }
}

int main()
{
    init();
    int n,m,Q;
    sciii(n,m,Q);
    rep(i,1,n) {
        rep(j,1,m) {
            sci(vecA[i][j]);
        }
    }
    rep(i,1,m) {
        rep(j,1,n) {
            sci(vecB[i][j]);
        }
    }
    
    int ok = 0;
    int a,b;
    
    while (Q --) {
        scii(a,b);
        if (cnt[a][0] >= 2 && cnt[b][1] >= 2 && !done[a][0] && !done[b][1]) {
            if (vecA[a][b] > max(q[a][0].front(),q[a][0].back()) &&
                vecB[b][a] > max(q[b][1].front(),q[b][1].back())) {
                printf("%d %d\n",a,b);
                done[a][0] = 1;
                done[b][1] = 1;
                ok = 1;
            } else {
                cnt[a][0] ++;
                cnt[b][1] ++;
            }
        } else {
            if (!done[a][0]) cnt[a][0] ++;
            if (!done[b][1]) cnt[b][1] ++;
        }
        q[a][0].pop_front();
        q[a][0].pb(vecA[a][b]);
        
        q[b][1].pop_front();
        q[b][1].pb(vecB[b][a]);
        
        
    }
    if (!ok) {
        puts("PTA is my only love");
    }
}
*/

/*
const int MAXN = 50;

struct Node {
    Node(){}
    Node(int n,Node *l,Node *r):n(n),l(l),r(r){}

    int n;
    Node *l;
    Node *r;
} *root;

int gin[MAXN];
int gpost[MAXN];

void build(int *in,int *post,int len,Node **node)
{
    if (len <= 0) return;
    int mid = post[len-1];
    int x = 0;
    REP(i,0,len) {
        if (in[i] == mid) {
            x = i;
            break;
        }
    }
    *node = new Node(mid,NULL,NULL);
    build(in,post,x,&((*node) -> l));
    build(in + x + 1, post + x, len - x - 1, &((*node) -> r));
}

int l[MAXN],r[MAXN];

void dfs(Node *node,int d) {
    if (!l[d]) l[d] = node -> n;
    r[d] = node -> n;
    if (node -> l != NULL) dfs(node -> l,d + 1);
    if (node -> r != NULL) dfs(node -> r,d + 1);
    
}

int main()
{
    int n;
    sci(n);
    REP(i,0,n) sci(gin[i]);
    REP(i,0,n) sci(gpost[i]);
    build(gin, gpost, n, &root);
    dfs(root,0);
    printf("R:");
    for (int i = 0;r[i];i ++) {
        printf(" %d",r[i]);
    }
    printf("\nL:");
    for (int i = 0;l[i];i ++) {
        printf(" %d",l[i]);
    }
    puts("");
}
*/

/*
string mp['z'];

int main()
{
    vector<int> str,bin;
    string tmp,t;

    mp['0'] = "0000";
    mp['1'] = "0001";
    mp['2'] = "0010";
    mp['3'] = "0011";
    mp['4'] = "0100";
    mp['5'] = "0101";
    mp['6'] = "0110";
    mp['7'] = "0111";
    mp['8'] = "1000";
    mp['9'] = "1001";
    mp['A'] = "1010";
    mp['B'] = "1011";
    mp['C'] = "1100";
    mp['D'] = "1101";
    mp['E'] = "1110";
    mp['F'] = "1111";

    int f;

    vector<int> ans;

    int n,m,pre,st;

    __T {
        cin >> tmp;
        str.clear();
        bin.clear();
        for (int i = 0;tmp[i];i ++) {
            bin.pb(tmp[i] ^ 48);
        }
        cin >> tmp;
        f = 1;
        for (int i = 0;tmp[i];i ++) {
            t = mp[tmp[i]];
            for (int j = 0;t[j];j ++) {
                if (t[j] == '0') {
                    if (f) continue;
                } else f = 0;
                str.pb(t[j] ^ 48);
            }
        }
//        for (auto i : bin) printf("%d",i);
//        puts("");
//        for (auto i : str) printf("%d",i);
//        puts("");
        ans.clear();
        pre = 0;
        n = str.size();
        m = bin.size();

        for (st = 0;st < m;st ++) {
            if (st < n) ans.pb(str[st]);
            else ans.pb(0);
        }


        while (pre < n) {
            f = ans.size();
//            rep(i,pre,f-1) printf("%d",ans[i]);
//            puts("");
            rep(i,pre,f - 1) {
                ans[i] = ans[i] ^ bin[i - pre];
            }
            while (!ans[pre]) {
                pre ++;
            }
            if (pre < n)
            while (f - pre + 1 <= m) {
                if (st < n) ans.pb(str[st]);
                else ans.pb(0);
                st ++;
                f ++;
            }
        }
        st = 0;
        rep(i,n,pre-1) {
            st ++;
            printf("0");
        }
        rep(i,pre,f-1) {
            printf("%d",ans[i]);
            st ++;
        }
//        puts("");
        rep(i,st,m-2) printf("0");
        puts("");
    }
}
*/

/*
const int maxn = 2e5 + 10;
const int MAXN = 6e6 + 10;

int a[maxn];
int idx[MAXN];

ll c[maxn];

int n;

inline void add(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

inline ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        _C(i)
        ans += c[i];
    }
    return ans;
}

inline ll query(int a,int b)
{
    _C(a << " " << b)
    return sum(b) - sum(a - 1);
}

int main()
{
    int n1,n2;
    scanf("%d%d",&n1,&n2);
    n = n1 + n2;
    pre(i,n1,1) {
        scanf("%d",a + i);
        idx[a[i]] = i;
        add(i,1);
    }
    rep(i,1 + n1,n2 + n1) {
        scanf("%d",a + i);
        idx[a[i]] = i;
        add(i,1);
    }
//    rep(i,1,n1+n2) printf("%d ",a[i]);
//    puts("");
    int board = n1;

    sort(a + 1,a + 1 + n);
    ll ans = 0;
    pre(i,n,1) {
        if (board >= idx[a[i]]) {
            // L
            ans += query(idx[a[i]] + 1,board);
            board = idx[a[i]];
        } else {
            // R
            ans += query(board + 1,idx[a[i]] - 1);
            board = idx[a[i]] - 1;
        }
        add(-1,idx[a[i]]);
    }
    printf("%lld\n",ans);
}
*/


/*
string mp['z'];

int main()
{
    vector<int> str,bin;
    string tmp,t;

    mp['0'] = "0000";
    mp['1'] = "0001";
    mp['2'] = "0010";
    mp['3'] = "0011";
    mp['4'] = "0100";
    mp['5'] = "0101";
    mp['6'] = "0110";
    mp['7'] = "0111";
    mp['8'] = "1000";
    mp['9'] = "1001";
    mp['A'] = "1010";
    mp['B'] = "1011";
    mp['C'] = "1100";
    mp['D'] = "1101";
    mp['E'] = "1110";
    mp['F'] = "1111";

    int f;

    vector<int> ans;

    int n,m,pre,st;

    __T {
        cin >> tmp;
        str.clear();
        bin.clear();
        for (int i = 0;tmp[i];i ++) {
            bin.pb(tmp[i] ^ 48);
        }
        cin >> tmp;
        f = 1;
        for (int i = 0;tmp[i];i ++) {
            t = mp[tmp[i]];
            for (int j = 0;t[j];j ++) {
                if (t[j] == '0') {
                    if (f) continue;
                } else f = 0;
                str.pb(t[j] ^ 48);
            }
        }
//        for (auto i : bin) printf("%d",i);
//        puts("");
//        for (auto i : str) printf("%d",i);
//        puts("");
        ans.clear();
        pre = 0;
        n = str.size();
        m = bin.size();

        for (st = 0;st < m;st ++) {
            if (st < n) ans.pb(str[st]);
            else ans.pb(0);
        }

        while (pre < n) {
            f = ans.size();
//            rep(i,pre,f-1) printf("%d",ans[i]);
//            puts("");
            rep(i,pre,f - 1) {
                ans[i] = ans[i] ^ bin[i - pre];
            }
            while (pre < f && !ans[pre]) {
                pre ++;
            }
            while (st - pre < m) {
                if (st < n) ans.pb(str[st]);
                else ans.pb(0);
                st ++;
            }
        }
        rep(i,n,n + m - 2) {
            printf("%d",ans[i]);
        }
        puts("");
    }
}
*/

/*
int main()
{
    string s,t;
    vector<pair<int,int>> ss,tt;
    int a,b;
    int n,m;
    int x;
    int ok;
    while (getline(cin,s)) {
        getline(cin,t);
        ss.clear();
        tt.clear();
        a = 0;
        b = 0;
        for (int i = 0;s[i];i ++) {
            if (s[i] == 'a') a ++;
            else if (s[i] == 'b') b ++;
            else {
                ss.pb(mpair(a,b));
                a = 0;
                b = 0;
            }
        }
        ss.pb(mpair(a,b));
        a = 0;
        b = 0;
        for (int i = 0;t[i];i ++) {
            if (t[i] == 'a') a ++;
            else if (t[i] == 'b') b ++;
            else {
                tt.pb(mpair(a,b));
                a = 0;
                b = 0;
            }
        }
        tt.pb(mpair(a,b));

        if (ss.size() != tt.size()) puts("No");
        else {
            ok = 1;
            for (auto i = ss.begin(),j = tt.begin();i != ss.end();i ++,j ++) {
                if (!(i -> first % 2 == j -> first % 2 && i -> second % 2 == j -> second % 2)) {
                    ok = 0;
                    break;
                }
            }
            puts(ok ? "Yes" : "No");
        }

    }

}
*/

/*
const int maxn = 2e5 + 10;

int a[maxn];
ll sub[maxn];

int main()
{
    int n;
    int ans;
    while (~scanf("%d",&n)) {
        rep(i,0,n) {
            sci(a[i]);
            sub[i] = 0;
        }
        sub[n] = a[n];
        pre(i,n-1,0) {
            sub[i] = a[i] + sub[i + 1];
        }
        ans = 0;
        rep(i,0,n) {
            if (sub[i] >= i) ans = i;
        }
        printf("%d\n",ans);
    }
}
*/

/*
const int maxn = 5e5 + 10;
int a[maxn];

int main()
{
    ll n;
    ll ans;
    ll sum;
    ll t;
    ll last;
    __T {
        scanf("%lld",&n);
        sum = 0;
        rep(i,1,n) {
            scanf("%d",a + i);
            sum += a[i];
        }
        last = a[1];
        t = a[1];
        rep(i,2,n) {
            t += last + a[i];
            last += a[i];
        }
        ans = t;
        rep(i,2,n) {
            t += sum;
            t -= a[i - 1] * n;
            ans = min(ans,t);
        }

        last = a[n];
        t = a[n];
        pre(i,n-1,1) {
            t += last + a[i];
            last += a[i];
        }
        ans = min(ans,t);
        pre(i,n-1,1) {
            t += sum;
            t -= a[i + 1] * n;
            ans = min(ans,t);
        }
        printf("%lld\n",ans);
    }
}*/

/*
int main()
{
    int s;
    __T {
        scanf("%d",&s);
        printf("%d\n",s == 1 || s == 2 || s == 3 ? -1 : s / 2);
    }
}*/

/*
int main()
{
    string str;
    int n;
    char ch[200];
    int ans;
    __T {
        scanf("%d",&n);
        cin >> str;
        ch['F'] = ch['e'] = ch['i'] = ch['M'] = ch['a'] = 0;
        ans = 0;
        for (int i = 0;str[i];i ++) {
            if (str[i] == 'F') ch[str[i]] ++;
            else if (str[i] == 'e') {
                if (ch['e'] < ch['F']) ch[str[i]] ++;
            } else if (str[i] == 'i') {
                if (ch['i'] < ch['e']) ch[str[i]] ++;
            } else if (str[i] == 'M') {
                if (ch['M'] < ch['i']) ch[str[i]] ++;
            } else if (str[i] == 'a') {
                if (ch['M']) {
                    ans ++;
                    ch['F'] = ch['e'] = ch['i'] = ch['M'] = ch['a'] = 0;
                }
            }
        }
        printf("%d\n",ans);
    }
}*/

/*
const int maxn = 1e2 + 10;
int a[maxn][maxn][maxn];

int dx[] = {-1,-1,-1,0,0,1,1,1};
int dy[] = {-1,0,1,1,-1,1,0,-1};

int main()
{
    int n,k;
    int xx,yy;
    int cnt;
    int ans,ok;
    __T {
        ans = -1;
        scanf("%d%d",&n,&k);
        rep(i,0,n - 1) {
            rep(j,0,n - 1) {
                scanf("%d",&a[i][j][0]);
            }
        }
        rep(ii,1,k) {
            rep(i,0,n - 1) {
                rep(j,0,n - 1) {
                    cnt = 0;
                    rep(kk,0,7) {
                        xx = (i + dx[kk] + n) % n;
                        yy = (j + dy[kk] + n) % n;
                        if (a[xx][yy][ii - 1]) cnt ++;
                    }
                    if (cnt < 2 || cnt > 3) a[i][j][ii] = 0;
                    else if (cnt == 3) a[i][j][ii] = 1;
                    else a[i][j][ii] = a[i][j][ii - 1];
                }
            }
            ok = 1;
            rep(i,0,n-1) {
                rep(j,0,n-1) {
                    if (a[i][j][0] != a[i][j][ii]) {
                        ok = 0;
                        goto end;
                    }
                }
            }
        end:
            if (ok) {
                ans = ii;
                goto finish;
            }
        }
        finish:
        puts(ans == -1 ? "NO" : "YES");
        if (ans != -1) printf("%d\n",ans);
    }
}*/

/*
struct Node {
    int circle,n;
    int x,y;
    Node(){}
    Node(int c,int b):circle(c),n(b){}
};

int cnt = 1;
ll base[100000];
Node dir[6];

Node get(ll xx)
{
    ll *fd = upper_bound(base,base + cnt,xx);
    int a,b;
    a = fd - base - 1;
    b = xx - *(fd - 1);
    Node ans = Node(a,b);
    if (a == 0) {
        ans.x = 0;
        ans.y = 0;
        return ans;
    }
    b = (b + 1) % (a * 6);
    ans.n = b;
    int block = b / a;
    int num = b % a;
    _C(a << " " << block)

    int x = 0,y = -a;

    dir[0].x = x;
    dir[0].y = y;

    x -= a;

    dir[1].x = x;
    dir[1].y = y;

    y += a;

    dir[2].x = x;
    dir[2].y = y;

    x += a;
    y += a;

    dir[3].x = x;
    dir[3].y = y;

    x += a;

    dir[4].x = x;
    dir[4].y = y;

    y -= a;

    dir[5].x = x;
    dir[5].y = y;

    if (block == 0) {

    } else if (block == 1) {

    } else if (block == 2) {

    } else if (block == 3) {

    } else if (block == 4) {

    } else if (block == 5) {

    }
    return ans;
}

int main()
{
    int x,y;
    base[0] = 1;
    base[1] = 2;
    ll k = 6;
    for (int i = 2;;i ++,k += 6) {
        base[i] = base[i - 1] + k;
        cnt ++;
        if (base[i] >= 2e9) break;
    }
    Node a,b;
    __T {
        scanf("%d%d",&x,&y);
        a = get(x);
//        b = get(y);


    }
}*/

/*
struct Node {
    int circle, n;
    int x, y;

    Node() {}

    Node(int c, int b) : circle(c), n(b) {}
};

int cnt = 1;
ll base[100000];
Node dir[6];

pair<ll, ll> p[7] = {{0,  -1},
                     {-1, -1},
                     {-1, 0},
                     {0,  1},
                     {1,  1},
                     {1,  0}};

Node get(ll xx) {
    ll *fd = upper_bound(base, base + cnt, xx);
    int a, b;
    a = fd - base - 1;
    b = xx - *(fd - 1);
    Node ans = Node(a, b);
    if (a == 0) {
        ans.x = 0;
        ans.y = 0;
        return ans;
    }
    int block = b / a;
    int num = b % a + 1;
//    cout << "a = " << a << " b = " << b << endl;
//    cout << "block = " << block << " num = " << num << endl;
    int tx = p[block].first * a, ty = p[block].second * a;
//    cout << "tx = " << tx << " ty = " << ty << endl;
    tx += p[(block + 2) % 6].first * num;
    ty += p[(block + 2) % 6].second * num;
    ans.x = tx;
    ans.y = ty;
    return ans;
}

int main() {
    int x, y,xx,yy;
    base[0] = 1;
    base[1] = 2;
    ll k = 6;
    for (int i = 2;; i++, k += 6) {
        base[i] = base[i - 1] + k;
        cnt++;
        if (base[i] >= 2e9) break;
    }
    Node a, b;
    int t;
    cin >> t;
    ll ans = 0;
    while (t--) {
        scanf("%d%d", &xx, &yy);
        a = get(xx);
        b = get(yy);
        x = b.x - a.x;
        y = b.y - a.y;
        if (y >= 0 && x >= 0) {
            ans = min(y, x) + (y - min(y, x)) + (x - min(y, x));
        }
        else if ((y >= 0 && x < 0) || (y <= 0 && x > 0)) {
            ans = y - x;
        } else {
            ans = -max(y, x) + (max(y, x) - y)+ (max(y, x) - x);
        }
        printf("%lld\n", abs(ans) + 1);

    }
}*/

/*
const int maxn = 2e5 + 10;
const int MAXN = 6e6 + 10;

int a[maxn];
int idx[MAXN];

ll c[maxn];

int n;

inline void add(int i,ll x)
{
    // 从叶子结点一路向上更新
    for (;i <= n;i += lowbit(i)) {
        c[i] += x;
    }
}

inline ll sum(int i)
{
    // 查询： 由于每个c结点相当于一小段前缀和，因此全+起来，最后求得的便是总共的前缀和
    ll ans = 0;
    for (;i > 0;i -= lowbit(i))
    {
        ans += c[i];
    }
    return ans;
}

inline ll query(int a,int b)
{
    return sum(b) - sum(a - 1);
}

int main()
{
    int n1,n2;
    scanf("%d%d",&n1,&n2);
    n = n1 + n2;
    pre(i,n1,1) {
        scanf("%d",a + i);
        idx[a[i]] = i;
        add(i,1);
    }
    rep(i,1 + n1,n2 + n1) {
        scanf("%d",a + i);
        idx[a[i]] = i;
        add(i,1);
    }
//    rep(i,1,n1+n2) printf("%d ",a[i]);
//    puts("");
    int board = n1;

    sort(a + 1,a + 1 + n);
    ll ans = 0;
    pre(i,n,1) {
        if (board >= idx[a[i]]) {
            // L
            ans += query(idx[a[i]] + 1,board);
            board = idx[a[i]];
        } else {
            // R
            ans += query(board + 1,idx[a[i]] - 1);
            board = idx[a[i]] - 1;
        }
        add(idx[a[i]],-1);
    }
    printf("%lld\n",ans);
}*/

/*
int main()
{
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    ll ans = 0;
    int u,v;
    rep(i,1,m) {
        scanf("%d%d",&u,&v);
        ans += abs(u - v);
    }
    rep(i,1,k) scanf("%d",&u);
    printf("%d\n",ans);
}
*/

/*
const double eps = 1e-5;

double a,b,c,d;

double sx(double cx) {
    double ans = 0;
    for (double i = eps;i <= cx;i += eps) {
        ans += sqrt(a * a - i * i) * eps;
    }
    return ans * b / a;
}

double sy(double cy) {
    double ans = 0;
    for (double i = eps;i <= cy;i += eps) {
        ans += sqrt(d * d - i * i) * eps;
    }
    return ans * c / d;
}

int main() {
    int T;
    scanf("%d",&T);
    double cx,cy;
    double ans;
    while (T --) {
        scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
        if (c <= a && d <= b) {
            ans = sx(a);
        } else if (a <= c && b <= d) {
            ans = sy(d);
        } else {
            cx = a * c * sqrt((d*d - b*b) / (a*a * d*d - b*b * c*c));
            cy = b * d * sqrt((a*a - c*c) / (a*a * d*d - b*b * c*c));
            ans = sx(cx) + sy(cy) - cx * cy;
            ans = sx(a) + sy(d) - ans;
        }
        printf("%.1f\n",ans * 4);
    }

    return 0;
}*/

/*
// 线段树 - 二叉树，节点存的是一个 l，r，区间的内容n
const int MAXN = 1e5 + 10;

struct Node {
    int l,r;
    ll mx;
    ll mn;
    ll sum;
    int lazy;
    ll lzn;
} tree[MAXN << 2];
ll a[MAXN];

void push_up(int i)
{
    tree[i].sum = tree[i << 1].sum + tree[i << 1 | 1].sum;
    tree[i].mn = min(tree[i << 1].mn,tree[i << 1 | 1].mn);
    tree[i].mx = max(tree[i << 1].mx,tree[i << 1 | 1].mx);
}

// 下推标记(Modify)
void push_down(int i)
{
    if (tree[i].lazy) {
        tree[i << 1].sum = (tree[i << 1].r - tree[i << 1].l + 1) * tree[i].lzn;
        tree[i << 1 | 1].sum = (tree[i << 1 | 1].r - tree[i << 1 | 1].l + 1) * tree[i].lzn;

        tree[i << 1].mx = tree[i].lzn;
        tree[i << 1 | 1].mx = tree[i].lzn;

        tree[i << 1].mn = tree[i].lzn;
        tree[i << 1 | 1].mn = tree[i].lzn;

        tree[i << 1].lzn = tree[i].lzn;
        tree[i << 1 | 1].lzn = tree[i].lzn;

        tree[i << 1].lazy = tree[i].lazy;
        tree[i << 1 | 1].lazy = tree[i].lazy;

        tree[i].lazy = 0;
        tree[i].lzn = 0;
    }
}

// i - 二叉树节点编号，调用时取1
// l，r 区间左右端下标，调用的时候取最大范围即可 build(1,n,1);
void build(int l,int r,int i)
{
    tree[i].l = l;
    tree[i].r = r;
    tree[i].lazy = 0;
    tree[i].lzn = 0;
    if (l == r) {
        tree[i].sum = a[l]; // a原数组，把原来的数值给叶子结点
        tree[i].mx = a[l];
        tree[i].mn = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(l,m,i << 1);
    build(m + 1,r,i << 1 | 1);
    push_up(i);
}

void modify(int l,int r,ll x,int i) // 将区间[l,r]直接变成x，调用(l,r,x,1)
{
    if (l <= tree[i].l && r >= tree[i].r) {
        tree[i].sum = (tree[i].r - tree[i].l + 1) * x;
        tree[i].mx = x;
        tree[i].mn = x;
        tree[i].lzn = x;

        tree[i].lazy = 1;
        return;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    if (l <= m) modify(l,r,x,i << 1);
    if (r > m) modify(l,r,x,i << 1 | 1);
    push_up(i);
}

ll query(int l,int r,int i) //查询
{
    if (l <= tree[i].l && r >= tree[i].r){
        return tree[i].sum;
//        return tree[i].mx;
//        return tree[i].mn;
    }
    push_down(i);
    int m = (tree[i].l + tree[i].r) >> 1;
    ll sum = 0;
//    ll mx = 0;
//    ll mn = INT_INF;
    if (l <= m) {
        sum += query(l,r,i << 1);
//         mx = max(mx,query(l,r,i << 1));
//         mn = min(mn,query(l,r,i << 1));
    }
    if (r > m) {
        sum += query(l,r,i << 1 | 1);
//        mx = max(mx,query(l,r,i << 1 | 1));
//        mn = min(mn,query(l,r,i << 1 | 1));
    }
    return sum;
//    return mx;
//    return mn;
}

char str[MAXN];

int main()
{
    int n,m;
    int l,r,k;
    int cnt;
    while (~scanf("%d%d",&n,&m)) {
        scanf("%s",str);
        rep(i,0,n-1) a[i + 1] = str[i] ^ 48;
        build(1,n,1);
        while (m --) {
            scanf("%d%d%d",&l,&r,&k);
            l ++;
            r ++;
            cnt = query(l,r,1);
            if (k) {
                modify(l,cnt+l-1,1,1);
                modify(cnt + l,r,0,1);
            } else {
//                _C(cnt)
//                _C(l << " " << r-cnt)
//                _C(r-cnt+1 << " " << r)
                modify(l,r-cnt,0,1);
                modify(r-cnt+1,r,1,1);
            }
//            rep(i,1,n) printf("%lld", query(i,i,1));
//            puts("");
        }
        rep(i,1,n) printf("%lld", query(i,i,1));
        puts("");
    }
}
*/

/*
int a[100],op[100];

int main()
{
    int n;
    sci(n);
    int mp[] = {1,2,1,1,4,2,2,1,4,2,4,1,4,4,4,4,2,2,3,1,1,1,1,2,4,1,1,3,1,3,3,4,3,2,3,3,1,4,4,2,1,1,2,2,4,4,2,4,4,4,3,2,3,3,1,4,4,3,4,1,4,2,4};
    rep(i,1,n) {
        sci(a[i]);
    }
    rep(i,1,n-1) sci(op[i]);
    ll ans = a[1];
    int o;
    rep(i,2,n) {
        o = mp[op[i-1] - 1];
        if (o == 1) {
            ans += a[i];
        } else if (o == 2) {
            ans -= a[i];
        } else if (o == 3) {
            ans *= a[i];
        } else if (o == 4) {
            ans /= a[i];
        }
    }
    printf("%lld\n",ans);
}*/

/*
const int mod = 1e9 + 7;
int vis[1000010];

int main()
{
    string str;
    cin >> str;
    ll n = 0,ya = 0;
    ll len = 0;
    for (int i = 0;str[i];i ++) {
        if (i != 0) {
            if (str[i] == 'a' && str[i - 1] == 'y') {
                ya ++;
                vis[i - 1] = vis[i] = 1;
            }
        }
        if (str[i] == 'n') {
            n ++;
            vis[i] = 1;
        }
    }
    for (int i = 0;str[i];i ++) {
        if (!vis[i]) len ++;
    }
    int k;
    scanf("%d",&k);
    cin >> str;
    for (int i = 0;str[i];i ++) {
        if (str[i] == 'n') {
            n += ya;
            n %= mod;
            ya = 0;
        } else if (str[i] == 'N') {
            ya += n;
            ya %= mod;
        }
    }
    ll ans = n;
    ans += ya * 2 % mod;
    ans %= mod;
    ans += len;
    ans %= mod;
    printf("%lld\n",ans);
}*/

/*
const int mod = 998244353;

ll quickpow(ll a, ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = a * ans % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main()
{
    ll a;
    ll x;
    __T {
        scanf("%lld",&a);
        a = 100 - a;
        x = a * quickpow(100,mod - 2) % mod;
        printf("%lld\n", x * x % mod);
    }
}*/

/*
//主席树求区间第k小
#define maxn 1000007
#define MAXN  18600007

int L[MAXN],R[MAXN],Sum[MAXN],T[maxn],TP;//左右子树，总和，树根，指针
void Add(int &rt,int l,int r,int x){//建立新树
    ++TP;L[TP]=L[rt];R[TP]=R[rt];Sum[TP]=Sum[rt]+1;rt=TP;//复制&新建
    if(l==r) return;
    int m=(l+r)>>1;
    if(x <= m) Add(L[rt],l,m,x);
    else  Add(R[rt],m+1,r,x);
}
int Search(int TL,int TR,int l,int r,int k){//区间查询第k大
    if(l==r) return l;//返回第k大的下标
    int m=(l+r)>>1;
    if(Sum[L[TR]]-Sum[L[TL]]>=k) return Search(L[TL],L[TR],l,m,k);
    else return Search(R[TL],R[TR],m+1,r,k-Sum[L[TR]]+Sum[L[TL]]);
}

//常规

int a[maxn];
//离散化
struct A{
    int x,id;
    bool operator<(const A&B)const{return x<B.x;} // TODO: <是区间第k小，>是区间第k大
}ID[maxn];
map<int,int> mp;
int Rank[maxn];

void build(int n) {
    rep(i, 1, n) {
        ID[i].x = a[i];
        ID[i].id = i;
    }
    sort(ID+1,ID+n+1);
    mp.clear();
    rep(i,1,n) {
        Rank[i]=ID[i].x;
        mp[ID[i].x]=i;
    }
    //初始化主席树
    L[0]=R[0]=Sum[0]=T[0]=TP=0;
    //建主席树
    rep(i,1,n) Add(T[i]=T[i-1],1,n,mp[a[i]]);
}

inline int query(int l,int r,int k,int n)
{
    return Rank[Search(T[l-1],T[r],1,n,k)];
}

int main()
{
    int q;
    int l,r,k;
    int n;
    while(~scanf("%d%d",&n,&q)){
        //读取输入+离散化
        rep(i,1,n) {
            scanf("%d",a + i);
        }

        build(n);

        //开始计算
        while (q --) {
            scanf("%d%d%d",&l,&r,&k);
            printf("%d\n",query(l,r,k,n));
        }
    }
    return 0;
}*/

